---
title: "Open Meteo Weather Exploration"
author: "davegoblue"
date: "2023-09-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache.lazy=FALSE)
```

## Background
Open-Meteo maintains an [API for historical weather](https://open-meteo.com/en/docs/historical-weather-api) that allows for non-commercial usage of historical weather data maintained by the website.

This file builds on _v001 to run exploratory analysis on some historical weather data.

## Functions and Libraries
The exploration process uses tidyverse, several generic custom functions, and several functions specific to Open Meteo processing. First, tidyverse and the generic functions are loaded:  
```{r}

library(tidyverse) # tidyverse functionality is included throughout

source("./Generic_Added_Utility_Functions_202105_v001.R") # Basic functions

```
  
Next, specific functions written in _v001 are copied:  
```{r}

# Helper function for reading a partial CSV file
partialCSVRead <- function(loc, firstRow=1L, lastRow=+Inf, col_names=TRUE, ...) {
    
    # FUNCTION arguments
    # loc: file location
    # firstRow: first row that is relevant to the partial file read (whether header line or data line)
    # last Row: last row that is relevant to the partial file read (+Inf means read until last line of file)
    # col_names: the col_names parameter passed to readr::read_csv
    #            TRUE means header=TRUE (get column names from file, read data starting on next line)
    #            FALSE means header=FALSE (auto-generate column names, read data starting on first line)
    #            character vector means use these as column names (read data starting on first line)
    # ...: additional arguments passed to read_csv

    # Read the file and return
    # skip: rows to be skipped are all those prior to firstRow
    # n_max: maximum rows read are lastRow-firstRow, with an additional data row when col_names is not TRUE
    readr::read_csv(loc, 
                    col_names=col_names,
                    skip=firstRow-1, 
                    n_max=lastRow-firstRow+ifelse(isTRUE(col_names), 0, 1), 
                    ...
                    )
    
}


# Get the break points for gaps in a vector (e.g., 0, 3, 5:8, 20 has break points 0, 3, 5, 20 and 0, 3, 8, 30)
vecGaps <- function(x, addElements=c(), sortUnique=TRUE) {
    
    if(length(addElements)>0) x <- c(addElements, x)
    if(isTRUE(sortUnique)) x <- unique(sort(x))
    list("starts"=c(x[is.na(lag(x)) | x-lag(x)>1], +Inf), 
         "ends"=x[is.na(lead(x)) | lead(x)-x>1]
         )
    
}


# Find the break points in a single file
flatFileGaps <- function(loc) {

    which(stringr::str_length(readLines(loc))==0) %>% vecGaps(addElements=0)
    
}


# Read all relevant data as CSV with header
readMultiCSV <- function(loc, col_names=TRUE, ...) {

    gaps <- flatFileGaps(loc)
    
    lapply(seq_along(gaps$ends), 
           FUN=function(x) partialCSVRead(loc, 
                                          firstRow=gaps$ends[x]+1, 
                                          lastRow=gaps$starts[x+1]-1, 
                                          col_names=col_names, 
                                          ...
                                          )
           )
    
}


# Create URL with specified parameters for downloading data from Open Meteo
openMeteoURLCreate <- function(mainURL="https://archive-api.open-meteo.com/v1/archive", 
                               lat=45, 
                               lon=-90, 
                               startDate=paste(year(Sys.Date())-1, "01", "01", sep="-"), 
                               endDate=paste(year(Sys.Date())-1, "12", "31", sep="-"), 
                               hourlyMetrics=NULL, 
                               dailyMetrics=NULL,
                               tz="GMT", 
                               ...
                               ) {
    
    # Create formatted string
    fString <- paste0(mainURL, 
                      "?latitude=", 
                      lat, 
                      "&longitude=", 
                      lon, 
                      "&start_date=", 
                      startDate, 
                      "&end_date=", 
                      endDate
                      )
    if(!is.null(hourlyMetrics)) fString <- paste0(fString, "&hourly=", hourlyMetrics)
    if(!is.null(dailyMetrics)) fString <- paste0(fString, "&daily=", dailyMetrics)
    
    # Return the formatted string
    paste0(fString, "&timezone=", stringr::str_replace(tz, "/", "%2F"), ...)
    
}


# Helper function to simplify entry of parameters for Open Meteo download requests
helperOpenMeteoURL <- function(cityName=NULL,
                               lat=NULL,
                               lon=NULL,
                               hourlyMetrics=NULL,
                               hourlyIndices=NULL,
                               hourlyDesc=tblMetricsHourly,
                               dailyMetrics=NULL,
                               dailyIndices=NULL,
                               dailyDesc=tblMetricsDaily,
                               startDate=NULL, 
                               endDate=NULL, 
                               tz=NULL,
                               ...
                               ) {
    
    # Convert city to lat/lon if lat/lon are NULL
    if(is.null(lat) | is.null(lon)) {
        if(is.null(cityName)) stop("\nMust provide lat/lon or city name available in maps::us.cities\n")
        cityData <- maps::us.cities %>% tibble::as_tibble() %>% filter(name==cityName)
        if(nrow(cityData)!=1) stop("\nMust provide city name that maps uniquely to maps::us.cities$name\n")
        lat <- cityData$lat[1]
        lon <- cityData$long[1]
    }
    
    # Get hourly metrics by index if relevant
    if(is.null(hourlyMetrics) & !is.null(hourlyIndices)) {
        hourlyMetrics <- hourlyDesc %>% slice(hourlyIndices) %>% pull(metric)
        hourlyMetrics <- paste0(hourlyMetrics, collapse=",")
        cat("\nHourly metrics created from indices:", hourlyMetrics, "\n\n")
    }
    
    # Get daily metrics by index if relevant
    if(is.null(dailyMetrics) & !is.null(dailyIndices)) {
        dailyMetrics <- dailyDesc %>% slice(dailyIndices) %>% pull(metric)
        dailyMetrics <- paste0(dailyMetrics, collapse=",")
        cat("\nDaily metrics created from indices:", dailyMetrics, "\n\n")
    }
    
    # Use default values from OpenMeteoURLCreate() for startDate, endDate, and tz if passed as NULL
    if(is.null(startDate)) startDate <- eval(formals(openMeteoURLCreate)$startDate)
    if(is.null(endDate)) endDate <- eval(formals(openMeteoURLCreate)$endDate)
    if(is.null(tz)) tz <- eval(formals(openMeteoURLCreate)$tz)
    
    # Create and return URL
    openMeteoURLCreate(lat=lat,
                       lon=lon, 
                       startDate=startDate, 
                       endDate=endDate, 
                       hourlyMetrics=hourlyMetrics, 
                       dailyMetrics=dailyMetrics, 
                       tz=tz,
                       ...
                       )
    
}


# Read JSON data returned from Open Meteo
readOpenMeteoJSON <- function(js, mapDaily=tblMetricsDaily, mapHourly=tblMetricsHourly) {
    
    # FUNCTION arguments: 
    # js: JSON list returned by download from Open-Meteo
    # mapDaily: mapping file for daily metrics
    # mapHourly: mapping file for hourly metrics
    
    # Get the object and names
    jsObj <- jsonlite::read_json(js, simplifyVector = TRUE)
    nms <- jsObj %>% names()
    cat("\nObjects in JSON include:", paste(nms, collapse=", "), "\n\n")
    
    # Set default objects as NULL
    tblDaily <- NULL
    tblHourly <- NULL
    tblUnitsDaily <- NULL
    tblUnitsHourly <- NULL
    
    # Get daily and hourly as tibble if relevant
    if("daily" %in% nms) tblDaily <- jsObj$daily %>% tibble::as_tibble() %>% omProcessDaily()
    if("hourly" %in% nms) tblHourly <- jsObj$hourly %>% tibble::as_tibble() %>% omProcessHourly()
    
    # Helper function for unit conversions
    helperMetricUnit <- function(x, mapper, desc=NULL) {
        if(is.null(desc)) 
            desc <- as.list(match.call())$x %>% 
                deparse() %>% 
                stringr::str_replace_all(pattern=".*\\$", replacement="")
        x %>% 
            tibble::as_tibble() %>% 
            pivot_longer(cols=everything()) %>% 
            left_join(mapper, by=c("name"="metric")) %>% 
            mutate(value=stringr::str_replace(value, "\u00b0", "deg ")) %>% 
            mutate(metricType=desc) %>% 
            select(metricType, everything())
    }
    
    # Get the unit descriptions
    if("daily_units" %in% nms) tblUnitsDaily <- helperMetricUnit(jsObj$daily_units, mapDaily)
    if("hourly_units" %in% nms) tblUnitsHourly <- helperMetricUnit(jsObj$hourly_units, mapHourly)
    if(is.null(tblUnitsDaily) & !is.null(tblUnitsHourly)) tblUnits <- tblUnitsHourly
    else if(!is.null(tblUnitsDaily) & is.null(tblUnitsHourly)) tblUnits <- tblUnitsDaily
    else if(!is.null(tblUnitsDaily) & !is.null(tblUnitsHourly)) 
        tblUnits <- bind_rows(tblUnitsHourly, tblUnitsDaily)
    else tblUnits <- NULL
    
    # Put everything else together
    tblDescription <- jsObj[setdiff(nms, c("hourly", "hourly_units", "daily", "daily_units"))] %>%
        tibble::as_tibble()
    
    # Return the list objects
    list(tblDaily=tblDaily, tblHourly=tblHourly, tblUnits=tblUnits, tblDescription=tblDescription)
    
}


# Return Open meteo metadata in prettified format
prettyOpenMeteoMeta <- function(df, extr="tblDescription") {
    if("list" %in% class(df)) df <- df[[extr]]
    for(name in names(df)) {
        cat("\n", name, ": ", df %>% pull(name), sep="")
    }
    cat("\n\n")
}


# Process Open Meteo daily data
omProcessDaily <- function(tbl, extr="tblDaily") {
    if("list" %in% class(tbl)) tbl <- tbl[[extr]]
    tbl %>% mutate(date=lubridate::ymd(time)) %>% select(date, everything())
}


# Process Open meteo hourly data
omProcessHourly <- function(tbl, extr="tblHourly") {
    if("list" %in% class(tbl)) tbl <- tbl[[extr]]
    tbl %>% 
        mutate(origTime=time, 
               time=lubridate::ymd_hm(time), 
               date=lubridate::date(time), 
               hour=lubridate::hour(time)
               ) %>% 
        select(time, date, hour, everything())
}


# Simple predictive model for categorical variable
simpleOneVarPredict <- function(df, 
                                tgt, 
                                prd, 
                                dfTest=NULL,
                                nPrint=30, 
                                showPlot=TRUE, 
                                returnData=TRUE
                                ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame or tibble with key elements (training data set)
    # tgt: target variable
    # prd: predictor variable
    # dfTest: test dataset for applying predictions
    # nPrint: maximum number of lines of confusion matrix to print
    #         0 means do not print any summary statistics
    # showPlot: boolean, should overlap plot be created and shown?
    
    # Counts of predictor to target variable
    dfPred <- df %>%
        group_by(across(all_of(c(prd, tgt)))) %>%
        summarize(n=n(), .groups="drop") %>%
        arrange(across(all_of(prd)), desc(n)) %>%
        group_by(across(all_of(prd))) %>%
        mutate(correct=row_number()==1, predicted=first(get(tgt))) %>%
        ungroup()

    # Confusion matrix and accuracy
    dfConf <- dfPred %>%
        group_by(across(all_of(c(tgt, "correct")))) %>%
        summarize(n=sum(n), .groups="drop") %>%
        pivot_wider(id_cols=tgt, names_from=correct, values_from=n, values_fill=0) %>%
        mutate(n=`TRUE`+`FALSE`, 
               pctCorrect=`TRUE`/n, 
               pctNaive=1/(nrow(.)), 
               lift=pctCorrect/pctNaive-1
               )
    
    # Overall confusion matrix
    dfConfAll <- dfConf %>%
        summarize(nMax=max(n), across(c(`FALSE`, `TRUE`, "n"), sum)) %>%
        mutate(pctCorrect=`TRUE`/n, 
               pctNaive=nMax/n, 
               lift=pctCorrect/pctNaive-1, 
               nBucket=length(unique(dfPred[[prd]]))
               )
    
    # Print confusion matrices
    if(nPrint > 0) {
        cat("\nAccuracy by target subgroup (training data):\n")
        dfConf %>% print(n=nPrint)
        cat("\nOverall Accuracy (training data):\n")
        dfConfAll %>% print(n=nPrint)
    }
    
    # Plot of overlaps
    if(isTRUE(showPlot)) {
        p1 <- dfPred %>%
            group_by(across(c(all_of(tgt), "predicted", "correct"))) %>%
            summarize(n=sum(n), .groups="drop") %>%
            ggplot(aes(x=get(tgt), y=predicted)) + 
            labs(x="Actual", 
                 y="Predicted", 
                 title=paste0("Training data - Actual vs. predicted ", tgt), 
                 subtitle=paste0("(using ", prd, ")")
                 ) + 
            geom_text(aes(label=n)) + 
            geom_tile(aes(fill=correct), alpha=0.25)
        print(p1)
    }
    
    # Create metrics for test dataset if requested
    if(!is.null(dfTest)) {
        # Get maximum category from training data
        mostPredicted <- count(dfPred, predicted, wt=n) %>% slice(1) %>% pull(predicted)
        # Get mapping of metric to prediction
        dfPredict <- dfPred %>% 
            group_by(across(all_of(c(prd, "predicted")))) %>% 
            summarize(n=sum(n), .groups="drop")
        # Create predictions for test data
        dfPredTest <- dfTest %>%
            select(all_of(c(prd, tgt))) %>%
            left_join(select(dfPredict, -n)) %>%
            replace_na(list(predicted=mostPredicted)) %>%
            group_by(across(all_of(c(prd, tgt, "predicted")))) %>%
            summarize(n=n(), .groups="drop") %>%
            mutate(correct=(get(tgt)==predicted))
        # Create confusion statistics for test data
        dfConfTest <- dfPredTest %>%
            group_by(across(all_of(c(tgt, "correct")))) %>%
            summarize(n=sum(n), .groups="drop") %>%
            pivot_wider(id_cols=tgt, names_from=correct, values_from=n, values_fill=0) %>%
            mutate(n=`TRUE`+`FALSE`, 
                   pctCorrect=`TRUE`/n, 
                   pctNaive=1/(nrow(.)), 
                   lift=pctCorrect/pctNaive-1
                   )
        # Overall confusion matrix for test data
        dfConfAllTest <- dfConfTest %>%
            summarize(nMax=max(n), across(c(`FALSE`, `TRUE`, "n"), sum)) %>%
            mutate(pctCorrect=`TRUE`/n, 
                   pctNaive=nMax/n, 
                   lift=pctCorrect/pctNaive-1, 
                   nBucket=length(unique(dfConfTest[[prd]]))
               )
        # Print confusion matrices
        if(nPrint > 0) {
            cat("\nAccuracy by target subgroup (testing data):\n")
            dfConfTest %>% print(n=nPrint)
            cat("\nOverall Accuracy (testing data):\n")
            dfConfAllTest %>% print(n=nPrint)
            }
    } else {
        dfPredTest <- NULL
        dfConfTest <- NULL
        dfConfAllTest <- NULL
        
    }
    
    # Return data if requested
    if(isTRUE(returnData)) list(dfPred=dfPred, 
                                dfConf=dfConf, 
                                dfConfAll=dfConfAll, 
                                dfPredTest=dfPredTest, 
                                dfConfTest=dfConfTest, 
                                dfConfAllTest=dfConfAllTest
                                )
    
}


# Fit a single predictor to a single categorical variable
simpleOneVarFit <- function(df, 
                            tgt, 
                            prd, 
                            rankType="last", 
                            naMethod=TRUE
                            ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame or tibble with key elements (training data set)
    # tgt: target variable
    # prd: predictor variable
    # rankType: method for breaking ties of same n, passed to base::rank as ties.method=
    # naMethod: method for handling NA in ranks, passed to base::rank as na.last=
    
    # Counts of predictor to target variable, and associated predictions
    df %>%
        group_by(across(all_of(c(prd, tgt)))) %>%
        summarize(n=n(), .groups="drop") %>%
        arrange(across(all_of(prd)), desc(n), across(all_of(tgt))) %>%
        group_by(across(all_of(prd))) %>%
        mutate(rankN=n()+1-rank(n, ties.method=rankType, na.last=naMethod)) %>%
        arrange(across(all_of(prd)), rankN) %>%
        ungroup()

}


# Create categorical predictions mapper
simpleOneVarMapper <- function(df, tgt, prd) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame or tibble from SimpleOneVarFit()
    # tgt: target variable
    # prd: predictor variable
    
    # Get the most common actual results
    dfCommon <- df %>% count(across(all_of(tgt)), wt=n, sort=TRUE)
    
    # Get the predictions
    dfPredictor <- df %>%
        group_by(across(all_of(prd))) %>%
        filter(row_number()==1) %>%
        select(all_of(c(prd, tgt))) %>%
        ungroup()
    
    list(dfPredictor=dfPredictor, dfCommon=dfCommon)
    
}


# Map the categorical predictions to unseen data
simpleOneVarApplyMapper <- function(df, 
                                    tgt,
                                    prd, 
                                    mapper, 
                                    mapperDF="dfPredictor", 
                                    mapperDefault="dfCommon",
                                    prdName="predicted"
                                    ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame containing prd for predicting tgt
    # tgt: target variable in df
    # prd: predictor variable in df
    # mapper: mapping list from sinpleOneVarMapper()
    # mapperDF: element that can be used to merge mappings
    # mapperDefault: element that can be used for NA resulting from merging mapperDF
    # prdName: name for the prediction variable
    
    # Extract the mapper and default value
    vecRename <- c(prdName) %>% purrr::set_names(tgt)
    dfMap <- mapper[[mapperDF]] %>% select(all_of(c(prd, tgt))) %>% colRenamer(vecRename=vecRename)
    chrDefault <- mapper[[mapperDefault]] %>% slice(1) %>% pull(tgt)
    
    # Merge mappings to df
    df %>%
        left_join(dfMap, by=prd) %>%
        replace_na(list("predicted"=chrDefault))
    
}


# Create confusion matrix data for categorical predictions
simpleOneVarConfusionData <- function(df, 
                                      tgtOrig,
                                      tgtPred, 
                                      otherVars=c(),
                                      weightBy="n"
                                      ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame from simpleOneVarApplyMapper()
    # tgtOrig: original target variable name in df
    # tgtPred: predicted target variable name in df
    # otherVars: other variables to be kept (will be grouping variables)
    # weightBy: weighting variable for counts in df (NULL means count each row of df as 1)
    
    # Confusion matrix data creation
    df %>%
        group_by(across(all_of(c(tgtOrig, tgtPred, otherVars)))) %>%
        summarize(n=if(!is.null(weightBy)) sum(get(weightBy)) else n(), .groups="drop") %>%
        mutate(correct=get(tgtOrig)==get(tgtPred))
    
}


# Print and plot confusion matrix for categorical predictions
simpleOneVarConfusionReport <- function(df, 
                                        tgtOrig,
                                        tgtPred, 
                                        otherVars=c(), 
                                        printConf=TRUE,
                                        printConfOrig=printConf, 
                                        printConfPred=printConf,
                                        printConfOverall=printConf, 
                                        plotConf=TRUE, 
                                        plotDesc="",
                                        nBucket=NA, 
                                        predictorVarName="", 
                                        returnData=FALSE
                                        ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame from simpleOneVarConfusionData()
    # tgtOrig: original target variable name in df
    # tgtPred: predicted target variable name in df
    # otherVars: other variables to be kept (will be grouping variables) - NOT IMPLEMENTED
    # printConf: boolean, should confusion matrix data be printed? Applies to all three
    # printConfOrig: boolean, should confusion data be printed based on original target variable?
    # printConfPred: boolean, should confusion data be printed based on predicted target variable?
    # printConfOverall: boolean, should overall confusion data be printed?
    # plotConf: boolean, should confusion overlap data be plotted?
    # plotDesc: descriptive label to be included in front of plot title
    # nBucket: number of buckets used for prediction (pass from previous data)
    # predictorVarName: variable name to be included in chart description
    # returnData: boolean, should the confusion matrices be returned?
    
    # Confusion data based on original target variable
    if(isTRUE(printConfOrig) | isTRUE(returnData)) {
        dfConfOrig <- df %>%
            group_by(across(all_of(c(tgtOrig)))) %>%
            summarize(right=sum(n*correct), wrong=sum(n)-right, n=sum(n), .groups="drop") %>%
            mutate(pctRight=right/n, pctNaive=n/(sum(n)), lift=pctRight/pctNaive-1)
    }

    # Confusion data based on predicted target variable
    if(isTRUE(printConfPred) | isTRUE(returnData)) {
        dfConfPred <- df %>%
            group_by(across(all_of(c(tgtPred)))) %>%
            summarize(right=sum(n*correct), wrong=sum(n)-right, n=sum(n), .groups="drop") %>%
            mutate(pctRight=right/n)
    }

    # Overall confusion data
    if(isTRUE(printConfOverall) | isTRUE(returnData)) {
        maxNaive <- df %>%
            group_by(across(all_of(tgtOrig))) %>%
            summarize(n=sum(n), .groups="drop") %>%
            arrange(desc(n)) %>%
            slice(1) %>%
            pull(n)
        dfConfOverall <- df %>%
            summarize(right=sum(n*correct), wrong=sum(n)-right, n=sum(n), .groups="drop") %>%
            mutate(maxN=maxNaive, pctRight=right/n, pctNaive=maxN/n, lift=pctRight/pctNaive-1, nBucket=nBucket)
    }
    
    # Confusion report based on original target variable
    if(isTRUE(printConfOrig)) {
        cat("\nConfusion data based on original target variable:", tgtOrig, "\n")
        dfConfOrig %>%
            print(n=50)
    }

    # Confusion report based on predicted target variable
    if(isTRUE(printConfPred)) {
        cat("\nConfusion data based on predicted target variable:", tgtPred, "\n")
        dfConfPred %>%
            print(n=50)
    }
    
    # Overall confusion matrix
    if(isTRUE(printConfOverall)) {
        cat("\nOverall confusion matrix\n")
        dfConfOverall %>%
            print(n=50)
    }
    
    # Plot of overlaps
    if(isTRUE(plotConf)) {
        p1 <- df %>%
            group_by(across(all_of(c(tgtOrig, tgtPred, "correct")))) %>%
            summarize(n=sum(n), .groups="drop") %>%
            ggplot(aes(x=get(tgtOrig), y=get(tgtPred))) + 
            labs(x="Actual", 
                 y="Predicted", 
                 title=paste0(plotDesc, "Actual vs. predicted ", tgtOrig), 
                 subtitle=paste0("(using ", predictorVarName, ")")
                 ) + 
            geom_text(aes(label=n)) + 
            geom_tile(aes(fill=correct), alpha=0.25)
        print(p1)
    }
    
    # Return data if requested
    if(isTRUE(returnData)) list(dfConfOrig=dfConfOrig, dfConfPred=dfConfPred, dfConfOverall=dfConfOverall)
    
}


# Process for chaining predictor, applier, and confusion matrix for categorical variables
simpleOneVarChain <- function(df,
                              tgt,
                              prd,
                              mapper=NULL, 
                              rankType="last", 
                              naMethod=TRUE, 
                              printReport=TRUE, 
                              plotDesc="",
                              returnData=TRUE, 
                              includeConfData=FALSE
                              ) {

    # FUNCTION ARGUMENTS:
    # df: data frame or tibble with key elements (training or testing data set)
    # tgt: target variable
    # prd: predictor variable
    # mapper: mapping file to be applied for predictions (NULL means create from simpleOneVarApply())
    # rankType: method for breaking ties of same n, passed to base::rank as ties.method=
    # naMethod: method for handling NA in ranks, passed to base::rank as na.last=    
    # printReport: boolean, should the confusion report data and plot be printed?
    # plotDesc: descriptive label to be included in front of plot title
    # returnData: boolean, should data elements be returned?
    # includeConfData: boolean, should confusion data be returned?
    
    # Create the summary of predictor-target-n
    dfFit <- simpleOneVarFit(df, tgt=tgt, prd=prd, rankType=rankType, naMethod=naMethod)     

    # Create the mapper if it does not already exist
    if(is.null(mapper)) mapper <- simpleOneVarMapper(dfFit, tgt=tgt, prd=prd)
    
    # Apply mapper to data
    dfApplied <- simpleOneVarApplyMapper(dfFit, tgt=tgt, prd=prd, mapper=mapper)

    # Create confusion data
    dfConfusion <- simpleOneVarConfusionData(dfApplied, tgtOrig=tgt, tgtPred="predicted")
    
    # Create confusion report if requested
    if(isTRUE(printReport) | isTRUE(includeConfData)) {
        dfConfReport <- simpleOneVarConfusionReport(df=dfConfusion, 
                                                    tgtOrig=tgt, 
                                                    tgtPred="predicted", 
                                                    nBucket=length(unique(dfApplied[[prd]])), 
                                                    predictorVarName=prd, 
                                                    printConf=printReport, 
                                                    plotConf=printReport,
                                                    plotDesc=plotDesc,
                                                    returnData=includeConfData
                                                    )
    }
    
    # Return data if requested
    if(isTRUE(returnData)) {
        ret <- list(dfFit=dfFit, mapper=mapper, dfApplied=dfApplied, dfConfusion=dfConfusion)
        if(isTRUE(includeConfData)) ret<-c(ret, list(dfConfData=dfConfReport))
        ret
    }
    
}


# Adds a train-test component for single variable predictions
simpleOneVarTrainTest <- function(dfTrain,
                                  dfTest,
                                  tgt,
                                  prd,
                                  rankType="last", 
                                  naMethod=TRUE, 
                                  printReport=FALSE, 
                                  includeConfData=TRUE, 
                                  returnData=TRUE
                              ) {

    # FUNCTION ARGUMENTS:
    # dfTrain: data frame or tibble with key elements (training data set)
    # dfTest: data frame or tibble with key elements (testing data set)
    # tgt: target variable
    # prd: predictor variable
    # rankType: method for breaking ties of same n, passed to base::rank as ties.method=
    # naMethod: method for handling NA in ranks, passed to base::rank as na.last=    
    # printReport: boolean, should the confusion report data and plot be printed?
    # includeConfData: boolean, should confusion data be returned?
    # returnData: boolean, should data elements be returned?
    
    # Fit the training data
    tmpTrain <- simpleOneVarChain(df=dfTrain, 
                                  tgt=tgt, 
                                  prd=prd,
                                  rankType=rankType,
                                  naMethod=naMethod,
                                  printReport=printReport,
                                  plotDesc="Training data: ",
                                  returnData=TRUE,
                                  includeConfData=includeConfData
                                  )
    
    # Fit the testing data
    tmpTest <- simpleOneVarChain(df=dfTest, 
                                 tgt=tgt, 
                                 prd=prd,
                                 mapper=tmpTrain$mapper,
                                 rankType=rankType,
                                 naMethod=naMethod,
                                 printReport=printReport,
                                 plotDesc="Testing data: ",
                                 returnData=TRUE,
                                 includeConfData=includeConfData
                                 )
    
    # Return data if requested
    if(isTRUE(returnData)) list(tmpTrain=tmpTrain, tmpTest=tmpTest)
    
}


# Plot the means by cluster and variable for a k-means object
plotClusterMeans <- function(km, nrow=NULL, ncol=NULL, scales="fixed") {

    # FUNCTION ARGUMENTS
    # km: object returned by stats::kmeans(...)
    # nrow: number of rows for faceting (NULL means default)
    # ncol: number of columns for faceting (NULL means default)
    # scales: passed to facet_wrap as scales=scales
    
    # Assess clustering by dimension
    p1 <- km$centers %>%
        tibble::as_tibble() %>%
        mutate(cluster=row_number()) %>%
        pivot_longer(cols=-c(cluster)) %>%
        ggplot(aes(x=fct_reorder(name, 
                                 value, 
                                 .fun=function(a) ifelse(length(a)==2, a[2]-a[1], diff(range(a)))
                                 ), 
                   y=value
                   )
               ) + 
        geom_point(aes(color=factor(cluster))) + 
        scale_color_discrete("Cluster") + 
        facet_wrap(~factor(cluster), nrow=nrow, ncol=ncol, scales=scales) +
        labs(title=paste0("Cluster means (kmeans, centers=", nrow(km$centers), ")"), 
             x="Metric", 
             y="Cluster mean"
             ) + 
        geom_hline(yintercept=median(km$centers), lty=2) +
        coord_flip()
    print(p1)
    
}


# Plot percentage by cluster
plotClusterPct <- function(df, km, keyVars, nRowFacet=1, printPlot=TRUE) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame initially passed to stats::kmeans(...)
    # km: object returned by stats::kmeans(...)
    # keyVars: character vector of length 1 (y-only, x will be cl) or length 2 (x, y, cl will facet)
    # nRowFacet: number of rows for facetting (only relevant if length(keyVars) is 2)
    # printPlot: boolean, should plot be printed? (if not true, plot will be returned)
    
    # Check length of keyVars
    if(!(length(keyVars) %in% c(1, 2))) stop("\nArgument keyVars must be length-1 or length-2\n")
    
    p1 <- df %>%
        mutate(cl=factor(km$cluster)) %>%
        group_by(across(c(all_of(keyVars), "cl"))) %>%
        summarize(n=n(), .groups="drop") %>%
        group_by(across(all_of(keyVars))) %>%
        mutate(pct=n/sum(n)) %>%
        ungroup() %>%
        ggplot() + 
        scale_fill_continuous(low="white", high="green") + 
        labs(title=paste0("Percentage by cluster (kmeans with ", nrow(km$centers), " centers)"), 
             x=ifelse(length(keyVars)==1, "Cluster", keyVars[1]), 
             y=ifelse(length(keyVars)==1, keyVars[1], keyVars[2])
             )
    if(length(keyVars)==1) p1 <- p1 + geom_tile(aes(fill=pct, x=cl, y=get(keyVars[1])))
    if(length(keyVars)==2) {
        p1 <- p1 + 
            geom_tile(aes(fill=pct, x=get(keyVars[1]), y=get(keyVars[2]))) + 
            facet_wrap(~cl, nrow=nRowFacet)
    }
    
    if(isTRUE(printPlot)) print(p1)
    else return(p1)
    
}


# Run k-means (or use passed k-means object) and plot centers and percentages of observations
runKMeans <- function(df, 
                      km=NULL,
                      vars=NULL, 
                      centers=2, 
                      nStart=1L, 
                      iter.max=10L, 
                      seed=NULL, 
                      plotMeans=FALSE,
                      nrowMeans=NULL,
                      plotPct=NULL, 
                      nrowPct=1, 
                      returnKM=is.null(km)
                      ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame for clustering
    # km: k-means object (will shut off k-means processing and run as plot-only)
    # vars: variables to be used for clustering (NULL means everything in df)
    # centers: number of centers
    # nStart: passed to kmeans
    # iter.max: passed to kmeans
    # seed: seed to be set (if NULL, no seed is set)
    # plotMeans: boolean, plot variable means by cluster?
    # nrowMeans: argument passed as nrow for faceting rows in plotClusterMeans() - NULL is default ggplot2
    # plotPct: list of character vectors to be passed sequentially as keyVars to plotClusterPct()
    #          NULL means do not run
    #          pctByCluster=list(c("var1"), c("var2", "var3")) will run plotting twice
    # nrowPct: argument for faceting number of rows in plotClusterPct()
    # returnKM: boolean, should the k-means object be returned?
    
    # Set seed if requested
    if(!is.null(seed)) set.seed(seed)
    
    # Get the variable names if passed as NULL
    if(is.null(vars)) vars <- names(df)
    
    # Run the k-means process if the object has not been passed
    if(is.null(km)) {
        km <- df %>%
            select(all_of(vars)) %>% 
            kmeans(centers=centers, iter.max=iter.max, nstart=nStart)
    }

    # Assess clustering by dimension if requested
    if(isTRUE(plotMeans)) plotClusterMeans(km, nrow=nrowMeans)
    if(!is.null((plotPct))) 
        for(ctr in 1:length(plotPct)) 
            plotClusterPct(df=df, km=km, keyVars=plotPct[[ctr]], nRowFacet=nrowPct)
    
    # Return the k-means object
    if(isTRUE(returnKM)) return(km)
    
}


# Assign points to closest center of a passed k-means object
assignKMeans <- function(km, df, returnAllDistanceData=FALSE) {
    
    # FUNCTION ARGUMENTS:
    # km: a k-means object
    # df: data frame or tibble
    # returnAllDistanceData: boolean, should the distance data and clusters be returned?
    #                        TRUE returns a data frame with distances as V1, V2, ..., and cluster as cl
    #                        FALSE returns a vector of cluster assignments as integers
    
    # Select columns from df to match km
    df <- df %>% select(all_of(colnames(km$centers)))
    if(!all.equal(names(df), colnames(km$centers))) stop("\nName mismatch in clustering and frame\n")
    
    # Create the distances and find clusters
    distClust <- sapply(seq_len(nrow(km$centers)), 
                        FUN=function(x) sqrt(rowSums(sweep(as.matrix(df), 
                                                           2, 
                                                           t(as.matrix(km$centers[x,,drop=FALSE]))
                                                           )**2
                                                     )
                                             )
                        ) %>% 
        as.data.frame() %>% 
        tibble::as_tibble() %>% 
        mutate(cl=apply(., 1, which.min))
    
    # Return the proper file
    if(isTRUE(returnAllDistanceData)) return(distClust)
    else return(distClust$cl)
    
}


```

Key mapping tables for available metrics are also copied:  
```{r}

hourlyMetrics <- "temperature_2m,relativehumidity_2m,dewpoint_2m,apparent_temperature,pressure_msl,surface_pressure,precipitation,rain,snowfall,cloudcover,cloudcover_low,cloudcover_mid,cloudcover_high,shortwave_radiation,direct_radiation,direct_normal_irradiance,diffuse_radiation,windspeed_10m,windspeed_100m,winddirection_10m,winddirection_100m,windgusts_10m,et0_fao_evapotranspiration,weathercode,vapor_pressure_deficit,soil_temperature_0_to_7cm,soil_temperature_7_to_28cm,soil_temperature_28_to_100cm,soil_temperature_100_to_255cm,soil_moisture_0_to_7cm,soil_moisture_7_to_28cm,soil_moisture_28_to_100cm,soil_moisture_100_to_255cm"
dailyMetrics <- "weathercode,temperature_2m_max,temperature_2m_min,apparent_temperature_max,apparent_temperature_min,precipitation_sum,rain_sum,snowfall_sum,precipitation_hours,sunrise,sunset,windspeed_10m_max,windgusts_10m_max,winddirection_10m_dominant,shortwave_radiation_sum,et0_fao_evapotranspiration"

hourlyDescription <- "Air temperature at 2 meters above ground\nRelative humidity at 2 meters above ground\nDew point temperature at 2 meters above ground\nApparent temperature is the perceived feels-like temperature combining wind chill factor, relative humidity and solar radiation\nAtmospheric air pressure reduced to mean sea level (msl) or pressure at surface. Typically pressure on mean sea level is used in meteorology. Surface pressure gets lower with increasing elevation.\nAtmospheric air pressure reduced to mean sea level (msl) or pressure at surface. Typically pressure on mean sea level is used in meteorology. Surface pressure gets lower with increasing elevation.\nTotal precipitation (rain, showers, snow) sum of the preceding hour. Data is stored with a 0.1 mm precision. If precipitation data is summed up to monthly sums, there might be small inconsistencies with the total precipitation amount.\nOnly liquid precipitation of the preceding hour including local showers and rain from large scale systems.\nSnowfall amount of the preceding hour in centimeters. For the water equivalent in millimeter, divide by 7. E.g. 7 cm snow = 10 mm precipitation water equivalent\nTotal cloud cover as an area fraction\nLow level clouds and fog up to 2 km altitude\nMid level clouds from 2 to 6 km altitude\nHigh level clouds from 6 km altitude\nShortwave solar radiation as average of the preceding hour. This is equal to the total global horizontal irradiation\nDirect solar radiation as average of the preceding hour on the horizontal plane and the normal plane (perpendicular to the sun)\nDirect solar radiation as average of the preceding hour on the horizontal plane and the normal plane (perpendicular to the sun)\nDiffuse solar radiation as average of the preceding hour\nWind speed at 10 or 100 meters above ground. Wind speed on 10 meters is the standard level.\nWind speed at 10 or 100 meters above ground. Wind speed on 10 meters is the standard level.\nWind direction at 10 or 100 meters above ground\nWind direction at 10 or 100 meters above ground\nGusts at 10 meters above ground of the indicated hour. Wind gusts in CERRA are defined as the maximum wind gusts of the preceding hour. Please consult the ECMWF IFS documentation for more information on how wind gusts are parameterized in weather models.\nET0 Reference Evapotranspiration of a well watered grass field. Based on FAO-56 Penman-Monteith equations ET0 is calculated from temperature, wind speed, humidity and solar radiation. Unlimited soil water is assumed. ET0 is commonly used to estimate the required irrigation for plants.\nWeather condition as a numeric code. Follow WMO weather interpretation codes. See table below for details. Weather code is calculated from cloud cover analysis, precipitation and snowfall. As barely no information about atmospheric stability is available, estimation about thunderstorms is not possible.\nVapor Pressure Deificit (VPD) in kilopascal (kPa). For high VPD (>1.6), water transpiration of plants increases. For low VPD (<0.4), transpiration decreases\nAverage temperature of different soil levels below ground.\nAverage temperature of different soil levels below ground.\nAverage temperature of different soil levels below ground.\nAverage temperature of different soil levels below ground.\nAverage soil water content as volumetric mixing ratio at 0-7, 7-28, 28-100 and 100-255 cm depths.\nAverage soil water content as volumetric mixing ratio at 0-7, 7-28, 28-100 and 100-255 cm depths.\nAverage soil water content as volumetric mixing ratio at 0-7, 7-28, 28-100 and 100-255 cm depths.\nAverage soil water content as volumetric mixing ratio at 0-7, 7-28, 28-100 and 100-255 cm depths."
dailyDescription <- "The most severe weather condition on a given day\nMaximum and minimum daily air temperature at 2 meters above ground\nMaximum and minimum daily air temperature at 2 meters above ground\nMaximum and minimum daily apparent temperature\nMaximum and minimum daily apparent temperature\nSum of daily precipitation (including rain, showers and snowfall)\nSum of daily rain\nSum of daily snowfall\nThe number of hours with rain\nSun rise and set times\nSun rise and set times\nMaximum wind speed and gusts on a day\nMaximum wind speed and gusts on a day\nDominant wind direction\nThe sum of solar radiaion on a given day in Megajoules\nDaily sum of ET0 Reference Evapotranspiration of a well watered grass field"

# Create tibble for hourly metrics
tblMetricsHourly <- tibble::tibble(metric=hourlyMetrics %>% str_split_1(","), 
                                   description=hourlyDescription %>% str_split_1("\n")
                                   )
tblMetricsHourly %>% 
    print(n=50)

# Create tibble for daily metrics
tblMetricsDaily <- tibble::tibble(metric=dailyMetrics %>% str_split_1(","), 
                                  description=dailyDescription %>% str_split_1("\n")
                                   )
tblMetricsDaily

```

Daily and hourly data are downloaded for NYc, cached to avoid multiple hits to the server:  
```{r cache=TRUE}

# Hourly data download for New York, NY
testURLHourly <- helperOpenMeteoURL(cityName="New York NY", 
                                    hourlyIndices=1:nrow(tblMetricsHourly),
                                    startDate="2010-01-01", 
                                    endDate="2023-06-15", 
                                    tz="America/New_York"
                                    )
testURLHourly

# Download file
if(!file.exists("testOM_hourly_nyc.json")) {
    fileDownload(fileName="testOM_hourly_nyc.json", url=testURLHourly)
} else {
    cat("\nFile testOM_hourly_nyc.json already exists, skipping download\n")
}


# Daily data download for New York, NY
testURLDaily <- helperOpenMeteoURL(cityName="New York NY", 
                                   dailyIndices=1:nrow(tblMetricsDaily),
                                   startDate="2010-01-01", 
                                   endDate="2023-06-15", 
                                   tz="America/New_York"
                                   )
testURLDaily

# Download file
if(!file.exists("testOM_daily_nyc.json")) {
    fileDownload(fileName="testOM_daily_nyc.json", url=testURLDaily)
} else {
    cat("\nFile testOM_daily_nyc.json already exists, skipping download\n")
}

```

Data are read (process cached):  
```{r cache=TRUE}

# Read daily JSON file
nycOMDaily <- readOpenMeteoJSON("testOM_daily_nyc.json")
nycOMDaily
prettyOpenMeteoMeta(nycOMDaily)

# Read hourly JSON file
nycOMHourly <- readOpenMeteoJSON("testOM_hourly_nyc.json")
nycOMHourly
prettyOpenMeteoMeta(nycOMHourly)

```

Percentiles and other explanatory variables are created:  
```{r, fig.height=9, fig.width=9}

# Create percentiles for numeric variables
nycTemp <- nycOMHourly$tblHourly %>%
    mutate(month=factor(month.abb[lubridate::month(date)], levels=month.abb), 
           hour=lubridate::hour(time), 
           fct_hour=factor(hour), 
           across(where(is.numeric), .fns=function(x) round(100*percent_rank(x)), .names="pct_{.col}")
           )
nycTemp

# Create summary statistics
nycStats <- nycTemp %>%
    select((where(is.numeric))) %>%
    pivot_longer(cols=everything()) %>%
    group_by(name) %>%
    summarize(across(value, .fns=list(min=min, median=median, mean=mean, max=max)))
nycStats %>%
    filter(str_detect(name, "pct")) %>%
    arrange(value_median, value_mean) %>%
    print(n=40)
nycStats %>%
    filter(!str_detect(name, "pct")) %>%
    arrange(value_max, value_mean) %>%
    print(n=40)

# Outlier wind data (includes Sandy 2012-10-29, as well as several other dates)
nycTemp %>%
    filter(windspeed_10m>60 | windgusts_10m>100) %>%
    select(time, windspeed_10m, windgusts_10m, everything())
keyDates <- nycTemp %>%
    filter(windspeed_10m>60 | windgusts_10m>100) %>%
    pull(date) %>%
    unique()
nycTemp %>%
    ggplot(aes(x=time)) +
    geom_line(aes(y=windgusts_10m)) + 
    geom_vline(xintercept = lubridate::ymd_hm(paste0(keyDates, "T12:00")), color="red", lty=2)
    
```

Random variables and additional explanatory variables are created, and test-train data are split:  
```{r}

# Add random variables to dataset, then split in to test and train
set.seed(23100415)
nycTempRand <- nycTemp %>%
    mutate(pct_0005=sample(0:5, size=nrow(.), replace=TRUE),
           pct_0025=sample(0:25, size=nrow(.), replace=TRUE), 
           pct_0100=sample(0:100, size=nrow(.), replace=TRUE), 
           pct_0250=sample(0:250, size=nrow(.), replace=TRUE),
           pct_0500=sample(0:500, size=nrow(.), replace=TRUE), 
           pct_1000=sample(0:1000, size=nrow(.), replace=TRUE), 
           pct_2500=sample(0:2500, size=nrow(.), replace=TRUE), 
           pct_5000=sample(0:5000, size=nrow(.), replace=TRUE), 
           tod=ifelse(hour>=7 & hour<=18, "Day", "Night"), 
           season=case_when(month %in% c("Mar", "Apr", "May") ~ "Spring", 
                            month %in% c("Jun", "Jul", "Aug") ~ "Summer", 
                            month %in% c("Sep", "Oct", "Nov") ~ "Fall", 
                            month %in% c("Dec", "Jan", "Feb") ~ "Winter", 
                            TRUE~"typo"
                            ), 
           todSeason=paste0(season, "-", tod), 
           tod=factor(tod, levels=c("Day", "Night")), 
           season=factor(season, levels=c("Spring", "Summer", "Fall", "Winter")), 
           todSeason=factor(todSeason, 
                            levels=paste0(rep(c("Spring", "Summer", "Fall", "Winter"), each=2), 
                                          "-", 
                                          c("Day", "Night")
                                          )
                            )
           )
nycTempRand %>% count(tod)
nycTempRand %>% count(season)
nycTempRand %>% count(todSeason)

# Split in to test and train data (3:1 split in favor of test)
idxTrain <- sort(sample(1:nrow(nycTempRand), size=round(0.75*nrow(nycTempRand)), replace=FALSE))
nycTempTrain <- nycTempRand[idxTrain, ]
nycTempTest <- nycTempRand[-idxTrain, ]

```

K-means is run using 1-15 centers, cached to reduce processing time:  
```{r, cache=TRUE}

# Create set of relevant training variables
varsTrain <- nycTempTrain %>%
    select(starts_with("pct")) %>%
    select(-pct_hour, -pct_weathercode, -ends_with("0"), -ends_with("5")) %>%
    names()
varsTrain

# Create k-means for 1-15 clusters (need to fix function for returning km object defaults)
t <- proc.time()
nycKMList <- lapply(1:15, FUN=function(x) runKMeans(nycTempTrain, 
                                                    vars=varsTrain, 
                                                    centers=x, 
                                                    nStart=25, 
                                                    seed=23100515, 
                                                    iter.max=50L,
                                                    plotMeans=FALSE, 
                                                    plotPct=NULL, 
                                                    returnKM=TRUE
                                                    )
                 )
proc.time()-t

```
  
Change in SS-between is explored based on number of clusters:  
```{r, fig.height=9, fig.width=9}

dfSS <- sapply(nycKMList, FUN=function(x) c("nCluster"=length(x$size), 
                                            "totss"=x$totss, 
                                            "betweenss"=x$betweenss, 
                                            "tot.withinss"=x$tot.withinss, 
                                            "iter"=x$iter, 
                                            "ifault"=unclass(ifelse(is.null(x$ifault), 0, x$ifault))
                                            )
               ) %>% 
    t() %>% 
    tibble::as_tibble() %>% 
    mutate(pct=tot.withinss/totss, dpct=pct-lag(pct)) 
dfSS

dfSS %>% 
    ggplot(aes(x=nCluster, y=pmin(1, pct))) + 
    geom_point() + 
    geom_line() + 
    lims(y=c(0, 1)) + 
    labs(x="# Clusters", 
         y="Within SS / Total SS", 
         title="Sum-squares ratio by number of clusters (k=means)"
         ) + 
    geom_text(aes(y=pct-0.05, label=round(pct, 3)), size=2.5)

dfSS %>% 
    filter(!is.na(dpct)) %>% 
    ggplot(aes(x=factor(nCluster), y=dpct)) + 
    geom_col(fill="lightblue") + 
    labs(x="When adding this cluster", 
         y="Change in (Within SS / Total SS)", 
         title="Sum-squares ratio by number of clusters (k=means)"
         ) + 
    geom_text(aes(y=dpct/2, label=round(dpct, 3)), size=2.5)

```
  
* The first cluster added (k=2) causes ~20% drop in SS-within  
* The next three clusters added (k=3, 4, 5) each cause 5%-10% drop in SS-within  
* Clusters after k=5 have consistent, modest drops in SS-within  
  
This is suggestive that exploring evolution of data splits at k = 1, 2, 3, 4, 5 may be informative  
  
The assignKMeans() functionality is tested:  
```{r}

# Example of returning distance data
glimpse(assignKMeans(km=nycKMList[[10]], df=nycTempTrain, returnAllDistanceData=TRUE))

# Confirmation that cluster assignments match (could occasionally have a tied distance and possible mismatch)
table(assignKMeans(km=nycKMList[[10]], df=nycTempTrain), nycKMList[[10]]$cluster)

```

The function successfully assigns points to the nearest centroid, consistent with the output of kmeans()

The output of 4 k-means clusters is explored:  
```{r, fig.height=9, fig.width=9}

# Function run on the 4-cluster k-means object
runKMeans(df=nycTempTrain, 
          km=nycKMList[[4]], 
          plotMeans=TRUE, 
          plotPct=list(c("todSeason"), c("hour", "month")), 
          nrowPct=1, 
          nrowMeans=1
          )

```

Clusters include the four quadrants of day/night and warm/cold season

The output of 5 k-means clusters is explored:  
```{r, fig.height=9, fig.width=9}

# Function run on the 5-cluster k-means object
runKMeans(df=nycTempTrain, 
          km=nycKMList[[5]], 
          plotMeans=TRUE, 
          plotPct=list(c("todSeason"), c("hour", "month")), 
          nrowPct=1, 
          nrowMeans=1
          )

# Exploring precipitation by cluster
nycTempTrain %>% 
    mutate(cl=nycKMList[[5]]$cluster) %>% 
    group_by(cl) %>% 
    summarize(n=n(), 
              precip=sum(precipitation), 
              rain=sum(rain), 
              snow=sum(snowfall), 
              pct_hrs_precip=mean(precipitation>0)
              ) %>%
    arrange(desc(precip))

```

Clusters include precipitation/no, followed by the four quadrants of day/night and warm/cold season

Principal component analysis is run to explore variance explained by number of components:  
```{r, fig.height=9, fig.width=9}

# Correlation analysis
corTrain <- cor(nycTempTrain[, varsTrain])
hcTrain <- hclust(as.dist((1-corTrain)/2))
orderTrain <- hcTrain$order %>% purrr::set_names(hcTrain$labels)
tmpHeat <- as.data.frame(corTrain, row.names=rownames(corTrain)) %>% 
    rownames_to_column("var1") %>% 
    tibble::as_tibble() %>% 
    pivot_longer(cols=-c("var1"), names_to="var2") %>%
    mutate()
tmpHeat %>%
    ggplot(aes(x=fct_reorder(var1, orderTrain[var1]), y=fct_reorder(var2, orderTrain[var2]))) + 
    geom_tile(aes(fill=value)) + 
    geom_text(aes(label=round(value, 2)), size=2) + 
    scale_fill_gradient2(low="red", mid="white", high="green") + 
    labs(x=NULL, y=NULL, title="Correlations") + 
    theme(axis.text.x=element_text(angle=90, vjust=0.5, hjust=1))

pcaTrain <- prcomp(nycTempTrain[, varsTrain])
summary(pcaTrain)
tibble::tibble(sd=pcaTrain$sdev, var=sd**2, n=1:length(pcaTrain$sdev)) %>%
    ggplot(aes(x=n)) + 
    geom_col(aes(y=var/sum(var)), fill="lightblue") +
    geom_text(aes(y=cumsum(var)/sum(var), label=round(cumsum(var)/sum(var), 2)), hjust=0, size=2.5) + 
    geom_line(aes(y=cumsum(var)/sum(var))) +
    labs(x="Component", y="Variance Explained", title="Variance Explained (cumulative and incremental)")

```
  
Around 75% of variance is explained by the first 5 components, with around 90% explained by the first 10 components

A simple random forest classification is explored, for prediction of month:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Simple random forest model
rfTempTrainMonth <- ranger::ranger(month ~ ., 
                                   data=nycTempTrain[, c('month', varsTrain)], 
                                   importance = "impurity"
                                   )
rfTempTrainMonth

# Variable importance
rfTempTrainMonth$variable.importance %>% 
    as.data.frame() %>% 
    purrr::set_names("imp") %>% 
    rownames_to_column("metric") %>% 
    tibble::as_tibble() %>%
    ggplot(aes(x=fct_reorder(metric, imp), y=imp/1000)) + 
    geom_col(fill="lightblue") + 
    labs(x=NULL, y="Variable Importance (000)", title="Simple random forest to predict month") +
    coord_flip()

# Performance on test data (confirm >99% accuracy)
rfTempTest <- nycTempTest %>%
    mutate(pred=predict(rfTempTrainMonth, data=.)$predictions)
cat("\nAccuracy on test dataset is: ", round(100*mean(rfTempTest$pred==rfTempTest$month), 2), "%\n", sep="")
rfTempTest %>%
    count(month, pred) %>%
    ggplot(aes(x=pred, y=month)) + 
    geom_tile(aes(fill=n)) + 
    geom_text(aes(label=n), size=2.5) +
    scale_fill_continuous("", low="white", high="green") + 
    labs(x="Predicted month", y="Actual month", title="Predicting month on test data")

```
  
The simple random forest has over 99% predictive accuracy on month, primarily focusing on metrics related to soil (soil temperature and soil moisture at various depths).

A portion of the predictive accuracy may be based on specific soil trends during a given year, as it is very unlikely that data consistently change right at 00h00 of a new month. Models are run using a holdout year:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Simple random forest model, holding out 2022 data
rfTempHoldout <- ranger::ranger(month ~ ., 
                                data=nycTempTrain[year(nycTempTrain$date) != 2022, c('month', varsTrain)], 
                                importance = "impurity"
                                )
rfTempHoldout

# Performance on holdout data
rfTempTest <- nycTempTrain %>%
    bind_rows(nycTempTest) %>%
    filter(year(date)==2022) %>%
    mutate(pred=predict(rfTempHoldout, data=.)$predictions)
cat("\nAccuracy on holdout 2022 data is: ", round(100*mean(rfTempTest$pred==rfTempTest$month), 2), "%\n", sep="")
rfTempTest %>%
    count(month, pred) %>%
    ggplot(aes(x=pred, y=month)) + 
    geom_tile(aes(fill=n)) + 
    geom_text(aes(label=n), size=2.5) +
    scale_fill_continuous("", low="white", high="green") + 
    labs(x="Predicted month (2022)", 
         y="Actual month (2022)", 
         title="Applying random forest fit without 2022 data to 2022"
         )

```
  
Without access to training data including 2022, the model still makes good predictions for 2022 month. But, predictions are commonly off by +/- 1 month leading to overall accuracy of ~80% (vs. 99%+ when able to train on soil heating patterns in the given year)

The process for running random forest is converted to functional form:  
```{r, fig.height=9, fig.width=9}

runSimpleRF <- function(df, yVar, xVars=NULL, ...) {

    # FUNCTION ARGUMENTS:
    # df: data frame containing observations
    # yVar: variable to be predicted (numeric for regression, categorical for classification)
    # xVars: predictor variables (NULL means everything in df except for yVar)
    # ...: other arguments passed to ranger::ranger
    
    # Create xVars if passed as NULL
    if(is.null(xVars)) xVars <- setdiff(names(df), yVar)
    
    # Simple random forest model
    ranger::ranger(as.formula(paste0(yVar, "~", paste0(xVars, collapse="+"))), 
                   data=df[, c(yVar, xVars)], 
                   ...
                   )
    
}

```

The function is checked for consistency:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

tstRF <- runSimpleRF(df=nycTempTrain, yVar="month", xVars=varsTrain, importance="impurity")
tstRF

# Comparison of variable importance
rfTempTrainMonth$variable.importance %>% 
    as.data.frame() %>% 
    purrr::set_names("imp") %>% 
    rownames_to_column("metric") %>% 
    tibble::as_tibble() %>%
    mutate(type="original") %>%
    bind_rows(tstRF$variable.importance %>% 
                  as.data.frame() %>% 
                  purrr::set_names("imp") %>% 
                  rownames_to_column("metric") %>% 
                  tibble::as_tibble() %>%
                  mutate(type="formula")
              ) %>%
    ggplot(aes(x=fct_reorder(metric, imp), y=imp/1000)) + 
    geom_point(aes(color=type)) + 
    labs(x=NULL, y="Variable Importance (000)", title="Simple random forest to predict month") +
    coord_flip()

```

Aside from minor differences due to different random conditions (no seed was set prior to either run), the function and original call produce substantially the same outputs

A function is written for plotting variable importance:  
```{r, fig.height=9, fig.width=9}

plotRFImportance <- function(rf, 
                             impName="variable.importance", 
                             divBy=1000, 
                             plotTitle=NULL, 
                             plotData=TRUE, 
                             returnData=!isTRUE(plotData)
                             ) {
    
    # FUNCTION ARGUMENTS:
    # rf: output list from random forest with an element for importance
    # impName: name of the element to extract from rf
    # divBy: divisor for the importance variable
    # plotTitle: title for plot (NULL means use default)
    # plotData: boolean, should the importance plot be created and printed?
    # returnData: boolean, should the processed data be returned?
    
    # Create title if not provided
    if(is.null(plotTitle)) plotTitle <- "Importance for simple random forest"

    # Create y-axis label
    yAxisLabel="Variable Importance"
    if(!isTRUE(all.equal(divBy, 1))) yAxisLabel <- paste0(yAxisLabel, " (", divBy, "s)")
    
    # Create variable importance
    df <- rf[[impName]] %>% 
        as.data.frame() %>% 
        purrr::set_names("imp") %>% 
        rownames_to_column("metric") %>% 
        tibble::as_tibble() 
    
    # Create and print plot if requested
    if(isTRUE(plotData)) {
        p1 <- df %>%
            ggplot(aes(x=fct_reorder(metric, imp), y=imp/divBy)) + 
            geom_col(fill="lightblue") + 
            labs(x=NULL, y=yAxisLabel, title=plotTitle) +
            coord_flip()
        print(p1)
    }
    
    # Return data if requested
    if(isTRUE(returnData)) return(df)
    
}

# Example for plot only
plotRFImportance(tstRF)

# Example for data only
plotRFImportance(tstRF, plotData=FALSE)

```
  
A function is written for applying the model to test (or other) data:  
```{r, fig.height=9, fig.width=9}

# Ranger needs to be explicitly in the namespace for predictions
library(ranger)

predictRF <- function(rf, df, newCol="pred", predsOnly=FALSE) {
    
    # FUNCTION ARGUMENTS:
    # rf: a trained random forest model
    # df: data frame for adding predictions
    # newCol: name for new column to be added to df
    # predsOnly: boolean, should only the vector of predictions be returned?
    #            if FALSE, a column named newCol is added to df, with df returned

    # Performance on holdout data
    preds <- predict(rf, data=df)$predictions
    
    # Return just the predictions if requested otherwise add as final column to df
    if(isTRUE(predsOnly)) return(preds)
    else {
        df[newCol] <- preds
        return(df)
    }
    
}

# Predictions only
summary(predictRF(rf=tstRF, df=nycTempTest, predsOnly=TRUE))

# Full data frame
glimpse(predictRF(rf=tstRF, df=nycTempTest))

```
  
A function is written to report accuracy:  
```{r, fig.height=9, fig.width=9}

reportAccuracy <- function(df, 
                           trueCol, 
                           predCol="pred", 
                           reportAcc=TRUE, 
                           rndReport=2, 
                           useLabel="requested data",
                           returnAcc=!isTRUE(reportAcc)
                           ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame containing actual and predictions
    # trueCol: column containing true value
    # predCol: column containing predicted value
    # reportAcc: boolean, should accuracy be reported (printed to output)?
    # rndReport: number of significant digits for reporting (will be converted to percentage first)
    # useLabel: label for data to be used in reporting
    # returnAcc: boolean, should the accuracy be returned 
    #            return value is not converted to percentage, not rounded
    
    # For now, implemented only for categorical
    acc <- mean(df[trueCol]==df[predCol])
    
    # Report accuracy if requested
    if(isTRUE(reportAcc)) cat("\nAccuracy of ", useLabel, " is: ", round(100*acc, rndReport), "%\n", sep="")    
    
    # Return accuracy statistic if requested
    if(isTRUE(returnAcc)) return(acc)
    
}

reportAccuracy(predictRF(rf=tstRF, df=nycTempTest), trueCol="month")
reportAccuracy(predictRF(rf=tstRF, df=nycTempTest), 
               trueCol="month", 
               rndReport=3, 
               useLabel="predictions applied to test dataset",
               returnAcc=TRUE
               )

```

A function is written to plot confusion:  
```{r, fig.height=9, fig.width=9}

plotConfusion <- function(df, 
                          trueCol, 
                          predCol="pred", 
                          useTitle=NULL,
                          useSub=NULL
                           ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame containing actual and predictions
    # trueCol: column containing true value
    # predCol: column containing predicted value
    # useTitle: title to be used for chart (NULL means create from trueCol)
    # useSub: subtitle to be used for chart (NULL means none)
    
    # Create title if not supplied
    if(is.null(useTitle)) useTitle <- paste0("Predicting ", trueCol)
    
    # Confusion matrix (categorical)
    p1 <- df %>%
        group_by(across(all_of(c(trueCol, predCol)))) %>%
        summarize(n=n(), .groups="drop") %>%
        ggplot(aes(x=get(predCol), y=get(trueCol))) + 
        geom_tile(aes(fill=n)) + 
        geom_text(aes(label=n), size=2.5) +
        scale_fill_continuous("", low="white", high="green") + 
        labs(x="Predicted", y="Actual", title=useTitle, subtitle=useSub)
    print(p1)
    
}

plotConfusion(predictRF(rf=tstRF, df=nycTempTest), trueCol="month")
plotConfusion(predictRF(rf=tstRF, df=nycTempTest), trueCol="month", useSub="Model applied to test dataset")

```

Functions are run to build the same random forest excluding 2023 data, and with 2022 as a holdout year:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# 1. Run random forest
tstRFHoldout <- runSimpleRF(df=filter(nycTempTrain, lubridate::year(date)<2022), 
                            yVar="month", 
                            xVars=varsTrain, 
                            importance="impurity"
                            )
tstRFHoldout

# 2. Plot variable importance
plotRFImportance(tstRFHoldout)

# 3. Predict on year 2022
tstRFPred <- predictRF(rf=tstRFHoldout, 
                       df=filter(bind_rows(nycTempTest, nycTempTrain), lubridate::year(date)==2022))
tstRFPred

# 4. Report on accuracy
reportAccuracy(tstRFPred, 
               trueCol="month", 
               rndReport=3, 
               useLabel="predictions based on pre-2022 training data applied to 2022 holdout dataset"
               )

# 5. Plot confusion data
plotConfusion(tstRFPred, 
              trueCol="month", 
              useSub="Model based on pre-2022 training data applied to 2022 holdout dataset"
              )

```

The model learns generalized trends, recording ~80% accuracy (always within +/- 1 month) for predictions applied to 2022 holdout data. Some of what the model learns is specific to one or more years in the non-holdout training dataset, accounting for >99% OOB accuracy in training data falling to ~80% accuracy in a holdout year

A main function is created for running all steps:  
```{r, fig.height=9, fig.width=9}

runFullRF <- function(dfTrain, 
                      yVar, 
                      xVars, 
                      dfTest=dfTrain,
                      useLabel="test data",
                      useSub=NULL, 
                      returnData=FALSE
                      ) {
    
    # FUNCTION ARGUMENTS:
    # dfTrain: training data
    # yVar: dependent variable
    # xVars: column(s) containing independent variables
    # dfTest: test dataset for applying predictions
    # useLabel: label to be used for reporting accuracy
    # useSub: subtitle to be used for confusion chart (NULL means none)
    # returnData: boolean, should data be returned?

    # 1. Run random forest using impurity for importance
    rf <- runSimpleRF(df=dfTrain, yVar=yVar, xVars=xVars, importance="impurity")

    # 2. Plot variable importance
    rfImp <- plotRFImportance(rf, returnData=TRUE)

    # 3. Predict on test dataset
    tstPred <- predictRF(rf=rf, df=dfTest)

    # 4. Report on accuracy
    rfAcc <- reportAccuracy(tstPred, trueCol=yVar, rndReport=3, useLabel=useLabel, returnAcc=TRUE)

    # 5. Plot confusion data
    plotConfusion(tstPred, trueCol=yVar, useSub=useSub)
    
    #6. Return data if requested
    if(isTRUE(returnData)) return(list(rf=rf, rfImp=rfImp, tstPred=tstPred, rfAcc=rfAcc))
    
}

```

The function is tested:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

dfTrain <- filter(nycTempTrain, lubridate::year(date)<2022)
dfTest <- filter(bind_rows(nycTempTest, nycTempTrain), lubridate::year(date)==2022)
keyLabel <- "predictions based on pre-2022 training data applied to 2022 holdout dataset"

runFullRF(dfTrain=dfTrain, 
          yVar="month", 
          xVars=varsTrain, 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel)
          )

runFullRF(dfTrain=dfTrain, 
          yVar="month", 
          xVars=varsTrain, 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          returnData=TRUE
          ) %>%
    str(max.level=3)

```
  
The function is run for hour as a factor:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

dfTrain <- filter(nycTempTrain, lubridate::year(date)<2022)
dfTest <- filter(bind_rows(nycTempTest, nycTempTrain), lubridate::year(date)==2022)
keyLabel <- "predictions based on pre-2022 training data applied to 2022 holdout dataset"

runFullRF(dfTrain=dfTrain, 
          yVar="fct_hour", 
          xVars=varsTrain, 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel)
          )

```
  
Function reportAccuracy() is updated for continuous variables:  
```{r}

# Backup of old function
oldReportAccuracy <- reportAccuracy

# Update for continuous variables
reportAccuracy <- function(df, 
                           trueCol, 
                           predCol="pred", 
                           reportAcc=TRUE, 
                           rndReport=2, 
                           useLabel="requested data",
                           returnAcc=!isTRUE(reportAcc), 
                           reportR2=FALSE
                           ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame containing actual and predictions
    # trueCol: column containing true value
    # predCol: column containing predicted value
    # reportAcc: boolean, should accuracy be reported (printed to output)?
    # rndReport: number of significant digits for reporting (will be converted to percentage first)
    # useLabel: label for data to be used in reporting
    # returnAcc: boolean, should the accuracy be returned 
    #            return value is not converted to percentage, not rounded
    # reportR2: boolean, should accuracy be calculated as R-squared?
    #           (default FALSE measures as categorical)
    
    # Continuous or categorical reporting
    if(isTRUE(reportR2)) {
        tc <- df %>% pull(get(trueCol))
        pc <- df %>% pull(get(predCol))
        mseNull <- mean((tc-mean(tc))**2)
        msePred <- mean((tc-pc)**2)
        r2 <- 1 - msePred/mseNull
        if(isTRUE(reportAcc)) 
            cat("\nR-squared of ", 
                useLabel, 
                " is: ", 
                round(100*r2, rndReport), 
                "% (RMSE ",
                round(sqrt(msePred), 2), 
                " vs. ", 
                round(sqrt(mseNull), 2),
                " null)\n", 
                sep=""
                )
        acc <- c("mseNull"=mseNull, "msePred"=msePred, "r2"=r2)
    } else {
        acc <- mean(df[trueCol]==df[predCol])
        if(isTRUE(reportAcc)) 
            cat("\nAccuracy of ", useLabel, " is: ", round(100*acc, rndReport), "%\n", sep="")    
    }
    
    # Return accuracy statistic if requested
    if(isTRUE(returnAcc)) return(acc)
    
}

# Test for categorical
set.seed(23121100)
dfTestCat <- tibble::tibble(trueVal=factor(sample(month.abb, 1000, replace=TRUE), levels=month.abb),
                            predNull=factor(sample(month.abb, 1000, replace=TRUE), levels=month.abb), 
                            predVal=factor(month.abb[as.integer(ifelse(runif(1000)<=0.9, trueVal, predNull))], 
                                           levels=month.abb
                                           )
                            )
dfTestCat
reportAccuracy(dfTestCat, trueCol="trueVal", predCol="predNull", useLabel="random 12-category null")
oldReportAccuracy(dfTestCat, trueCol="trueVal", predCol="predNull", useLabel="random 12-category null")
reportAccuracy(dfTestCat, trueCol="trueVal", predCol="predVal", useLabel="random 12-category (90% true)")
oldReportAccuracy(dfTestCat, trueCol="trueVal", predCol="predVal", useLabel="random 12-category (90% true)")

# Test for continuous
set.seed(23121100)
dfTestCont <- tibble::tibble(trueVal=rnorm(100000),
                             predNull=mean(trueVal), 
                             predVal=ifelse(runif(100000)<=0.9, trueVal, predNull)
                             )
dfTestCont
reportAccuracy(dfTestCont, 
               trueCol="trueVal", 
               predCol="predNull", 
               useLabel="continuous rnorm null", 
               reportR2=TRUE
               )
reportAccuracy(dfTestCont, 
               trueCol="trueVal", 
               predCol="predVal", 
               useLabel="continuous rnorm (90% true)", 
               reportR2=TRUE
               )

```

Function plotConfusion() is updated for continuous variables:  
```{r, fig.height=9, fig.width=9}

# Backup of old function
oldPlotConfusion <- plotConfusion

# Update for continuous variables
plotConfusion <- function(df, 
                          trueCol, 
                          predCol="pred", 
                          useTitle=NULL,
                          useSub=NULL, 
                          plotCont=FALSE
                          ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame containing actual and predictions
    # trueCol: column containing true value
    # predCol: column containing predicted value
    # useTitle: title to be used for chart (NULL means create from trueCol)
    # useSub: subtitle to be used for chart (NULL means none)
    # plotCont: boolean, should plotting assume continuous variables?
    #           (default FALSE assumes confusion plot for categorical variables)
    
    # Create title if not supplied
    if(is.null(useTitle)) useTitle <- paste0("Predicting ", trueCol)

    # Create base plot (applicable to categorical or continuous variables)
    p1 <- df %>%
        group_by(across(all_of(c(trueCol, predCol)))) %>%
        summarize(n=n(), .groups="drop") %>%
        ggplot(aes(x=get(predCol), y=get(trueCol))) + 
        labs(x="Predicted", y="Actual", title=useTitle, subtitle=useSub)
        
    # Update plot as appropriate
    if(isTRUE(plotCont)) {
        p1 <- p1 +
            geom_point(aes(size=n), alpha=0.5) + 
            scale_size_continuous("# Obs") +
            coord_flip() +
            geom_smooth(aes(weight=n), method="lm")
    } else {
        p1 <- p1 + 
            geom_tile(aes(fill=n)) + 
            geom_text(aes(label=n), size=2.5) +
            scale_fill_continuous("", low="white", high="green")
    }
    
    # Output plot
    print(p1)
    
}

# Test for categorical (use same data as above)
plotConfusion(dfTestCat, trueCol="trueVal", predCol="predNull")
oldPlotConfusion(dfTestCat, trueCol="trueVal", predCol="predNull")
plotConfusion(dfTestCat, trueCol="trueVal", predCol="predVal")
oldPlotConfusion(dfTestCat, trueCol="trueVal", predCol="predVal")

# Test for continuous (use same data as above, all data rounded to nearest 0.05)
dfTestCont05 <- dfTestCont %>% mutate(across(where(is.numeric), .fns=function(x) round(x*20)/20))
dfTestCont05
plotConfusion(dfTestCont05, trueCol="trueVal", predCol="predNull", plotCont=TRUE)
plotConfusion(dfTestCont05, trueCol="trueVal", predCol="predVal", plotCont=TRUE)

```

The main function is updated to run all steps for continuous or categorical:  
```{r, fig.height=9, fig.width=9}

oldRunFullRF <- runFullRF

runFullRF <- function(dfTrain, 
                      yVar, 
                      xVars, 
                      dfTest=dfTrain,
                      useLabel="test data",
                      useSub=NULL, 
                      isContVar=FALSE,
                      returnData=FALSE, 
                      ...
                      ) {
    
    # FUNCTION ARGUMENTS:
    # dfTrain: training data
    # yVar: dependent variable
    # xVars: column(s) containing independent variables
    # dfTest: test dataset for applying predictions
    # useLabel: label to be used for reporting accuracy
    # useSub: subtitle to be used for confusion chart (NULL means none)
    # isContVar: boolean, is the variable continuous? (default FALSE means categorical)
    # returnData: boolean, should data be returned?
    # ...: additional parameters to pass to runSimpleRF(), which are then passed to ranger::ranger()

    # 1. Run random forest using impurity for importance
    rf <- runSimpleRF(df=dfTrain, yVar=yVar, xVars=xVars, importance="impurity", ...)

    # 2. Plot variable importance
    rfImp <- plotRFImportance(rf, returnData=TRUE)

    # 3. Predict on test dataset
    tstPred <- predictRF(rf=rf, df=dfTest)

    # 4. Report on accuracy (updated for continuous or categorical)
    rfAcc <- reportAccuracy(tstPred, 
                            trueCol=yVar, 
                            rndReport=3, 
                            useLabel=useLabel, 
                            reportR2=isTRUE(isContVar),
                            returnAcc=TRUE
                            )

    # 5. Plot confusion data (updated for continuous vs. categorical)
    plotConfusion(tstPred, trueCol=yVar, useSub=useSub, plotCont=isTRUE(isContVar))
    
    #6. Return data if requested
    if(isTRUE(returnData)) return(list(rf=rf, rfImp=rfImp, tstPred=tstPred, rfAcc=rfAcc))
    
}

```

The new function is tested on categorical data (default):  
```{r, fig.height=9, fig.width=9, cache=TRUE}

runFullRF(dfTrain=dfTrain, 
          yVar="month", 
          xVars=varsTrain, 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel)
          )

```

The new function is tested on continuous data (new):  
```{r, fig.height=9, fig.width=9, cache=TRUE}

tmp2m <- runFullRF(dfTrain=dfTrain, 
                   yVar="temperature_2m", 
                   xVars=varsTrain[!str_detect(varsTrain, "temper")], 
                   dfTest=dfTest, 
                   useLabel=keyLabel, 
                   useSub=stringr::str_to_sentence(keyLabel), 
                   isContVar = TRUE, 
                   returnData=TRUE
                   )

```

The new function is tested excluding dewpoint:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

tmp2m$rfImp %>% 
    arrange(-imp)

runFullRF(dfTrain=dfTrain, 
          yVar="temperature_2m", 
          xVars=varsTrain[!str_detect(varsTrain, "temper|dew")], 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE
          )

```

Function plotConfusion() is updated to aggregate (round) continuous variables:  
```{r, fig.height=9, fig.width=9}

# Update for continuous variables
plotConfusion <- function(df, 
                          trueCol, 
                          predCol="pred", 
                          useTitle=NULL,
                          useSub=NULL, 
                          plotCont=FALSE, 
                          rndTo=NULL
                          ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame containing actual and predictions
    # trueCol: column containing true value
    # predCol: column containing predicted value
    # useTitle: title to be used for chart (NULL means create from trueCol)
    # useSub: subtitle to be used for chart (NULL means none)
    # plotCont: boolean, should plotting assume continuous variables?
    #           (default FALSE assumes confusion plot for categorical variables)
    # rndTo: number for rounding continuous variables (NULL means no rounding)
    
    # Create title if not supplied
    if(is.null(useTitle)) useTitle <- paste0("Predicting ", trueCol)

    # Round data if requested
    if(!is.null(rndTo)) {
        df <- df %>%
            mutate(across(all_of(c(trueCol, predCol)), .fns=function(x) round(x/rndTo)*rndTo))
    }
    
    # Create base plot (applicable to categorical or continuous variables)
    p1 <- df %>%
        group_by(across(all_of(c(trueCol, predCol)))) %>%
        summarize(n=n(), .groups="drop") %>%
        ggplot(aes(x=get(predCol), y=get(trueCol))) + 
        labs(x="Predicted", y="Actual", title=useTitle, subtitle=useSub)
        
    # Update plot as appropriate
    if(isTRUE(plotCont)) {
        p1 <- p1 +
            geom_point(aes(size=n), alpha=0.5) + 
            scale_size_continuous("# Obs") +
            coord_flip() +
            geom_smooth(aes(weight=n), method="lm")
    } else {
        p1 <- p1 + 
            geom_tile(aes(fill=n)) + 
            geom_text(aes(label=n), size=2.5) +
            scale_fill_continuous("", low="white", high="green")
    }
    
    # Output plot
    print(p1)
    
}

# Test for continuous (use same data as above, all data rounded to nearest 0.05)
plotConfusion(dfTestCont05, trueCol="trueVal", predCol="predVal", plotCont=TRUE)

# Run function on non-rounded data
plotConfusion(dfTestCont, trueCol="trueVal", predCol="predVal", plotCont=TRUE, rndTo=0.05)

```

The main function is updated to include rounding:  
```{r, fig.height=9, fig.width=9}

runFullRF <- function(dfTrain, 
                      yVar, 
                      xVars, 
                      dfTest=dfTrain,
                      useLabel="test data",
                      useSub=NULL, 
                      isContVar=FALSE,
                      rndTo=NULL,
                      returnData=FALSE, 
                      ...
                      ) {
    
    # FUNCTION ARGUMENTS:
    # dfTrain: training data
    # yVar: dependent variable
    # xVars: column(s) containing independent variables
    # dfTest: test dataset for applying predictions
    # useLabel: label to be used for reporting accuracy
    # useSub: subtitle to be used for confusion chart (NULL means none)
    # isContVar: boolean, is the variable continuous? (default FALSE means categorical)
    # rndTo: round x and y to the nearest rndTo prior to counting examples and plotting accuracy 
    #        (NULL means categorical data or requests no rounding of continuous data)
    # returnData: boolean, should data be returned?
    # ...: additional parameters to pass to runSimpleRF(), which are then passed to ranger::ranger()

    # 1. Run random forest using impurity for importance
    rf <- runSimpleRF(df=dfTrain, yVar=yVar, xVars=xVars, importance="impurity", ...)

    # 2. Plot variable importance
    rfImp <- plotRFImportance(rf, returnData=TRUE)

    # 3. Predict on test dataset
    tstPred <- predictRF(rf=rf, df=dfTest)

    # 4. Report on accuracy (updated for continuous or categorical)
    rfAcc <- reportAccuracy(tstPred, 
                            trueCol=yVar, 
                            rndReport=3, 
                            useLabel=useLabel, 
                            reportR2=isTRUE(isContVar),
                            returnAcc=TRUE
                            )

    # 5. Plot confusion data (updated for continuous vs. categorical)
    plotConfusion(tstPred, trueCol=yVar, useSub=useSub, plotCont=isTRUE(isContVar), rndTo=rndTo)
    
    #6. Return data if requested
    if(isTRUE(returnData)) return(list(rf=rf, rfImp=rfImp, tstPred=tstPred, rfAcc=rfAcc))
    
}

```

The new function is tested for temperature, excluding predictors that are temperature or dewpoint:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

runFullRF(dfTrain=dfTrain, 
          yVar="temperature_2m", 
          xVars=varsTrain[!str_detect(varsTrain, "temper|dew")], 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=1
          )

```

For comparison, a model is run with access only to month and hour, then with only access to dewpoint:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

runFullRF(dfTrain=dfTrain, 
          yVar="temperature_2m", 
          xVars=c("month", "fct_hour"), 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=1
          )

runFullRF(dfTrain=dfTrain, 
          yVar="temperature_2m", 
          xVars=c("dewpoint_2m"), 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=1
          )

runFullRF(dfTrain=dfTrain, 
          yVar="temperature_2m", 
          xVars=c("month", "fct_hour", "dewpoint_2m"), 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=1
          )

```

Access to either 1) both month and hour, or 2) dewpoint reduces RMSE from ~10 in the null model to between 4-5. Including all 3 further reduces RMSE to ~2.5

Function plotConfusion() is updated to optionally add a y=x reference line:  
```{r, fig.height=9, fig.width=9}

# Update for continuous variables
plotConfusion <- function(df, 
                          trueCol, 
                          predCol="pred", 
                          useTitle=NULL,
                          useSub=NULL, 
                          plotCont=FALSE, 
                          rndTo=NULL,
                          refXY=FALSE
                          ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame containing actual and predictions
    # trueCol: column containing true value
    # predCol: column containing predicted value
    # useTitle: title to be used for chart (NULL means create from trueCol)
    # useSub: subtitle to be used for chart (NULL means none)
    # plotCont: boolean, should plotting assume continuous variables?
    #           (default FALSE assumes confusion plot for categorical variables)
    # rndTo: number for rounding continuous variables (NULL means no rounding)
    # refXY: boolean, should a reference line for y=x be included? (relevant only for continuous)
    
    # Create title if not supplied
    if(is.null(useTitle)) useTitle <- paste0("Predicting ", trueCol)

    # Round data if requested
    if(!is.null(rndTo)) {
        df <- df %>%
            mutate(across(all_of(c(trueCol, predCol)), .fns=function(x) round(x/rndTo)*rndTo))
    }
    
    # Create base plot (applicable to categorical or continuous variables)
    # Use x as true and y as predicted, for more meaningful geom_smooth() if continuous
    # Flip coordinates if categorical
    p1 <- df %>%
        group_by(across(all_of(c(trueCol, predCol)))) %>%
        summarize(n=n(), .groups="drop") %>%
        ggplot(aes(y=get(predCol), x=get(trueCol))) + 
        labs(y="Predicted", x="Actual", title=useTitle, subtitle=useSub)
        
    # Update plot as appropriate
    if(isTRUE(plotCont)) {
        p1 <- p1 +
            geom_point(aes(size=n), alpha=0.5) + 
            scale_size_continuous("# Obs") +
            geom_smooth(aes(weight=n), method="lm")
        if(isTRUE(refXY)) p1 <- p1 + geom_abline(slope=1, intercept=0, lty=2, color="red")
    } else {
        p1 <- p1 + 
            geom_tile(aes(fill=n)) + 
            geom_text(aes(label=n), size=2.5) +
            coord_flip() +
            scale_fill_continuous("", low="white", high="green")
    }
    
    # Output plot
    print(p1)
    
}

# Add reference line
plotConfusion(dfTestCont, trueCol="trueVal", predCol="predVal", plotCont=TRUE, rndTo=0.05, refXY=TRUE)

```

The main function is updated to include the optional reference line:  
```{r, fig.height=9, fig.width=9}

runFullRF <- function(dfTrain, 
                      yVar, 
                      xVars, 
                      dfTest=dfTrain,
                      useLabel="test data",
                      useSub=NULL, 
                      isContVar=FALSE,
                      rndTo=NULL,
                      refXY=FALSE,
                      returnData=FALSE, 
                      ...
                      ) {
    
    # FUNCTION ARGUMENTS:
    # dfTrain: training data
    # yVar: dependent variable
    # xVars: column(s) containing independent variables
    # dfTest: test dataset for applying predictions
    # useLabel: label to be used for reporting accuracy
    # useSub: subtitle to be used for confusion chart (NULL means none)
    # isContVar: boolean, is the variable continuous? (default FALSE means categorical)
    # rndTo: round x and y to the nearest rndTo prior to counting examples and plotting accuracy 
    #        (NULL means categorical data or requests no rounding of continuous data)
    # refXY: boolean, should a reference line for y=x be included? (relevant only for continuous)
    # returnData: boolean, should data be returned?
    # ...: additional parameters to pass to runSimpleRF(), which are then passed to ranger::ranger()

    # 1. Run random forest using impurity for importance
    rf <- runSimpleRF(df=dfTrain, yVar=yVar, xVars=xVars, importance="impurity", ...)

    # 2. Plot variable importance
    rfImp <- plotRFImportance(rf, returnData=TRUE)

    # 3. Predict on test dataset
    tstPred <- predictRF(rf=rf, df=dfTest)

    # 4. Report on accuracy (updated for continuous or categorical)
    rfAcc <- reportAccuracy(tstPred, 
                            trueCol=yVar, 
                            rndReport=3, 
                            useLabel=useLabel, 
                            reportR2=isTRUE(isContVar),
                            returnAcc=TRUE
                            )

    # 5. Plot confusion data (updated for continuous vs. categorical)
    plotConfusion(tstPred, trueCol=yVar, useSub=useSub, plotCont=isTRUE(isContVar), rndTo=rndTo, refXY=refXY)
    
    #6. Return data if requested
    if(isTRUE(returnData)) return(list(rf=rf, rfImp=rfImp, tstPred=tstPred, rfAcc=rfAcc))
    
}

```

The updated function is again tested for temperature, excluding predictors that are temperature or dewpoint:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

runFullRF(dfTrain=dfTrain, 
          yVar="temperature_2m", 
          xVars=varsTrain[!str_detect(varsTrain, "temper|dew")], 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=1, 
          refXY=TRUE
          )

```

The updated function is re-run with access only to month and hour, then with only access to dewpoint:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

runFullRF(dfTrain=dfTrain, 
          yVar="temperature_2m", 
          xVars=c("month", "fct_hour"), 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=1, 
          refXY=TRUE
          )

runFullRF(dfTrain=dfTrain, 
          yVar="temperature_2m", 
          xVars=c("dewpoint_2m"), 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=1, 
          refXY=TRUE
          )

runFullRF(dfTrain=dfTrain, 
          yVar="temperature_2m", 
          xVars=c("month", "fct_hour", "dewpoint_2m"), 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=1,
          refXY=TRUE
          )

```

The updated function is tested for rainfall, excluding predictors that are rain, snow, or precipitation:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

runFullRF(dfTrain=dfTrain, 
          yVar="rain", 
          xVars=varsTrain[!str_detect(varsTrain, "rain|snow|precip")], 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=0.1, 
          refXY=TRUE
          )

```

The updated function is tested on month (categorical data by default):  
```{r, fig.height=9, fig.width=9, cache=TRUE}

runFullRF(dfTrain=dfTrain, 
          yVar="month", 
          xVars=varsTrain, 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel)
          )

```

Patterns in the deepest soil temperature are explored:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

dfTrain %>%
    mutate(year=year(date), dom=day(date)) %>%
    filter(dom!=29 | month != "Feb") %>%
    select(year, month, dom, soil_temperature_100_to_255cm) %>%
    group_by(year, month, dom) %>%
    summarize(across(where(is.numeric), .fns=list(mean=mean, sd=sd)), .groups="drop") %>%
    pivot_longer(cols=-c(year, month, dom)) %>%
    mutate(newdate=lubridate::mdy(paste0(as.character(month), "-", zeroPad2(dom), "-2021"))) %>%
    ggplot(aes(x=newdate, y=value)) + 
    geom_line(aes(group=factor(year), color=factor(year))) + 
    facet_wrap(~name, ncol=1, scales="free_y") + 
    labs(x=NULL, y="Soil Temperature (C)", title="Soil Temperature by day and year") + 
    scale_color_discrete(NULL) +
    scale_x_date(labels=scales::date_format("%b"))


runFullRF(dfTrain=dfTrain, 
          yVar="soil_temperature_100_to_255cm", 
          xVars=c("month"), 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=1, 
          refXY=TRUE
          )

```

Deep soil temperature varies gradually in a largely stable and repeatable annual pattern. There is very little intra-day fluctuation in deep soil temperature, and a model using month only achieves R-squared over 95%

Models using only day-of-year and month are explored:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

runFullRF(dfTrain=dfTrain %>% mutate(doy=yday(date)), 
          yVar="soil_temperature_100_to_255cm", 
          xVars=c("doy"), 
          dfTest=dfTest %>% mutate(doy=yday(date)), 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=.25, 
          refXY=TRUE
          )

runFullRF(dfTrain=dfTrain %>% mutate(doy=yday(date)), 
          yVar="soil_temperature_100_to_255cm", 
          xVars=c("doy", "month"), 
          dfTest=dfTest %>% mutate(doy=yday(date)), 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=.25, 
          refXY=TRUE
          )

```

Including day-of-year cuts RMSE by ~40%, as variations in soil temperature from early-month to late-month can also be partially captured

Models including all variables except for day-of-year and month are explored:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rfSoilTemp100255 <- runFullRF(dfTrain=dfTrain %>% mutate(doy=yday(date)), 
                              yVar="soil_temperature_100_to_255cm", 
                              xVars=varsTrain[!str_detect(varsTrain, pattern="soil_temperature_100_to_255cm")], 
                              dfTest=dfTest %>% mutate(doy=yday(date)), 
                              useLabel=keyLabel, 
                              useSub=stringr::str_to_sentence(keyLabel), 
                              isContVar = TRUE, 
                              rndTo=.25, 
                              refXY=TRUE, 
                              returnData=TRUE
                              )

```

Prediction accuracy is decreased, and anomalies introduced, as day-of-year (or its surrogate month) is removed, even as many other potential explanatory variables are added

Prediction vs. month is further explored:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rfSoilTemp100255$tstPred %>%
    mutate(across(.cols=c(soil_temperature_100_to_255cm, pred), .fns=function(x) round(x*2)/2)) %>% 
    count(month, soil_temperature_100_to_255cm, pred) %>% 
    ggplot(aes(y=soil_temperature_100_to_255cm, x=pred)) + 
    geom_point(aes(size=n)) + 
    geom_smooth(aes(weight=n), method="lm") + 
    geom_abline(slope=1, intercept=0, lty=2, color="red") + 
    facet_wrap(~month) + 
    labs(title="Prediction vs. Actual for Deep Soil Temperature (100 cm to 255 cm)", 
         x="Predicted", 
         y="Actual"
         )

rfSoilTemp100255$tstPred %>%
    mutate(across(.cols=c(soil_temperature_100_to_255cm, pred), .fns=function(x) round(x*1)/1)) %>% 
    count(month, soil_temperature_100_to_255cm, pred) %>% 
    ggplot(aes(x=pred, y=n)) + 
    geom_col(aes(fill=month), position="fill") + 
    coord_flip() +
    labs(title="Predicted Deep Soil Temperature (100 cm to 255 cm) vs. Actual Month", 
         x="Predicted Deep Soil Temperature", 
         y="% Observations in Month"
         ) + 
    scale_fill_discrete("Month")

```

Prediction vs. actual is further explored:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rfSoilTemp100255$tstPred %>% 
    select(time, actual=soil_temperature_100_to_255cm, pred) %>% 
    pivot_longer(cols=-c(time)) %>% 
    ggplot(aes(x=time, y=value)) + 
    geom_line(aes(group=name, color=name)) + 
    labs(x=NULL, 
         y="Soil Temperature", 
         title="Predicted vs. Actual for Deep Soil Temperature (100 cm - 255 cm)"
         ) + 
    scale_color_discrete("Metric")

rfSoilTemp100255$tstPred %>% 
    select(date, month, actual=soil_temperature_100_to_255cm, pred) %>% 
    pivot_longer(cols=-c(date, month), names_to="metric") %>% 
    group_by(date, month, metric) %>%
    filter(n()>1) %>%
    summarize(mean=mean(value), sd=sd(value), .groups="drop") %>%
    pivot_longer(cols=-c(date, month, metric)) %>%
    ggplot(aes(x=month, y=value)) + 
    geom_boxplot(aes(fill=metric)) + 
    labs(x=NULL, 
         y=NULL, 
         title="Daily Metrics for Deep Soil Temperature (100 cm - 255 cm)"
         ) + 
    scale_fill_discrete("Metric") + 
    facet_wrap(~c("mean"="Daily Mean", "sd"="Daily Std. Deviation")[name], scales="free_y")

```

Predictions have a similar annual pattern as actual, with monthly means broadly aligned. Predictions are often variable over the course of a single day, while actual values change little (if at all) during a single day

The model including only day-of-year and month is explored for comparison:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rfSoilTemp255doy <- runFullRF(dfTrain=dfTrain %>% mutate(doy=yday(date)), 
                              yVar="soil_temperature_100_to_255cm", 
                              xVars=c("doy"), 
                              dfTest=dfTest %>% mutate(doy=yday(date)), 
                              useLabel=keyLabel, 
                              useSub=stringr::str_to_sentence(keyLabel), 
                              isContVar = TRUE, 
                              rndTo=.25, 
                              refXY=TRUE, 
                              returnData=TRUE
                              )

rfSoilTemp255doy$tstPred %>%
    mutate(across(.cols=c(soil_temperature_100_to_255cm, pred), .fns=function(x) round(x*2)/2)) %>% 
    count(month, soil_temperature_100_to_255cm, pred) %>% 
    ggplot(aes(y=soil_temperature_100_to_255cm, x=pred)) + 
    geom_point(aes(size=n)) + 
    geom_smooth(aes(weight=n), method="lm") + 
    geom_abline(slope=1, intercept=0, lty=2, color="red") + 
    facet_wrap(~month) + 
    labs(title="Prediction vs. Actual for Deep Soil Temperature (100 cm to 255 cm)", 
         x="Predicted", 
         y="Actual"
         )

rfSoilTemp255doy$tstPred %>%
    mutate(across(.cols=c(soil_temperature_100_to_255cm, pred), .fns=function(x) round(x*1)/1)) %>% 
    count(month, soil_temperature_100_to_255cm, pred) %>% 
    ggplot(aes(x=pred, y=n)) + 
    geom_col(aes(fill=month), position="fill") + 
    coord_flip() +
    labs(title="Predicted Deep Soil Temperature (100 cm to 255 cm) vs. Actual Month", 
         x="Predicted Deep Soil Temperature", 
         y="% Observations in Month"
         ) + 
    scale_fill_discrete("Month")

rfSoilTemp255doy$tstPred %>% 
    select(time, actual=soil_temperature_100_to_255cm, pred) %>% 
    pivot_longer(cols=-c(time)) %>% 
    ggplot(aes(x=time, y=value)) + 
    geom_line(aes(group=name, color=name)) + 
    labs(x=NULL, 
         y="Soil Temperature", 
         title="Predicted vs. Actual for Deep Soil Temperature (100 cm - 255 cm)"
         ) + 
    scale_color_discrete("Metric")

rfSoilTemp255doy$tstPred %>% 
    select(date, month, actual=soil_temperature_100_to_255cm, pred) %>% 
    pivot_longer(cols=-c(date, month), names_to="metric") %>% 
    group_by(date, month, metric) %>%
    filter(n()>1) %>%
    summarize(mean=mean(value), sd=sd(value), .groups="drop") %>%
    pivot_longer(cols=-c(date, month, metric)) %>%
    ggplot(aes(x=month, y=value)) + 
    geom_boxplot(aes(fill=metric)) + 
    labs(x=NULL, 
         y=NULL, 
         title="Daily Metrics for Deep Soil Temperature (100 cm - 255 cm)"
         ) + 
    scale_fill_discrete("Metric") + 
    facet_wrap(~c("mean"="Daily Mean", "sd"="Daily Std. Deviation")[name], scales="free_y")

```

Predictions using day-of-year have a much closer match to the seasonal pattern of the actual 2022 holdout data

Patterns in the deepest soil moisture are explored:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

dfTrain %>%
    mutate(year=year(date), dom=day(date)) %>%
    filter(dom!=29 | month != "Feb") %>%
    select(year, month, dom, soil_moisture_100_to_255cm) %>%
    group_by(year, month, dom) %>%
    summarize(across(where(is.numeric), .fns=list(mean=mean, sd=sd)), .groups="drop") %>%
    pivot_longer(cols=-c(year, month, dom)) %>%
    mutate(newdate=lubridate::mdy(paste0(as.character(month), "-", zeroPad2(dom), "-2021"))) %>%
    ggplot(aes(x=newdate, y=value)) + 
    geom_line(aes(group=factor(year), color=factor(year))) + 
    facet_wrap(~name, ncol=1, scales="free_y") + 
    labs(x=NULL, y="Soil Moisture", title="Soil Moisture by day and year") + 
    scale_color_discrete(NULL) +
    scale_x_date(labels=scales::date_format("%b"))

runFullRF(dfTrain=dfTrain, 
          yVar="soil_moisture_100_to_255cm", 
          xVars=c("month"), 
          dfTest=dfTest, 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=.0025, 
          refXY=TRUE
          )

```

Deep soil moisture varies gradually, though not in a stable and repeatable annual pattern. There is very little intra-day fluctuation in deep soil temperature, and a model using month only achieves R-squared of around 80%

Models using only day-of-year and month are explored:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

runFullRF(dfTrain=dfTrain %>% mutate(doy=yday(date)), 
          yVar="soil_moisture_100_to_255cm", 
          xVars=c("doy"), 
          dfTest=dfTest %>% mutate(doy=yday(date)), 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=.0025, 
          refXY=TRUE
          )

runFullRF(dfTrain=dfTrain %>% mutate(doy=yday(date)), 
          yVar="soil_moisture_100_to_255cm", 
          xVars=c("doy", "month"), 
          dfTest=dfTest %>% mutate(doy=yday(date)), 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=.0025, 
          refXY=TRUE
          )

```

In contrast to deep soil temperature, Including day-of-year makes no meaningful change in RMSE for predictions of deep soil moisture. Soil moisture patterns appear to be only somewhat seasonal, with different patterns by year

Models including all variables except for day-of-year and month are explored:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rfSoilMois100255 <- runFullRF(dfTrain=dfTrain %>% mutate(doy=yday(date)), 
                              yVar="soil_moisture_100_to_255cm", 
                              xVars=varsTrain[!str_detect(varsTrain, pattern="soil_moisture_100_to_255cm")], 
                              dfTest=dfTest %>% mutate(doy=yday(date)), 
                              useLabel=keyLabel, 
                              useSub=stringr::str_to_sentence(keyLabel), 
                              isContVar = TRUE, 
                              rndTo=.0025, 
                              refXY=TRUE, 
                              returnData=TRUE
                              )

```

Prediction accuracy is similar even as day-of-year (or its surrogate month) is removed. Soil temperature and moisture (at shallower levels) are roughly as good predictors of deep soil moisture as month or day of year

Prediction vs. month is further explored:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rfSoilMois100255$tstPred %>%
    mutate(across(.cols=c(soil_moisture_100_to_255cm, pred), .fns=function(x) round(x*400)/400)) %>% 
    count(month, soil_moisture_100_to_255cm, pred) %>% 
    ggplot(aes(y=soil_moisture_100_to_255cm, x=pred)) + 
    geom_point(aes(size=n)) + 
    geom_smooth(aes(weight=n), method="lm") + 
    geom_abline(slope=1, intercept=0, lty=2, color="red") + 
    facet_wrap(~month) + 
    labs(title="Prediction vs. Actual for Deep Soil Moisture (100 cm to 255 cm)", 
         x="Predicted", 
         y="Actual"
         )

rfSoilMois100255$tstPred %>%
    mutate(across(.cols=c(soil_moisture_100_to_255cm, pred), .fns=function(x) round(x*200)/200)) %>% 
    count(month, soil_moisture_100_to_255cm, pred) %>% 
    ggplot(aes(x=pred, y=n)) + 
    geom_col(aes(fill=month), position="fill") + 
    coord_flip() +
    labs(title="Predicted Deep Soil Moisture (100 cm to 255 cm) vs. Actual Month", 
         x="Predicted Deep Soil Moisture", 
         y="% Observations in Month"
         ) + 
    scale_fill_discrete("Month")

```

Prediction vs. actual is further explored:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rfSoilMois100255$tstPred %>% 
    select(time, actual=soil_moisture_100_to_255cm, pred) %>% 
    pivot_longer(cols=-c(time)) %>% 
    ggplot(aes(x=time, y=value)) + 
    geom_line(aes(group=name, color=name)) + 
    labs(x=NULL, 
         y="Soil Moisture", 
         title="Predicted vs. Actual for Deep Soil Moisture (100 cm - 255 cm)"
         ) + 
    scale_color_discrete("Metric")

rfSoilMois100255$tstPred %>% 
    select(date, month, actual=soil_moisture_100_to_255cm, pred) %>% 
    pivot_longer(cols=-c(date, month), names_to="metric") %>% 
    group_by(date, month, metric) %>%
    filter(n()>1) %>%
    summarize(mean=mean(value), sd=sd(value), .groups="drop") %>%
    pivot_longer(cols=-c(date, month, metric)) %>%
    ggplot(aes(x=month, y=value)) + 
    geom_boxplot(aes(fill=metric)) + 
    labs(x=NULL, 
         y=NULL, 
         title="Daily Metrics for Deep Soil Moisture (100 cm - 255 cm)"
         ) + 
    scale_fill_discrete("Metric") + 
    facet_wrap(~c("mean"="Daily Mean", "sd"="Daily Std. Deviation")[name], scales="free_y")

```

Predictions are often variable over the course of a single day, while actual values change little (if at all) during a single day. As well, while predictions follow a similar seasonal pattern as actual values, predicted and actual means differ meaningfully in several months

The model including only day-of-year and month is explored for comparison:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rfSoilMois255doy <- runFullRF(dfTrain=dfTrain %>% mutate(doy=yday(date)), 
                              yVar="soil_moisture_100_to_255cm", 
                              xVars=c("doy"), 
                              dfTest=dfTest %>% mutate(doy=yday(date)), 
                              useLabel=keyLabel, 
                              useSub=stringr::str_to_sentence(keyLabel), 
                              isContVar = TRUE, 
                              rndTo=.0025, 
                              refXY=TRUE, 
                              returnData=TRUE
                              )

rfSoilMois255doy$tstPred %>%
    mutate(across(.cols=c(soil_moisture_100_to_255cm, pred), .fns=function(x) round(x*400)/400)) %>% 
    count(month, soil_moisture_100_to_255cm, pred) %>% 
    ggplot(aes(y=soil_moisture_100_to_255cm, x=pred)) + 
    geom_point(aes(size=n)) + 
    geom_smooth(aes(weight=n), method="lm") + 
    geom_abline(slope=1, intercept=0, lty=2, color="red") + 
    facet_wrap(~month) + 
    labs(title="Prediction vs. Actual for Deep Soil Moisture (100 cm to 255 cm)", 
         x="Predicted", 
         y="Actual"
         )

rfSoilMois255doy$tstPred %>%
    mutate(across(.cols=c(soil_moisture_100_to_255cm, pred), .fns=function(x) round(x*400)/400)) %>% 
    count(month, soil_moisture_100_to_255cm, pred) %>% 
    ggplot(aes(x=pred, y=n)) + 
    geom_col(aes(fill=month), position="fill") + 
    coord_flip() +
    labs(title="Predicted Deep Soil Moisture (100 cm to 255 cm) vs. Actual Month", 
         x="Predicted Deep Soil Moisture", 
         y="% Observations in Month"
         ) + 
    scale_fill_discrete("Month")

rfSoilMois255doy$tstPred %>% 
    select(time, actual=soil_moisture_100_to_255cm, pred) %>% 
    full_join(rfSoilMois100255$tstPred %>% select(time, oldpred=pred), by="time") %>%
    pivot_longer(cols=-c(time)) %>% 
    ggplot(aes(x=time, y=value)) + 
    geom_line(aes(group=name, 
                  color=c("actual"="1. Actual", "oldpred"="2. Prev Predicted", "pred"="3. New Predicted")[name]
                  )
              ) + 
    labs(x=NULL, 
         y="Soil Moisture", 
         title="Predicted vs. Actual for Deep Soil Moisture (100 cm - 255 cm)"
         ) + 
    scale_color_discrete("Metric")

rfSoilMois255doy$tstPred %>% 
    select(date, month, actual=soil_moisture_100_to_255cm, pred) %>% 
    pivot_longer(cols=-c(date, month), names_to="metric") %>% 
    group_by(date, month, metric) %>%
    filter(n()>1) %>%
    summarize(mean=mean(value), sd=sd(value), .groups="drop") %>%
    pivot_longer(cols=-c(date, month, metric)) %>%
    ggplot(aes(x=month, y=value)) + 
    geom_boxplot(aes(fill=metric)) + 
    labs(x=NULL, 
         y=NULL, 
         title="Daily Metrics for Deep Soil Moisture (100 cm - 255 cm)"
         ) + 
    scale_fill_discrete("Metric") + 
    facet_wrap(~c("mean"="Daily Mean", "sd"="Daily Std. Deviation")[name], scales="free_y")

```

Both predictions generally match the seasonal pattern, but fail to capture unique elements of the holdout data

Function runFullRF() is updated to omit plots for variables importance and/or confusion matrix:  
```{r}

runFullRF <- function(dfTrain, 
                      yVar, 
                      xVars, 
                      dfTest=dfTrain,
                      useLabel="test data",
                      useSub=NULL, 
                      isContVar=FALSE,
                      rndTo=NULL,
                      refXY=FALSE,
                      makePlots=TRUE,
                      plotImp=makePlots,
                      plotConf=makePlots,
                      returnData=FALSE, 
                      ...
                      ) {
    
    # FUNCTION ARGUMENTS:
    # dfTrain: training data
    # yVar: dependent variable
    # xVars: column(s) containing independent variables
    # dfTest: test dataset for applying predictions
    # useLabel: label to be used for reporting accuracy
    # useSub: subtitle to be used for confusion chart (NULL means none)
    # isContVar: boolean, is the variable continuous? (default FALSE means categorical)
    # rndTo: round x and y to the nearest rndTo prior to counting examples and plotting accuracy 
    #        (NULL means categorical data or requests no rounding of continuous data)
    # refXY: boolean, should a reference line for y=x be included? (relevant only for continuous)
    # makePlots: boolean, should plots be created for variable importance and confusion matrix?
    # plotImp: boolean, should variable importance be plotted? (default is makePlots)
    # plotConf: boolean, should confusion matrix be plotted? (default is makePlots)
    # returnData: boolean, should data be returned?
    # ...: additional parameters to pass to runSimpleRF(), which are then passed to ranger::ranger()

    # 1. Run random forest using impurity for importance
    rf <- runSimpleRF(df=dfTrain, yVar=yVar, xVars=xVars, importance="impurity", ...)

    # 2. Create, and optionally plot, variable importance
    rfImp <- plotRFImportance(rf, plotData=plotImp, returnData=TRUE)

    # 3. Predict on test dataset
    tstPred <- predictRF(rf=rf, df=dfTest)

    # 4. Report on accuracy (updated for continuous or categorical)
    rfAcc <- reportAccuracy(tstPred, 
                            trueCol=yVar, 
                            rndReport=3, 
                            useLabel=useLabel, 
                            reportR2=isTRUE(isContVar),
                            returnAcc=TRUE
                            )

    # 5. Plot confusion data (updated for continuous vs. categorical) if requested
    if(isTRUE(plotConf)) {
        plotConfusion(tstPred, 
                      trueCol=yVar, 
                      useSub=useSub, 
                      plotCont=isTRUE(isContVar), 
                      rndTo=rndTo, 
                      refXY=refXY
                      )
    }
    
    #6. Return data if requested
    if(isTRUE(returnData)) return(list(rf=rf, rfImp=rfImp, tstPred=tstPred, rfAcc=rfAcc))
    
}

# Test function with and without plotting
runFullRF(dfTrain=dfTrain %>% mutate(doy=yday(date)), 
          yVar="soil_moisture_100_to_255cm", 
          xVars=c("doy", "month"), 
          dfTest=dfTest %>% mutate(doy=yday(date)), 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=.0025, 
          refXY=TRUE, 
          returnData=TRUE
          )


# Test function with and without plotting
runFullRF(dfTrain=dfTrain %>% mutate(doy=yday(date)), 
          yVar="soil_moisture_100_to_255cm", 
          xVars=c("doy", "month"), 
          dfTest=dfTest %>% mutate(doy=yday(date)), 
          useLabel=keyLabel, 
          useSub=stringr::str_to_sentence(keyLabel), 
          isContVar = TRUE, 
          rndTo=.0025, 
          refXY=TRUE, 
          makePlots=FALSE,
          returnData=TRUE
          )

```

The model is run for each continuous variable, using only month as a predictor:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

vCont <- c('temperature_2m', 'relativehumidity_2m', 'dewpoint_2m', 'apparent_temperature', 
           'pressure_msl', 'surface_pressure', 
           'precipitation', 'rain', 'snowfall', 
           'cloudcover', 'cloudcover_low', 'cloudcover_mid', 'cloudcover_high', 
           'shortwave_radiation', 'direct_radiation', 'direct_normal_irradiance', 'diffuse_radiation',
           'windspeed_10m', 'windspeed_100m', 'winddirection_10m', 'winddirection_100m', 'windgusts_10m',
           'et0_fao_evapotranspiration', 'vapor_pressure_deficit', 
           'soil_temperature_0_to_7cm', 'soil_temperature_7_to_28cm', 
           'soil_temperature_28_to_100cm', 'soil_temperature_100_to_255cm', 
           'soil_moisture_0_to_7cm', 'soil_moisture_7_to_28cm', 
           'soil_moisture_28_to_100cm', 'soil_moisture_100_to_255cm'
           )

set.seed(24010817)

lstContMonth <- lapply(vCont, 
                       FUN=function(x) {
                           runFullRF(dfTrain=dfTrain %>% mutate(doy=yday(date)), 
                                     yVar=x, 
                                     xVars=c("month"), 
                                     dfTest=dfTest %>% mutate(doy=yday(date)), 
                                     isContVar = TRUE, 
                                     useLabel=paste0("predictions on 2022 holdout data for variable ", x),
                                     makePlots=FALSE,
                                     returnData=TRUE
                                     )
                          }
                      )
names(lstContMonth) <- vCont

```

Predictive power on the holdout 2022 data is explored:  
```{r, fig.height=9, fig.width=9}

sapply(lstContMonth, FUN=function(x) x[["rfAcc"]]["r2"]) %>% 
    as.data.frame() %>% 
    purrr::set_names("r2") %>% 
    rownames_to_column("metric") %>% 
    tibble::as_tibble() %>% 
    mutate(metric=str_replace(metric, pattern=".r2", replacement="")) %>% 
    arrange(r2) %>% 
    ggplot(aes(x=fct_reorder(metric, r2), y=r2)) + 
    geom_col(fill="lightblue") + 
    geom_text(aes(y=r2/2, label=round(r2, 2)), size=2.5) + 
    coord_flip() + 
    labs(x=NULL, 
         y="R2", 
         title="R-squared on holdout data", 
         subtitle="(random forest using only month as predictor)"
         )

```

Temperature, dewpoint, and soil moisture/temperature are best explained when using only month as a predictor

The model is run for each continuous variable, using only day of year as a predictor:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

set.seed(24011017)

lstContDoY <- lapply(vCont, 
                     FUN=function(x) {
                         runFullRF(dfTrain=dfTrain %>% mutate(doy=yday(date)), 
                                   yVar=x, 
                                   xVars=c("doy"), 
                                   dfTest=dfTest %>% mutate(doy=yday(date)), 
                                   isContVar = TRUE, 
                                   useLabel=paste0("predictions on 2022 holdout data for variable ", x),
                                   makePlots=FALSE,
                                   returnData=TRUE
                                   )
                         }
                     )
names(lstContDoY) <- vCont

```

Predictive power on the holdout 2022 data is explored:  
```{r, fig.height=9, fig.width=9}

sapply(lstContMonth, FUN=function(x) x[["rfAcc"]]["r2"]) %>% 
    as.data.frame() %>% 
    purrr::set_names("r2") %>% 
    rownames_to_column("metric") %>% 
    tibble::as_tibble() %>% 
    mutate(metric=str_replace(metric, pattern=".r2", replacement=""), preds="month") %>%
    bind_rows(sapply(lstContDoY, FUN=function(x) x[["rfAcc"]]["r2"]) %>% 
                  as.data.frame() %>% 
                  purrr::set_names("r2") %>% 
                  rownames_to_column("metric") %>% 
                  tibble::as_tibble() %>% 
                  mutate(metric=str_replace(metric, pattern=".r2", replacement=""), preds="doy")
              ) %>%
    ggplot(aes(x=fct_reorder(metric, r2), y=r2)) + 
    geom_col(fill="lightblue") + 
    geom_text(aes(y=r2/2, label=round(r2, 2)), size=2.5) + 
    coord_flip() + 
    facet_wrap(~preds) +
    labs(x=NULL, 
         y="R2", 
         title="R-squared on holdout data", 
         subtitle="(random forest using only month or day-of-year as predictor)"
         )

```

The variables have similar predictive power, though day-of-year is slightly more useful for consistently seasonal, gradual change metrics (e.g., soil moisture/temperature) while being more prone to overfit on metrics that have small (if any) seasonality

The model is run for each continuous variable, using only hour of day (as both factor and integer) as a predictor:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

set.seed(24011017)

lstContToD <- lapply(vCont, 
                     FUN=function(x) {
                         runFullRF(dfTrain=dfTrain %>% mutate(doy=yday(date)), 
                                   yVar=x, 
                                   xVars=c("hour", "fct_hour"), 
                                   dfTest=dfTest %>% mutate(doy=yday(date)), 
                                   isContVar = TRUE, 
                                   useLabel=paste0("predictions on 2022 holdout data for variable ", x),
                                   makePlots=FALSE,
                                   returnData=TRUE
                                   )
                         }
                     )
names(lstContToD) <- vCont

```

Predictive power on the holdout 2022 data is explored:  
```{r, fig.height=9, fig.width=9}

sapply(lstContToD, FUN=function(x) x[["rfAcc"]]["r2"]) %>% 
    as.data.frame() %>% 
    purrr::set_names("r2") %>% 
    rownames_to_column("metric") %>% 
    tibble::as_tibble() %>% 
    mutate(metric=str_replace(metric, pattern=".r2", replacement="")) %>% 
    arrange(r2) %>% 
    ggplot(aes(x=fct_reorder(metric, r2), y=r2)) + 
    geom_col(fill="lightblue") + 
    geom_text(aes(y=r2/2, label=round(r2, 2)), size=2.5) + 
    coord_flip() + 
    labs(x=NULL, 
         y="R2", 
         title="R-squared on holdout data", 
         subtitle="(random forest using only hour of day as predictor)"
         )

```

As expected, hour of day is a moderately strong predictor for radiation and associated metrics

The model is run for each continuous variable, using hour of day (as both factor and integer), month, and day of year as predictors:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

set.seed(24011414)

lstContHDM <- lapply(vCont, 
                     FUN=function(x) {
                         runFullRF(dfTrain=dfTrain %>% mutate(doy=yday(date)), 
                                   yVar=x, 
                                   xVars=c("hour", "fct_hour", "month", "doy"), 
                                   dfTest=dfTest %>% mutate(doy=yday(date)), 
                                   isContVar = TRUE, 
                                   useLabel=paste0("predictions on 2022 holdout data for variable ", x),
                                   makePlots=FALSE,
                                   returnData=TRUE
                                   )
                         }
                     )
names(lstContHDM) <- vCont

```

Predictive power on the holdout 2022 data is explored:  
```{r, fig.height=9, fig.width=9}

tmpFun <- function(x) {
    sapply(get(x), FUN=function(y) y[["rfAcc"]]["r2"]) %>% 
        as.data.frame() %>% 
        purrr::set_names("r2") %>% 
        rownames_to_column("metric") %>% 
        tibble::as_tibble() %>% 
        mutate(metric=str_replace(metric, pattern=".r2", replacement=""), preds=x)
}

map_dfr(c("lstContDoY", "lstContHDM", "lstContMonth", "lstContToD"), .f=tmpFun) %>% 
    mutate(predLab=c("lstContDoY"="Day of Year", 
                     "lstContHDM"="All", 
                     "lstContMonth"="Month", 
                     "lstContToD"="Hour of Day"
                     )[preds]
           ) %>%
    ggplot(aes(x=fct_reorder(metric, r2, max), y=r2)) + 
    geom_point(aes(color=predLab)) + 
    coord_flip() +
    labs(x=NULL, 
         y="R2", 
         title="R-squared on holdout data", 
         subtitle="(random forest using combinations of hour, day of year, month as predictor)"
         ) + 
    geom_hline(yintercept=0, lty=2) +
    scale_color_discrete(NULL)

```

As expected, the random forest using all three variables generally performs similar to the best performing standalone metric

R-squared is compared between holdout and OOB training data:  
```{r, fig.height=9, fig.width=9}

tmpFun_v2 <- function(x) {
    sapply(get(x), FUN=function(y) c("rfTrain"=y[["rf"]][["r.squared"]], "rfTest"=y[["rfAcc"]][["r2"]])) %>% 
        t() %>% 
        as.data.frame() %>% 
        rownames_to_column("metric") %>% 
        tibble::as_tibble() %>% 
        pivot_longer(cols=-c(metric)) %>% 
        mutate(preds=x)
}

map_dfr(c("lstContDoY", "lstContHDM", "lstContMonth", "lstContToD"), .f=tmpFun_v2) %>% 
    mutate(predLab=c("lstContDoY"="Day of Year", 
                     "lstContHDM"="All", 
                     "lstContMonth"="Month", 
                     "lstContToD"="Hour of Day"
                     )[preds], 
           nameLab=c("rfTest"="Holdout R2", "rfTrain"="OOB R2 Estimate")[name]
           ) %>%
    ggplot(aes(x=fct_reorder(metric, value, max), y=value)) + 
    geom_point(aes(color=nameLab)) + 
    coord_flip() +
    labs(x=NULL, 
         y=NULL, 
         title="R-squared on holdout data vs. OOB training estimate", 
         subtitle="(random forest using combinations of hour, day of year, month as predictor)"
         ) + 
    geom_hline(yintercept=c(0, 1), lty=2) +
    facet_wrap(~predLab, nrow=1) +
    scale_color_discrete(NULL) + 
    theme(legend.position="bottom")

```

R-squared is compared between holdout and OOB training data, for the full model and the best single-variable model:  
```{r, fig.height=9, fig.width=9}

map_dfr(c("lstContDoY", "lstContHDM", "lstContMonth", "lstContToD"), .f=tmpFun_v2) %>% 
    mutate(predLab=c("lstContDoY"="Day of Year", 
                     "lstContHDM"="All", 
                     "lstContMonth"="Month", 
                     "lstContToD"="Hour of Day"
    )[preds], 
    nameLab=c("rfTest"="Holdout R2", "rfTrain"="OOB R2 Estimate")[name]
    ) %>% 
    group_by(metric, name, nameLab) %>% 
    summarize(maxAll=max(ifelse(predLab=="All", value, NA), na.rm=TRUE), 
              maxSingle=max(ifelse(predLab=="All", NA, value), na.rm=TRUE),
              .groups="drop"
              ) %>% 
    pivot_longer(cols=starts_with("max"), names_to="varType") %>% 
    ggplot(aes(x=fct_reorder(metric, value), y=value)) + 
    geom_point(aes(color=c("maxAll"="All", "maxSingle"="Best\nSingle")[varType])) + 
    facet_wrap(~nameLab) + 
    coord_flip() + 
    labs(x=NULL, 
         y="R-squared", 
         title="R-squared using best single predictor or all-three predictors", 
         subtitle="(random forest using combinations of hour, day of year, month as predictor)"
         ) + 
    geom_hline(yintercept=c(0, 1), lty=2) +
    scale_color_discrete(NULL)

```

Using several variables is especially helpful for predicting radiation and related variables (vapor pressure deficit, evapotranspiration) that are highly associated with sunny days in the warm season
