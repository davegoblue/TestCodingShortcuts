---
title: "Coronavirus US - USA Facts"
author: "davegoblue"
date: "2022-09-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
This module builds on code contained in Coronavirus_Statistics_USAF_v006.Rmd.  This file includes the latest code for analyzing data from [USA Facts](https://usafacts.org/visualizations/coronavirus-covid-19-spread-map/).  USA Facts maintains data on cases and deaths by county for coronavirus in the US.  Downloaded data are unique by county with date as a column and a separate file for each of cases, deaths, and population.

The intent of this code is to source updated functions that allow for readRunUSAFacts() to be run to obtain, read, process, and analyze data from USA Facts.

## Sourcing Functions  
The tidyverse library is loaded, and the functions used for CDC daily processing are sourced.  Additionally, specific functions for USA Facts are also sourced:  
```{r}

library(tidyverse)

# Functions are available in source file
source("./Generic_Added_Utility_Functions_202105_v001.R")
source("./Coronavirus_CDC_Daily_Functions_v002.R")
source("./Coronavirus_USAF_Functions_v001.R")

```
  
Further, the mapping file specific to USA Facts is sourced:  
```{r}

source("./Coronavirus_USAF_Default_Mappings_v002.R")

```
  
Updated functions for diagnoseClusters(), createDetailedSummaries(), createSummary(), and helperSummaryMap() are included in Coronavirus_USAF_Functions_v001.R. These functions should be checked for consistency with state-level data with just a single copy kept later.
  
## Example Process  
The latest county-level burden data are downloaded:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

readList <- list("usafCase"="./RInputFiles/Coronavirus/covid_confirmed_usafacts_downloaded_20220913.csv", 
                 "usafDeath"="./RInputFiles/Coronavirus/covid_deaths_usafacts_downloaded_20220913.csv"
                 )
compareList <- list("usafCase"=readFromRDS("cty_newdata_20220807")$dfRaw$usafCase, 
                    "usafDeath"=readFromRDS("cty_newdata_20220807")$dfRaw$usafDeath
                    )

# Use existing clusters
cty_newdata_20220913 <- readRunUSAFacts(maxDate="2022-09-11", 
                                        downloadTo=lapply(readList, 
                                                          FUN=function(x) if(file.exists(x)) NA else x
                                                          ),
                                        readFrom=readList, 
                                        compareFile=compareList, 
                                        writeLog="./RInputFiles/Coronavirus/USAF_NewData_20220913_chk_v005.log", 
                                        ovrwriteLog=TRUE,
                                        useClusters=readFromRDS("cty_newdata_20210813")$useClusters,
                                        skipAssessmentPlots=FALSE,
                                        brewPalette="Paired"
                                        )

# Plot all counties based on closest cluster
sparseCountyClusterMap(cty_newdata_20220913$useClusters, 
                       caption="Includes only counties with 25k+ population",
                       brewPalette="viridis"
                       )

# Save the refreshed file
saveToRDS(cty_newdata_20220913, ovrWriteError=FALSE)

```
  
Vaccines data are also updated, though the process needs to integrate previous data:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

cty_vaxdata_20220914 <- processCountyVaccines(loc="./RInputFiles/Coronavirus/county_vaccine_20220914.csv", 
                                              ctyList=cty_newdata_20220913, 
                                              minDateCD=c("2022-06-09", "2022-06-09"),
                                              maxDateCD="2022-09-01"
                                              )

# Save the refreshed file
saveToRDS(cty_vaxdata_20220914, ovrWriteError=FALSE)

```
  
County-level data are post-processed:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

cty_postdata_20220913 <- postProcessCountyData(lstCtyBurden=cty_newdata_20220913$dfPerCapita, 
                                               lstCtyVax=cty_vaxdata_20220914$vaxFix, 
                                               lstState=readFromRDS("cdc_daily_220902")$dfPerCapita
                                               )

# Save the refreshed file
saveToRDS(cty_postdata_20220913, ovrWriteError=FALSE)

```
  

Additional post-processing steps are run:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Step 1a: Burden comparisons for aggregated states
additionalCountyPostProcess(cty_postdata_20220913, p1CompareStates=c(state.abb, "DC"), p1AggData=TRUE)

# Step 1: Burden aggregation for key states
# Step 2: vaccine comparisons
# Step 3: Scoring updates (and errors)
# Step 4: New rolling data (28-day default with ceilings 50000 CPM, 500 DPM)
additionalCountyPostProcess(cty_postdata_20220913, 
                            p1CompareStates=c("GA", "FL", "NE"), 
                            p2VaxStates=c("MA", "HI", "TX", "VA", "VT", "GA", "CO", "SD"), 
                            p3VaxTimes=sort(c("2022-01-01", "2022-08-31")),
                            p4DF=cty_newdata_20220913$dfPerCapita
                            )

```
  
Additional plots are also updated:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Creating the vaccine and burden data
tmpVaxBurden <- createVaxBurdenData(lstVax=cty_vaxdata_20220914, lstBurden=cty_newdata_20220913)

# Nationwide aggregation, excluding problem states
problemStates <- c("VA", "TX", "SD", "HI", "GA", "CO", "GA", "FL", "NE", "VA")
useStates <- state.abb
tmpCountyList <- tmpVaxBurden$ctyPop %>%
    filter(state %in% useStates, !(state %in% problemStates)) %>%
    left_join(filter(tmpVaxBurden$dfVaxBurden, name=="vxcpoppct", date==max(date)), by="countyFIPS") %>%
    mutate(vaxPct=percent_rank(value), 
           vaxBucket=case_when(vaxPct <= .25 ~ "3. Low", vaxPct >= .75 ~ "1. High", TRUE ~ "2. Medium")
           ) %>%
    split(f=.$vaxBucket)

# Plot of absolute burden
plotVaxBurdenData(tmpVaxBurden, 
                  ctyPlot=lapply(tmpCountyList, FUN=function(x) x %>% rename(bucket=vaxBucket)), 
                  plotTitle="Counties in states with continuous county data"
                  )

# Plots of burden relative to May 2021
plotVaxBurdenData(tmpVaxBurden, 
                  ctyPlot=lapply(tmpCountyList, FUN=function(x) x %>% rename(bucket=vaxBucket)), 
                  plotTitle="Counties in states with continuous county data", 
                  scaleToDate="2021-05-01"
                  )

```
  
Multiple data anomalies need to be addressed - vaccines data covering only a short time period, counties significantly revising burden downwards, etc.
  
Counties with significant negative burden are investigated:  
```{r, fig.height=9, fig.width=9}

keyRatio <- cty_newdata_20220913$dfPerCapita %>%
    select(countyFIPS, state, date, cases, deaths) %>%
    group_by(countyFIPS, state) %>%
    summarize(keyRatDeath=sum(ifelse(date==max(date), deaths, 0)/max(deaths)), 
              keyRatCases=sum(ifelse(date==max(date), cases, 0)/max(cases)),
              .groups="drop"
              )

keyRatio %>%
    mutate(across(where(is.numeric), .fns=function(x) round(x, 3))) %>%
    count(keyRatCases, keyRatDeath) %>%
    ggplot(aes(x=keyRatCases, y=keyRatDeath)) + 
    geom_point(aes(size=n)) + 
    lims(x=c(0, 1), y=c(0, 1)) + 
    labs(x="Latest cases vs. maximum cases", 
         y="Latest deaths vs. maximum deaths", 
         title="County-level restatement"
         )

keyRatio %>%
    mutate(across(where(is.numeric), .fns=function(x) round(x, 3))) %>%
    count(keyRatCases, keyRatDeath) %>%
    filter(keyRatCases < 1 | keyRatDeath < 1) %>%
    ggplot(aes(x=keyRatCases, y=keyRatDeath)) + 
    geom_point(aes(size=n)) + 
    lims(x=c(0, 1), y=c(0, 1)) + 
    labs(x="Latest cases vs. maximum cases", 
         y="Latest deaths vs. maximum deaths", 
         title="County-level restatement", 
         subtitle="Only counties with at least one ratio .999 or lower included"
         )

```

Restatement of deaths is much more common than restatement of cases. Counties with declines are further explored:  
```{r, fig.height=9, fig.width=9}

decStatus <- keyRatio %>%
    mutate(rd=case_when(is.na(keyRatDeath) ~ -1, 
                        keyRatDeath==1 ~ 1, 
                        keyRatDeath>=.95 ~ .95, 
                        keyRatDeath>=.9 ~ .9, 
                        keyRatDeath>=.75 ~ .75, 
                        keyRatDeath>=.5 ~ .5, 
                        TRUE ~ 0
                        )
           )
decStatus %>%
    count(rd)
decStatus %>%
    count(rd, state) %>%
    filter(rd<.95, rd>=0, n>1) %>%
    arrange(rd, -n)

cty_newdata_20220913$dfPerCapita %>%
    left_join(select(decStatus, countyFIPS, state, rd), by=c("countyFIPS", "state")) %>%
    group_by(rd, date) %>%
    summarize(cases=sum(cases), deaths=sum(deaths), n=n(), .groups="drop") %>%
    mutate(labFacet=paste0(rd, " (n=", n, ")")) %>%
    ggplot(aes(x=date, y=deaths)) + 
    geom_line() + 
    facet_wrap(~labFacet, scales="free_y") + 
    labs(x=NULL, 
         y="Reported deaths", 
         title="Reported deaths, facetted by change from maximum"
         )

```
  
Illinois and Nebraska appear to be main drivers of reported declines (discontinuities) in deaths. Reporting is potentially lagged, as much of the issue appears to be recent.

Restatement of cases is also explored:  
```{r, fig.height=9, fig.width=9}

decStatus <- keyRatio %>%
    mutate(rd=case_when(is.na(keyRatCases) ~ -1, 
                        keyRatCases==1 ~ 1, 
                        keyRatCases>=.99 ~ .99, 
                        keyRatCases>=.95 ~ .95, 
                        keyRatCases>=.5 ~ .5, 
                        TRUE ~ 0
                        )
           )
decStatus %>%
    count(rd)
decStatus %>%
    count(rd, state) %>%
    filter(rd<.99, rd>=0, n>1) %>%
    arrange(rd, -n)

cty_newdata_20220913$dfPerCapita %>%
    left_join(select(decStatus, countyFIPS, state, rd), by=c("countyFIPS", "state")) %>%
    group_by(rd, date) %>%
    summarize(cases=sum(cases), deaths=sum(deaths), n=n(), .groups="drop") %>%
    mutate(labFacet=paste0(rd, " (n=", n, ")")) %>%
    ggplot(aes(x=date, y=cases)) + 
    geom_line() + 
    facet_wrap(~labFacet, scales="free_y") + 
    labs(x=NULL, 
         y="Reported cases", 
         title="Reported cases, facetted by change from maximum"
         )

```
  
In aggregate, the cases look OK, with the exception of a few counties that may have incomplete reporting in the most recent time period. Specific county declines are further explored:  
```{r, fig.height=9, fig.width=9}

decStatus <- keyRatio %>%
    mutate(rd=case_when(is.na(keyRatDeath) ~ -1, 
                        keyRatDeath==1 ~ 1, 
                        keyRatDeath>=.95 ~ .95, 
                        keyRatDeath>=.9 ~ .9, 
                        keyRatDeath>=.75 ~ .75, 
                        keyRatDeath>=.5 ~ .5, 
                        TRUE ~ 0
                        )
           )
decStatus %>%
    count(rd)
decStatus %>%
    count(rd, state) %>%
    filter(rd<.95, rd>=0, n>1) %>%
    arrange(rd, -n)

cty_newdata_20220913$dfPerCapita %>%
    left_join(select(decStatus, countyFIPS, state, rd), by=c("countyFIPS", "state")) %>%
    filter(rd > 0, rd < 0.9) %>%
    ggplot(aes(x=date, y=deaths)) + 
    geom_line(aes(group=countyFIPS, color=state)) + 
    facet_wrap(~rd, scales="free_y") + 
    labs(x=NULL, 
         y="Reported deaths by county", 
         title="Reported deaths, facetted by change from maximum"
         )

```
  
There are two separate issues - some counties appear to have incomplete data in the latest time period, while other counties appear to have significant negative restatement of data earlier in 2022

The ratio process is updated:  
```{r, fig.height=9, fig.width=9}

keyRatioDate <- cty_newdata_20220913$dfPerCapita %>%
    select(countyFIPS, state, date, cases, deaths) %>%
    pivot_longer(-c(countyFIPS, state, date)) %>%
    arrange(countyFIPS, state, name, date) %>%
    group_by(countyFIPS, state, name) %>%
    mutate(ratMax=value/max(value, na.rm=TRUE), cumMax=value/cummax(value)) %>%
    ungroup()
keyRatioDate
dfMinMax <- keyRatioDate %>%
    filter(!is.na(cumMax)) %>%
    group_by(countyFIPS, name) %>%
    summarize(minMax=min(cumMax), .groups="drop") 
dfMinMax %>%
    ggplot(aes(x=minMax)) + 
    geom_density(aes(group=name, color=name)) + 
    labs(title="Ratio of burden vs. cumulative maximum of burden (expected to be 1 for ascending sequence)", 
         subtitle="Lowest value per county and metric plotted", 
         x="Lowest value of daily burden vs. cumulative maximum of burden", 
         y="Density"
         ) + 
    scale_color_discrete("Metric")
dfMinMax %>%
    filter(minMax == 0, name=="deaths") %>%
    select(countyFIPS) %>%
    left_join(cty_newdata_20220913$dfPerCapita, by="countyFIPS") %>%
    ggplot(aes(x=date, y=deaths)) + 
    geom_line(aes(group=countyFIPS)) + 
    facet_wrap(~countyFIPS, scales="free_y") + 
    labs(title="Reported deaths by counties with zero following non-zero", x=NULL, y="Reported deaths")

```
  
While some of the declines are anomalous, others appear to be curves that are either very low volume or smooth on a rolling-7 basis

The process is repeated to examine issues by state:  
```{r, fig.height=9, fig.width=9}

keyRatioDateState <- cty_newdata_20220913$dfPerCapita %>%
    group_by(state, date) %>%
    summarize(across(c(cases, deaths), .fns=function(x) sum(x, na.rm=TRUE)), .groups="drop") %>%
    pivot_longer(-c(state, date)) %>%
    arrange(state, name, date) %>%
    group_by(state, name) %>%
    mutate(ratMax=value/max(value, na.rm=TRUE), cumMax=ifelse(cummax(value)==0, 1, value/cummax(value))) %>%
    ungroup()
keyRatioDateState
dfMinMaxState <- keyRatioDateState %>%
    filter(!is.na(cumMax)) %>%
    group_by(state, name) %>%
    summarize(minMax=min(cumMax), .groups="drop") 
dfMinMaxState %>%
    ggplot(aes(x=minMax)) + 
    geom_density(aes(group=name, color=name)) + 
    labs(title="Ratio of burden vs. cumulative maximum of burden (expected to be 1 for ascending sequence)", 
         subtitle="Lowest value per state and metric plotted", 
         x="Lowest value of daily burden vs. cumulative maximum of burden", 
         y="Density"
         ) + 
    scale_color_discrete("Metric")
dfMinMaxState %>%
    filter(minMax < 0.95, name=="deaths") %>%
    select(state) %>%
    left_join(cty_newdata_20220913$dfPerCapita, by="state") %>%
    group_by(state, date) %>%
    summarize(across(c(cases, deaths), .fns=function(x) sum(x, na.rm=TRUE)), .groups="drop") %>%
    ggplot(aes(x=date, y=deaths)) + 
    geom_line(aes(group=state)) + 
    facet_wrap(~state, scales="free_y") + 
    labs(title="Reported deaths by states with meaningfully non-ascending trend", x=NULL, y="Reported deaths")

```
  
Significant restatements appear to be in MA, while missing recent data appears to be in IL. It is unclear if MO and NE are still reporting county-level deaths. The data is potentially less complete and accurate than in previous iterations

The definition of a decline is modified to be min(cur-cummax)/max, so that declines of 1 or 2 early in the data are not flagged as major percentage changes:  
```{r, fig.height=9, fig.width=9}

keyRatioDateState_v2 <- cty_newdata_20220913$dfPerCapita %>%
    group_by(state, date) %>%
    summarize(across(c(cases, deaths), .fns=function(x) sum(x, na.rm=TRUE)), .groups="drop") %>%
    pivot_longer(-c(state, date)) %>%
    arrange(state, name, date) %>%
    group_by(state, name) %>%
    mutate(ratMax=value/max(value, na.rm=TRUE), 
           cumMax=ifelse(cummax(value)==0, 1, (value-cummax(value))/max(value, na.rm=TRUE))
           ) %>%
    ungroup()
keyRatioDateState_v2
dfMinMaxState_v2 <- keyRatioDateState_v2 %>%
    filter(!is.na(cumMax)) %>%
    group_by(state, name) %>%
    summarize(minMax=min(cumMax), .groups="drop") 
dfMinMaxState_v2 %>%
    ggplot(aes(x=fct_reorder(state, -minMax, min), y=1+minMax)) + 
    geom_col(fill="lightblue") +
    geom_text(aes(label=round(1+minMax, 2)), hjust=0) +
    labs(title="Ratio of burden vs. cumulative maximum of burden (expected to be 1 for ascending sequence)", 
         subtitle="Lowest value of 1 + (value - cummax(value)) / max(value)", 
         y="Lowest value", 
         x=NULL
         ) + 
    coord_flip() +
    facet_wrap(~name)
dfMinMaxState_v2 %>%
    filter(state %in% c("IL", "TX", "MA", "NE")) %>%
    select(state) %>%
    left_join(cty_newdata_20220913$dfPerCapita, by="state") %>%
    group_by(state, date) %>%
    summarize(across(c(cases, deaths), .fns=function(x) sum(x, na.rm=TRUE)), .groups="drop") %>%
    ggplot(aes(x=date, y=deaths)) + 
    geom_line(aes(group=state)) + 
    facet_wrap(~state, scales="free_y") + 
    labs(title="Reported deaths by states with meaningfully non-ascending trend", x=NULL, y="Reported deaths")
dfMinMaxState_v2 %>%
    filter(state %in% c("IL", "WY")) %>%
    select(state) %>%
    left_join(cty_newdata_20220913$dfPerCapita, by="state") %>%
    group_by(state, date) %>%
    summarize(across(c(cases, deaths), .fns=function(x) sum(x, na.rm=TRUE)), .groups="drop") %>%
    ggplot(aes(x=date, y=cases)) + 
    geom_line(aes(group=state)) + 
    facet_wrap(~state, scales="free_y") + 
    labs(title="Reported cases by states with meaningfully non-ascending trend", x=NULL, y="Reported cases")

```
  
The updated methodology better flags states with meaningful restatement problems

The process is converted to functional form:  
```{r, fig.height=9, fig.width=9}

# Function to calculate distance from global maxima and previous maxima (including self)
findDeltaFromMax <- function(df, groupBy=c(), timeVar="date", numVars=NULL) {
    
    # FUNCTION ARGUMENTS:
    # df: a data frame
    # groupBy: levels to which the final data should be aggregated
    # timeVar: time variable to which data should be aggregated
    # numVars: numeric variables to be summarized (NULL means all numeric variables)
    
    # Find numVars if not provided
    if(is.null(numVars)) numVars <- df %>% select(where(is.numeric)) %>% names %>% setdiff(groupBy)
    
    df %>%
        group_by_at(all_of(c(groupBy, timeVar))) %>%
        summarize(across(all_of(numVars), .fns=function(x) sum(x, na.rm=TRUE)), .groups="drop") %>%
        pivot_longer(all_of(numVars)) %>%
        arrange(across(all_of(c(groupBy, "name", timeVar)))) %>%
        group_by_at(all_of(c(groupBy, "name"))) %>%
        mutate(ratMax=value/max(value, na.rm=TRUE), 
               cumMax=ifelse(cummax(value)==0, 1, value/cummax(value)), 
               delMax=ifelse(cummax(value)==0, 1, (value-cummax(value))/max(value, na.rm=TRUE))
               ) %>%
        ungroup()
    
}

# Check for states
dfTest <- findDeltaFromMax(cty_newdata_20220913$dfPerCapita, groupBy="state", numVar=c("cases", "deaths"))
identical(dfTest %>% select(-delMax), keyRatioDateState)
identical(dfTest %>% select(-cumMax) %>% rename(cumMax=delMax), keyRatioDateState_v2)

# Check for counties - old approach output NaN rather than 1 when cummax(value)=0
dfTest_v2 <- findDeltaFromMax(cty_newdata_20220913$dfPerCapita, 
                              groupBy=c("countyFIPS", "state"), 
                              numVar=c("cases", "deaths")
                              )
identical(dfTest_v2 %>% select(-delMax, -cumMax), keyRatioDate %>% select(-cumMax))
all.equal(dfTest_v2 %>% pull(cumMax), 
          keyRatioDate %>% select(cumMax) %>% mutate(cumMax=ifelse(is.na(cumMax), 1, cumMax)) %>% pull(cumMax)
          )

```
  
Functions are also written for plot creation:  
```{r, fig.height=9, fig.width=9}

plotDeltaFromMax <- function(df, 
                             dfCtyData=NULL,
                             plotStateRatio=FALSE, 
                             plotDeathStates=c(), 
                             plotCaseStates=c()
                             ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame or tibble containing ratios by entity and date
    # dfCtyData: county-level per-capita data (not needed if only plotStateRatio is run)
    # plotStateRatio: should the state ratio plot be created?
    # plotDeathStates: vector of states to plot on the deaths metric (c() means do not plot)
    # plotCaseStates: vector of states to plot on the cases metric (c() means do not plot)

    
    # Plot 1: state ratios
    if(isTRUE(plotStateRatio)) {
        p1 <- df %>%
            filter(!is.na(delMax)) %>%
            group_by(state, name) %>%
            summarize(minMax=min(delMax), .groups="drop") %>%
            ggplot(aes(x=fct_reorder(state, -minMax, min), y=1+minMax)) + 
            geom_col(fill="lightblue") +
            geom_text(aes(label=round(1+minMax, 2)), hjust=0) +
            labs(title="Ratio of burden vs. cumulative maximum of burden (expected to be 1 for ascending sequence)", 
                 subtitle="Lowest value of 1 + (value - cummax(value)) / max(value)", 
                 y="Lowest value", 
                 x=NULL
                 ) + 
            coord_flip() +
            facet_wrap(~name)
        print(p1)
    }
    
    # Plots 2 and 3: Create case and death data
    if((length(plotCaseStates) > 0) | (length(plotDeathStates) > 0)) {
        dfPlot <- dfCtyData %>%
            select(state, date, cases, deaths) %>%
            filter(state %in% all_of(union(plotCaseStates, plotDeathStates))) %>%
            group_by(state, date) %>%
            summarize(across(c(cases, deaths), .fns=function(x) sum(x, na.rm=TRUE)), .groups="drop")
    }
    
    # Plot 2: Death states
    if(length(plotDeathStates) > 0) {
        p2 <- dfPlot %>%
            filter(state %in% all_of(plotDeathStates)) %>%
            ggplot(aes(x=date, y=deaths)) + 
            geom_line(aes(group=state)) + 
            facet_wrap(~state, scales="free_y") + 
            labs(title="Reported deaths by states with meaningfully non-ascending trend", 
                 x=NULL, 
                 y="Reported deaths"
                 )
        print(p2)
    }
    
    # Plot 3: Case states
    if(length(plotCaseStates) > 0) {
        p3 <- dfPlot %>%
            filter(state %in% all_of(plotCaseStates)) %>%
            ggplot(aes(x=date, y=cases)) + 
            geom_line(aes(group=state)) + 
            facet_wrap(~state, scales="free_y") + 
            labs(title="Reported cases by states with meaningfully non-ascending trend", 
                 x=NULL, 
                 y="Reported cases"
                 )
        print(p3)
    }
    
}

plotDeltaFromMax(dfTest, plotStateRatio=TRUE)
plotDeltaFromMax(dfTest, 
                 dfCtyData=cty_newdata_20220913$dfPerCapita, 
                 plotDeathStates=c("IL", "TX", "MA", "NE"), 
                 plotCaseStates=c("IL", "WY")
                 )

```
  
Missing vaccines data are also explored:  
```{r, fig.height=9, fig.width=9}

tmpVaxCounts <- readFromRDS("cty_vaxdata_20220709")$vaxFix %>% 
    count(date, name="vax0709") %>%
    full_join(cty_vaxdata_20220914$vaxFix %>% 
                  count(date, name="vax0914"), 
              by="date"
              )

tmpVaxCounts %>%
    pivot_longer(-c(date)) %>%
    mutate(value=ifelse(is.na(value), 0, value)) %>%
    ggplot(aes(x=date, y=value)) + 
    geom_line(aes(group=name, color=name)) + 
    labs(title="# Counties reporting vaccines by date", x=NULL, y="# Counties reporting") + 
    scale_color_discrete("Source Date")

```
  
There is only a small overlapping section of data. Older data will need to be merged for a complete dataset. Consistency of reported vaccines is also checked:  
```{r, fig.height=9, fig.width=9}

tempGetVax <- function(df, groupBy=c("date")) {
    
    df %>%
        group_by_at(all_of(groupBy)) %>%
        summarize(vxc=sum(vxcpoppct*pop/100, na.rm=TRUE), 
                  vxcgte18=sum(vxcgte18pct*popgte18/100, na.rm=TRUE), 
                  vxcgte65=sum(vxcgte65pct*popgte65/100, na.rm=TRUE), 
                  .groups="drop"
                  )
    
}

tmpVaxSum <- tempGetVax(cty_vaxdata_20220914$vaxFix) %>%
    bind_rows(tempGetVax(readFromRDS("cty_vaxdata_20220709")$vaxFix), .id="src")

tmpVaxSum %>%
    mutate(src=c("1"="14-SEP-22", "2"="09-JUL-22")[src]) %>%
    pivot_longer(-c(src, date)) %>%
    ggplot(aes(x=date, y=value)) + 
    geom_line(aes(group=src, color=src)) + 
    facet_wrap(~name) + 
    labs(title="Vaccinated by source, date, and age bucket", x=NULL, y="# Fully vaccinated") + 
    scale_color_discrete("Data From:")

```
  
Data volumes appear to be broadly consistent, further suggestive that pasting back missing historical data is reasonable.

## Data Updates  
The latest county-level burden data are downloaded:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

readList <- list("usafCase"="./RInputFiles/Coronavirus/covid_confirmed_usafacts_downloaded_20221010.csv", 
                 "usafDeath"="./RInputFiles/Coronavirus/covid_deaths_usafacts_downloaded_20221010.csv"
                 )
compareList <- list("usafCase"=readFromRDS("cty_newdata_20220913")$dfRaw$usafCase, 
                    "usafDeath"=readFromRDS("cty_newdata_20220913")$dfRaw$usafDeath
                    )

# Use existing clusters
cty_newdata_20221010 <- readRunUSAFacts(maxDate="2022-10-08", 
                                        downloadTo=lapply(readList, 
                                                          FUN=function(x) if(file.exists(x)) NA else x
                                                          ),
                                        readFrom=readList, 
                                        compareFile=compareList, 
                                        writeLog="./RInputFiles/Coronavirus/USAF_NewData_20221010_chk_v005.log", 
                                        ovrwriteLog=TRUE,
                                        useClusters=readFromRDS("cty_newdata_20210813")$useClusters,
                                        skipAssessmentPlots=FALSE,
                                        brewPalette="Paired"
                                        )

# Plot all counties based on closest cluster
sparseCountyClusterMap(cty_newdata_20221010$useClusters, 
                       caption="Includes only counties with 25k+ population",
                       brewPalette="viridis"
                       )

# Save the refreshed file
saveToRDS(cty_newdata_20221010, ovrWriteError=FALSE)

```
  
Vaccines data are also updated, though the process will need to integrate previous data:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

cty_vaxdata_20221011 <- processCountyVaccines(loc="./RInputFiles/Coronavirus/county_vaccine_20221011.csv", 
                                              ctyList=cty_newdata_20221010, 
                                              minDateCD=c("2022-06-09", "2022-06-09"),
                                              maxDateCD="2022-09-29"
                                              )

# Save the refreshed file
saveToRDS(cty_vaxdata_20221011, ovrWriteError=FALSE)

```
  
County-level data are post-processed:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

cty_postdata_20221010 <- postProcessCountyData(lstCtyBurden=cty_newdata_20221010$dfPerCapita, 
                                               lstCtyVax=cty_vaxdata_20221011$vaxFix, 
                                               lstState=readFromRDS("cdc_daily_221002")$dfPerCapita
                                               )

# Save the refreshed file
saveToRDS(cty_postdata_20221010, ovrWriteError=FALSE)

```
  
The Alaska portion of usmap::plot_usmap() has an issue with Valdex county. The function is updated to allow for excluding problematic states:  
```{r}

# Updated to allow for include and exclude
makeBurdenDatePlot <- function(df, 
                               keyVar,
                               timeLabel,
                               plotTitle=NULL,
                               varLabel=NULL,
                               varFloor=0,
                               varCeiling=+Inf,
                               varDivBy=1,
                               vecRename=c("countyFIPS"="fips"), 
                               includeStates=c(), 
                               excludeStates=c()
                               ) {
    
    # FUNCTION ARGUMENTS:
    # df: a processed data frame with fips, asofDate, burden
    # keyVar: character string for variable to be plotted
    # timeLabel: character string for amount of time (e.g., "1-month" or "5-week")
    # plotTitle: title for the plot (NULL means infer from other arguments)
    # varLabel: label for the variable in plot scale (NULL means infer from other arguments)
    # varFloor: minimum value to be allowed for variable (-Inf means no floor applied)
    # varCeiling: maximum value to be allowed for variable (Inf means no ceiling applied)
    # varDivBy: variable should be divivded by this for plotting
    # vecRename: renaming vector to get desired variables in frame
    # includeStates: specific states to be plotted, where c() means all states
    # excludeStates: specific states NOT to be plotted (ignored if includeStates has length > 0)
    
    # Create varLabel if passed as NULL
    if(is.null(varLabel)) {
        varLabel <- stringr::str_to_upper(stringr::str_extract(keyVar, "^[A-Za-z]*"))
        if((varDivBy > 1) & isTRUE(all.equal(log10(varDivBy) %% 1, 0))) 
            varLabel <- paste0(varLabel, "(", stringr::str_replace(varDivBy, pattern="1", replacement=""), "s)")
        else if (varDivBy != 1) varLabel <- paste0(varLabel, "(units of ", varDivBy, ")")
    }
    
    # Create plotTitle if passed as NULL
    if(is.null(plotTitle)) 
        plotTitle <- paste0(timeLabel, 
                            " coronavirus ", 
                            if(str_detect(stringr::str_to_upper(keyVar), pattern="CPM")) "cases" else "deaths",
                            " by county"
        )
    
    # Resolve includeStates and excludeStates
    if(length(includeStates) > 0) {
        if(length(excludeStates) > 0) {
            cat("\nParamater excludeStates will be ignored since includeStates was passed\n")
            excludeStates <- c()
        }
        invalidInclude <- setdiff(includeStates, c(state.abb, "DC"))
        if(length(invalidInclude) > 0) {
            cat("\nInvalid states passed in includeStates deleted:", paste(invalidInclude, collapse=", "), "\n")
            includeStates <-setdiff(includeStates, invalidInclude)
        }
    }
    
    # Create and return plot
    p1 <- df %>%
        colRenamer(vecRename=vecRename) %>%
        mutate(burden=pmax(pmin(get(all_of(keyVar)), varCeiling), varFloor)/varDivBy) %>%
        select(fips, burden, asofDate) %>%
        usmap::plot_usmap(regions="counties", data=., values="burden", include=includeStates, exclude=excludeStates) + 
        labs(title=plotTitle, 
             subtitle=if(varFloor > -Inf | varCeiling < +Inf) "Floors and/or ceilings applied" else NULL, 
             caption="Source: USA Facts"
        ) +
        scale_fill_continuous(paste0(varLabel, "\n", timeLabel), low="grey", high="red") +
        facet_wrap(~asofDate) + 
        theme(legend.position="bottom")
    p1
    
}

postProcessCountyData <- function(lstCtyBurden,
                                  lstCtyVax,
                                  lstState, 
                                  maxDate=NULL, 
                                  minDateBurden="2020-02-15", 
                                  minDateVax="2021-04-01", 
                                  includeStates=c(), 
                                  excludeStates=c()
                                  ) {
    
    # FUNCTION ARGUMENTS:
    # lstCtyBurden: list of processed county-level burden data (or a dfPerCapita file from this list)
    # lstCtyVax: list of processed county-level vaccines data (or a vaxFix file from this list)
    # lstState: list of processed state-level burden data (or a dfPerCapita file from this list)
    # maxDate: maximum date to use for plotting (NULL means latest date in both lstCty and lstState)
    # minDateBurden: earliest date for scoring burden similarity across files
    # minDateVax: earliest date for scoring vaccine similarity across files
    # includeStates: specific states to be plotted, where c() means all states
    # excludeStates: specific states NOT to be plotted (ignored if includeStates has length > 0)
    
    # Extract the relevant perCapita and vaxFix data if needed
    if("list" %in% class(lstCtyBurden)) lstCtyBurden <- lstCtyBurden[["dfPerCapita"]]
    if("list" %in% class(lstState)) lstState <- lstState[["dfPerCapita"]]
    if("list" %in% class(lstCtyVax)) lstCtyVax <- lstCtyVax[["vaxFix"]]
    
    # Get maxDate if not provided
    if(is.null(maxDate)) maxDate <- min(max(lstCtyBurden$date, na.rm=TRUE), max(lstState$date, na.rm=TRUE))
    cat("\nParameter maxDate is:", as.character(maxDate), "\n\n")
    
    # Data for score similarity process
    dfCompare <- compareStateSummedCounty(dfState=lstState, 
                                          dfCounty=lstCtyBurden, 
                                          inclStates=c(state.abb, "DC"), 
                                          dateThru=maxDate, 
                                          makePlot=FALSE,
                                          returnData=TRUE
    )
    scoreSimilarity(dfCompare, minDate=minDateBurden, maxDate=maxDate, makeFacet=FALSE)
    
    # Check differences in data sources
    dfAllState <- integrateStateVaccine(lstCtyVax, statePerCap=lstState, treatNAZero=TRUE)
    vaxDiff <- scoreVaxSimilarity(dfAllState, minDate=minDateVax, maxDate=maxDate, returnBaseData=TRUE)
    
    # Create county-level burden data by quarters
    dfRoll91 <- createBurdenCountyDate(lstCtyBurden, 
                                       maxDate=maxDate, 
                                       rollBy=months(c(0, -3, -6, -9)), 
                                       dateSpan=91
    )
    makeBurdenDatePlot(dfRoll91, 
                       keyVar="cpm91", 
                       timeLabel="3-month", 
                       varCeiling=100000, 
                       varDivBy=1000, 
                       includeStates=includeStates, 
                       excludeStates=excludeStates
                       ) %>% 
        print()
    makeBurdenDatePlot(dfRoll91, 
                       keyVar="dpm91", 
                       timeLabel="3-month", 
                       varCeiling=1500, 
                       includeStates=includeStates, 
                       excludeStates=excludeStates
                       ) %>% 
        print()
    
    # Return the key elements
    list(dfCompare=dfCompare, dfAllState=dfAllState, vaxDiff=vaxDiff, dfRoll91=dfRoll91)
    
}

```

County-level data are post-processed:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

cty_postdata_20221010_v2 <- postProcessCountyData(lstCtyBurden=cty_newdata_20221010$dfPerCapita, 
                                                  lstCtyVax=cty_vaxdata_20221011$vaxFix, 
                                                  lstState=readFromRDS("cdc_daily_221002")$dfPerCapita, 
                                                  excludeStates="AK"
                                                  )

# Check equivalence of data files
identical(cty_postdata_20221010, cty_postdata_20221010_v2)

```
  
Additional post-processing steps are run:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Step 1a: Burden comparisons for aggregated states
additionalCountyPostProcess(cty_postdata_20221010, p1CompareStates=c(state.abb, "DC"), p1AggData=TRUE)

# Step 1: Burden aggregation for key states
# Step 2: vaccine comparisons
# Step 3: Scoring updates (and errors)
# Step 4: New rolling data (28-day default with ceilings 50000 CPM, 500 DPM)
additionalCountyPostProcess(cty_postdata_20221010, 
                            p1CompareStates=c("GA", "FL", "NE"), 
                            p2VaxStates=c("MA", "HI", "TX", "VA", "VT", "GA", "CO", "SD"), 
                            p3VaxTimes=sort(c("2022-01-01", "2022-09-28")),
                            p4DF=cty_newdata_20221010$dfPerCapita
                            )

```
  
The function is updated to allow for excluding states (such as AK in this case where Valdez County issues in usmap cause an NA issue):  
```{r}

additionalCountyPostProcess <- function(lstPost, 
                                        p1CompareStates=c(), 
                                        p1AggData=FALSE, 
                                        p2VaxStates=c(), 
                                        p3VaxTimes=c(), 
                                        p4DF=NULL,
                                        p4MaxDate=NULL, 
                                        p4RollBy=months(c(0, -1, -2, -3)),
                                        p4DateSpan=28, 
                                        p4CPMCeiling=50000, 
                                        p4DPMCeiling=500, 
                                        includeStates=c(), 
                                        excludeStates=c()
                                        ) {
    
    # FUNCTION ARGUMENTS:
    # lstPost: list of post-processed county data
    # p1CompareStates: states that should be compared vs. summed county
    # p1AggData: boolean, should the comparison states all be aggregated to a single comparison?
    # p2VaxStates: states that should be compared for vaccine evolution
    # p3VaxTimes: character vector of form c(minDate, maxDate) for time period to score vaccine similarity
    # p4DF: data frame for creating rolling data (NULL means do not run)
    # p4MaxDate: maximum date for rolling analysis (NULL means use maximum date in p4DF minus 1 day)
    # p4RollBy: time periods to roll back for analysis
    # p4DateSpan: size of windows for rolling analysis
    # p4CPMCeiling: ceiling for plots on CPM (all values at or above this will be the same color)
    # p4DPMCeiling: ceiling for plots on DPM (all values at or above this will be the same color)
    # includeStates: specific states to be plotted, where c() means all states
    # excludeStates: specific states NOT to be plotted (ignored if includeStates has length > 0)
    
    # 1. Plotting state vs. summed county for key states
    if(length(p1CompareStates) > 0) {
        compareStateSummedCounty(lstAll=lstPost[["dfCompare"]], 
                                 inclStates=p1CompareStates, 
                                 createData=FALSE, 
                                 aggData=p1AggData
        )
    }
    
    # 2. Plot differences in vaccines data if needed
    if(length(p2VaxStates) > 0) 
        stateAgeVaxEvolution(lstPost[["dfAllState"]], keyState=p2VaxStates)
    
    # 3. Check vaccine similarity scoring on a different time period
    if(length(p3VaxTimes) > 0) {
        if(length(p3VaxTimes) != 2 | p3VaxTimes[2] < p3VaxTimes[1]) 
            cat("\np3VaxTimes should be c(minDate, maxDate), skipping this step due to bad parameter\n")
        else 
            scoreVaxSimilarity(lstPost[["dfAllState"]], minDate=p3VaxTimes[1], maxDate=p3VaxTimes[2])
    }
    
    # 4. Additional rolling data as needed
    if(!is.null(p4DF)) {
        if(is.null(p4MaxDate)) p4MaxDate <- max(p4DF$date) - lubridate::days(1)
        dfRoll <- createBurdenCountyDate(p4DF, maxDate=p4MaxDate, rollBy=p4RollBy, dateSpan=p4DateSpan)
        makeBurdenDatePlot(dfRoll, 
                           keyVar=paste0("cpm", p4DateSpan), 
                           timeLabel=paste0(p4DateSpan, "-day"), 
                           varCeiling=p4CPMCeiling, 
                           varDivBy=1000, 
                           includeStates=includeStates, 
                           excludeStates=excludeStates
        ) %>%
            print()
        makeBurdenDatePlot(dfRoll, 
                           keyVar=paste0("dpm", p4DateSpan), 
                           timeLabel=paste0(p4DateSpan, "-day"), 
                           varCeiling=p4DPMCeiling, 
                           includeStates=includeStates, 
                           excludeStates=excludeStates
        ) %>%
            print()
    }
    
}

```
  
Additional post-processing steps are re-run:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Step 1a: Burden comparisons for aggregated states
additionalCountyPostProcess(cty_postdata_20221010, p1CompareStates=c(state.abb, "DC"), p1AggData=TRUE)

# Step 1: Burden aggregation for key states
# Step 2: vaccine comparisons
# Step 3: Scoring updates (and errors)
# Step 4: New rolling data (28-day default with ceilings 50000 CPM, 500 DPM)
additionalCountyPostProcess(cty_postdata_20221010, 
                            p1CompareStates=c("GA", "FL", "NE"), 
                            p2VaxStates=c("MA", "HI", "TX", "VA", "VT", "GA", "CO", "SD"), 
                            p3VaxTimes=sort(c("2022-01-01", "2022-09-28")),
                            p4DF=cty_newdata_20221010$dfPerCapita, 
                            excludeStates=c("AK")
                            )

```
  
Restatement issues are explore:  
```{r, fig.height=9, fig.width=9}

# Check for states
dfTest_20221010_state <- findDeltaFromMax(cty_newdata_20221010$dfPerCapita, 
                                          groupBy="state", 
                                          numVar=c("cases", "deaths")
                                          )

# Check for counties
dfTest_20221010_cty <- findDeltaFromMax(cty_newdata_20221010$dfPerCapita, 
                                        groupBy=c("countyFIPS", "state"), 
                                        numVar=c("cases", "deaths")
                                        )

# Explore state differences
plotDeltaFromMax(dfTest_20221010_state, plotStateRatio=TRUE)
plotDeltaFromMax(dfTest_20221010_state,
                 dfCtyData=cty_newdata_20221010$dfPerCapita,
                 plotDeathStates=c("IL", "MA", "NE"),
                 plotCaseStates=c("IL", "WY")
                 )

```
  
Counties are also explored for restatement, using a combination of value and ratio:  
```{r, fig.height=9, fig.width=9}

dfRatio_cty <- dfTest_20221010_cty %>% 
    group_by(countyFIPS, state, name) %>% 
    filter(delMax==min(delMax)) %>% 
    filter(date==max(date)) %>% 
    ungroup()
dfRatio_cty

# Explore ratios of deaths by county - IL/MA/NE vs. others
dfRatio_cty %>%
    filter(name=="deaths", value > 0) %>%
    mutate(type=case_when(state=="IL" ~ "IL", state %in% c("MA", "NE") ~ "MA/NE", state=="WY" ~ "WY", TRUE ~ "Other"), 
           rat=1+delMax
           ) %>%
    ggplot(aes(x=rat)) + 
    geom_histogram(aes(fill=type)) + 
    facet_wrap(~type, nrow=2, scales="free_y") + 
    labs(x="Lowest ratio of (deaths-cummax(deaths))/max(deaths) by county", 
         y="# Counties", 
         title="Death ratios by county (1.0 means strictly non-descending, 0.0 means reports 0 after max)"
         )

# Explore ratios of cases by county - IL/WY vs. others
dfRatio_cty %>%
    filter(name=="cases", value > 0) %>%
    mutate(type=case_when(state=="IL" ~ "IL", state %in% c("MA", "NE") ~ "MA/NE", state=="WY" ~ "WY", TRUE ~ "Other"), 
           rat=1+delMax
           ) %>%
    ggplot(aes(x=rat)) + 
    geom_histogram(aes(fill=type)) + 
    facet_wrap(~type, nrow=2, scales="free_y") + 
    labs(x="Lowest ratio of (cases-cummax(cases))/max(cases) by county", 
         y="# Counties", 
         title="Case ratios by county (1.0 means strictly non-descending, 0.0 means reports 0 after max)"
         )

```
  
Case data generally has more restatement than deaths data. IL, MA, and NE all have significant county-level changes for deaths, while WY has the most counties reporting large changes in cases

A sample of counties with high death restatements are plotted:  
```{r, fig.height=9, fig.width=9}

dfRatio_cty %>% 
    filter(name=="deaths", delMax < -0.01, delMax*value < -100) %>%
    select(countyFIPS) %>%
    left_join(cty_newdata_20221010$dfPerCapita, by="countyFIPS") %>%
    ggplot(aes(x=date, y=deaths)) + 
    geom_line() + 
    facet_wrap(~paste0(countyFIPS, " (", state, ")"), scales="free_y")

```
  
The issue in IL is driven almost exclusively by 17031, which restated away around 50% of deaths. The issue in MA appears to be consistent across counties, with the restated data somewhat close to on trend prior to the spike. Two counties in TX and NJ have an erroneous spike, while one county in TX (48141) restated away almost all deaths

A sample of counties with high case restatements are plotted:  
```{r, fig.height=9, fig.width=9}

dfRatio_cty %>% 
    filter(name=="cases", delMax < -0.01, delMax*value < -2000) %>%
    select(countyFIPS) %>%
    left_join(cty_newdata_20221010$dfPerCapita, by="countyFIPS") %>%
    ggplot(aes(x=date, y=cases)) + 
    geom_line() + 
    facet_wrap(~paste0(countyFIPS, " (", state, ")"), scales="free_y")

```
  
Many counties with high case restatements appear to mainly follow trend at a glance. Significant off-trend deviations occur in 17031 (IL), 25007 (MA), 48139 (TX), 48141 (TX), 48189 (TX), and 48279 (TX). The deviations in Wyoming appear to be one-time issues.

Data with and without anomalous counties can then be plotted:  
```{r, fig.height=9, fig.width=9}

anom_cty <- dfRatio_cty %>% 
    filter(name=="cases") %>%
    mutate(bigPct=(delMax < -0.05), bigVol=(delMax*value < -2000))
anom_cty %>%
    count(bigPct, bigVol)

anom_cty %>%
    select(countyFIPS, state, bigPct, bigVol) %>%
    inner_join(cty_newdata_20221010$dfPerCapita, by=c("state", "countyFIPS")) %>%
    mutate(type=case_when(bigVol ~ "2) Big volume change", 
                          bigPct ~ "3) Big percent change", 
                          TRUE ~ "1) Low/no percent change"
                          )
           ) %>%
    group_by(type, date) %>%
    summarize(across(c(cases, deaths), sum), .groups="drop") %>%
    ggplot(aes(x=date, y=cases)) + 
    geom_line() + 
    facet_wrap(~type, scales="free_y") + 
    labs(title="Sum of cases by county type", 
         x=NULL, 
         y="Sum of cases", 
         subtitle="Big volume change is at least 2000 cases, big percentage change is at least 5% (but not 2000 cases)"
         )

```
  
Case data appear reasonable after anomalies are removed. The large percentage changes make some impact but appear to generally average out and remain on trend. The large volume changes appear to be anomalies that impact trends, especially in the most recent time periods.

The process is converted to functional form:  
```{r, fig.height=9, fig.width=9}

plotByRestatement <- function(dfRatio, 
                              dfBurden, 
                              idVars=c("countyFIPS", "state"),
                              keyMetric="cases", 
                              keyMetricBurden=keyMetric, 
                              delMaxHurdle=0,
                              bigVolHurdle=0, 
                              returnData=FALSE
                              ) {
    
    # FUNCTION ARGUMENTS:
    # dfRatio: file containing key metrics for determining restatement status
    # dfBurden: the burden data by geography
    # idVars: variables that identify a geographical unit
    # keyMetric: name of variable in the ratio file
    # keyMetricBurden: name of variable in the burden file
    # delMaxHurdle: cutoff for determining large delMax
    # bigVolHurdle: cutoff for determining large delMax*value
    # returnData: boolean, should dfSeg be returned?
    
    # Create segment data
    dfSeg <- dfRatio %>% 
        filter(name==keyMetric) %>%
        mutate(bigPct=(delMax < delMaxHurdle), bigVol=(delMax*value < bigVolHurdle))
    
    # Report on segment data
    dfSeg %>%
        count(bigPct, bigVol) %>%
        print()

    # Create and print plot
    p1 <- dfSeg %>%
        select(c(all_of(idVars), "bigPct", "bigVol")) %>%
        inner_join(dfBurden, by=all_of(idVars)) %>%
        mutate(type=case_when(bigVol ~ "2) Big volume change", 
                              bigPct ~ "3) Big percent change", 
                              TRUE ~ "1) Low/no percent change"
                              )
               ) %>%
        group_by(type, date) %>%
        summarize(across(all_of(keyMetricBurden), sum), .groups="drop") %>%
        ggplot(aes_string(x="date", y=keyMetricBurden[1])) + 
        geom_line() + 
        facet_wrap(~type, scales="free_y") + 
        labs(title="Sum of cases by segment", 
             x=NULL, 
             y="Sum of cases", 
             subtitle=paste0("Big volume change is more than ", 
                             -bigVolHurdle, 
                             " ", 
                             keyMetricBurden[1],  
                             ", big percentage change is at least ", 
                             round(-100*delMaxHurdle), 
                             "% (but not ", 
                             -bigVolHurdle, 
                             " ", 
                             keyMetricBurden[1], 
                             ")"
                             )
             )
    print(p1)

    # Return data if requested
    if(isTRUE(returnData)) return(dfSeg)
    
}


dfSegTest <- plotByRestatement(dfRatio_cty, 
                               dfBurden=cty_newdata_20221010$dfPerCapita, 
                               keyMetric="cases", 
                               delMaxHurdle=-0.05, 
                               bigVolHurdle=-2000, 
                               returnData=TRUE
                               )
identical(anom_cty, dfSegTest)

```
  
