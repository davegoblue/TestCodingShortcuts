---
title: "Coronavirus US - USA Facts"
author: "davegoblue"
date: "2022-09-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
This module builds on code contained in Coronavirus_Statistics_USAF_v006.Rmd.  This file includes the latest code for analyzing data from [USA Facts](https://usafacts.org/visualizations/coronavirus-covid-19-spread-map/).  USA Facts maintains data on cases and deaths by county for coronavirus in the US.  Downloaded data are unique by county with date as a column and a separate file for each of cases, deaths, and population.

The intent of this code is to source updated functions that allow for readRunUSAFacts() to be run to obtain, read, process, and analyze data from USA Facts.

## Sourcing Functions  
The tidyverse library is loaded, and the functions used for CDC daily processing are sourced.  Additionally, specific functions for USA Facts are also sourced:  
```{r}

library(tidyverse)

# Functions are available in source file
source("./Generic_Added_Utility_Functions_202105_v001.R")
source("./Coronavirus_CDC_Daily_Functions_v002.R")
source("./Coronavirus_USAF_Functions_v001.R")

```
  
Further, the mapping file specific to USA Facts is sourced:  
```{r}

source("./Coronavirus_USAF_Default_Mappings_v002.R")

```
  
Updated functions for diagnoseClusters(), createDetailedSummaries(), createSummary(), and helperSummaryMap() are included in Coronavirus_USAF_Functions_v001.R. These functions should be checked for consistency with state-level data with just a single copy kept later.
  
## Example Process  
The latest county-level burden data are downloaded:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

readList <- list("usafCase"="./RInputFiles/Coronavirus/covid_confirmed_usafacts_downloaded_20220913.csv", 
                 "usafDeath"="./RInputFiles/Coronavirus/covid_deaths_usafacts_downloaded_20220913.csv"
                 )
compareList <- list("usafCase"=readFromRDS("cty_newdata_20220807")$dfRaw$usafCase, 
                    "usafDeath"=readFromRDS("cty_newdata_20220807")$dfRaw$usafDeath
                    )

# Use existing clusters
cty_newdata_20220913 <- readRunUSAFacts(maxDate="2022-09-11", 
                                        downloadTo=lapply(readList, 
                                                          FUN=function(x) if(file.exists(x)) NA else x
                                                          ),
                                        readFrom=readList, 
                                        compareFile=compareList, 
                                        writeLog="./RInputFiles/Coronavirus/USAF_NewData_20220913_chk_v005.log", 
                                        ovrwriteLog=TRUE,
                                        useClusters=readFromRDS("cty_newdata_20210813")$useClusters,
                                        skipAssessmentPlots=FALSE,
                                        brewPalette="Paired"
                                        )

# Plot all counties based on closest cluster
sparseCountyClusterMap(cty_newdata_20220913$useClusters, 
                       caption="Includes only counties with 25k+ population",
                       brewPalette="viridis"
                       )

# Save the refreshed file
saveToRDS(cty_newdata_20220913, ovrWriteError=FALSE)

```
  
Vaccines data are also updated, though the process needs to integrate previous data:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

cty_vaxdata_20220914 <- processCountyVaccines(loc="./RInputFiles/Coronavirus/county_vaccine_20220914.csv", 
                                              ctyList=cty_newdata_20220913, 
                                              minDateCD=c("2022-06-09", "2022-06-09"),
                                              maxDateCD="2022-09-01"
                                              )

# Save the refreshed file
saveToRDS(cty_vaxdata_20220914, ovrWriteError=FALSE)

```
  
County-level data are post-processed:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

cty_postdata_20220913 <- postProcessCountyData(lstCtyBurden=cty_newdata_20220913$dfPerCapita, 
                                               lstCtyVax=cty_vaxdata_20220914$vaxFix, 
                                               lstState=readFromRDS("cdc_daily_220902")$dfPerCapita
                                               )

# Save the refreshed file
saveToRDS(cty_postdata_20220913, ovrWriteError=FALSE)

```
  

Additional post-processing steps are run:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Step 1a: Burden comparisons for aggregated states
additionalCountyPostProcess(cty_postdata_20220913, p1CompareStates=c(state.abb, "DC"), p1AggData=TRUE)

# Step 1: Burden aggregation for key states
# Step 2: vaccine comparisons
# Step 3: Scoring updates (and errors)
# Step 4: New rolling data (28-day default with ceilings 50000 CPM, 500 DPM)
additionalCountyPostProcess(cty_postdata_20220913, 
                            p1CompareStates=c("GA", "FL", "NE"), 
                            p2VaxStates=c("MA", "HI", "TX", "VA", "VT", "GA", "CO", "SD"), 
                            p3VaxTimes=sort(c("2022-01-01", "2022-08-31")),
                            p4DF=cty_newdata_20220913$dfPerCapita
                            )

```
  
Additional plots are also updated:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Creating the vaccine and burden data
tmpVaxBurden <- createVaxBurdenData(lstVax=cty_vaxdata_20220914, lstBurden=cty_newdata_20220913)

# Nationwide aggregation, excluding problem states
problemStates <- c("VA", "TX", "SD", "HI", "GA", "CO", "GA", "FL", "NE", "VA")
useStates <- state.abb
tmpCountyList <- tmpVaxBurden$ctyPop %>%
    filter(state %in% useStates, !(state %in% problemStates)) %>%
    left_join(filter(tmpVaxBurden$dfVaxBurden, name=="vxcpoppct", date==max(date)), by="countyFIPS") %>%
    mutate(vaxPct=percent_rank(value), 
           vaxBucket=case_when(vaxPct <= .25 ~ "3. Low", vaxPct >= .75 ~ "1. High", TRUE ~ "2. Medium")
           ) %>%
    split(f=.$vaxBucket)

# Plot of absolute burden
plotVaxBurdenData(tmpVaxBurden, 
                  ctyPlot=lapply(tmpCountyList, FUN=function(x) x %>% rename(bucket=vaxBucket)), 
                  plotTitle="Counties in states with continuous county data"
                  )

# Plots of burden relative to May 2021
plotVaxBurdenData(tmpVaxBurden, 
                  ctyPlot=lapply(tmpCountyList, FUN=function(x) x %>% rename(bucket=vaxBucket)), 
                  plotTitle="Counties in states with continuous county data", 
                  scaleToDate="2021-05-01"
                  )

```
  
Multiple data anomalies need to be addressed - vaccines data covering only a short time period, counties significantly revising burden downwards, etc.
  
Counties with significant negative burden are investigated:  
```{r, fig.height=9, fig.width=9}

keyRatio <- cty_newdata_20220913$dfPerCapita %>%
    select(countyFIPS, state, date, cases, deaths) %>%
    group_by(countyFIPS, state) %>%
    summarize(keyRatDeath=sum(ifelse(date==max(date), deaths, 0)/max(deaths)), 
              keyRatCases=sum(ifelse(date==max(date), cases, 0)/max(cases)),
              .groups="drop"
              )

keyRatio %>%
    mutate(across(where(is.numeric), .fns=function(x) round(x, 3))) %>%
    count(keyRatCases, keyRatDeath) %>%
    ggplot(aes(x=keyRatCases, y=keyRatDeath)) + 
    geom_point(aes(size=n)) + 
    lims(x=c(0, 1), y=c(0, 1)) + 
    labs(x="Latest cases vs. maximum cases", 
         y="Latest deaths vs. maximum deaths", 
         title="County-level restatement"
         )

keyRatio %>%
    mutate(across(where(is.numeric), .fns=function(x) round(x, 3))) %>%
    count(keyRatCases, keyRatDeath) %>%
    filter(keyRatCases < 1 | keyRatDeath < 1) %>%
    ggplot(aes(x=keyRatCases, y=keyRatDeath)) + 
    geom_point(aes(size=n)) + 
    lims(x=c(0, 1), y=c(0, 1)) + 
    labs(x="Latest cases vs. maximum cases", 
         y="Latest deaths vs. maximum deaths", 
         title="County-level restatement", 
         subtitle="Only counties with at least one ratio .999 or lower included"
         )

```

Restatement of deaths is much more common than restatement of cases. Counties with declines are further explored:  
```{r, fig.height=9, fig.width=9}

decStatus <- keyRatio %>%
    mutate(rd=case_when(is.na(keyRatDeath) ~ -1, 
                        keyRatDeath==1 ~ 1, 
                        keyRatDeath>=.95 ~ .95, 
                        keyRatDeath>=.9 ~ .9, 
                        keyRatDeath>=.75 ~ .75, 
                        keyRatDeath>=.5 ~ .5, 
                        TRUE ~ 0
                        )
           )
decStatus %>%
    count(rd)
decStatus %>%
    count(rd, state) %>%
    filter(rd<.95, rd>=0, n>1) %>%
    arrange(rd, -n)

cty_newdata_20220913$dfPerCapita %>%
    left_join(select(decStatus, countyFIPS, state, rd), by=c("countyFIPS", "state")) %>%
    group_by(rd, date) %>%
    summarize(cases=sum(cases), deaths=sum(deaths), n=n(), .groups="drop") %>%
    mutate(labFacet=paste0(rd, " (n=", n, ")")) %>%
    ggplot(aes(x=date, y=deaths)) + 
    geom_line() + 
    facet_wrap(~labFacet, scales="free_y") + 
    labs(x=NULL, 
         y="Reported deaths", 
         title="Reported deaths, facetted by change from maximum"
         )

```
  
Illinois and Nebraska appear to be main drivers of reported declines (discontinuities) in deaths. Reporting is potentially lagged, as much of the issue appears to be recent.

Restatement of cases is also explored:  
```{r, fig.height=9, fig.width=9}

decStatus <- keyRatio %>%
    mutate(rd=case_when(is.na(keyRatCases) ~ -1, 
                        keyRatCases==1 ~ 1, 
                        keyRatCases>=.99 ~ .99, 
                        keyRatCases>=.95 ~ .95, 
                        keyRatCases>=.5 ~ .5, 
                        TRUE ~ 0
                        )
           )
decStatus %>%
    count(rd)
decStatus %>%
    count(rd, state) %>%
    filter(rd<.99, rd>=0, n>1) %>%
    arrange(rd, -n)

cty_newdata_20220913$dfPerCapita %>%
    left_join(select(decStatus, countyFIPS, state, rd), by=c("countyFIPS", "state")) %>%
    group_by(rd, date) %>%
    summarize(cases=sum(cases), deaths=sum(deaths), n=n(), .groups="drop") %>%
    mutate(labFacet=paste0(rd, " (n=", n, ")")) %>%
    ggplot(aes(x=date, y=cases)) + 
    geom_line() + 
    facet_wrap(~labFacet, scales="free_y") + 
    labs(x=NULL, 
         y="Reported cases", 
         title="Reported cases, facetted by change from maximum"
         )

```
  
In aggregate, the cases look OK, with the exception of a few counties that may have incomplete reporting in the most recent time period. Specific county declines are further explored:  
```{r, fig.height=9, fig.width=9}

decStatus <- keyRatio %>%
    mutate(rd=case_when(is.na(keyRatDeath) ~ -1, 
                        keyRatDeath==1 ~ 1, 
                        keyRatDeath>=.95 ~ .95, 
                        keyRatDeath>=.9 ~ .9, 
                        keyRatDeath>=.75 ~ .75, 
                        keyRatDeath>=.5 ~ .5, 
                        TRUE ~ 0
                        )
           )
decStatus %>%
    count(rd)
decStatus %>%
    count(rd, state) %>%
    filter(rd<.95, rd>=0, n>1) %>%
    arrange(rd, -n)

cty_newdata_20220913$dfPerCapita %>%
    left_join(select(decStatus, countyFIPS, state, rd), by=c("countyFIPS", "state")) %>%
    filter(rd > 0, rd < 0.9) %>%
    ggplot(aes(x=date, y=deaths)) + 
    geom_line(aes(group=countyFIPS, color=state)) + 
    facet_wrap(~rd, scales="free_y") + 
    labs(x=NULL, 
         y="Reported deaths by county", 
         title="Reported deaths, facetted by change from maximum"
         )

```
  
There are two separate issues - some counties appear to have incomplete data in the latest time period, while other counties appear to have significant negative restatement of data earlier in 2022

The ratio process is updated:  
```{r, fig.height=9, fig.width=9}

keyRatioDate <- cty_newdata_20220913$dfPerCapita %>%
    select(countyFIPS, state, date, cases, deaths) %>%
    pivot_longer(-c(countyFIPS, state, date)) %>%
    arrange(countyFIPS, state, name, date) %>%
    group_by(countyFIPS, state, name) %>%
    mutate(ratMax=value/max(value, na.rm=TRUE), cumMax=value/cummax(value)) %>%
    ungroup()
keyRatioDate
dfMinMax <- keyRatioDate %>%
    filter(!is.na(cumMax)) %>%
    group_by(countyFIPS, name) %>%
    summarize(minMax=min(cumMax), .groups="drop") 
dfMinMax %>%
    ggplot(aes(x=minMax)) + 
    geom_density(aes(group=name, color=name)) + 
    labs(title="Ratio of burden vs. cumulative maximum of burden (expected to be 1 for ascending sequence)", 
         subtitle="Lowest value per county and metric plotted", 
         x="Lowest value of daily burden vs. cumulative maximum of burden", 
         y="Density"
         ) + 
    scale_color_discrete("Metric")
dfMinMax %>%
    filter(minMax == 0, name=="deaths") %>%
    select(countyFIPS) %>%
    left_join(cty_newdata_20220913$dfPerCapita, by="countyFIPS") %>%
    ggplot(aes(x=date, y=deaths)) + 
    geom_line(aes(group=countyFIPS)) + 
    facet_wrap(~countyFIPS, scales="free_y") + 
    labs(title="Reported deaths by counties with zero following non-zero", x=NULL, y="Reported deaths")

```
  
While some of the declines are anomalous, others appear to be curves that are either very low volume or smooth on a rolling-7 basis

The process is repeated to examine issues by state:  
```{r, fig.height=9, fig.width=9}

keyRatioDateState <- cty_newdata_20220913$dfPerCapita %>%
    group_by(state, date) %>%
    summarize(across(c(cases, deaths), .fns=function(x) sum(x, na.rm=TRUE)), .groups="drop") %>%
    pivot_longer(-c(state, date)) %>%
    arrange(state, name, date) %>%
    group_by(state, name) %>%
    mutate(ratMax=value/max(value, na.rm=TRUE), cumMax=ifelse(cummax(value)==0, 1, value/cummax(value))) %>%
    ungroup()
keyRatioDateState
dfMinMaxState <- keyRatioDateState %>%
    filter(!is.na(cumMax)) %>%
    group_by(state, name) %>%
    summarize(minMax=min(cumMax), .groups="drop") 
dfMinMaxState %>%
    ggplot(aes(x=minMax)) + 
    geom_density(aes(group=name, color=name)) + 
    labs(title="Ratio of burden vs. cumulative maximum of burden (expected to be 1 for ascending sequence)", 
         subtitle="Lowest value per state and metric plotted", 
         x="Lowest value of daily burden vs. cumulative maximum of burden", 
         y="Density"
         ) + 
    scale_color_discrete("Metric")
dfMinMaxState %>%
    filter(minMax < 0.95, name=="deaths") %>%
    select(state) %>%
    left_join(cty_newdata_20220913$dfPerCapita, by="state") %>%
    group_by(state, date) %>%
    summarize(across(c(cases, deaths), .fns=function(x) sum(x, na.rm=TRUE)), .groups="drop") %>%
    ggplot(aes(x=date, y=deaths)) + 
    geom_line(aes(group=state)) + 
    facet_wrap(~state, scales="free_y") + 
    labs(title="Reported deaths by states with meaningfully non-ascending trend", x=NULL, y="Reported deaths")

```
  
Significant restatements appear to be in MA, while missing recent data appears to be in IL. It is unclear if MO and NE are still reporting county-level deaths. The data is potentially less complete and accurate than in previous iterations

The definition of a decline is modified to be min(cur-cummax)/max, so that declines of 1 or 2 early in the data are not flagged as major percentage changes:  
```{r, fig.height=9, fig.width=9}

keyRatioDateState_v2 <- cty_newdata_20220913$dfPerCapita %>%
    group_by(state, date) %>%
    summarize(across(c(cases, deaths), .fns=function(x) sum(x, na.rm=TRUE)), .groups="drop") %>%
    pivot_longer(-c(state, date)) %>%
    arrange(state, name, date) %>%
    group_by(state, name) %>%
    mutate(ratMax=value/max(value, na.rm=TRUE), 
           cumMax=ifelse(cummax(value)==0, 1, (value-cummax(value))/max(value, na.rm=TRUE))
           ) %>%
    ungroup()
keyRatioDateState_v2
dfMinMaxState_v2 <- keyRatioDateState_v2 %>%
    filter(!is.na(cumMax)) %>%
    group_by(state, name) %>%
    summarize(minMax=min(cumMax), .groups="drop") 
dfMinMaxState_v2 %>%
    ggplot(aes(x=fct_reorder(state, -minMax, min), y=1+minMax)) + 
    geom_col(fill="lightblue") +
    geom_text(aes(label=round(1+minMax, 2)), hjust=0) +
    labs(title="Ratio of burden vs. cumulative maximum of burden (expected to be 1 for ascending sequence)", 
         subtitle="Lowest value of 1 + (value - cummax(value)) / max(value)", 
         y="Lowest value", 
         x=NULL
         ) + 
    coord_flip() +
    facet_wrap(~name)
dfMinMaxState_v2 %>%
    filter(state %in% c("IL", "TX", "MA", "NE")) %>%
    select(state) %>%
    left_join(cty_newdata_20220913$dfPerCapita, by="state") %>%
    group_by(state, date) %>%
    summarize(across(c(cases, deaths), .fns=function(x) sum(x, na.rm=TRUE)), .groups="drop") %>%
    ggplot(aes(x=date, y=deaths)) + 
    geom_line(aes(group=state)) + 
    facet_wrap(~state, scales="free_y") + 
    labs(title="Reported deaths by states with meaningfully non-ascending trend", x=NULL, y="Reported deaths")
dfMinMaxState_v2 %>%
    filter(state %in% c("IL", "WY")) %>%
    select(state) %>%
    left_join(cty_newdata_20220913$dfPerCapita, by="state") %>%
    group_by(state, date) %>%
    summarize(across(c(cases, deaths), .fns=function(x) sum(x, na.rm=TRUE)), .groups="drop") %>%
    ggplot(aes(x=date, y=cases)) + 
    geom_line(aes(group=state)) + 
    facet_wrap(~state, scales="free_y") + 
    labs(title="Reported cases by states with meaningfully non-ascending trend", x=NULL, y="Reported cases")

```
  
The updated methodology better flags states with meaningful restatement problems

The process is converted to functional form:  
```{r, fig.height=9, fig.width=9}

# Function to calculate distance from global maxima and previous maxima (including self)
findDeltaFromMax <- function(df, groupBy=c(), timeVar="date", numVars=NULL) {
    
    # FUNCTION ARGUMENTS:
    # df: a data frame
    # groupBy: levels to which the final data should be aggregated
    # timeVar: time variable to which data should be aggregated
    # numVars: numeric variables to be summarized (NULL means all numeric variables)
    
    # Find numVars if not provided
    if(is.null(numVars)) numVars <- df %>% select(where(is.numeric)) %>% names %>% setdiff(groupBy)
    
    df %>%
        group_by_at(all_of(c(groupBy, timeVar))) %>%
        summarize(across(all_of(numVars), .fns=function(x) sum(x, na.rm=TRUE)), .groups="drop") %>%
        pivot_longer(all_of(numVars)) %>%
        arrange(across(all_of(c(groupBy, "name", timeVar)))) %>%
        group_by_at(all_of(c(groupBy, "name"))) %>%
        mutate(ratMax=value/max(value, na.rm=TRUE), 
               cumMax=ifelse(cummax(value)==0, 1, value/cummax(value)), 
               delMax=ifelse(cummax(value)==0, 1, (value-cummax(value))/max(value, na.rm=TRUE))
               ) %>%
        ungroup()
    
}

# Check for states
dfTest <- findDeltaFromMax(cty_newdata_20220913$dfPerCapita, groupBy="state", numVar=c("cases", "deaths"))
identical(dfTest %>% select(-delMax), keyRatioDateState)
identical(dfTest %>% select(-cumMax) %>% rename(cumMax=delMax), keyRatioDateState_v2)

# Check for counties - old approach output NaN rather than 1 when cummax(value)=0
dfTest_v2 <- findDeltaFromMax(cty_newdata_20220913$dfPerCapita, 
                              groupBy=c("countyFIPS", "state"), 
                              numVar=c("cases", "deaths")
                              )
identical(dfTest_v2 %>% select(-delMax, -cumMax), keyRatioDate %>% select(-cumMax))
all.equal(dfTest_v2 %>% pull(cumMax), 
          keyRatioDate %>% select(cumMax) %>% mutate(cumMax=ifelse(is.na(cumMax), 1, cumMax)) %>% pull(cumMax)
          )

```
  
