---
title: "Data Camp Python Notes"
author: "davegoblue"
date: "May 11, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(engine.path=list(python="C:\\Users\\Dave\\AppData\\Local\\Programs\\Python\\Python36-32\\python.exe"))
```

## Background and Overview  
DataCamp offer interactive courses related to Python Programming.  Since R Markdown documents can run simple Python code chunks (though the data is not accessible to future chunks, a large difference from R Markdown for R), this document attempts to summarize notes from the first module.
  
## Python Programming  
###_Intro to Python for Data Science_#
  
Chapter 1 - Python Basics  
  
Hello Python! - focusing on Python specific to data science:  
  
* Designed by Guido Van Rossum (started as a hobby), but has become a general purpose language that can build anything  
* Python is open-source, free, and has packages for data science  
* This course will focus on Python 3.x given that support for Python 2.7 has been (and will continue to) decreasing  
	* Available at https://www.python.org/downloads (have downloaded Python 3.6.1 for Windows)  
    * The DataCamp module uses interactive Python (iPython)  
* Python scripts are simply text files with a .py extension - must use print() inside scripts in order to force printing  
  
Variables and Types - variables names are case-sensitive in Python:  
  
* The single equals sign is the assignment operator  
* The type(myVar) call will return the type of the variable - float, integer ("int"), string ("str"), boolean ("bool"), etc.  
	* The booleans are represented as proper-noun capitalization - True and False  
* String summation is concatenation without spacing (roughly the same as paste0() in R) -- "ab" + "cd" = "abcd" ; note also that "ab" * 2 = "abab"  
	* In general, different types of data will respond differently to the same function  
  
Example code includes:  
```{r engine='python'}

# Example, do not modify!
print(5 / 8)

# Put code below here
print(7 + 10)

# Recall that commented lines are marked by the hash-sign, same as R
# Exponentiation is ** and modulo division is %

# Addition and subtraction
print(5 + 5)
print(5 - 5)

# Multiplication and division
print(3 * 5)
print(10 / 2)

# Exponentiation
print(4 ** 2)

# Modulo
print(18 % 7)

# How much is your $100 worth after 7 years?
print(100 * 1.1**7)


# Create a variable savings
savings = 100

# Print out savings
print(savings)


# Create a variable savings
savings = 100

# Create a variable factor
factor = 1.10

# Calculate result
result = savings * factor ** 7

# Print out result
print(result)


# Create a variable desc
desc = "compound interest"

# Create a variable profitable
profitable = True


# Several variables to experiment with
savings = 100
factor = 1.1
desc = "compound interest"

# Assign product of factor and savings to year1
year1 = savings * factor

# Print the type of year1
print(type(year1))

# Assign sum of desc and desc to doubledesc
doubledesc = desc + desc

# Print out doubledesc
print(doubledesc)


# Definition of savings and result
savings = 100
result = 100 * 1.10 ** 7

# Fix the printout
print("I started with $" + str(savings) + " and now have $" + str(result) + ". Awesome!")

# Definition of pi_string
pi_string = "3.1415926"

# Convert pi_string into float: pi_float
pi_float = float(pi_string)


```
  
The output all comes at once, another difference from R Markdown for R.  In combination with being unable to access any of the variables later in the same document, there are tangible limitations to this approach.

Using Python within R Markdown may be more useful if I install "feather" for both Python and R.  Feather allows for running code in Python, then quick-saving pandas in a way that is quick-readable as frames for the next R chunk.  See https://blog.rstudio.org/2016/03/29/feather/.  

Getting feather for R took just a few seconds using install.packages().  Getting feather for Python 3.6 using Windows seems to require a C++ 14.0 compiler from MS Visual Studio.  So far, that is easier said than done.
  
***

Chapter 2 - Lists  
  
What are lists?  Multiple vales in one variable, formed using square brackets such as myList = [a, b, c]:  
  
* The elements of a list may be of any type, including lists  
  
Subsetting lists - the first element in the list is defined as element 0:  
  
* Subsetting can be done as myList[myIndex]  
* Alternately, subsetting can be done using negative numbers, with -1 being the last element of the list  
* List slicing can be run using the colon operator  
	* myList[a:b] will start with index a and end with index b-1  
    * myList[:b] means go from start to index b-1, while myList[a:] means go from a to the end of the list  
  
List manipulation - changing, adding, or removing elements:  
  
* Changing elements is based on using the indices and the equal sign - myList[myIndex] = myNewValue  
* The addition operator will concatenate the various lists  
    * myList + [a, b] will produce a new list [myList, a, b]  
* Deleting elements from a list uses the del() operator - for example, del(myList[2]) will delete the third item of myList which occupies index 2  
* Behind the scense, Python is storing the data and the references to the data  
	* Importantly, this means that copying a list and then editing the copy will edit the original list also; the pointers are to the same underlying data  
    * Basically, myNewList = myList is copying the references to the data that are contained in myList, rather than copying all the data and the references  
    * On the other hand, myNewList = myList[:] or myNewList = list(myList) will make the full, independent copy of the data with new references  
  
Example code includes:  
```{r engine='python'}

# area variables (in square meters)
hall = 11.25
kit = 18.0
liv = 20.0
bed = 10.75
bath = 9.50

# Create list areas
areas = [hall, kit, liv, bed, bath]

# Print areas
print(areas)


# area variables (in square meters)
hall = 11.25
kit = 18.0
liv = 20.0
bed = 10.75
bath = 9.50

# Adapt list areas
areas = ["hallway", hall, "kitchen", kit, "living room", liv, "bedroom", bed, "bathroom", bath]

# Print areas
print(areas)


# area variables (in square meters)
hall = 11.25
kit = 18.0
liv = 20.0
bed = 10.75
bath = 9.50

# house information as list of lists
house = [["hallway", hall],
         ["kitchen", kit],
         ["living room", liv],
         ["bedroom", bed], 
         ["bathroom", bath]
         ]

# Print out house
print(house)

# Print out the type of house
print(type(house))


# Create the areas list
areas = ["hallway", 11.25, "kitchen", 18.0, "living room", 20.0, "bedroom", 10.75, "bathroom", 9.50]

# Print out second element from areas
print(areas[1])

# Print out last element from areas
print(areas[-1])

# Print out the area of the living room
print(areas[5])


# Create the areas list
areas = ["hallway", 11.25, "kitchen", 18.0, "living room", 20.0, "bedroom", 10.75, "bathroom", 9.50]

# Sum of kitchen and bedroom area: eat_sleep_area
eat_sleep_area = areas[3] + areas[7]

# Print the variable eat_sleep_area
print(eat_sleep_area)


# Create the areas list
areas = ["hallway", 11.25, "kitchen", 18.0, "living room", 20.0, "bedroom", 10.75, "bathroom", 9.50]

# Use slicing to create downstairs
downstairs = areas[:6]

# Use slicing to create upstairs
upstairs = areas[6:]

# Print out downstairs and upstairs
print(downstairs)
print(upstairs)


# Create the areas list
areas = ["hallway", 11.25, "kitchen", 18.0, "living room", 20.0, "bedroom", 10.75, "bathroom", 9.50]

# Correct the bathroom area
areas[-1] = 10.5

# Change "living room" to "chill zone"
areas[4] = "chill zone"


# Create the areas list and make some changes
areas = ["hallway", 11.25, "kitchen", 18.0, "chill zone", 20.0,
         "bedroom", 10.75, "bathroom", 10.50]

# Add poolhouse data to areas, new list is areas_1
areas_1 = areas + ["poolhouse", 24.5]

# Add garage data to areas_1, new list is areas_2
areas_2 = areas_1 + ["garage", 15.45]


# Create list areas
areas = [11.25, 18.0, 20.0, 10.75, 9.50]

# Create areas_copy
areas_copy = list(areas)

# Change areas_copy
areas_copy[0] = 5.0

# Print areas
print(areas)


```
  
  
***

Chapter 3 - Functions and Packages  
  
Introduction to functions - pieces of reusable code for solving a particular task:  
  
* Built-in functions are things like max() or type() or round(myNum, myDecimals)  
* Can use help(builtInFunction) to get the help page for builtInFunction  
  
Methods - all objects of a specific type have default access to the methods for that object:  
  
* Methods are functions that belong to an object  
* For example, myList.index("mySearch") will return the index that matches to "mySearch" (if a number, should not be quoted)  
	* Alternately, myList.count("mySearch") will return the number of matches to "mySearch"  
* The methods will behave differently (perhaps even not existing) for different object types  
* Further, some methods modify the object that they are associated with; for example .append()  
  
Packages are directoried of pyhton scripts, each a module specifying functions, methods, and types:  
  
* Thousands of Python packages are available, including Numpy, Matplotlib, and Scikit-learn  
* Installing packages is based on the "pip" system - download get-pip.py from http://pip.readthedocs.org/en/stable/installing  
	* Then, uses "pip3 install myPackage" (unquoted) at the command line  
    * On my machine, needs to be at command line, then [PythonPath]\python.exe -m pip install myPackage  
* Packages can then be imported using "import myPackage" (unquoted) at the command line  
* The package always needs to be attached to its command, for example numpy.array() rather than just array()  
	* As a result, it is often helpful to use import numpy as np, so that np.array() can serve as a shortcut for numpy.array()  
* Alternately, can ask for "from numpy import array" if only wanting to import the function array()  
	* Now, array() can also be called without any prefix; for example, as array(myNumbers) rather than numpy.array(myNumbers)  
  
Example code includes:  
```{r engine='python'}

# Create variables var1 and var2
var1 = [1, 2, 3, 4]
var2 = True

# Print out type of var1
print(type(var1))

# Print out length of var1
print(len(var1))

# Convert var2 to an integer: out2
out2 = int(var2)


# Create lists first and second
first = [11.25, 18.0, 20.0]
second = [10.75, 9.50]

# Paste together first and second: full
full = first + second

# Sort full in descending order: full_sorted
full_sorted = sorted(full, reverse=True)

# Print out full_sorted
print(full_sorted)


# string to experiment with: room
room = "poolhouse"

# Use upper() on room: room_up
room_up = room.upper()

# Print out room and room_up
print(room)
print(room_up)

# Print out the number of o's in room
print(room.count("o"))


# Create list areas
areas = [11.25, 18.0, 20.0, 10.75, 9.50]

# Print out the index of the element 20.0
print(areas.index(20.0))

# Print out how often 14.5 appears in areas
print(areas.count(14.5))


# Create list areas
areas = [11.25, 18.0, 20.0, 10.75, 9.50]

# Use append twice to add poolhouse and garage size
areas.append(24.5)
areas.append(15.45)

# Print out areas
print(areas)

# Reverse the orders of the elements in areas
areas.reverse()

# Print out areas
print(areas)


# Definition of radius
r = 0.43

# Import the math package
import math

# Calculate C
C = 2 * math.pi * r

# Calculate A
A = math.pi * (r ** 2)

# Build printout
print("Circumference: " + str(C))
print("Area: " + str(A))


# Definition of radius
r = 192500

# Import radians function of math package
from math import radians

# Travel distance of Moon over 12 degrees. Store in dist.
dist = r * radians(12)

# Print out dist
print(dist)

```
  
  
***

Chapter 4 - Numpy  
  
Numpy extends list operations using "Numerical Python" (collections of values, optimized for speed):  
  
* The Numpy array is like a list, but you can run mathematical calculations with it  
	* For example, [1, 2, 3] * 2 is [1, 2, 3, 1, 2, 3] while [1, 2, 3] **2 throws an error  
    * However, numpy.array([1, 2, 3]) * 2 is array([2, 4, 6]) while numpy.array([1, 2, 3]) ** 2 is array([1, 4, 9]), both as expected  
* The basic structure of numpy.array() is a vector, which will operate element-wise  
	* Numpy arrays must be of a single-type, converted to the "most flexible" (e.g., string is more flexible than float is more flexible than boolean)  
* The plus sign with a numpy.array() will add element-wise rather than pasting (as it would with lists)  
* Can also use logical subsetting; for example, bmi[bmi > 23] will return all bmi that are greater than 23  
  
2D Numpy Arrays - extending the vector to be multi-dimensional:  
  
* For a numpy vector/array, the type will be numpy.ndarray (stands for n-dimensional array)  
* Can create a two-dimensional array much like an array of lists; numpy.array( [ [1, 2, 3], [4, 5, 6] ] )  
    * The .shape() method will give the dimensions of the array as rows, columns  
* Selecting a row is just based on myArray[rowIndex], so a specific cell can be extracted with myArray[rowIndex][colIndex]  
	* Alternately, myArray[rowIndex, colIndex] will also return the specified row and column  
    * Can also use myArray[:, colIndex] to get just the specified column(s)  
* The 2D Numpy arrays can also be used for element-wise operations
* The 2D Numpy arrays can also be used for element-wise operations  
  
Numpy Basic Statistics - basic data exploration:  
  
* numpy.mean() will take the mean of the relevant data  
* numpy.median() will take the median of the relevant data  
* numpy.corrcoef() will create the correlation coefficients  
* numpy.std() will take the standard deviation  
* numpy.sum() and numpy.sort() are faster than the base versions since numpy has enforced common data types within the array  
* Note that Filip manufactured the MLB data as follows  
    * height = numpy.round(numpy.random.normal(1.75, 0.20, 5000), 2)  
    * weight = numpy.round(numpy.random.normal(60.32, 15, 5000), 2)  
    * np_baseball = np.column_stack((height, weight))  
  
Example code includes:  
```{r engine='python'}

# Create list baseball
baseball = [180, 215, 210, 210, 188, 176, 209, 200]

# Import the numpy package as np
import numpy as np

# Create a Numpy array from baseball: np_baseball
np_baseball = np.array(baseball)

# Print out type of np_baseball
print(type(np_baseball))


# DO NOT HAVE THE HEIGHT OR WEIGHT DATA - it is MLB data on 1000 players
# Create dummy data
height = np.round(np.random.normal(1.75, 0.20, 5000), 2)  
weight = np.round(np.random.normal(60.32, 15, 5000), 2)  


# Create a Numpy array from height: np_height
np_height = np.array(height)

# Print out np_height
print(np_height)

# Convert np_height to m: np_height_m
np_height_m = np_height * 0.0254

# Print np_height_m
print(np_height_m)


# Create array from height with correct units: np_height_m
np_height_m = np.array(height) * 0.0254

# Create array from weight with correct units: np_weight_kg
np_weight_kg = np.array(weight) * 0.453592

# Calculate the BMI: bmi
bmi = np_weight_kg / (np_height_m ** 2)

# Print out bmi
print(bmi)


# Calculate the BMI: bmi
np_height_m = np.array(height) * 0.0254
np_weight_kg = np.array(weight) * 0.453592
bmi = np_weight_kg / np_height_m ** 2

# Create the light array
light = bmi < 21

# Print out light
print(light)

# Print out BMIs of all baseball players whose BMI is below 21
print(bmi[light])


# Store weight and height lists as numpy arrays
np_weight = np.array(weight)
np_height = np.array(height)

# Print out the weight at index 50
print(np_weight[50])

# Print out sub-array of np_height: index 100 up to and including index 110
print(np_height[100:111])


# Create baseball, a list of lists
baseball = [[180, 78.4],
            [215, 102.7],
            [210, 98.5],
            [188, 75.2]]

# Import numpy
import numpy as np

# Create a 2D Numpy array from baseball: np_baseball
np_baseball = np.array(baseball)

# Print out the type of np_baseball
print(type(np_baseball))

# Print out the shape of np_baseball
print(np_baseball.shape)


# DO NOT HAVE baseball, which is a list of lists of the 1015 MLB players with their height/weight
# Create a 2D Numpy array from baseball: np_baseball
# np_baseball = np.array(baseball)
# Dummy up the data instead
np_baseball = np.column_stack((height, weight))  

# Print out the shape of np_baseball
print(np_baseball.shape)  # 1015 x 2


# Create np_baseball (2 cols)
# np_baseball = np.array(baseball)

# Print out the 50th row of np_baseball
print(np_baseball[49])

# Select the entire second column of np_baseball: np_weight
np_weight = np_baseball[:, 1]

# Print out height of 124th player
print(np_baseball[123, 0])


# DO NOT HAVE baseball OR updated ; each should be 1,015 x 3 (height, weight, bmi)
# Create np_baseball (3 cols)
# np_baseball = np.array(baseball)

# Print out addition of np_baseball and updated
# print(np_baseball + updated)

# Create Numpy array: conversion
# conversion = np.array([0.0254, 0.453592, 1])

# Print out product of np_baseball and conversion
# print(np_baseball * conversion)


# Create np_height from np_baseball
np_height = np_baseball[:, 0]

# Print out the mean of np_height
print(np.mean(np_height))

# Print out the median of np_height
print(np.median(np_height))


# Print mean height (first column)
avg = np.mean(np_baseball[:,0])
print("Average: " + str(avg))

# Print median height. Replace 'None'
med = np.median(np_baseball[:,0])
print("Median: " + str(med))

# Print out the standard deviation on height. Replace 'None'
stddev = np.std(np_baseball[:,0])
print("Standard Deviation: " + str(stddev))

# Print out correlation between first and second column. Replace 'None'
corr = np.corrcoef(np_baseball[:, 0], np_baseball[:, 1])
print("Correlation: " + str(corr))


# DO NOT HAVE DATA for positions or heights (soccer data . . . )
# Convert positions and heights to numpy arrays: np_positions, np_heights
# np_positions = np.array(positions)
# np_heights = np.array(heights)

# Heights of the goalkeepers: gk_heights
# gk_heights = np_heights[np_positions == "GK"]

# Heights of the other players: other_heights
# other_heights = np_heights[np_positions != "GK"]

# Print out the median height of goalkeepers. Replace 'None'
# print("Median height of goalkeepers: " + str(np.median(gk_heights)))

# Print out the median height of other players. Replace 'None'
# print("Median height of other players: " + str(np.median(other_heights)))


```
  

###_Intermediate Python for Data Science_#  
  
Chapter 1 - Matplotlib for Data Visualization  
  
Basic plots with matplotlib - generally, the heart of visualization within Python:  
  
* Need to import the key functions; for example import matplotlib.pyplot as plt  
* Then, plt.plot(list1, list2) will create a line plot with list1 being x and list2 being y  
	* If you want to actually see the plot, use plt.show(), somewhat like plt.plot() just being a saved ggplot2 object  
* Alternately, plt.scatter() to create a scatter plot  
  
Histograms are useful for exploring a dataset (getting an idea about the distribution):  
  
* import matplotlib.pyplot as plt  # help(plt.hist) will show all the options for a histogram  
* plt.hist(x, bins=myBins)  # default for myBins is 10  
	* Needs plt.show() as per the above  
  
Customization for changing the base plot types in Python:  
  
* Can label x-axis with plt.xlabel('X Label')  
* Can label y-axis with plt.xlabel('Y Label')  
* Can add title with plt.title('My Title')  
* Can add plt.yticks([myList], [myNames]) # myList can be 2+ elements which will define the y-range; optional list myNames must be the same length as myList and will label the y-axis  
	* All of these must be run PRIOR to the plt.show() command  
  
Example code includes:  
```{r engine="python"}

# Define the reading data path
readPath = "C:/Users/Dave/Documents/Personal/Learning/Coursera/RDirectory/RHomework/DataCamp/"

# This is world population 1950-2100 (DO NOT HAVE FILE)
# Import some wikipedia data from CSV as panda
import pandas as pd

globalPop = pd.read_csv(readPath + "GlobalPopYear_1950_2100_v001.csv")

year = globalPop["year"]
pop = globalPop["pop"]

# Print the last item from year and pop
print(year.iloc[-1])
print(pop.iloc[-1])

# Import matplotlib.pyplot as plt
import matplotlib.pyplot as plt

# Make a line plot: year on the x-axis, pop on the y-axis
plt.plot(year, pop)

# Display the plot with plt.show()
# Need to use a proper Python IDE for plt.show() - otherwise just pops up the images "live"
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy001.png", bbox_inches="tight")

```
  
**The population plot saved from Python is**:  
![](_dummyPy001.png)
  
Next, the Hans Rosling Data is explored:  
```{r engine = "python"}

# Using the Hans Rosling Data (2007 life expectancy and GDP for 142 countries)
# Create from Wikipedia, World Bank, and the like
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# readPath = "C:\\Users\\Dave\\Documents\\Personal\\Learning\\Coursera\\RDirectory\\RHomework\\DataCamp\\"
readPath = "C:/Users/Dave/Documents/Personal/Learning/Coursera/RDirectory/RHomework/DataCamp/"


globalData = pd.read_csv(readPath + "GlobalGDPLifeExpectancy_v001.csv")

gdp_cap = 1000000 * np.array(globalData["gdp"]) / np.array(globalData["pop"])
life_exp = globalData["le_2015"]
pop = globalData["pop"]
life_exp1950 = globalData["le_1960"]  # Much easier to get 1960 than 1950 online - KLUGE
regn = globalData["region"]

# Print the last item of gdp_cap and life_exp
print(gdp_cap[-1])  # Since it is a numpy
print(life_exp.iloc[-1])  # Since it is a panda

# Make a line plot, gdp_cap on the x-axis, life_exp on the y-axis
plt.plot(gdp_cap, life_exp)

# Display the plot
# Need to use a proper Python IDE for plt.show()
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy002.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting

# Change the line plot below to a scatter plot
plt.scatter(gdp_cap, life_exp)

# Put the x-axis on a logarithmic scale
plt.xscale('log')

# Show plot
# Need to use a proper Python IDE for plt.show()
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy003.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting

# Brings in yet another variable, population

# Build Scatter plot
plt.scatter(pop, life_exp)
plt.xscale("log")

# Show plot
# Need to use a proper Python IDE for plt.show()
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy004.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting

# Create histogram of life_exp data
plt.hist(life_exp)

# Display histogram
# Need to use a proper Python IDE for plt.show()
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy005.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting

# Build histogram with 5 bins
plt.hist(life_exp, bins=5)

# Show and clean up plot
# Need to use a proper Python IDE for plt.show()
# plt.show()
# plt.clf()
# Save as dummy PNG instead
plt.savefig("_dummyPy006.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting

# Build histogram with 20 bins
plt.hist(life_exp, bins=20)

# Show and clean up again
# Need to use a proper Python IDE for plt.show()
# plt.show()
# plt.clf()
# Save as dummy PNG instead
plt.savefig("_dummyPy007.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting

# Histogram of life_exp, 15 bins
plt.hist(life_exp, bins=15)

# Show and clear plot
# Need to use a proper Python IDE for plt.show()
# plt.show()
# plt.clf()
# Save as dummy PNG instead
plt.savefig("_dummyPy008.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting

# Histogram of life_exp1950, 15 bins
plt.hist(life_exp1950, bins=15)

# Show and clear plot again
# Need to use a proper Python IDE for plt.show()
# plt.show()
# plt.clf()
# Save as dummy PNG instead
plt.savefig("_dummyPy009.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting

# Basic scatter plot, log scale
plt.scatter(gdp_cap, life_exp)
plt.xscale('log') 

# Strings
xlab = 'GDP per Capita [in USD]'
ylab = 'Life Expectancy [in years]'
title = 'World Development in 2007'

# Add axis labels
plt.xlabel(xlab)
plt.ylabel(ylab)

# Add title
plt.title(title)

# After customizing, display the plot
# Need to use a proper Python IDE for plt.show()
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy010.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting

# Scatter plot
plt.scatter(gdp_cap, life_exp)

# Previous customizations
plt.xscale('log') 
plt.xlabel('GDP per Capita [in USD]')
plt.ylabel('Life Expectancy [in years]')
plt.title('World Development in 2007')

# Definition of tick_val and tick_lab
tick_val = [1000,10000,100000]
tick_lab = ['1k','10k','100k']

# Adapt the ticks on the x-axis
plt.xticks(tick_val, tick_lab)

# After customizing, display the plot
# Need to use a proper Python IDE for plt.show()
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy011.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting

# Import numpy as np
import numpy as np

# Store pop as a numpy array: np_pop
np_pop = np.array(pop) / 1000000  # Population in millions

# Double np_pop
np_pop = np_pop * 2 # Doubled for larger bubbles

# Update: set s argument to np_pop
plt.scatter(gdp_cap, life_exp, s = np_pop)

# Previous customizations
plt.xscale('log') 
plt.xlabel('GDP per Capita [in USD]')
plt.ylabel('Life Expectancy [in years]')
plt.title('World Development in 2007')
plt.xticks([1000, 10000, 100000],['1k', '10k', '100k'])

# Display the plot
# Need to use a proper Python IDE for plt.show()
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy012.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting

# Color is based on continent, using the below dictionary
colDict = {
    'Asia':'red',
    'Europe':'green',
    'Africa':'blue',
    'Americas':'yellow',
    'Oceania':'black'
}

col=[]

for eachRegion in regn :
    col.append(colDict[eachRegion])

# Specify c and alpha inside plt.scatter()
plt.scatter(x = gdp_cap, y = life_exp, s = np_pop , c=col, alpha=0.8)

# Previous customizations
plt.xscale('log') 
plt.xlabel('GDP per Capita [in USD]')
plt.ylabel('Life Expectancy [in years]')
plt.title('World Development in 2007')
plt.xticks([1000,10000,100000], ['1k','10k','100k'])

# Show the plot
# Need to use a proper Python IDE for plt.show()
# plt.show()
# plt.clf()
# Save as dummy PNG instead
plt.savefig("_dummyPy013.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting

# Scatter plot
plt.scatter(x = gdp_cap, y = life_exp, s = np_pop, c = col, alpha = 0.4)

# Previous customizations
plt.xscale('log') 
plt.xlabel('GDP per Capita [in USD]')
plt.ylabel('Life Expectancy [in years]')
plt.title('World Development in 2007')
plt.xticks([1000,10000,100000], ['1k','10k','100k'])

# Additional customizations
plt.text(1550, 71, 'India')
plt.text(5700, 80, 'China')

# Add grid() call
plt.grid(True)

# Show the plot
# Need to use a proper Python IDE for plt.show()
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy014.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting

```
  
**GDP vs Life Expectancy by Country as Line Graph (not good . . . )**:  
![](_dummyPy002.png)
  
**GDP vs Life Expectancy by Country as Scatter Plot**:  
![](_dummyPy003.png)

**GDP vs Life Expectancy by Country as Scatter Plot with Log Scale**:  
![](_dummyPy004.png)

**Life Expectancy Histogram (default 10 bins)**:  
![](_dummyPy005.png)

**Life Expectancy Histogram (5 bins)**:  
![](_dummyPy006.png)

**Life Expectancy Histogram (20 bins)**:  
![](_dummyPy007.png)

**Life Expectancy Histogram for 2015 (15 bins)**:  
![](_dummyPy008.png)

**Life Expectancy Histogram for 1960 (15 bins)**:  
![](_dummyPy009.png)

**Base Rosling-like graph (GDP vs Life Expectancy by Country Scatter)**:  
![](_dummyPy010.png)

**Rosling-like graph (enhanced tick labels)**:  
![](_dummyPy011.png)

**Rosling-like graph (bubble size ~ population)**:  
![](_dummyPy012.png)

**Rosling-like graph (bubble color based on region)**:  
![](_dummyPy013.png)
  
**Rosling-like graph (semit-transparent bubbles)**:  
![](_dummyPy014.png)
  
  
***
  
Chapter 2 - Dictionaries and Pandas  
  
Dictionaries, Part I - key-value pairs:  
  
* The dictionary is created with curly brackets, with key-value pairs denoted by a colon and separated by a comma  
	* world = { "afghanistan":31, "albania":2.8, "algeria":39 }  # sets up three key-value pairs as the dictionary called world  
    * Now, world["albania"] will return 2.8, the value that is associated with key "albania"  
* Dictionary look-ups are extremely fast even for enormous dictionaries  
  
Dictionaries, Part II:  
  
* Dictionaries need to have unique keys; if duplicate keys are included, the value associated with the LAST key is retained  
* The keys also need to be immutable objects, which is to say strings or booleans or integers or floats (but not lists, since you can change their contents dynamically)  
* Assigning (or changing) key-value pairs in a dictionary is myDict[myKey] = myValue  
* To test whether a key is in the dictionary, use myKey in myDict # returns boolean True or False  
* To delete an item from the dictionary, use del(myDict[myKey]) # the full key-value pair is removed  
* Lists and dictionaries have many similarities, but also some key differences  
	* Lists are indexed by a range of numbers, making them ideal for collections of values where the order matters  
    * Dictionaries are indexed by unique keys, making them ideal for fast look-ups (they are also inherently completely unordered/unsorted based on how they are hashed)  
  
Pandas, Part I - tabular dataset storage and manipulation:  
  
* Same general philosophy where rows are observations and columns are attributes/variables  
* Basically, need a form of numpy.array() that allows for different variable types in different columns  
* The pandas package provides a high-level data-manipulation tool (built on numpy by Wes McKinney)  
	* The pandas package conveniently stores data as a DataFrame  
    * Generally, the rows and columns will all have unique names  
    * Further, the columns can all be of different types  
* Suppose that you create a dictionary where the keys are the desired column labels while the values are a list of the desired values for the column  
	* import pandas as pd  
    * myFrame = pd.DataFrame(myDict)  
    * myFrame.index = labelList # optional, if wanting to provide row-names  
* Alternately, the data can be imported such as from a CSV  
	* pd.read_csv(myCSVPath, index_col=myIndex)  # index_col is optional and needed only if an index column has been provided  
  
Pandas, Part II - indexing and selecting data from a DataFrame using square brackets, loc, and iloc:  
  
* myFrame[colNameQuoted] will return a subset of the panda with type pandas.core.series.Series  
* myFrame[[colNameQuoted]] will return a single-column panda with type pandas.core.frame.DataFrame  
* myFrame[[colName1Quoted, colName2Quoted]] will return a two-column panda  
* myFrame[a:b] will return rows rather than columns, starting with index a and ending at index b-1  
* The loc and iloc tools are designed to extend Pandas data extraction to be more similar to numpy extractions such as [ rows, columns ]  
	* myFrame.loc[rowNameQuoted] will return a panda series matching the ROW  
    * myFrame.loc[[rowNameQuoted]] will return a panda frame containing just that ROW  
    * myFrame.loc[[rowName1Quoted, rowName2Quoted, rowName3Quoted]] will return a panda frame containing the requested ROWS  
    * myFrame.loc[[rowListQuoted], [colListQuoted]] will return just the specified rows and columns  
    * myFrame.loc[:, [colListQuoted]] will return all rows and just the specified columns  
* The iloc function is the index-based version of loc for data access and extraction  
	* myFrame.iloc[[rowIndices]] will return a panda frame containing just these ROWS  
    * myFrame.iloc[[rowIndices], [colIndices]] will return a panda frame containing just these COLUMNS  
  
Example code includes:  
```{r engine="python"}

# Definition of countries and capital
countries = ['spain', 'france', 'germany', 'norway']
capitals = ['madrid', 'paris', 'berlin', 'oslo']

# Get index of 'germany': ind_ger
ind_ger = countries.index("germany")

# Use ind_ger to print out capital of Germany
print(capitals[ind_ger])


# Definition of countries and capital
countries = ['spain', 'france', 'germany', 'norway']
capitals = ['madrid', 'paris', 'berlin', 'oslo']

# From string in countries and capitals, create dictionary europe
europe = {
   'spain':'madrid', 
   'france':'paris', 
   'germany':'berlin', 
   'norway':'oslo'
}

# Print europe
print(europe)


# Definition of dictionary
europe = {'spain':'madrid', 'france':'paris', 'germany':'berlin', 'norway':'oslo' }

# Print out the keys in europe
print(europe.keys())

# Print out value that belongs to key 'norway'
print(europe['norway'])


# Definition of dictionary
europe = {'spain':'madrid', 'france':'paris', 'germany':'berlin', 'norway':'oslo' }

# Add italy to europe
europe['italy'] = 'rome'

# Print out italy in europe
print('italy' in europe)

# Add poland to europe
europe['poland'] = 'warsaw'

# Print europe
print(europe)


# Definition of dictionary
europe = {'spain':'madrid', 'france':'paris', 'germany':'bonn',
          'norway':'oslo', 'italy':'rome', 'poland':'warsaw',
          'australia':'vienna' }

# Update capital of germany
europe['germany'] = 'berlin'

# Remove australia
del(europe['australia'])

# Print europe
print(europe)


# Dictionary of dictionaries
europe = { 'spain': { 'capital':'madrid', 'population':46.77 },
           'france': { 'capital':'paris', 'population':66.03 },
           'germany': { 'capital':'berlin', 'population':80.62 },
           'norway': { 'capital':'oslo', 'population':5.084 } }


# Print out the capital of France
print(europe['france']['capital'])

# Create sub-dictionary data
data = { 'capital':'rome', 'population':59.83 }

# Add data to europe under key 'italy'
europe['italy'] = data

# Print europe
print(europe)


# Pre-defined lists
names = ['United States', 'Australia', 'Japan', 'India', 'Russia', 'Morocco', 'Egypt']
dr =  [True, False, False, False, True, True, True]
cpc = [809, 731, 588, 18, 200, 70, 45]

# Import pandas as pd
import pandas as pd

# Create dictionary my_dict with three key:value pairs: my_dict
my_dict = { 'country': names, 'drives_right': dr, 'cars_per_cap': cpc }

# Build a DataFrame cars from my_dict: cars
cars = pd.DataFrame(my_dict)

# Print cars
print(cars)


# Build cars DataFrame
names = ['United States', 'Australia', 'Japan', 'India', 'Russia', 'Morocco', 'Egypt']
dr =  [True, False, False, False, True, True, True]
cpc = [809, 731, 588, 18, 200, 70, 45]
dict = { 'country':names, 'drives_right':dr, 'cars_per_cap':cpc }
cars = pd.DataFrame(dict)
print(cars)

# Definition of row_labels
row_labels = ['US', 'AUS', 'JAP', 'IN', 'RU', 'MOR', 'EG']

# Specify row labels of cars
cars.index = row_labels

# Print cars again
print(cars)


# DO NOT HAVE FILE "cars.csv" - cars_per_cap , country , drives_right
# Created as cars.to_csv("cars.csv")
# Import the cars.csv data: cars
cars = pd.read_csv("cars.csv")

# Print out cars
print(cars)


# SLIGHTLY DIFFERENT VERSION WITH ROW NAMES AS THE FIRST COLUMN
# Import pandas as pd
import pandas as pd

# Fix import by including index_col
cars = pd.read_csv('cars.csv', index_col=0)

# Print out cars
print(cars)


# Import cars data
import pandas as pd
cars = pd.read_csv('cars.csv', index_col = 0)

# Print out country column as Pandas Series
print(cars["country"])

# Print out country column as Pandas DataFrame
print(cars[["country"]])

# Print out DataFrame with country and drives_right columns
print(cars[["country", "drives_right"]])


# Import cars data
import pandas as pd
cars = pd.read_csv('cars.csv', index_col = 0)

# Print out first 3 observations
print(cars[0:3])

# Print out fourth, fifth and sixth observation
print(cars[3:6])


# Print out observation for Japan
print(cars.loc["JAP"])

# Print out observations for Australia and Egypt
print(cars.loc[["AUS", "EG"]])


# Print out drives_right value of Morocco
print(cars.loc[["MOR"], ["drives_right"]])

# Print sub-DataFrame
print(cars.loc[["RU", "MOR"], ["country", "drives_right"]])


# Print out drives_right column as Series
print(cars.loc[:, "drives_right"])

# Print out drives_right column as DataFrame
print(cars.loc[:, ["drives_right"]])

# Print out cars_per_cap and drives_right as DataFrame
print(cars.loc[:, ["cars_per_cap", "drives_right"]])


```
  
  
***

Chapter 3 - Logic, Control Flow, and Filtering  
  
Comparison Operators - how two values relate (tests for equality, greater, lesser, etc.):  
  
* Less than (<), greater than (>), equals (==), less than or equal (<=), greater than or equal (>=), and not equals (!=) are as per R  
* Need to have comparisons between objects of the same type (specifically, not comparing strings and floats)  
  
Boolean operators - most commonly used are and, or, and not:  
  
* In Python, the word "and" is used rather than & or &&  
* In Python, the word "or" is used rather than | or ||  
* In Python, the word "not" is used rather than - or !  
* If comparisons will be run on an array, then use np.logical_and(), np.logical_or(), and np.logical_not()  
    * np.logical_and(bmi > 27, bmi < 30)  
  
If, elif, else:  
  
* General syntax is "if condition : action" followed optionally by "elif condition : action" or "else condition : action"
	* If written on multiple lines, the action should be indented by 4 spaces and may include block instructions  
    * Any code without the indentation will be known to no longer be part of the if block  
  
Filtering Pandas DataFrame - generally a three-step process of 1) select key column as panda.series, 2) run test, and 3) use to grab relevant rows:  
  
* If you pass myFrame[myBool] where myBool is the same size (number of rows) as myFrame, then it will automatically pull back the rows where myBool == True  
* Because pandas are built on the numpy infrastructure, np.logical_and() and the related terms will work on the pandas also  
  
Example code includes:  
```{r engine='python'}

# Comparison of booleans
print(True == False)

# Comparison of integers
print((-5 * 15) != 75)

# Comparison of strings
print("pyscript" == "PyScript")

# Compare a boolean with an integer
print(True == 1)


# Comparison of integers
x = -3 * 6
print(x >= -10)

# Comparison of strings
y = "test"
print("test" <= y)

# Comparison of booleans
print(True > False)


# Create arrays
import numpy as np
my_house = np.array([18.0, 20.0, 10.75, 9.50])
your_house = np.array([14.0, 24.0, 14.25, 9.0])

# my_house greater than or equal to 18
print(my_house >= 18)

# my_house less than your_house
print(my_house < your_house)


# Define variables
my_kitchen = 18.0
your_kitchen = 14.0

# my_kitchen bigger than 10 and smaller than 18?
print(my_kitchen > 10 and my_kitchen < 18)

# my_kitchen smaller than 14 or bigger than 17?
print(my_kitchen < 14 or my_kitchen > 17)

# Double my_kitchen smaller than triple your_kitchen?
print(2 * my_kitchen < 3 * your_kitchen)


# Create arrays
import numpy as np
my_house = np.array([18.0, 20.0, 10.75, 9.50])
your_house = np.array([14.0, 24.0, 14.25, 9.0])

# my_house greater than 18.5 or smaller than 10
print(np.logical_or(my_house > 18.5, my_house < 10))

# Both my_house and your_house smaller than 11
print(np.logical_and(my_house <11, your_house < 11))


# Define variables
room = "kit"
area = 14.0

# if statement for room
if room == "kit" :
    print("looking around in the kitchen.")

# if statement for area
if area > 15 :
    print("big place!")


# Define variables
room = "kit"
area = 14.0

# if-else construct for room
if room == "kit" :
    print("looking around in the kitchen.")
else :
    print("looking around elsewhere.")

# if-else construct for area
if area > 15 :
    print("big place!")
else :
    print("pretty small.")


# Define variables
room = "bed"
area = 14.0

# if-elif-else construct for room
if room == "kit" :
    print("looking around in the kitchen.")
elif room == "bed":
    print("looking around in the bedroom.")
else :
    print("looking around elsewhere.")

# if-elif-else construct for area
if area > 15 :
    print("big place!")
elif area > 10 :
    print("medium size, nice!")
else :
    print("pretty small.")


# AS PER ABOVE, DO NOT HAVE THIS DATASET
# That has since been worked around . . . 
# Import cars data
import pandas as pd
cars = pd.read_csv('cars.csv', index_col = 0)

# Extract drives_right column as Series: dr
dr = cars["drives_right"]

# Use dr to subset cars: sel
sel = cars[dr]

# Print sel
print(sel)


# Convert code to a one-liner
sel = cars[cars['drives_right']]

# Print sel
print(sel)


# Import cars data
import pandas as pd
cars = pd.read_csv('cars.csv', index_col = 0)

# Create car_maniac: observations that have a cars_per_cap over 500
cpc = cars["cars_per_cap"]
many_cars = cpc > 500
car_maniac = cars[many_cars]

# Print car_maniac
print(car_maniac)


# Create medium: observations with cars_per_cap between 100 and 500
cpc = cars['cars_per_cap']
between = np.logical_and(cpc > 100, cpc < 500)
medium = cars[between]

# Print medium
print(medium)


```
  
  
***

Chapter 4 - Loops  
  
The while loop - alternative to the if/elif/else process:  
  
* The while loop will continue to execute as long as the condition is met  
* These loops are typically rare (and can easily cause an infinite loop), but can be powerful in certain circumstances  
* The syntax is while condition : expression # If expression is placed on the next line(s), then it should be indented by 4 spaces  
* CTRL-C will typically kill a Python infinte loop  
  
The for loop - alternative to the while loop:  
  
* The basic syntax is for var in seq : expression # as per previous, if expression is on the next line(s), it should be indented by 4 spaces  
	* The seq can be a list or a dictionary or the like, which will iterate by item in the list or disctionary or the like  
* Using a list, the enumerate() command will pull out a tuple which can be used in the iterations  
	for a, b in enumerate(myList) : expression # a will be the index and b will be the value  
* If iterating over a string, the for loop will extract character by character  
  
Looping data structures - Part I - extension to dictionaries, numpy arrays, and the like:  
  
* Looping through a dictionary requires calling the .items() method on the dictionary  
	* for key, value in myDict.items() : expression # will extract key, value as tuples  
    * Since dictionaries are unordered, the key will not be sorted and can come out in any order (hash-table dependent)  
* Looping through a 1-D numpy array will work the same as looping through a list; standard for-loop syntax  
* Looping through a 2-D numpy array will extract the 1-D numpy arrays underlying the 2-D numpy array (which may or may not be the desired output)  
	* Alternately, using np.nditer(myNumpy2D) will extract the items one at a time
  
Looping data structures - Part II - extension to pandas DataFrame:  
  
* The basic expression for x in myPanda : expression # the x will just iterate across the column names  
* To extract the rows, use for lab, row in myPanda.iterrows() : expression # the lab will be the row name and the row will be the row data, iterated over all the rows  
* Rather than using a loop, the apply function can be used to create new columns in the panda  
	* myPanda["myNewCol"] = myPanda["myOldCol"].apply(len)  # will create new variable myNewCol as len(myOldCol)  
  
Example code includes:  
```{r engine='python'}

# Initialize offset
offset = 8

# Code the while loop
while offset != 0 :
    print("correcting...")
    offset = offset - 1
    print(offset)


# Initialize offset
offset = -6

# Code the while loop
while offset != 0 :
    print("correcting...")
    if offset > 0 :
        offset = offset - 1
    else :
        offset = offset + 1
    print(offset)


# areas list
areas = [11.25, 18.0, 20.0, 10.75, 9.50]

# Code the for loop
for x in areas :
    print(x)


# areas list
areas = [11.25, 18.0, 20.0, 10.75, 9.50]

# Change for loop to use enumerate()
for a, b in enumerate(areas) :
    print("room " + str(a) + ": " + str(b))


# areas list
areas = [11.25, 18.0, 20.0, 10.75, 9.50]

# Code the for loop
for index, area in enumerate(areas) :
    print("room " + str(index + 1) + ": " + str(area))


# house list of lists
house = [["hallway", 11.25], 
         ["kitchen", 18.0], 
         ["living room", 20.0], 
         ["bedroom", 10.75], 
         ["bathroom", 9.50]]
         
# Build a for loop from scratch
for rooms in house :
    print("the " + str(rooms[0]) + " is " + str(rooms[1]) + " sqm")


# Definition of dictionary
europe = {'spain':'madrid', 'france':'paris', 'germany':'bonn', 
          'norway':'oslo', 'italy':'rome', 'poland':'warsaw', 'australia':'vienna' }
          
# Iterate over europe
for country, capital in europe.items() :
    print("the capital of " + str(country) + " is " + str(capital))


# Import numpy as np
import numpy as np

# DO NOT HAVE EITHER DATASET
# Create np_height
height = np.round(np.random.normal(1.75, 0.20, 50), 2)  
np_height = np.array(height)

# Create np_baseball
# baseball = [180, 215, 210, 210, 188, 176, 209, 200]
# np_baseball = np.array(baseball)

weight = np.round(np.random.normal(60.32, 15, 50), 2)
np_baseball = np.column_stack((height, weight))


# For loop over np_height
for height in np_height :
    print(str(height) + " inches")

# The end= argument over-rides the default to move to a new line
# For loop over np_baseball
for item in np.nditer(np_baseball) :
    print(item, end=" ")


# Import cars data
import pandas as pd
cars = pd.read_csv('cars.csv', index_col = 0)

# Iterate over rows of cars
for lab, dat in cars.iterrows() :
    print(lab)
    print(dat)


# Import cars data
import pandas as pd
cars = pd.read_csv('cars.csv', index_col = 0)

# Adapt for loop
for lab, row in cars.iterrows() :
    print(lab + ": " + str(row['cars_per_cap']))


# Import cars data
import pandas as pd
cars = pd.read_csv('cars.csv', index_col = 0)

# Code for loop that adds COUNTRY column
for lab, row in cars.iterrows() :
    cars.loc[lab, "COUNTRY"] = row['country'].upper()

# Print cars
print(cars)


# Import cars data
import pandas as pd
cars = pd.read_csv('cars.csv', index_col = 0)

# Use .apply(str.upper)
cars["COUNTRY"] = cars["country"].apply(str.upper)
print(cars)


```
  
  
***
  
Chapter 5 - Case Study: Hacker Statistics  
  
Random numbers - random walk using a 6-sided dice where 1/2 means -1, 3/4/5 means +1, and 6 means roll again and go up the number of the next roll:  
  
* Further, set a floor of step 0 and also add a 0.1% chance of falling down the stairs (presumably reverting to floor 0) at any given move  
* Assume that this is a 100-move game, and assess the odds of ending at floor 60+  
* Hacker statistics is simulating the game to assess the probabilities, as opposed to solving the game analytically  
* The np.random.rand() function will return a random number between 0 and 1  
	* Calling np.random.seed(mySeed) will set the seed for the upcoming trials, useful for reproducibility  
    * Calling np.random.int(a, b) will generate random integers between a and b-1 (both inclusive) assuming equal probabilities  
  
Random walk - well-known pattern in science:  
  
* Initializing an empty list can be done with the square brackets; myEmptyList = []  
	* Appending items to the list can be done with myEmptyList.append(myEntry)  
* For the random walk, start at 0 making myList = [0]  
	* Then, can run for x in range(runs) : myList.append(myList[x] + myRandom)  
    * Note that range(x) will generate an integer list from 0 to x-1  
  
Distribution of random walks - expanding on the 100-trial random walk:  
  
* Simulating many times allows for building a distribution and then making calculations based on that distribution  
  
Example code includes:  
```{r engine='python'}

# Import numpy as np
import numpy as np

# Set the seed
np.random.seed(123)

# Generate and print random float
print(np.random.rand())


# Import numpy and set seed
import numpy as np
np.random.seed(123)

# Use randint() to simulate a dice
print(np.random.randint(1, 7))

# Use randint() again
print(np.random.randint(1, 7))


# Import numpy and set seed
import numpy as np
np.random.seed(123)

# Starting step
step = 50

# Roll the dice
dice = np.random.randint(1, 7)

# Finish the control construct
if dice <= 2 :
    step = step - 1
elif dice < 6 :
    step = step + 1
else :
    step = step + np.random.randint(1,7)

# Print out dice and step
print(dice)
print(step)


# Import numpy and set seed
import numpy as np
np.random.seed(123)

# Initialize random_walk
random_walk = [0]

# Complete the ___
for x in range(100) :
    # Set step: last element in random_walk
    step = random_walk[-1]

    # Roll the dice
    dice = np.random.randint(1,7)

    # Determine next step
    if dice <= 2:
        step = step - 1
    elif dice <= 5:
        step = step + 1
    else:
        step = step + np.random.randint(1,7)

    # append next_step to random_walk
    random_walk.append(step)

# Print random_walk
print(random_walk)


# Import numpy and set seed
import numpy as np
np.random.seed(123)

# Initialize random_walk
random_walk = [0]

for x in range(100) :
    step = random_walk[-1]
    dice = np.random.randint(1,7)

    if dice <= 2:
        # Replace below: use max to make sure step can't go below 0
        step = max(0, step - 1)
    elif dice <= 5:
        step = step + 1
    else:
        step = step + np.random.randint(1,7)

    random_walk.append(step)

print(random_walk)


# Initialization
import numpy as np
np.random.seed(123)
random_walk = [0]

for x in range(100) :
    step = random_walk[-1]
    dice = np.random.randint(1,7)

    if dice <= 2:
        step = max(0, step - 1)
    elif dice <= 5:
        step = step + 1
    else:
        step = step + np.random.randint(1,7)

    random_walk.append(step)

# Import matplotlib.pyplot as plt
import matplotlib.pyplot as plt

# Plot random_walk
plt.plot(random_walk)

# Show the plot
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy015.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting


# Initialization
import numpy as np
np.random.seed(123)

# Initialize all_walks
all_walks = []

# Simulate random walk 10 times
for i in range(10) :

    # Code from before
    random_walk = [0]
    for x in range(100) :
        step = random_walk[-1]
        dice = np.random.randint(1,7)

        if dice <= 2:
            step = max(0, step - 1)
        elif dice <= 5:
            step = step + 1
        else:
            step = step + np.random.randint(1,7)
        random_walk.append(step)

    # Append random_walk to all_walks
    all_walks.append(random_walk)

# Print all_walks
print(all_walks)


import matplotlib.pyplot as plt
import numpy as np
np.random.seed(123)
all_walks = []
for i in range(10) :
    random_walk = [0]
    for x in range(100) :
        step = random_walk[-1]
        dice = np.random.randint(1,7)
        if dice <= 2:
            step = max(0, step - 1)
        elif dice <= 5:
            step = step + 1
        else:
            step = step + np.random.randint(1,7)
        random_walk.append(step)
    all_walks.append(random_walk)

# Convert all_walks to Numpy array: np_aw
np_aw = np.array(all_walks)

# Plot np_aw and show
plt.plot(np_aw)
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy016.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting


# Transpose np_aw: np_aw_t
np_aw_t = np.transpose(np_aw)

# Plot np_aw_t and show
plt.plot(np_aw_t)
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy017.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting


import matplotlib.pyplot as plt
import numpy as np
np.random.seed(123)
all_walks = []

# Simulate random walk 250 times
for i in range(250) :
    random_walk = [0]
    for x in range(100) :
        step = random_walk[-1]
        dice = np.random.randint(1,7)
        if dice <= 2:
            step = max(0, step - 1)
        elif dice <= 5:
            step = step + 1
        else:
            step = step + np.random.randint(1,7)

        # Implement clumsiness
        if np.random.rand() <= 0.001 :
            step = 0

        random_walk.append(step)
    all_walks.append(random_walk)

# Create and plot np_aw_t
np_aw_t = np.transpose(np.array(all_walks))
plt.plot(np_aw_t)
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy018.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting


import matplotlib.pyplot as plt
import numpy as np
np.random.seed(123)
all_walks = []

# Simulate random walk 500 times
for i in range(500) :
    random_walk = [0]
    for x in range(100) :
        step = random_walk[-1]
        dice = np.random.randint(1,7)
        if dice <= 2:
            step = max(0, step - 1)
        elif dice <= 5:
            step = step + 1
        else:
            step = step + np.random.randint(1,7)
        if np.random.rand() <= 0.001 :
            step = 0
        random_walk.append(step)
    all_walks.append(random_walk)

# Create and plot np_aw_t
np_aw_t = np.transpose(np.array(all_walks))

# Select last row from np_aw_t: ends
ends = np_aw_t[-1]

# Plot histogram of ends, display plot
plt.hist(ends)
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy019.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting


```
  
**Single random walk**:  
![](_dummyPy015.png)

**10 full walks**:  
![](_dummyPy016.png)

**10 full walks transposed**:  
![](_dummyPy017.png)

**250 random walks with "clumsiness"**:  
![](_dummyPy018.png)

**500 random walks with "clumsiness"**:  
![](_dummyPy019.png)

  
  
***
  
###_Python Data Science Toolbox (Part I)_#  
  
Chapter 1 - Writing your own functions  
  
User-defined functions - with/without parameters, and with/without returning values:  
  
* The general syntax is def myFunction(myParams) : commands  # commands can be on additional lines provided that they are indented by 4 spaces  
* Parameters are defined in the function body, while arguments are passed to the function; so def myFunction(myParams) has a parameter while myFunction(myArg) provides an argument  
* If the command return myReturn is included in the function, then myReturn will be passed back to the main body of the code and the function will stop and return  
* Docstrings serve as documentation for a function, and are included in the first line after the function call, surrounded by triple quotes ("""myComment""")  
  
Multiple parameters and return values:  
  
* Functions can accept multiple arguments, such as def myFunction(myParam1, myParam2)  
* Can also return multiple values using tuples (like a list, but immutable and defined using parentheses rather than square brackets)  
* Tuples can be unpacked using just variables separated by commans, so for example:
	* myTuple = (2, 4, 6)  
    * a, b, c = myTuple # a will be 2, b will be 4, c will be 6  
    * myTuple[1] will be 4, so the tuples can be accessed by way of an index  
  
Bringing it all together - practical examples using Twitter data:  
  
* Function header, function body including a docstring, and (optionally) function returns  
  
Example code includes:  
```{r engine='python'}

# Define the function shout
def shout():
    """Print a string with three exclamation marks"""
    # Concatenate the strings: shout_word
    shout_word = "congratulations" + "!!!"
    
    # Print shout_word
    print(shout_word)

# Call shout
shout()


# Define shout with the parameter, word
def shout(word):
    """Print a string with three exclamation marks"""
    # Concatenate the strings: shout_word
    shout_word = word + '!!!'

    # Print shout_word
    print(shout_word)

# Call shout with the string 'congratulations'
shout("congratulations")


# Define shout with the parameter, word
def shout(word):
    """Return a string with three exclamation marks"""
    # Concatenate the strings: shout_word
    shout_word = word + "!!!"

    # Replace print with return
    return(shout_word)

# Pass 'congratulations' to shout: yell
yell = shout("congratulations")

# Print yell
print(yell)


# Define shout with parameters word1 and word2
def shout(word1, word2):
    """Concatenate strings with three exclamation marks"""
    # Concatenate word1 with '!!!': shout1
    shout1 = word1 + "!!!"
    
    # Concatenate word2 with '!!!': shout2
    shout2 = word2 + "!!!"
    
    # Concatenate shout1 with shout2: new_shout
    new_shout = shout1 + shout2

    # Return new_shout
    return new_shout

# Pass 'congratulations' and 'you' to shout(): yell
yell = shout("congratulations", "you")

# Print yell
print(yell)


# Set up the nums tuple for later access
nums = (3, 4, 6)

# Unpack nums into num1, num2, and num3
num1, num2, num3 = nums

# Construct even_nums
even_nums = (2, num2, num3)


# Define shout_all with parameters word1 and word2
def shout_all(word1, word2):
    
    # Concatenate word1 with '!!!': shout1
    shout1 = word1 + "!!!"
    
    # Concatenate word2 with '!!!': shout2
    shout2 = word2 + "!!!"
    
    # Construct a tuple with shout1 and shout2: shout_words
    shout_words = (shout1, shout2)

    # Return shout_words
    return shout_words

# Pass 'congratulations' and 'you' to shout_all(): yell1, yell2
yell1, yell2 = shout_all("congratulations", "you")

# Print yell1 and yell2
print(yell1)
print(yell2)


# Import pandas
import pandas as pd

# DO NOT HAVE THIS CSV; CAN JUST MAKE A COLUMN WITH A SINGLE WORD FOR THE EXAMPLE
# Import Twitter data as DataFrame: df
df = pd.read_csv("tweets.csv")

# Initialize an empty dictionary: langs_count
langs_count = {}

# Extract column from DataFrame: col
col = df['lang']

# Iterate over lang column in DataFrame
for entry in col:

    # If the language is in langs_count, add 1
    if entry in langs_count.keys():
        langs_count[entry] = langs_count[entry] + 1
    # Else add the language to langs_count, set the value to 1
    else:
        langs_count[entry] = 1

# Print the populated dictionary
print(langs_count)


# Define count_entries()
def count_entries(df, col_name):
    """Return a dictionary with counts of 
    occurrences as value for each key."""

    # Initialize an empty dictionary: langs_count
    langs_count = {}
    
    # Extract column from DataFrame: col
    col = df[col_name]
    
    # Iterate over lang column in DataFrame
    for entry in col:

        # If the language is in langs_count, add 1
        if entry in langs_count.keys():
            langs_count[entry] = langs_count[entry] + 1
        # Else add the language to langs_count, set the value to 1
        else:
            langs_count[entry] = 1

    # Return the langs_count dictionary
    return(langs_count)

# NEED TO CREATE tweets_df such that it contains a column 'lang'
# Call count_entries(): result
tweets_df = df
result = count_entries(tweets_df, "lang")

# Print the result
print(result)


```
  

***

Chapter 2 - Default arguments and variable-length arguments  
  
Scope (where are objects or names accessible) and user-defined functions:  
  
* Global scope - defined in the main body of the script  
* Local scope - defined inside a function (once the function ends, the names and objects from the function disappear)  
* Built-in scope - names in the pre-defined built-ins module (e.g., print)  
    * To access the builtins, type "import builtins" followed by "dir(builtins)" - long story as to why  
* Search path for a name/object is local scope, then global scope, then built-in scope  
* Can use the key word "global" within a function to access the global scope, meaning that variable will be edited in the global scope, not in the local scope  
	* def square(value) : global new_val ; new_val = new_val ** 2; return(new_ val)  
    * new_val = 10 ; square(3) # returns 100, but now the global variable new_val is also 100  
  
Nested functions - one function defined inside another function:  
  
* With nested functions, the search is first local, then to the enclosing function, then to the global scope, then to the builtins  
* The inner function can be helpful if the outer function will need to repeat certain actions to achieve its objectives  
* Can return an inner function as the output of a function (example being raising to a user-specified power)  
* There is a computer-science term "closure" that defines exactly how the scopes work during this process  
	* Per DataCamp, "One other pretty cool reason for nesting functions is the idea of a closure. This means that the nested or inner function remembers the state of its enclosing scope when called."  
    * Continuing the DataCamp quote "Thus, anything defined locally in the enclosing scope is available to the inner function even when the outer function has finished execution."  
* The keyword "nonlocal" is available for changing names/values in the enclosing scope (not the global scope; that is keyword "global")  
  
Default and flexible arguments - arguments used when they are not specified, or when a flexible number of arguments can be passed:  
  
* The default arguments are defined using the equal sign, same as R (can be over-ridden if passed by the user, otherwise the default value will be used)  
* Using a parameter *args (anything with a single star) will create a tuple called "args" out of whatever the user-passed (1 or more arguments)  
	* It appears from the example that Python has the += command (as well as -=, *= and /=)  
* Using parameter **kwargs (anything with a double-star) will create a dictionary kwargs with key, value pairs off whatever the user has entered  
  
Bringing it all together - case study on processing a data frame to get word counts, defaulted to column 'lang':  
  
* Objective is to further generalize the process to be able to work on any number (arbitrary, user-specified) of columns in the DataFrame  
  
Example code includes:  
```{r engine='python'}

# Create a string: team
team = "teen titans"

# Define change_team()
def change_team():
    """Change the value of the global variable team."""

    # Use team in global scope
    global team

    # Change the value of team in global: team
    team = "justice league"

# Print team
print(team)

# Call change_team()
change_team()

# Print team
print(team)


# Define three_shouts
def three_shouts(word1, word2, word3):
    """Returns a tuple of strings
    concatenated with '!!!'."""

    # Define inner
    def inner(word):
        """Returns a string concatenated with '!!!'."""
        return word + '!!!'

    # Return a tuple of strings
    return (inner(word1), inner(word2), inner(word3))

# Call three_shouts() and print
print(three_shouts('a', 'b', 'c'))


# Define echo
def echo(n):
    """Return the inner_echo function."""

    # Define inner_echo
    def inner_echo(word1):
        """Concatenate n copies of word1."""
        echo_word = word1 * n
        return echo_word

    # Return inner_echo
    return inner_echo

# Call echo: twice
twice = echo(2)

# Call echo: thrice
thrice = echo(3)

# Call twice() and thrice() then print
print(twice('hello'), thrice('hello'))


# Define echo_shout()
def echo_shout(word):
    """Change the value of a nonlocal variable"""
    
    # Concatenate word with itself: echo_word
    echo_word = word + word
    
    #Print echo_word
    print(echo_word)
    
    # Define inner function shout()
    def shout():
        """Alter a variable in the enclosing scope"""    
        #Use echo_word in nonlocal scope
        nonlocal echo_word
        
        #Change echo_word to echo_word concatenated with '!!!'
        echo_word = echo_word + "!!!"
    
    # Call function shout()
    shout()
    
    #Print echo_word
    print(echo_word)

#Call function echo_shout() with argument 'hello'    
echo_shout("hello")


# Define shout_echo
def shout_echo(word1, echo=1):
    """Concatenate echo copies of word1 and three
     exclamation marks at the end of the string."""

    # Concatenate echo copies of word1 using *: echo_word
    echo_word = word1 * echo

    # Concatenate '!!!' to echo_word: shout_word
    shout_word = echo_word + '!!!'

    # Return shout_word
    return shout_word

# Call shout_echo() with "Hey": no_echo
no_echo = shout_echo("Hey")

# Call shout_echo() with "Hey" and echo=5: with_echo
with_echo = shout_echo("Hey", 5)

# Print no_echo and with_echo
print(no_echo)
print(with_echo)


# Define shout_echo
def shout_echo(word1, echo=1, intense=False):
    """Concatenate echo copies of word1 and three
    exclamation marks at the end of the string."""

    # Concatenate echo copies of word1 using *: echo_word
    echo_word = word1 * echo

    # Capitalize echo_word if intense is True
    if intense is True:
        # Capitalize and concatenate '!!!': echo_word_new
        echo_word_new = echo_word.upper() + '!!!'
    else:
        # Concatenate '!!!' to echo_word: echo_word_new
        echo_word_new = echo_word + '!!!'

    # Return echo_word_new
    return echo_word_new

# Call shout_echo() with "Hey", echo=5 and intense=True: with_big_echo
with_big_echo = shout_echo("Hey", 5, True)

# Call shout_echo() with "Hey" and intense=True: big_no_echo
big_no_echo = shout_echo("Hey", intense=True)

# Print values
print(with_big_echo)
print(big_no_echo)


# Define gibberish
def gibberish(*args):
    """Concatenate strings in *args together."""

    # Initialize an empty string: hodgepodge
    hodgepodge = ""

    # Concatenate the strings in args
    for word in args:
        hodgepodge += word

    # Return hodgepodge
    return(hodgepodge)

# Call gibberish() with one string: one_word
one_word = gibberish("luke")

# Call gibberish() with five strings: many_words
many_words = gibberish("luke", "leia", "han", "obi", "darth")

# Print one_word and many_words
print(one_word)
print(many_words)


# Define report_status
def report_status(**kwargs):
    """Print out the status of a movie character."""

    print("\nBEGIN: REPORT\n")

    # Iterate over the key-value pairs of kwargs
    for key, value in kwargs.items():
        # Print out the keys and values, separated by a colon ':'
        print(key + ": " + value)

    print("\nEND REPORT")

# First call to report_status()
report_status(name="luke", affiliation="jedi", status="missing")

# Second call to report_status()
report_status(name="anakin", affiliation="sith lord", status="deceased")


# DO NOT HAVE file tweets_df (may need to create some dummy data . . . )
import pandas as pd
tweets_df = pd.read_csv("tweets.csv")


# Define count_entries()
def count_entries(df, col_name="lang"):
    """Return a dictionary with counts of
    occurrences as value for each key."""

    # Initialize an empty dictionary: cols_count
    cols_count = {}

    # Extract column from DataFrame: col
    col = df[col_name]
    
    # Iterate over the column in DataFrame
    for entry in col:

        # If entry is in cols_count, add 1
        if entry in cols_count.keys():
            cols_count[entry] += 1

        # Else add the entry to cols_count, set the value to 1
        else:
            cols_count[entry] = 1

    # Return the cols_count dictionary
    return cols_count

# Call count_entries(): result1
result1 = count_entries(tweets_df)

# Call count_entries(): result2
result2 = count_entries(tweets_df, "source")

# Print result1 and result2
print(result1)
print(result2)


# Define count_entries()
def count_entries(df, *args):
    """Return a dictionary with counts of
    occurrences as value for each key."""
    
    #Initialize an empty dictionary: cols_count
    cols_count = {}
    
    # Iterate over column names in args
    for col_name in args:
    
        # Extract column from DataFrame: col
        col = df[col_name]
    
        # Iterate over the column in DataFrame
        for entry in col:
    
            # If entry is in cols_count, add 1
            if entry in cols_count.keys():
                cols_count[entry] += 1
    
            # Else add the entry to cols_count, set the value to 1
            else:
                cols_count[entry] = 1

    # Return the cols_count dictionary
    return cols_count

# Call count_entries(): result1
result1 = count_entries(tweets_df, "lang")

# Call count_entries(): result2
result2 = count_entries(tweets_df, "lang", "source")

# Print result1 and result2
print(result1)
print(result2)

```
  
  
***

Chapter 3 - Lambda functions and error handling  
  
Lambda functions - quicker way to write functions on the fly:  
  
* The general syntax is lambda : expression  
	* raise_to_power = lambda x, y : x ** y  
    * raise_to_power(2, 3) = 8 # runs as 2 ** 3  
* The lambda function is "quick and dirty", so it should be limited to key areas where that is appropriate  
* An example is map(func, seq) which will apply the function over all elements of the sequence  
	* The lambda function can be valuable here, since it allows for a custom function to be applied quickly across a sequence  
    * square_all = map(lambda num: num ** 2, nums)  
    * Need to use print(list(square_all)) since print(square_all) will just define that it is an object at a designated point in memory  
  
Introduction to error handling - functions generally return an error if something is wrong, though that can be trapped/over-ridden:  
  
* Endeavor to provide useful error messages rather than just a trace-back default from Python  
* The typical approach in Python is try-except, where try will try the command and except will run if the try produces an error  
	* try : command to try  # The commands to try are typically on a new line(s) and indented by 4 spaces  
    * except : do otherwise  # The except lines up with the try, while the do otherwise are typically on a new line(s) and indented by 4 spaces  
* Can add types of errors to be trapped, for example "type errors only" using except TypeError :   
* To generate an error (for example, if negative inputs are not desired), can use raise ValueError("quotedMessage")  
    * This will throw a trace-back message, with the quotedMessage appearing at the bottom  
  
Bringing it all together:  
  
* Case study for error handling on the tweets data frame  
  
Example code includes:  
```{r engine='python'}

# Define echo_word as a lambda function: echo_word
echo_word = (lambda word1, echo : word1 * echo)

# Call echo_word: result
result = echo_word("hey", 5)

# Print result
print(result)


# Create a list of strings: spells
spells = ["protego", "accio", "expecto patronum", "legilimens"]

# Use map() to apply a lambda function over spells: shout_spells
shout_spells = map(lambda a : a + "!!!", spells)

# Convert shout_spells to a list: shout_spells_list
shout_spells_list = list(shout_spells)

# Convert shout_spells into a list and print it
print(shout_spells_list)


# Create a list of strings: fellowship
fellowship = ['frodo', 'samwise', 'merry', 'aragorn', 'legolas', 'boromir', 'gimli']

# Use filter() to apply a lambda function over fellowship: result
result = filter(lambda a : len(a) > 6, fellowship)

# Convert result to a list: result_list
result_list = list(result)

# Convert result into a list and print it
print(result_list)


# Import reduce from functools
from functools import reduce

# Create a list of strings: stark
stark = ['robb', 'sansa', 'arya', 'eddard', 'jon']

# Use reduce() to apply a lambda function over stark: result
result = reduce(lambda item1, item2 : item1 + item2, stark)

# Print the result
print(result)


# Define shout_echo
def shout_echo(word1, echo=1):
    """Concatenate echo copies of word1 and three
    exclamation marks at the end of the string."""

    # Initialize empty strings: echo_word, shout_words
    echo_word = ""
    shout_words = ""

    # Add exception handling with try-except
    try:
        # Concatenate echo copies of word1 using *: echo_word
        echo_word = word1 * echo

        # Concatenate '!!!' to echo_word: shout_words
        shout_words = echo_word + "!!!"
    except:
        # Print error message
        print("word1 must be a string and echo must be an integer.")

    # Return shout_words
    return shout_words

# Call shout_echo
shout_echo("particle", echo="accelerator")


# Define shout_echo
def shout_echo(word1, echo=1):
    """Concatenate echo copies of word1 and three
    exclamation marks at the end of the string."""

    # Raise an error with raise
    if echo < 0:
        raise ValueError('echo must be greater than 0')

    # Concatenate echo copies of word1 using *: echo_word
    echo_word = word1 * echo

    # Concatenate '!!!' to echo_word: shout_word
    shout_word = echo_word + '!!!'

    # Return shout_word
    return shout_word

# Call shout_echo
shout_echo("particle", echo=5)


# DO NOT HAVE file tweets_df (made "tweets.csv" using R)
import pandas as pd
tweets_df = pd.read_csv("tweets.csv")

# Select retweets from the Twitter DataFrame: result
result = filter(lambda x : x[0:2] == "RT", tweets_df["text"])

# Create list from filter object result: res_list
res_list = list(result)

# Print all retweets in res_list
for tweet in res_list:
    print(tweet)


# Define count_entries()
def count_entries(df, col_name='lang'):
    """Return a dictionary with counts of
    occurrences as value for each key."""

    # Initialize an empty dictionary: cols_count
    cols_count = {}

    # Add try block
    try:
        # Extract column from DataFrame: col
        col = df[col_name]
        
        # Iterate over the column in dataframe
        for entry in col:
    
            # If entry is in cols_count, add 1
            if entry in cols_count.keys():
                cols_count[entry] += 1
            # Else add the entry to cols_count, set the value to 1
            else:
                cols_count[entry] = 1
    
        # Return the cols_count dictionary
        return cols_count

    # Add except block
    except:
        print('The DataFrame does not have a ' + col_name + ' column.')

# DO NOT HAVE file tweets_df
# Call count_entries(): result1
result1 = count_entries(tweets_df, 'lang')

# Print result1
print(result1)

# Call count_entries(): result2
result2 = count_entries(tweets_df, 'lang1')


# Define count_entries()
def count_entries(df, col_name='lang'):
    """Return a dictionary with counts of
    occurrences as value for each key."""
    
    # Raise a ValueError if col_name is NOT in DataFrame
    if col_name not in df.columns:
        raise ValueError('The DataFrame does not have a ' + col_name + ' column.')

    # Initialize an empty dictionary: cols_count
    cols_count = {}
    
    # Extract column from DataFrame: col
    col = df[col_name]
    
    # Iterate over the column in DataFrame
    for entry in col:

        # If entry is in cols_count, add 1
        if entry in cols_count.keys():
            cols_count[entry] += 1
            # Else add the entry to cols_count, set the value to 1
        else:
            cols_count[entry] = 1
        
        # Return the cols_count dictionary
    return cols_count

# Call count_entries(): result1
result1 = count_entries(tweets_df, "lang")

# Print result1
print(result1)


# CAREFUL, THIS ONE IS DESIGNED TO RAISE THE ERROR!
# count_entries(tweets_df, 'lang1')


```


###_Python Data Science Toolbox (Part II)_#  
  
Chapter 1 - Using iterators in PythonLand  
  
Introduction to iterators - for loops and the like:  
  
* For loops can be used for iterating over strings, lists, dictionaries, range() objects, and the like  
* Anything that can be looped over is called an "iterable", and will have an associated iter() method  
* An "iterator" is something that produces the next value with a next() call  
* For loops are using the "iterable" property of objects under-the-hood, with an associated (if silent) "next" call  
	* word = "Da"; it = iter(word); next(it); next(it)  # "D" then "a"  
* The "star" (*) operator will impact all elements of an iterator at once  
	* word = "Data"; it = iter(word); print(*it)  # single-line of "D" "a" "t" "a"  
    * Note that if print(*it) were then called again, there would just be a blank line; there is nothing left to iterate over  
* To unpack a dictionary, use myDict.items()  
* To iterate over a file, use file=open("file.txt"); it = iter(file); print(next(it))  
  
Playing with iterators - enumerate and zip:  
  
* The function enumerate(myIterable) returns an "enumerate" class object with both items and their indices  
	* Running list() on the "enumerate" class object will make a list out of the tuples [(index1, item1), (index2, item2), . . . ]  
    * The default is for index1=0, though the argument start= may be included in the enumerate() call for a different starting index  
* The zip(myIter01, myIter02) will create a "zip" class object of the iterators  
	* list(zip()) will return a list of tuples, starting with (allItem1), (allIterm2), . . . 
    * Seems to require that the iterators all be the same length, else only items until running out of the shortest iterator will be tupled  
  
Using iterators to load large files in to memory - loading data in chunks:  
  
* Common strategy with large files is to read in some data, process it, save the results, discard the data, and then repeat  
* The pandas.read_csv() has an option for chunksize= that allows for reading chunks of any given size  
  
Example code includes:  
```{r engine='python'}

# Create a list of strings: flash
flash = ['jay garrick', 'barry allen', 'wally west', 'bart allen']

# Print each list item in flash using a for loop
for person in flash : print(person)

# Create an iterator for flash: superspeed
superspeed = iter(flash)

# Print each item from the iterator
print(next(superspeed))
print(next(superspeed))
print(next(superspeed))
print(next(superspeed))


# Create an iterator for range(3): small_value
small_value = iter(range(3))

# Print the values in small_value
print(next(small_value))
print(next(small_value))
print(next(small_value))

# Loop over range(3) and print the values
for num in range(3) : print(num)


# Create an iterator for range(10 ** 100): googol
googol = iter(range(10 ** 100))

# Print the first 5 values from googol
print(next(googol))
print(next(googol))
print(next(googol))
print(next(googol))
print(next(googol))


# Create a range object: values
values = range(10, 21)

# Print the range object
print(values)

# Create a list of integers: values_list
values_list = list(values)

# Print values_list
print(values_list)

# Get the sum of values: values_sum
values_sum = sum(values)

# Print values_sum
print(values_sum)


# Create a list of strings: mutants
mutants = ['charles xavier', 
            'bobby drake', 
            'kurt wagner', 
            'max eisenhardt', 
            'kitty pride']

# Create a list of tuples: mutant_list
mutant_list = list(enumerate(mutants))

# Print the list of tuples
print(mutant_list)

# Unpack and print the tuple pairs
for index1, value1 in mutant_list :
    print(index1, value1)

# Change the start index
for index2, value2 in list(enumerate(mutants, start=1)) :
    print(index2, value2)


aliases = ['prof x', 'iceman', 'nightcrawler', 'magneto', 'shadowcat']
powers = ['telepathy', 'thermokinesis', 'teleportation', 'magnetokinesis', 'intangibility' ]

# Create a list of tuples: mutant_data
mutant_data = list(zip(mutants, aliases, powers))

# Print the list of tuples
print(mutant_data)

# Create a zip object using the three lists: mutant_zip
mutant_zip = zip(mutants, aliases, powers)

# Print the zip object
print(mutant_zip)

# Unpack the zip object and print the tuple values
for value1, value2, value3 in mutant_zip :
    print(value1, value2, value3)


# Create a zip object from mutants and powers: z1
z1 = zip(mutants, powers)

# Print the tuples in z1 by unpacking with *
print(*z1)

# Re-create a zip object from mutants and powers: z1
z1 = zip(mutants, powers)

# 'Unzip' the tuples in z1 by unpacking with * and zip(): result1, result2
result1, result2 = zip(*z1)

# Check if unpacked tuples are equivalent to original tuples
print(result1 == tuple(mutants))
print(result2 == tuple(powers))


import pandas as pd

# Initialize an empty dictionary: counts_dict
counts_dict = dict()

# DO NOT HAVE FILE tweets.csv
# Created in R - see above for code
# Iterate over the file chunk by chunk
for chunk in pd.read_csv("tweets.csv", chunksize=10):
    # Iterate over the column in DataFrame
    for entry in chunk['lang']:
        if entry in counts_dict.keys():
            counts_dict[entry] += 1
        else:
            counts_dict[entry] = 1

# Print the populated dictionary
print(counts_dict)


# Define count_entries()
def count_entries(csv_file, c_size, colname):
    """Return a dictionary with counts of
    occurrences as value for each key."""
    
    # Initialize an empty dictionary: counts_dict
    counts_dict = {}

    # Iterate over the file chunk by chunk
    for chunk in pd.read_csv(csv_file, chunksize=c_size):

        # Iterate over the column in DataFrame
        for entry in chunk[colname]:
            if entry in counts_dict.keys():
                counts_dict[entry] += 1
            else:
                counts_dict[entry] = 1

    # Return counts_dict
    return counts_dict

# Call count_entries(): result_counts
result_counts = count_entries("tweets.csv", 10, "lang")

# Print result_counts
print(result_counts)

```
  
  
***
  
Chapter 2 - List comprehensions and generators  
  
List comprehensions help address some of the inefficiencies (coding, run time, etc.) of using for loops for some tasks:  
  
* The syntax is [myDesiredCalcs for myVar in myIter]  # should be square-bracketed  
* List comprehension may be used over any iterable; for example, [num for num in range(11)] will return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  
* List comprehension can also be valuable in lieu of nested for loops; for example, with [(num1, num2) for num1 in range(0, 2) for num2 in range(6, 8)]  
* There is sometimes a trade-off for readability to keep in mind  
  
Advanced comprehensions - additional functionality available:  
  
* [myDesiredCalcs for myVar in myIter if myCond] # allows for myCond to limit the myVar that are available to myDesiredCalcs (thus limiting the output list)  
* [myDesiredCalcs if myCond else myDefault for myVar in myIter]  # allows for extracting where myCond is met and replacing with myDefault otherwise  
* {myCalc01 : myCalc02 for myVar in myIter} # produces a dictionary with key myCalc01 and value myCalc02  
  
Introduction to generator expressions - creating generator objects rather than list/dictionaries:  
  
* (myDesiredCalcs for myVar in myIter)  # will create a generator object rather than a list  
* Using a generator expression can help significantly with large sequences due to "lazy evaluation" (not evaluated until needed, such as next() being called)  
	* While [num for num in range(10 ** 1000000)] will bomb out of memory, (num for num in range(10 ** 1000000)) is OK!  
* An additional nice feature is that all the conditionals can be run in the generator expression also  
* Note that using "yield" rather than "return" in a def (function) will build a generator function (it will return a generator object when called)  
  
Wrapping up comprehensions and generators - helps with wrangling data:  
  
* Basic form - enclosed in brackets, output will be a list  
* More advanced forms - conditions on the iterator and/or iterable  
* Dictionaries - enclosed in braces  
* Generators - enclosed in parentheses  
  
Example code includes:  
```{r engine='python'}

doctor = ['house', 'cuddy', 'chase', 'thirteen', 'wilson']
[doc[0] for doc in doctor]

# Create list comprehension: squares
squares = [i ** 2 for i in range(0, 10)]


# Create a 5 x 5 matrix using a list of lists: matrix
matrix = [[col for col in range(5)] for row in range(5)]

# Print the matrix
for row in matrix:
    print(row)


# Create a list of strings: fellowship
fellowship = ['frodo', 'samwise', 'merry', 'aragorn', 'legolas', 'boromir', 'gimli']

# Create list comprehension: new_fellowship
new_fellowship = [member for member in fellowship if len(member) >= 7]

# Print the new list
print(new_fellowship)


# Create a list of strings: fellowship
fellowship = ['frodo', 'samwise', 'merry', 'aragorn', 'legolas', 'boromir', 'gimli']

# Create list comprehension: new_fellowship
new_fellowship = [member if len(member) >= 7 else "" for member in fellowship]

# Print the new list
print(new_fellowship)


# Create a list of strings: fellowship
fellowship = ['frodo', 'samwise', 'merry', 'aragorn', 'legolas', 'boromir', 'gimli']

# Create dict comprehension: new_fellowship
new_fellowship = {member : len(member) for member in fellowship}

# Print the new list
print(new_fellowship)


# Create generator object: result
result = (num for num in range(16))

# Print the first 5 values
print(next(result))
print(next(result))
print(next(result))
print(next(result))
print(next(result))

# Print the rest of the values
# NOTE - only will print 5-15 since 0-4 have previously been "consumed" above
for value in result:
    print(value)


# Create a list of strings: lannister
lannister = ['cersei', 'jaime', 'tywin', 'tyrion', 'joffrey']

# Create a generator object: lengths
lengths = (len(person) for person in lannister)

# Iterate over and print the values in lengths
for value in lengths:
    print(value)


# Create a list of strings
lannister = ['cersei', 'jaime', 'tywin', 'tyrion', 'joffrey']

# Define generator function get_lengths
def get_lengths(input_list):
    """Generator function that yields the
    length of the strings in input_list."""
    # Yield the length of a string
    for person in input_list:
        yield len(person)

# Print the values generated by get_lengths()
for value in get_lengths(lannister):
    print(value)


# DO NOT HAVE panda "df"
# Extract the created_at column from df: tweet_time
# tweet_time = df["created_at"]

# Extract the clock time: tweet_clock_time
# tweet_clock_time = [entry[11:19] for entry in tweet_time]

# Print the extracted times
# print(tweet_clock_time)


# Extract the created_at column from df: tweet_time
# tweet_time = df['created_at']

# Extract the clock time: tweet_clock_time
# tweet_clock_time = [entry[11:19] for entry in tweet_time if entry[17:19] == "19"]

# Print the extracted times
# print(tweet_clock_time)

```
  
  
***

Chapter 3 - Bringing it all together (case study)  
  
Welcome to the case study - previous two course techniques:  
  
* Wrangle and extract data from the World Bank Indicators dataset (1960-2015 data on 227 countries)  
* Recall that zip(a, b, . . . ) creates an iterable of tuples conmtaining (a1, b1, …), (a2, b2, …), …  
  
Using Python generators for streaming data:  
  
* Generators are helpful for reading large files - in fact, they work even on files that are being written (as long as the read stays behind the write)  
* Generator functions are written like regular functions, but they have a "yield" (put it in to the generator and keep going) rather than a "return" (return the value and stop)  
* Goal will be to write a generator to read streaming data  
  
Reading files in chunks with pandas.read_csv():  
  
* pandas.read_csv(file, chunksize= ) # allows the file to be read in chunks of size chunksize  
  
Example code includes:  
```{r engine='python'}

row_vals = [ 'Arab World', 'ARB', 'Adolescent fertility rate (births per 1,000 women ages 15-19)', 'SP.ADO.TFRT', '1960', '133.56090740552298' ]

feature_names = [ 'CountryName', 'CountryCode', 'IndicatorName', 'IndicatorCode', 'Year', 'Value' ]

# Zip lists: zipped_lists
zipped_lists = zip(feature_names, row_vals)

# Create a dictionary: rs_dict
rs_dict = dict(zipped_lists)

# Print the dictionary
print(rs_dict)


# Define lists2dict()
def lists2dict(list1, list2):
    """Return a dictionary where list1 provides
    the keys and list2 provides the values."""
    
    # Zip lists: zipped_lists
    zipped_lists = zip(list1, list2)
    
    # Create a dictionary: rs_dict
    rs_dict = dict(zipped_lists)
    
    # Return the dictionary
    return rs_dict

# Call lists2dict: rs_fxn
rs_fxn = lists2dict(feature_names, row_vals)

# Print rs_fxn
print(rs_fxn)


# Create list row_lists
regn = ['Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World', 'Arab World']

abb = ['ARB', 'ARB', 'ARB', 'ARB', 'ARB', 'ARB', 'ARB', 'ARB', 'ARB', 'ARB', 'ARB', 'ARB', 'ARB', 'ARB', 'ARB', 'ARB', 'ARB', 'ARB', 'ARB', 'ARB']

indName = ['Adolescent fertility rate (births per 1,000 women ages 15-19)', 'Age dependency ratio (% of working-age population)', 'Age dependency ratio, old (% of working-age population)', 'Age dependency ratio, young (% of working-age population)', 'Arms exports (SIPRI trend indicator values)', 'Arms imports (SIPRI trend indicator values)', 'Birth rate, crude (per 1,000 people)', 'CO2 emissions (kt)', 'CO2 emissions (metric tons per capita)', 'CO2 emissions from gaseous fuel consumption (% of total)', 'CO2 emissions from liquid fuel consumption (% of total)', 'CO2 emissions from liquid fuel consumption (kt)', 'CO2 emissions from solid fuel consumption (% of total)', 'Death rate, crude (per 1,000 people)', 'Fertility rate, total (births per woman)', 'Fixed telephone subscriptions', 'Fixed telephone subscriptions (per 100 people)', 'Hospital beds (per 1,000 people)', 'International migrant stock (% of population)', 'International migrant stock, total' ]

indCode = ['SP.ADO.TFRT', 'SP.POP.DPND', 'SP.POP.DPND.OL', 'SP.POP.DPND.YG', 'MS.MIL.XPRT.KD', 'MS.MIL.MPRT.KD', 'SP.DYN.CBRT.IN', 'EN.ATM.CO2E.KT', 'EN.ATM.CO2E.PC', 'EN.ATM.CO2E.GF.ZS', 'EN.ATM.CO2E.LF.ZS', 'EN.ATM.CO2E.LF.KT', 'EN.ATM.CO2E.SF.ZS', 'SP.DYN.CDRT.IN', 'SP.DYN.TFRT.IN', 'IT.MLT.MAIN', 'IT.MLT.MAIN.P2', 'SH.MED.BEDS.ZS', 'SM.POP.TOTL.ZS', 'SM.POP.TOTL']

year = ['1960', '1960', '1960', '1960', '1960', '1960', '1960', '1960', '1960', '1960', '1960', '1960', '1960', '1960', '1960', '1960', '1960', '1960', '1960', '1960']

value = ['133.56090740552298', '87.7976011532547', '6.634579191565161', '81.02332950839141', '3000000.0', '538000000.0', '47.697888095096395', '59563.9892169935', '0.6439635478877049', '5.041291753975099', '84.8514729446567', '49541.707291032304', '4.72698138789597', '19.7544519237187', '6.92402738655897', '406833.0', '0.6167005703199', '1.9296220724398703', '2.9906371279862403', '3324685.0']

row_lists=list(zip(regn, abb, indName, indCode, year, value))

# Print the first two lists in row_lists
print(row_lists[0])
print(row_lists[1])

# Turn list of lists into list of dicts: list_of_dicts
list_of_dicts = [lists2dict(feature_names, sublist) for sublist in row_lists]

# Print the first two dictionaries in list_of_dicts
print(list_of_dicts[0])
print(list_of_dicts[1])

# Import the pandas package
import pandas as pd

# Turn list of lists into list of dicts: list_of_dicts
list_of_dicts = [lists2dict(feature_names, sublist) for sublist in row_lists]

# Turn list of dicts into a DataFrame: df
df = pd.DataFrame(list_of_dicts)

# Print the head of the DataFrame
print(df.head())

# REFERENCE DATA POSSIBLY AT http://data.worldbank.org/data-catalog/world-development-indicators
# Created relevant file "world_dev_ind.csv" using Python and World Bank download
# Open a connection to the file
with open("world_dev_ind.csv") as file:
    
    # Skip the column names
    file.readline()
    
    # Initialize an empty dictionary: counts_dict
    counts_dict = {}
    
    # Process only the first 1000 rows
    for j in range(1000):
        
        # Split the current line into a list: line
        line = file.readline().split(',')
        
        # Get the value for the first column: first_col
        first_col = line[0]
        
        # If the column value is in the dict, increment its value
        if first_col in counts_dict.keys():
            counts_dict[first_col] += 1
        
        # Else, add to the dict and set value to 1
        else:
            counts_dict[first_col] = 1

# Print the resulting dictionary
print(counts_dict)

# Define read_large_file()
def read_large_file(file_object):
    """A generator function to read a large file lazily."""
    
    # Loop indefinitely until the end of the file
    while True:
        
        # Read a line from the file: data
        data = file_object.readline()
        
        # Break if this is the end of the file
        if not data:
            break
        
        # Yield the line of data
        yield data
        
# Open a connection to the file
with open('world_dev_ind.csv') as file:
    
    # Create a generator object for the file: gen_file
    gen_file = read_large_file(file)
    
    # Print the first three lines of the file
    print(next(gen_file))
    print(next(gen_file))
    print(next(gen_file))


# Initialize an empty dictionary: counts_dict
counts_dict = {}


# Open a connection to the file
with open("world_dev_ind.csv") as file:
    
    # Iterate over the generator from read_large_file()
    for line in read_large_file(file):
        row = line.split(',')
        first_col = row[0]
        
        if first_col in counts_dict.keys():
            counts_dict[first_col] += 1
        else:
            counts_dict[first_col] = 1

# Print            
print(counts_dict)


# DO NOT HAVE FILE ind_pop.csv (CountryName,CountryCode,IndicatorName,IndicatorCode,Year,Value\n)
# Value for regions of CountryName/CountryCode - fixing Urban population (% of total), SP.URB.TOTL.IN.ZS , 1960
# Just changed it to use "world_dev_ind.csv"
# Import the pandas package
import pandas as pd
import matplotlib.pyplot as plt


# Initialize reader object: df_reader
df_reader = pd.read_csv("world_dev_ind.csv", chunksize=10)

# Print two chunks
print(next(df_reader))
print(next(df_reader))


# DO NOT HAVE FILE ind_pop_data.csv 
# ('CountryName,CountryCode,Year,Total Population,Urban population (% of total)\n)
# Appears to be 1960-1964
# Initialize reader object: urb_pop_reader
# Create file using Python, needs to read in using encoding="latin-1"
urb_pop_reader = pd.read_csv("ind_pop_data.csv", chunksize=2500, encoding="latin-1")

# Get the first DataFrame chunk: df_urb_pop
df_urb_pop = next(urb_pop_reader)

# Check out the head of the DataFrame
print(df_urb_pop.head())

# Check out specific country: df_pop_ceb
idxCeb = df_urb_pop[df_urb_pop["CountryCode"] == "CEB"].index
df_pop_ceb = df_urb_pop.loc[idxCeb, :]  # Make sure it is not just a reference . . . 

# Zip DataFrame columns of interest: pops
pops = zip(df_pop_ceb["Total Population"], df_pop_ceb["Urban population (% of total)"])

# Turn zip object into list: pops_list
pops_list = list(pops)

# Print pops_list
print(pops_list)


# Initialize reader object: urb_pop_reader
urb_pop_reader = pd.read_csv("ind_pop_data.csv", chunksize=2500, encoding="latin-1")

# Get the first DataFrame chunk: df_urb_pop
df_urb_pop = next(urb_pop_reader)

# Check out specific country: df_pop_ceb
idxCeb = df_urb_pop[df_urb_pop["CountryCode"] == "CEB"].index
df_pop_ceb = df_urb_pop.loc[idxCeb, :]  # Make sure it is not just a reference . . . 
# df_pop_ceb = df_urb_pop[df_urb_pop['CountryCode'] == 'CEB']

# Zip DataFrame columns of interest: pops
pops = zip(df_pop_ceb['Total Population'], 
            df_pop_ceb['Urban population (% of total)'])

# Turn zip object into list: pops_list
pops_list = list(pops)

# Use list comprehension to create new DataFrame column 'Total Urban Population'
# df_pop_ceb["Total Urban Population"] = df_pop_ceb["Total Population"]
# a = [int(0.01 * tup[0] * tup[1]) for tup in pops_list]
df_pop_ceb['Total Urban Population'] = [int(0.01 * tup[0] * tup[1]) for tup in pops_list]


# Plot urban population data
df_pop_ceb.plot(kind="scatter", x="Year", y="Total Urban Population")
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy020.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting

# Initialize reader object: urb_pop_reader
urb_pop_reader = pd.read_csv('ind_pop_data.csv', chunksize=1000, encoding="latin-1")

# Initialize empty DataFrame: data
data = pd.DataFrame()

# Iterate over each DataFrame chunk
for df_urb_pop in urb_pop_reader:

    # Check out specific country: df_pop_ceb
    idxCeb = df_urb_pop[df_urb_pop["CountryCode"] == "CEB"].index
    df_pop_ceb = df_urb_pop.loc[idxCeb, :]  # Make sure it is not just a reference . . . 

    # Zip DataFrame columns of interest: pops
    pops = zip(df_pop_ceb['Total Population'],
                df_pop_ceb['Urban population (% of total)'])

    # Turn zip object into list: pops_list
    pops_list = list(pops)

    # Use list comprehension to create new DataFrame column 'Total Urban Population'
    # df_pop_ceb["Total Urban Population"] = df_pop_ceb["Total Population"]
    # a = [int(0.01 * tup[0] * tup[1]) for tup in pops_list]
    df_pop_ceb['Total Urban Population'] = [int(0.01 * tup[0] * tup[1]) for tup in pops_list]
    
    # Append DataFrame chunk to data: data
    data = data.append(df_pop_ceb)

# Plot urban population data
data.plot(kind='scatter', x='Year', y='Total Urban Population')
# plt.show()
# Save as dummy PNG instead
plt.savefig("_dummyPy021.png", bbox_inches="tight")
plt.clf()  # Required to prevent continued over-plotting


# Define plot_pop()
def plot_pop(filename, country_code, pngCode=False):
    
    # Initialize reader object: urb_pop_reader
    urb_pop_reader = pd.read_csv(filename, chunksize=1000, encoding="latin-1")
    
    # Initialize empty DataFrame: data
    data = pd.DataFrame()
    
    # Iterate over each DataFrame chunk
    for df_urb_pop in urb_pop_reader:
        # Check out specific country: df_pop_ceb
        idxCeb = df_urb_pop[df_urb_pop["CountryCode"] == country_code].index
        df_pop_ceb = df_urb_pop.loc[idxCeb, :]  # Make sure it is not just a reference . . . 
        
        # Zip DataFrame columns of interest: pops
        pops = zip(df_pop_ceb['Total Population'],
                    df_pop_ceb['Urban population (% of total)'])
        
        # Turn zip object into list: pops_list
        pops_list = list(pops)
        
        # Use list comprehension to create new DataFrame column 'Total Urban Population'
        # df_pop_ceb["Total Urban Population"] = df_pop_ceb["Total Population"]
        # a = [int(0.01 * tup[0] * tup[1]) for tup in pops_list]
        # df_pop_ceb.loc[df_pop_ceb.index, 'Total Urban Population'] = a
        df_pop_ceb['Total Urban Population'] = [int(0.01 * tup[0] * tup[1]) for tup in pops_list]
        
        # Append DataFrame chunk to data: data
        data = data.append(df_pop_ceb)
        
    # Plot urban population data
    data.plot(kind='scatter', x='Year', y='Total Urban Population')
    if pngCode == False :
        plt.show()  # Plot by default
    else :
        plt.savefig(pngCode, bbox_inches="tight") # Save as dummy PNG instead
    
    plt.clf()  # Required to prevent continued over-plotting

# Set the filename: fn
fn = 'ind_pop_data.csv'

# Call plot_pop for country code 'CEB'
plot_pop(fn, "CEB", "_dummyPy022.png")

# Call plot_pop for country code 'ARB'
plot_pop(fn, "ARB", "_dummyPy023.png")

```
  
Plots 20 and 21 are not displayed as they are redundant with plot 22.


**Urban Population by Year for Country Code CEB**:  
![](_dummyPy022.png)

**Urban Population by Year for Country Code ARB**:  
![](_dummyPy023.png)
  
###_Network Analysis in Python (Part I)_#  
  
Chapter 1 - Introduction to Networks  
  
Introduction to networks - examples like social networks, transportation networks, etc.:  
  
* Networks are a useful tool for modeling relationships between entities  
* Networks are defined by two sets of attributes; nodes and edges (these form a network, known in mathematics as a "graph")  
* The "networkx" library is frequently imported as nx  
* The start of an empty network (Graph) can be defined as G = nx.Graph()  
* Nodes can be added using G.add_nodes_from([nodeList])  
	* The call to G.nodes() provides a list of the nodes currently in the Graph  
* The call to G.add_edge(myTuple) will create a link (edge) as defined by myTuple  
	* The call to G.edges will be a tuple showing all the edges currently defined  
* Metadata can further be added to the nodes, such as using G.node[1]["label"] = "blue"  
	* The call to G.nodes(data=True) will then bring back the nodes and also the associated metadata (as dictionaries)  
* The nx.draw() function will draw out the Graph (requires plt.show() where plt is matplotlab.pyplot)  
  
Types of graphs:  
  
* Undirected graphs (e.g., Facebook) are typically drawn as a line with no arrows between two circles  
	* These are created empty as per above using nx.Graph()  
* Directed graphs (e.g., Twitter) are typically drawn as a line with an arrow (uni or bi directional depending on follow/follower) between two circles  
	* These are created empty using nx.DiGraph()  
* Multi graphs (e.g., trips between bike stations) are typically drawn as many arrows between two circles  
	* These are created empty using nx.MultiGraph()  
* Multi graphs can instead be created as weighted arrows, where the weight represents the frequency of occurrence (save memory, plotting, etc. vs. baseline)  
	* The weight may just be included as part of the metadata dictionary  
* Self-loops are nodes that connect to themselves, such as bike trips that start and end at the same station  
  
Network visualization - irrational ("looks like a hairball") and rational visualizations:  
  
* Three primary types of plots - Matrix plot, Arc plot, Circos plot  
* The Matrix plot is a simple row-column, with the square filled in if the edge between the nodes exists  
	* With an undirected Graph, the matrix will be symmetrical around the diagonal  
    * With a directed Graph, the matrix need not be symmetrical around the diagonal (the columns are what the arrow hits, the rows are what it is from)  
* The Arc plot is a transformation where the nodes are all along a single axis of the plot, with connections drawn as semi-circles  
* The Circos plot is a trasnformation of the Arc plot, but where the "axis" is converted in to a circle  
* The "nxviz" package, typically imported as "nv", allows for visualizing the Graphs the above types  
	* ap = nv.ArcPlot(G) ; ap.draw() ; plt.show() will create the ArcPlot  
  
Example code includes:  
```{r engine='python'}

## NEED TO MOCK UP T_sub from the above
import networkx as nx
import datetime

T_sub = nx.DiGraph()

T_sub.add_nodes_from([1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49])

T_sub.add_edges_from([(1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (1, 10), (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20), (1, 21), (1, 22), (1, 23), (1, 24), (1, 25), (1, 26), (1, 27), (1, 28), (1, 29), (1, 30), (1, 31), (1, 32), (1, 33), (1, 34), (1, 35), (1, 36), (1, 37), (1, 38), (1, 39), (1, 40), (1, 41), (1, 42), (1, 43), (1, 44), (1, 45), (1, 46), (1, 47), (1, 48), (1, 49), (16, 48), (16, 18), (16, 35), (16, 36), (18, 16), (18, 24), (18, 35), (18, 36), (19, 35), (19, 36), (19, 5), (19, 8), (19, 11), (19, 13), (19, 15), (19, 48), (19, 17), (19, 20), (19, 21), (19, 24), (19, 37), (19, 30), (19, 31), (28, 1), (28, 5), (28, 7), (28, 8), (28, 11), (28, 14), (28, 15), (28, 17), (28, 20), (28, 21), (28, 24), (28, 25), (28, 27), (28, 29), (28, 30), (28, 31), (28, 35), (28, 36), (28, 37), (28, 44), (28, 48), (28, 49), (36, 24), (36, 35), (36, 5), (36, 37), (37, 24), (37, 35), (37, 36), (39, 1), (39, 35), (39, 36), (39, 38), (39, 33), (39, 40), (39, 41), (39, 45), (39, 24), (42, 1), (43, 48), (43, 35), (43, 36), (43, 37), (43, 24), (43, 29), (43, 47), (45, 1), (45, 39), (45, 41)])

node_meta = [{'occupation': 'scientist', 'category': 'I'}, {'occupation': 'politician', 'category': 'P'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'politician', 'category': 'I'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'scientist', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'scientist', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'politician', 'category': 'P'}, {'occupation': 'scientist', 'category': 'P'}, {'occupation': 'scientist', 'category': 'P'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'politician', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'scientist', 'category': 'D'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'politician', 'category': 'P'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'P'}, {'occupation': 'scientist', 'category': 'I'}, {'occupation': 'scientist', 'category': 'P'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'scientist', 'category': 'P'}, {'occupation': 'politician', 'category': 'I'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'scientist', 'category': 'I'}, {'occupation': 'politician', 'category': 'I'}, {'occupation': 'scientist', 'category': 'I'}, {'occupation': 'scientist', 'category': 'P'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'politician', 'category': 'P'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'scientist', 'category': 'D'}, {'occupation': 'politician', 'category': 'P'}, {'occupation': 'celebrity', 'category': 'P'}, {'occupation': 'scientist', 'category': 'P'}, {'occupation': 'politician', 'category': 'P'}]

for x in range(len(T_sub.nodes())) :
    T_sub.node[T_sub.nodes()[x]]["occupation"] = node_meta[x]["occupation"]
    T_sub.node[T_sub.nodes()[x]]["category"] = node_meta[x]["category"]

edge_meta = [{'date': datetime.date(2012, 11, 17)}, {'date': datetime.date(2007, 6, 19)}, {'date': datetime.date(2014, 3, 18)}, {'date': datetime.date(2007, 3, 18)}, {'date': datetime.date(2011, 12, 19)}, {'date': datetime.date(2013, 12, 7)}, {'date': datetime.date(2009, 11, 9)}, {'date': datetime.date(2008, 10, 7)}, {'date': datetime.date(2008, 8, 14)}, {'date': datetime.date(2011, 3, 22)}, {'date': datetime.date(2014, 8, 3)}, {'date': datetime.date(2007, 5, 19)}, {'date': datetime.date(2009, 12, 13)}, {'date': datetime.date(2011, 4, 7)}, {'date': datetime.date(2013, 8, 2)}, {'date': datetime.date(2014, 11, 17)}, {'date': datetime.date(2013, 5, 20)}, {'date': datetime.date(2010, 12, 15)}, {'date': datetime.date(2010, 11, 27)}, {'date': datetime.date(2013, 9, 5)}, {'date': datetime.date(2013, 3, 1)}, {'date': datetime.date(2007, 7, 8)}, {'date': datetime.date(2010, 5, 23)}, {'date': datetime.date(2007, 9, 14)}, {'date': datetime.date(2013, 1, 24)}, {'date': datetime.date(2013, 6, 21)}, {'date': datetime.date(2010, 6, 28)}, {'date': datetime.date(2011, 12, 2)}, {'date': datetime.date(2010, 7, 24)}, {'date': datetime.date(2010, 7, 4)}, {'date': datetime.date(2013, 9, 28)}, {'date': datetime.date(2007, 3, 17)}, {'date': datetime.date(2013, 11, 7)}, {'date': datetime.date(2012, 8, 13)}, {'date': datetime.date(2009, 2, 19)}, {'date': datetime.date(2007, 3, 17)}, {'date': datetime.date(2011, 11, 15)}, {'date': datetime.date(2011, 12, 26)}, {'date': datetime.date(2010, 2, 14)}, {'date': datetime.date(2014, 4, 16)}, {'date': datetime.date(2010, 2, 28)}, {'date': datetime.date(2007, 11, 2)}, {'date': datetime.date(2008, 5, 17)}, {'date': datetime.date(2013, 11, 18)}, {'date': datetime.date(2010, 11, 14)}, {'date': datetime.date(2007, 8, 19)}, {'date': datetime.date(2012, 5, 11)}, {'date': datetime.date(2007, 10, 27)}, {'date': datetime.date(2009, 11, 14)}, {'date': datetime.date(2009, 4, 19)}, {'date': datetime.date(2007, 7, 14)}, {'date': datetime.date(2012, 5, 7)}, {'date': datetime.date(2014, 5, 4)}, {'date': datetime.date(2012, 6, 16)}, {'date': datetime.date(2012, 4, 25)}, {'date': datetime.date(2012, 6, 25)}, {'date': datetime.date(2010, 10, 14)}, {'date': datetime.date(2013, 4, 18)}, {'date': datetime.date(2013, 10, 6)}, {'date': datetime.date(2009, 8, 2)}, {'date': datetime.date(2008, 9, 23)}, {'date': datetime.date(2011, 11, 26)}, {'date': datetime.date(2010, 1, 22)}, {'date': datetime.date(2012, 6, 23)}, {'date': datetime.date(2013, 11, 20)}, {'date': datetime.date(2008, 7, 6)}, {'date': datetime.date(2009, 4, 12)}, {'date': datetime.date(2011, 12, 28)}, {'date': datetime.date(2012, 1, 22)}, {'date': datetime.date(2009, 1, 26)}, {'date': datetime.date(2012, 1, 13)}, {'date': datetime.date(2010, 9, 26)}, {'date': datetime.date(2013, 11, 14)}, {'date': datetime.date(2010, 7, 22)}, {'date': datetime.date(2013, 3, 17)}, {'date': datetime.date(2008, 10, 18)}, {'date': datetime.date(2008, 12, 9)}, {'date': datetime.date(2012, 1, 14)}, {'date': datetime.date(2012, 6, 28)}, {'date': datetime.date(2011, 10, 5)}, {'date': datetime.date(2007, 5, 19)}, {'date': datetime.date(2013, 1, 24)}, {'date': datetime.date(2008, 6, 28)}, {'date': datetime.date(2008, 5, 16)}, {'date': datetime.date(2013, 5, 8)}, {'date': datetime.date(2007, 7, 23)}, {'date': datetime.date(2010, 8, 4)}, {'date': datetime.date(2011, 10, 18)}, {'date': datetime.date(2011, 6, 2)}, {'date': datetime.date(2009, 5, 23)}, {'date': datetime.date(2010, 10, 14)}, {'date': datetime.date(2013, 7, 17)}, {'date': datetime.date(2008, 5, 19)}, {'date': datetime.date(2008, 3, 19)}, {'date': datetime.date(2010, 8, 14)}, {'date': datetime.date(2012, 6, 19)}, {'date': datetime.date(2013, 8, 12)}, {'date': datetime.date(2013, 7, 6)}, {'date': datetime.date(2014, 10, 11)}, {'date': datetime.date(2012, 7, 1)}, {'date': datetime.date(2013, 11, 5)}, {'date': datetime.date(2009, 11, 6)}, {'date': datetime.date(2009, 4, 19)}, {'date': datetime.date(2008, 8, 12)}, {'date': datetime.date(2012, 8, 8)}, {'date': datetime.date(2009, 8, 12)}, {'date': datetime.date(2012, 5, 27)}, {'date': datetime.date(2011, 9, 15)}, {'date': datetime.date(2013, 12, 19)}, {'date': datetime.date(2007, 12, 7)}, {'date': datetime.date(2008, 3, 4)}, {'date': datetime.date(2013, 9, 16)}, {'date': datetime.date(2009, 11, 22)}, {'date': datetime.date(2014, 9, 19)}, {'date': datetime.date(2008, 10, 20)}, {'date': datetime.date(2010, 12, 16)}, {'date': datetime.date(2013, 3, 15)}, {'date': datetime.date(2012, 4, 25)}, {'date': datetime.date(2009, 5, 10)}]

for x in range(len(T_sub.edges())) :
    a, b = T_sub.edges()[x]
    T_sub.edge[a][b]["date"] = edge_meta[x]["date"]


# Import necessary modules
import matplotlib.pyplot as plt


# Draw the graph to screen
nx.draw(T_sub)
# plt.show()
plt.savefig("_dummyPy024.png", bbox_inches="tight")



# Also need to mock up T
# Use T_sub for these
# Use a list comprehension to get the nodes of interest: noi
noi = [n for n, d in T_sub.nodes(data=True) if d['occupation'] == 'scientist']

# Use a list comprehension to get the edges of interest: eoi
eoi = [(u, v) for u, v, d in T_sub.edges(data=True) if d["date"] < datetime.date(2010, 1, 1)]


# Set the weight of the edge
T_sub.edge[1][10]["weight"] = 2

# Iterate over all the edges (with metadata)
for u, v, d in T_sub.edges(data=True):
    
    # Check if node 293 is involved
    # Make it node 23 instead
    if 23 in [u, v]:
        # Set the weight to 1.1
        T_sub.edge[u][v]["weight"] = 1.1


# Define find_selfloop_nodes()
def find_selfloop_nodes(G):
    """
    Finds all nodes that have self-loops in the graph G.
    """
    nodes_in_selfloops = []
    
    # Iterate over all the edges of G
    for u, v in G.edges():
    # Check if node u and node v are the same
        if u == v:
            # Append node u to nodes_in_selfloops
            nodes_in_selfloops.append(u)
            
    return nodes_in_selfloops

# Check whether number of self loops equals the number of nodes in self loops
# The mock-up above has no self-loops, so this is just for reference on how to find them
assert T_sub.number_of_selfloops() == len(find_selfloop_nodes(T_sub))


# Import nxviz
import nxviz as nv

# Create the MatrixPlot object: m
m = nv.MatrixPlot(T_sub)

# Draw m to the screen
m.draw()

# Display the plot
# plt.show()
plt.savefig("_dummyPy025.png", bbox_inches="tight")


# Convert T to a matrix format: A
A = nx.to_numpy_matrix(T_sub)

# Convert A back to the NetworkX form as a directed graph: T_conv
T_conv = nx.from_numpy_matrix(A, create_using=nx.DiGraph())

# Check that the `category` metadata field is lost from each node
for n, d in T_conv.nodes(data=True):
    assert 'category' not in d.keys()


# Import necessary modules
import matplotlib.pyplot as plt
from nxviz import CircosPlot

# Create the CircosPlot object: c
c = CircosPlot(T_sub)

# Draw c to the screen
c.draw()

# Display the plot
# plt.show()
plt.savefig("_dummyPy026.png", bbox_inches="tight")


# Import necessary modules
from nxviz import ArcPlot

# Create the un-customized ArcPlot object: a
a = ArcPlot(T_sub)

# Draw a to the screen
a.draw()

# Display the plot
# plt.show()
plt.savefig("_dummyPy027.png", bbox_inches="tight")


# Create the customized ArcPlot object: a2
a2 = ArcPlot(T_sub, node_order="category", node_color="category")

# Draw a2 to the screen
a2.draw()

# Display the plot
# plt.show()
plt.savefig("_dummyPy028.png", bbox_inches="tight")


```
  
**Example network plot**:  
![](_dummyPy024.png)

**Example MatrixPlot (network)**:  
![](_dummyPy025.png)

**Example CircosPlot (network)**:  
![](_dummyPy026.png)

**Example ArcPlot (network)**:  
![](_dummyPy027.png)

**Example ArcPlot (network) colored by category**:  
![](_dummyPy028.png)


***

Chapter 2 - Important Nodes  
  
Degree centrality - one method of determining important nodes:  
  
* Being connected to another node makes you a "neighbor" of that node  
* Degree centrality for a node is defined as "# neighbors I have" divided by "number of possible neighbors"  
	* Depending on self-loops, the "number of possible neighbors" may or may not include itself  
* Examples of high degree centrality include Twitter broadcasters, airport hubs, disease super-spreaders, and the like  
* Within the "networkx" package, G.neighbors(1) will give a list of all the neighbors of node 1  
	* Can instead run nx.degree_centrality(G)  # outputs a dictionary of node:centrality; self-loops are not considered  
  
Graph algorithms - path finding for optimization (e.g., shortest path between nodes, information or disease spread, etc.):  
  
* Breadth-first search (BFS) algorithm first developed in the 1950s for finding the shortest path out of a maze  
* Basically, take one of the points, then find its neighbors, then its neighbors' neighbors, etc., until the second point is found  
* Use G.edges(), G.nodes(), and automate the search for finding paths between any two given points  
  
Betweeness centrality - including the key concept of "all shortest paths":  
  
* All shortest paths is based on finding all shortest paths between all pairs of nodes  
* Betweeness centrality is defined as "# shortest paths running THROUGH node" divide by "all possible shortest paths"  
	* n.b. that a node and its neighbor is not counted in the numerator or the denominator; only paths of length 2+ are relevant  
* This helps to identify "bottleneck" nodes - points that if eliminated would significantly slow or even stop connections  
	* Can use nx.barbell_graph(m1=, m2=) # m1 will be the size of the barbells, m2 will be the number of connector nodes (zero would just connect a point on each dumbbell)  
    * Can use nx.betweenness_centrality(G) to get a dictionary of node:betweeness  
  
Example code includes:  
```{r engine='python'}

import networkx as nx
import matplotlib.pyplot as plt
import datetime


# DO NOT HAVE Graph T
# Make the same as above
T = nx.DiGraph()

T.add_nodes_from([1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49])

T.add_edges_from([(1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (1, 10), (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (1, 16), (1, 17), (1, 18), (1, 19), (1, 20), (1, 21), (1, 22), (1, 23), (1, 24), (1, 25), (1, 26), (1, 27), (1, 28), (1, 29), (1, 30), (1, 31), (1, 32), (1, 33), (1, 34), (1, 35), (1, 36), (1, 37), (1, 38), (1, 39), (1, 40), (1, 41), (1, 42), (1, 43), (1, 44), (1, 45), (1, 46), (1, 47), (1, 48), (1, 49), (16, 48), (16, 18), (16, 35), (16, 36), (18, 16), (18, 24), (18, 35), (18, 36), (19, 35), (19, 36), (19, 5), (19, 8), (19, 11), (19, 13), (19, 15), (19, 48), (19, 17), (19, 20), (19, 21), (19, 24), (19, 37), (19, 30), (19, 31), (28, 1), (28, 5), (28, 7), (28, 8), (28, 11), (28, 14), (28, 15), (28, 17), (28, 20), (28, 21), (28, 24), (28, 25), (28, 27), (28, 29), (28, 30), (28, 31), (28, 35), (28, 36), (28, 37), (28, 44), (28, 48), (28, 49), (36, 24), (36, 35), (36, 5), (36, 37), (37, 24), (37, 35), (37, 36), (39, 1), (39, 35), (39, 36), (39, 38), (39, 33), (39, 40), (39, 41), (39, 45), (39, 24), (42, 1), (43, 48), (43, 35), (43, 36), (43, 37), (43, 24), (43, 29), (43, 47), (45, 1), (45, 39), (45, 41)])

node_meta = [{'occupation': 'scientist', 'category': 'I'}, {'occupation': 'politician', 'category': 'P'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'politician', 'category': 'I'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'scientist', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'scientist', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'politician', 'category': 'P'}, {'occupation': 'scientist', 'category': 'P'}, {'occupation': 'scientist', 'category': 'P'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'politician', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'scientist', 'category': 'D'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'politician', 'category': 'P'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'P'}, {'occupation': 'scientist', 'category': 'I'}, {'occupation': 'scientist', 'category': 'P'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'scientist', 'category': 'P'}, {'occupation': 'politician', 'category': 'I'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'scientist', 'category': 'I'}, {'occupation': 'politician', 'category': 'I'}, {'occupation': 'scientist', 'category': 'I'}, {'occupation': 'scientist', 'category': 'P'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'politician', 'category': 'P'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'scientist', 'category': 'D'}, {'occupation': 'politician', 'category': 'P'}, {'occupation': 'celebrity', 'category': 'P'}, {'occupation': 'scientist', 'category': 'P'}, {'occupation': 'politician', 'category': 'P'}]

for x in range(len(T.nodes())) :
    T.node[T.nodes()[x]]["occupation"] = node_meta[x]["occupation"]
    T.node[T.nodes()[x]]["category"] = node_meta[x]["category"]

edge_meta = [{'date': datetime.date(2012, 11, 17)}, {'date': datetime.date(2007, 6, 19)}, {'date': datetime.date(2014, 3, 18)}, {'date': datetime.date(2007, 3, 18)}, {'date': datetime.date(2011, 12, 19)}, {'date': datetime.date(2013, 12, 7)}, {'date': datetime.date(2009, 11, 9)}, {'date': datetime.date(2008, 10, 7)}, {'date': datetime.date(2008, 8, 14)}, {'date': datetime.date(2011, 3, 22)}, {'date': datetime.date(2014, 8, 3)}, {'date': datetime.date(2007, 5, 19)}, {'date': datetime.date(2009, 12, 13)}, {'date': datetime.date(2011, 4, 7)}, {'date': datetime.date(2013, 8, 2)}, {'date': datetime.date(2014, 11, 17)}, {'date': datetime.date(2013, 5, 20)}, {'date': datetime.date(2010, 12, 15)}, {'date': datetime.date(2010, 11, 27)}, {'date': datetime.date(2013, 9, 5)}, {'date': datetime.date(2013, 3, 1)}, {'date': datetime.date(2007, 7, 8)}, {'date': datetime.date(2010, 5, 23)}, {'date': datetime.date(2007, 9, 14)}, {'date': datetime.date(2013, 1, 24)}, {'date': datetime.date(2013, 6, 21)}, {'date': datetime.date(2010, 6, 28)}, {'date': datetime.date(2011, 12, 2)}, {'date': datetime.date(2010, 7, 24)}, {'date': datetime.date(2010, 7, 4)}, {'date': datetime.date(2013, 9, 28)}, {'date': datetime.date(2007, 3, 17)}, {'date': datetime.date(2013, 11, 7)}, {'date': datetime.date(2012, 8, 13)}, {'date': datetime.date(2009, 2, 19)}, {'date': datetime.date(2007, 3, 17)}, {'date': datetime.date(2011, 11, 15)}, {'date': datetime.date(2011, 12, 26)}, {'date': datetime.date(2010, 2, 14)}, {'date': datetime.date(2014, 4, 16)}, {'date': datetime.date(2010, 2, 28)}, {'date': datetime.date(2007, 11, 2)}, {'date': datetime.date(2008, 5, 17)}, {'date': datetime.date(2013, 11, 18)}, {'date': datetime.date(2010, 11, 14)}, {'date': datetime.date(2007, 8, 19)}, {'date': datetime.date(2012, 5, 11)}, {'date': datetime.date(2007, 10, 27)}, {'date': datetime.date(2009, 11, 14)}, {'date': datetime.date(2009, 4, 19)}, {'date': datetime.date(2007, 7, 14)}, {'date': datetime.date(2012, 5, 7)}, {'date': datetime.date(2014, 5, 4)}, {'date': datetime.date(2012, 6, 16)}, {'date': datetime.date(2012, 4, 25)}, {'date': datetime.date(2012, 6, 25)}, {'date': datetime.date(2010, 10, 14)}, {'date': datetime.date(2013, 4, 18)}, {'date': datetime.date(2013, 10, 6)}, {'date': datetime.date(2009, 8, 2)}, {'date': datetime.date(2008, 9, 23)}, {'date': datetime.date(2011, 11, 26)}, {'date': datetime.date(2010, 1, 22)}, {'date': datetime.date(2012, 6, 23)}, {'date': datetime.date(2013, 11, 20)}, {'date': datetime.date(2008, 7, 6)}, {'date': datetime.date(2009, 4, 12)}, {'date': datetime.date(2011, 12, 28)}, {'date': datetime.date(2012, 1, 22)}, {'date': datetime.date(2009, 1, 26)}, {'date': datetime.date(2012, 1, 13)}, {'date': datetime.date(2010, 9, 26)}, {'date': datetime.date(2013, 11, 14)}, {'date': datetime.date(2010, 7, 22)}, {'date': datetime.date(2013, 3, 17)}, {'date': datetime.date(2008, 10, 18)}, {'date': datetime.date(2008, 12, 9)}, {'date': datetime.date(2012, 1, 14)}, {'date': datetime.date(2012, 6, 28)}, {'date': datetime.date(2011, 10, 5)}, {'date': datetime.date(2007, 5, 19)}, {'date': datetime.date(2013, 1, 24)}, {'date': datetime.date(2008, 6, 28)}, {'date': datetime.date(2008, 5, 16)}, {'date': datetime.date(2013, 5, 8)}, {'date': datetime.date(2007, 7, 23)}, {'date': datetime.date(2010, 8, 4)}, {'date': datetime.date(2011, 10, 18)}, {'date': datetime.date(2011, 6, 2)}, {'date': datetime.date(2009, 5, 23)}, {'date': datetime.date(2010, 10, 14)}, {'date': datetime.date(2013, 7, 17)}, {'date': datetime.date(2008, 5, 19)}, {'date': datetime.date(2008, 3, 19)}, {'date': datetime.date(2010, 8, 14)}, {'date': datetime.date(2012, 6, 19)}, {'date': datetime.date(2013, 8, 12)}, {'date': datetime.date(2013, 7, 6)}, {'date': datetime.date(2014, 10, 11)}, {'date': datetime.date(2012, 7, 1)}, {'date': datetime.date(2013, 11, 5)}, {'date': datetime.date(2009, 11, 6)}, {'date': datetime.date(2009, 4, 19)}, {'date': datetime.date(2008, 8, 12)}, {'date': datetime.date(2012, 8, 8)}, {'date': datetime.date(2009, 8, 12)}, {'date': datetime.date(2012, 5, 27)}, {'date': datetime.date(2011, 9, 15)}, {'date': datetime.date(2013, 12, 19)}, {'date': datetime.date(2007, 12, 7)}, {'date': datetime.date(2008, 3, 4)}, {'date': datetime.date(2013, 9, 16)}, {'date': datetime.date(2009, 11, 22)}, {'date': datetime.date(2014, 9, 19)}, {'date': datetime.date(2008, 10, 20)}, {'date': datetime.date(2010, 12, 16)}, {'date': datetime.date(2013, 3, 15)}, {'date': datetime.date(2012, 4, 25)}, {'date': datetime.date(2009, 5, 10)}]

for x in range(len(T.edges())) :
    a, b = T.edges()[x]
    T.edge[a][b]["date"] = edge_meta[x]["date"]



# Define nodes_with_m_nbrs()
def nodes_with_m_nbrs(G, m):
    """
    Returns all nodes in graph G that have m neighbors.
    """
    nodes = set()
    
    # Iterate over all nodes in G
    for n in G.nodes():
        # Check if the number of neighbors of n matches m
        if len(G.neighbors(n)) == m:
            # Add the node n to the set
            nodes.add(n)
    # Return the nodes with m neighbors
    return nodes

# Compute and print all nodes in T that have 3 neighbors
three_nbrs = nodes_with_m_nbrs(T, 3)
print(three_nbrs)


# Compute the degree of every node: degrees
degrees = [len(T.neighbors(n)) for n in T.nodes()]

# Print the degrees
print(degrees)


# Compute the degree centrality of the Twitter network: deg_cent
deg_cent = nx.degree_centrality(T)

# Plot a histogram of the degree centrality distribution of the graph.
plt.figure()
plt.hist(list(deg_cent.values()))
# plt.show()
plt.savefig("_dummyPy029.png", bbox_inches="tight")
plt.clf()

# Plot a histogram of the degree distribution of the graph
plt.figure()
plt.hist(degrees)
# plt.show()
plt.savefig("_dummyPy030.png", bbox_inches="tight")
plt.clf()

# Plot a scatter plot of the centrality distribution and the degree distribution
plt.figure()
plt.scatter(degrees, list(deg_cent.values()))
# plt.show()
plt.savefig("_dummyPy031.png", bbox_inches="tight")
plt.clf()


def path_exists(G, node1, node2):
    """
    This function checks whether a path exists between two nodes (node1, node2) in graph G.
    """
    visited_nodes = set()
    queue = [node1]
    
    for node in queue:  
        neighbors = G.neighbors(node)
        if node2 in neighbors:
            print('Path exists between nodes {0} and {1}'.format(node1, node2))
            return True
            break
            
        else:
            visited_nodes.add(node)
            queue.extend([n for n in neighbors if n not in visited_nodes])
            
        # Check to see if the final element of the queue has been reached
        if node == queue[-1]:
            print('Path does not exist between nodes {0} and {1}'.format(node1, node2))
            
            # Place the appropriate return statement
            return False


# Compute the betweenness centrality of T: bet_cen
bet_cen = nx.betweenness_centrality(T)

# Compute the degree centrality of T: deg_cen
deg_cen = nx.degree_centrality(T)

# Create a scatter plot of betweenness centrality and degree centrality
plt.scatter(list(bet_cen.values()), list(deg_cen.values()))

# Display the plot
# plt.show()
plt.savefig("_dummyPy032.png", bbox_inches="tight")
plt.clf()


# Define find_nodes_with_highest_deg_cent()
def find_nodes_with_highest_deg_cent(G):
    # Compute the degree centrality of G: deg_cent
    deg_cent = nx.degree_centrality(G)
    
    # Compute the maximum degree centrality: max_dc
    max_dc = max(list(deg_cent.values()))
    
    nodes = set()
    
    # Iterate over the degree centrality dictionary
    for k, v in deg_cent.items():
        # Check if the current value has the maximum degree centrality
        if v == max_dc:
            # Add the current node to the set of nodes
            nodes.add(k)
            
    return nodes
    
# Find the node(s) that has the highest degree centrality in T: top_dc
top_dc = find_nodes_with_highest_deg_cent(T)
print(top_dc)

# Write the assertion statement
for node in top_dc:
    assert nx.degree_centrality(T)[node] == max(nx.degree_centrality(T).values())


# Define find_node_with_highest_bet_cent()
def find_node_with_highest_bet_cent(G):
    # Compute betweenness centrality: bet_cent
    bet_cent = nx.betweenness_centrality(G)
    
    # Compute maximum betweenness centrality: max_bc
    max_bc = max(list(bet_cent.values()))
    
    nodes = set()
    
    # Iterate over the betweenness centrality dictionary
    for k, v in bet_cent.items():
        # Check if the current value has the maximum betweenness centrality
        if v == max_bc:
            # Add the current node to the set of nodes
            nodes.add(k)
            
    return nodes

# Use that function to find the node(s) that has the highest betweenness centrality in the network: top_bc
top_bc = find_node_with_highest_bet_cent(T)
print(top_bc)

# Write an assertion statement that checks that the node(s) is/are correctly identified.
for node in top_bc:
    assert nx.betweenness_centrality(T)[node] == max(nx.betweenness_centrality(T).values())


```
  
  
**Histogram of degree centrality**:  
![](_dummyPy029.png)
  
**Histogram of degree distribution**:  
![](_dummyPy030.png)

**Scatter plot of degree centrality vs degree distribution**:  
![](_dummyPy031.png)

**Scatter plot of degree centrality vs between centrality**:  
![](_dummyPy032.png)
  
  
***

Chapter 3 - Structures
  
Cliques and communities - idea of tightly-knit groups:  
  
* In network theory, a "clique" is a set of nodes that are full connected to each other by way of an edge  
* Triangle closures are the idea that if A and B are connected and if A and C are connected, but that B and C are not connected, then connecting B and C will form a "clique"  
* A helpful package "itertools" has a function "combinations" that can help to iterate over many combinations (rather than a double for loop)  
	* For example, combinations("ABC", 2) will create ("A", "B"), ("A", "C"), ("B", "C")  
    * This will be an iterable, but it will not print by itself  
  
Maximal cliques - defined as a clique that when expanded by one node is no longer a clique:  
  
* Basically, there is no single extension (one extra edge) that would make the clique larger  
* Communities are an expansion of the idea of communities  
* One possible definition of "communities" would be maximal cliques that are of at least size x and that have at least y members in common  
* The find_cliques() function will find all of the maximal cliques in the network data  
  
Sub-graphs - sometimes helpful to view just a small portion of a larger graph:  
  
* Can use commands such as Gnew = G.subgraph(myNodes)  # will just contain the nodes of interest, as well as their edges to each other  
* Can then look at nx.draw(Gnew, with_labels=True) to request that labels be included on the visual  
  
Example code includes:  
```{r engine='python'}

from itertools import combinations

# Define is_in_triangle() 
def is_in_triangle(G, n):
    """
    Checks whether a node `n` in graph `G` is in a triangle relationship or not. 
    Returns a boolean.
    """
    in_triangle = False
    
    # Iterate over all possible triangle relationship combinations
    for n1, n2 in combinations(G.neighbors(n), 2):
        # Check if an edge exists between n1 and n2
        if G.has_edge(n1, n2):
            in_triangle = True
            break
    return in_triangle

# DO NOT HAVE T (make randomly, minus metadata)
import networkx as nx
import random
import numpy as np
import matplotlib.pyplot as plt

T = nx.Graph()
T.add_nodes_from([x for x in range(1, 31)])
np.random.seed(170530)
n1 = np.random.choice(range(1, 31), size=100, replace=True)
n2 = np.random.choice(range(1, 31), size=100, replace=True)

# Require that first be less than second
edge_list = [(min(x, y), max(x, y)) for x, y in zip(n1, n2) if x != y]
T.add_edges_from(edge_list)


# APPEARS THAT the set() makes sure to keep a sorted and unique list; if a = set(1, 2) and a.add(1) is run, than a will still be {1, 2}
# Can remove items from the set using a.remove() and can add items to the set using a.add()

# Write a function that identifies all nodes in a triangle relationship with a given node.
def nodes_in_triangle(G, n):
    """
    Returns the nodes in a graph `G` that are involved in a triangle relationship with the node `n`.
    """
    triangle_nodes = set([n])
    
    # Iterate over all possible triangle relationship combinations
    for n1, n2 in combinations(G.neighbors(n), 2):
        # Check if n1 and n2 have an edge between them
        if G.has_edge(n1, n2):
            # Add n1 to triangle_nodes
            triangle_nodes.add(n1)
            
            # Add n2 to triangle_nodes
            triangle_nodes.add(n2)
            
    return triangle_nodes
    
# Write the assertion statement
assert len(nodes_in_triangle(T, 1)) == 5  # happens to be what the RNG generated in this case


# Define node_in_open_triangle()
def node_in_open_triangle(G, n):
    """
    Checks whether pairs of neighbors of node `n` in graph `G` are in an 'open triangle' relationship with node `n`.
    """
    in_open_triangle = False
    
    # Iterate over all possible triangle relationship combinations
    for n1, n2 in combinations(G.neighbors(n), 2):
        # Check if n1 and n2 do NOT have an edge between them
        if not G.has_edge(n1, n2):
            in_open_triangle = True
            break
            
    return in_open_triangle

# Compute the number of open triangles in T
num_open_triangles = 0

# Iterate over all the nodes in T
for n in T.nodes():
    
    # Check if the current node is in an open triangle
    if node_in_open_triangle(T, n):
        
        # Increment num_open_triangles
        num_open_triangles += 1
    

print(num_open_triangles)


# Define maximal_cliques()
def maximal_cliques(G, size):
    """
    Finds all maximal cliques in graph `G` that are of size `size`.
    """
    mcs = []
    for clique in nx.find_cliques(G):
        if len(clique) == size:
            mcs.append(clique)
    return mcs

# Check that there are 33 maximal cliques of size 3 in the graph T
assert len(maximal_cliques(T, 3)) == 26  # happens to be what the RNG returns in this case


# Define get_nodes_and_nbrs()
def get_nodes_and_nbrs(G, nodes_of_interest):
    """
    Returns a subgraph of the graph `G` with only the `nodes_of_interest` and their neighbors.
    """
    nodes_to_draw = []
    
    # Iterate over the nodes of interest
    for n in nodes_of_interest:
        # Append the nodes of interest to nodes_to_draw
        nodes_to_draw.append(n)
        
        # Iterate over all the neighbors of node n
        for nbr in G.neighbors(n):
            # Append the neighbors of n to nodes_to_draw
            nodes_to_draw.append(nbr)
        
    return G.subgraph(nodes_to_draw)


# Extract the subgraph with the nodes of interest: T_draw
nodes_of_interest = [8, 24, 26]
T_draw = get_nodes_and_nbrs(T, nodes_of_interest)

# Draw the subgraph to the screen
nx.draw(T_draw, with_labels=True)
# plt.show()
plt.savefig("_dummyPy033.png", bbox_inches="tight")


# Extract the nodes of interest: nodes
node_meta = [{'occupation': 'scientist', 'category': 'I'}, {'occupation': 'politician', 'category': 'P'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'politician', 'category': 'I'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'scientist', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'scientist', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'politician', 'category': 'P'}, {'occupation': 'scientist', 'category': 'P'}, {'occupation': 'scientist', 'category': 'P'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'politician', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'scientist', 'category': 'D'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'celebrity', 'category': 'D'}, {'occupation': 'politician', 'category': 'D'}, {'occupation': 'politician', 'category': 'P'}, {'occupation': 'celebrity', 'category': 'I'}, {'occupation': 'celebrity', 'category': 'P'}, {'occupation': 'scientist', 'category': 'I'}, {'occupation': 'scientist', 'category': 'P'}]

for x in range(len(T.nodes())) :
    T.node[T.nodes()[x]]["occupation"] = node_meta[x]["occupation"]
    T.node[T.nodes()[x]]["category"] = node_meta[x]["category"]


nodes = [n for n, d in T.nodes(data=True) if d['occupation'] == 'celebrity']

# Create the set of nodes: nodeset
nodeset = set(nodes)

# Iterate over nodes
for n in nodeset:
    
    # Compute the neighbors of n: nbrs
    nbrs = T.neighbors(n)
    
    # Compute the union of nodeset and nbrs: nodeset
    nodeset = nodeset.union(nbrs)


# Compute the subgraph using nodeset: T_sub
T_sub = T.subgraph(nodeset)

# Draw T_sub to the screen
nx.draw(T_sub, with_labels=True)
# plt.show()
plt.savefig("_dummyPy034.png", bbox_inches="tight")

```
  
  
**Example Sub-graph (anything touching any of [8, 24, 26]**:  
![](_dummyPy033.png)

**Example Sub-graph (specified "occupation" in metadata)**:  
![](_dummyPy034.png)
  
***
  
Chapter 4 - Case Study  
  
Case study introduction - GitHub collaborator data:  
  
* The data will be a GitHub use collaboration network  
* The nodes will be the users and the edges will reflect collaboration on 1+ GitHub repositories  
* Goals include 1) analyze structure, 2) visualize graph, and 3) build simple recommendation systems  
  
Case Study Part II - Visualization using the nxviz API:  
  
* circ = nv.CircosPlot(G) ; circ.draw()  # Create the Circos plot  
* Additionally, will use the "connected component subgraph" features of networkx  
* A connected component subragph is defined as a group of nodes connected to each other (perhaps not as a clique; may be through hubs) but with no connection to some other group of nodes  
	* nx.connected_component_subgraph(G)  # forms a generator object; cast as list to read them  
  
Case Study Part III: Cliques:  
  
* Simplest clique is an edge  
* Simplest complex clique is a triangle  
* Maximal clique is a clique that cannot be extended just be adding one additional node  
* The nx.find_cliques(G) will find all of the maximal cliques in G  
  
Case Study Part IV: Additional Tasks (building a recommender):  
  
* Find important users (share with the most other users - degree_centrality)  
* Find largest communities of collaborators (maximal cliques)  
* Build a collaboration recommendation system (open triangles)  
  
Example code includes:  
```{r engine='python'}

# Import necessary modules
import matplotlib.pyplot as plt
import networkx as nx 
import numpy as np
import random


# DO NOT HAVE Github collaborator graph "G"
# Dummy up the data - 20 each of 2 "flavors"
G = nx.Graph()
G.add_nodes_from([x for x in range(1, 41)])
np.random.seed(170531)

# Add edges for 1-20 with preference that they match to themselves
n1 = np.random.choice(range(1, 21), size=100, replace=True)
n2 = np.random.choice(range(1, 21), size=90, replace=True)
n3 = np.random.choice(range(21, 41), size=10, replace=True)

# Require that first be less than second
edge_list = [(min(x, y), max(x, y)) for x, y in zip(n1, np.append(n2, n3)) if x != y]
G.add_edges_from(edge_list)


# Add edges for 21-40 with preference that they match to themselves
n1 = np.random.choice(range(21, 41), size=50, replace=True)
n2 = np.random.choice(range(21, 41), size=40, replace=True)
n3 = np.random.choice(range(1, 21), size=10, replace=True)

# Require that first be less than second
edge_list = [(min(x, y), max(x, y)) for x, y in zip(n1, np.append(n2, n3)) if x != y]
G.add_edges_from(edge_list)

# Create two groupings for the nodes
node_meta = [{'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type01'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}, {'grouping': 'type02'}]

for x in range(len(G.nodes())) :
    G.node[G.nodes()[x]]["grouping"] = node_meta[x]["grouping"]



# Plot the degree distribution of the GitHub collaboration network
plt.hist(list(nx.degree_centrality(G).values()))
# plt.show()
plt.savefig("_dummyPy035.png", bbox_inches="tight")
plt.clf()



# Plot the degree distribution of the GitHub collaboration network
plt.hist(list(nx.betweenness_centrality(G).values()))
# plt.show()
plt.savefig("_dummyPy036.png", bbox_inches="tight")
plt.clf()


# Import necessary modules
from nxviz import MatrixPlot


# Calculate the largest connected component subgraph: largest_ccs
largest_ccs = sorted(nx.connected_component_subgraphs(G), key=lambda x: len(x))[-1]

# Create the customized MatrixPlot object: h
h = MatrixPlot(largest_ccs, node_grouping="grouping")

# Draw the MatrixPlot to the screen
h.draw()
# plt.show()
plt.savefig("_dummyPy037.png", bbox_inches="tight")


# Import necessary modules
from nxviz.plots import ArcPlot


# Iterate over all the nodes in G, including the metadata
for n, d in G.nodes(data=True):
    
    # Calculate the degree of each node: G.node[n]['degree']
    G.node[n]['degree'] = nx.degree(G, n)
    
# Create the ArcPlot object: a
a = ArcPlot(G, node_order="degree")

# Draw the ArcPlot to the screen
a.draw()
# plt.show()
plt.savefig("_dummyPy038.png", bbox_inches="tight")


# Import necessary modules
from nxviz import CircosPlot
 
 
# Iterate over all the nodes, including the metadata
for n, d in G.nodes(data=True):
    
    # Calculate the degree of each node: G.node[n]['degree']
    G.node[n]['degree'] = nx.degree(G, n)

# Create the CircosPlot object: c
c = CircosPlot(G, node_order="degree", node_grouping="grouping", node_color="grouping")

# Draw the CircosPlot object to the screen
c.draw()
# plt.show()
plt.savefig("_dummyPy039.png", bbox_inches="tight")


# Calculate the maximal cliques in G: cliques
cliques = nx.find_cliques(G)

# Count and print the number of maximal cliques in G
print(len(list(cliques)))


# Find the author(s) that are part of the largest maximal clique: largest_clique
largest_clique = sorted(nx.find_cliques(G), key=lambda x:len(x))[-1]

# Create the subgraph of the largest_clique: G_lc
G_lc = G.subgraph(largest_clique)

# Create the CircosPlot object: c
c = CircosPlot(G_lc)

# Draw the CircosPlot to the screen
c.draw()
# plt.show()
plt.savefig("_dummyPy040.png", bbox_inches="tight")


# Compute the degree centralities of G: deg_cent
deg_cent = nx.degree_centrality(G)

# Compute the maximum degree centrality: max_dc
max_dc = max(deg_cent.values())

# Find the user(s) that have collaborated the most: prolific_collaborators
prolific_collaborators = [n for n, dc in deg_cent.items() if dc == max_dc]

# Print the most prolific collaborator(s)
print(prolific_collaborators)


# Identify the largest maximal clique: largest_max_clique
largest_max_clique = set(sorted(nx.find_cliques(G), key=lambda x: len(x))[-1])

# Create a subgraph from the largest_max_clique: G_lmc
G_lmc = G.subgraph(largest_max_clique)

# Go out 1 degree of separation
for node in G_lmc.nodes():
    G_lmc.add_nodes_from(G.neighbors(node))
    G_lmc.add_edges_from(zip([node]*len(G.neighbors(node)), G.neighbors(node)))

# Record each node's degree centrality score
for n in G_lmc.nodes():
    G_lmc.node[n]['degree centrality'] = nx.degree_centrality(G_lmc)[n]
        
# Create the ArcPlot object: a
a = ArcPlot(G_lmc, node_order = "degree centrality")

# Draw the ArcPlot to the screen
a.draw()
# plt.show()
plt.savefig("_dummyPy041.png", bbox_inches="tight")


# Import necessary modules
from itertools import combinations
from collections import defaultdict

# Initialize the defaultdict: recommended
recommended = defaultdict(int)

# Iterate over all the nodes in G
for n, d in G.nodes(data=True):
    
    # Iterate over all possible triangle relationship combinations
    for n1, n2 in combinations(G.neighbors(n), 2):
        
        # Check whether n1 and n2 do not have an edge
        if not G.has_edge(n1, n2):
            
            # Increment recommended
            recommended[(n1, n2)] += 1


# Identify the top 10 pairs of users
all_counts = sorted(recommended.values())
top10_pairs = [pair for pair, count in recommended.items() if count > all_counts[-10]]
print(top10_pairs)

```
  
  
**Case study - degree distribution**:  
![](_dummyPy035.png)

**Case study - betweenness centrality**:  
![](_dummyPy036.png)

**Case study - MatrixPlot**:  
![](_dummyPy037.png)

**Case study - ArcPlot**:  
![](_dummyPy038.png)

**Case study - CircosPlot**:  
![](_dummyPy039.png)

**Case Study - CircosPlot (for largest clique)**:  
![](_dummyPy040.png)

**Case Study - ArcPlot (ordered by degree centrality)**:  
![](_dummyPy041.png)
  
  
###_Network Analysis in Python (Part II)_#  
  
Chapter 1 - Bipartite Graphs and Recommendation Systems  
  

  
  
  
## Python Import and Clean Data  
###_Importing Data in Python (Part I)_#
  
Chapter 1 - Introduction and flat files  
  
Welcome to the course - importing from 1) flat files, 2) other native data, and 3) relational databases:  
  
* Begin by looking at text files - plain text and table data (each row is an observation)  
* The python "open()" function is the easiest way to look at a file  
	* filename = "myFile" ; fPointer = open(filename, mode="r"), fText = fPointer.read(); file.close()  
    * print(fText)  # All the text will be printed to the console  
* Alternately, can use "with open("myFile", mode="r") as fPointer:  # the file will close when the with ends  
	* The "with" statement is known as a context manager  
    * The use of a context manager is a best practice, since you never have to worry about closing a file  
  
The importance of flat files in data science:  
  
* Flat files are text files containing records (which is to say "table data" with each row being an observation and each column being an attribute)  
* Flat files may also have a header describing the columns of the data (important to know for the data import process)  
* Flat files are especially relevant for data science since they are a nice way to store tidy data  
* Flat files may be separated by delimitors (comma, tab, etc.)   
* Imports may be done through numpy or pandas  
  
Importing flat files using numpy (only for data that is purely numerical):  
  
* numpy arrays are the Python standard for storing numerical data; efficient, fast, and clean, and also often essential for other packages  
* numpy.loadtxt() - import numpy as np; myData=np.loadtxt("myFile", delimiter=<myDelim>, skiprows=0, usecols=myList, dtype=)  # default delimiter is any whitespace, default skip-rows is 0, default usecols is ALL, dtype=str will load as strings  
	* Tends to break down when loading mixed data types; these are typically better for pandas  
* numpy.genfromtxt() is another option, though only briefly mentioned in this course  
  
Importing flat files using pandas - create 2-D data structures with columns of different data types:  
  
* The pandas package is designed to help elevate Python from data munging (where it has always been excellent) to the full data analysis workflow (which might otherwise require R)  
* The pandas DataFrame is modeled off the data frame in R; same idea of observations (rows) and variables (columns)  
* The pandas package is the current best practice for loading data from flat files in to Python  
* In the most basic usage, myData = pd.read_csv("myFile")  # assumes import pandas as pd called previously  
	* myData.head()  # shows the first 5 rows of the data  
    * myData.values # This will be the associated numpy array  
  
Example code includes:  
```{r engine='python'}

# put in directory ./PythonInputFiles/
# moby_dick.txt (converted to romeo-full.txt)
# digits.csv (using mnist_test.csv)
# digits_header.txt (skipped)
# seaslug.txt (downloaded)
# titanic.csv (converted from R)
# titanic_corrupt.txt (skipped)

myPath = "./PythonInputFiles/"


# NEED FILE "moby_dick.txt" (used "romeo-full.txt" instead)
# Open a file: file
file = open(myPath + "romeo-full.txt", mode="r")

# Print it
print(file.read())

# Check whether file is closed
print(file.closed)

# Close file
file.close()

# Check whether file is closed
print(file.closed)


# Read & print the first 3 lines
with open(myPath + "romeo-full.txt") as file:
    print(file.readline())
    print(file.readline())
    print(file.readline())


# NEED DIGIT RECOGNITION SITE - see http://yann.lecun.com/exdb/mnist/
# Import package
import numpy as np

# Assign filename to variable: file
file = myPath + 'mnist_test.csv'

# Load file as array: digits
digits = np.loadtxt(file, delimiter=",")

# Print datatype of digits
print(type(digits))

# Select and reshape a row
im = digits[21, 1:]
im_sq = np.reshape(im, (28, 28))


import matplotlib.pyplot as plt  # so the plotting below can be done

# Plot reshaped data (matplotlib.pyplot already loaded as plt)
plt.imshow(im_sq, cmap='Greys', interpolation='nearest')
# plt.show()
plt.savefig("_dummyPy042.png", bbox_inches="tight")
plt.clf()

# File should be tab-delimited and with a header row (for the skiprows=1)
# Assign the filename: file
# file = 'digits_header.txt'

# Load the data: data
# data = np.loadtxt(file, delimiter="\t", skiprows=1, usecols=[0, 2])

# Print data
# print(data)


# NEED FILE FROM http://www.stat.ucla.edu/projects/datasets/seaslug-explanation.html
# Should be floats with a single text header row, and tab-delimited

# Assign filename: file
file = myPath + 'seaslug.txt'

# Import file: data
data = np.loadtxt(file, delimiter='\t', dtype=str)

# Print the first element of data
print(data[0])

# Import data as floats and skip the first row: data_float
data_float = np.loadtxt(file, delimiter="\t", dtype=float, skiprows=1)

# Print the 10th element of data_float
print(data_float[9])

# Plot a scatterplot of the data
plt.scatter(data_float[:, 0], data_float[:, 1])
plt.xlabel('time (min.)')
plt.ylabel('percentage of larvae')
# plt.show()
plt.savefig("_dummyPy043.png", bbox_inches="tight")
plt.clf()

# NEED FILE "titanic.csv"
# Idea is that np.genfromtxt() and np.recfromcsv() can accept mixed data types through making each row its own array; dtype=None lets Python pick the data type by column

# Assign the filename: file
# file = myPath + 'titanic.csv'

# Import file using np.recfromcsv: d
# d=np.recfromcsv(file)   # This is like np.genfromtxt() with defaults set to dtype=None, delimiter=",", names=True

# Print out first three entries of d
# print(d[:3])


# PassengerId-Survived-Pclass-Sex-Age-SibSp-Parch-Ticket-Fare-Cabin-Embarked
# Import pandas as pd
import pandas as pd

# Assign the filename: file
file = myPath + 'titanic.csv'

# Read the file into a DataFrame: df
df = pd.read_csv(file)

# View the head of the DataFrame
print(df.head())



# Assign the filename: file
file = myPath + 'mnist_test.csv'

# Read the first 5 rows of the file into a DataFrame: data
data=pd.read_csv(file, nrows=5, header=None)

# Build a numpy array from the DataFrame: data_array
data_array = data.values

# Print the datatype of data_array to the shell
print(type(data_array))


# Assign filename: file
# file = 'titanic_corrupt.txt'

# Import file: data
# data = pd.read_csv(file, sep="\t", comment="#", na_values=["Nothing"])

# Print the head of the DataFrame
# print(data.head())

# Plot 'Age' variable in a histogram
# pd.DataFrame.hist(data[['Age']])
# plt.xlabel('Age (years)')
# plt.ylabel('count')
# plt.show()


```
  
**Example Image Recognition Digit**:  
![](_dummyPy042.png)

**Sea Slug Data**:  
![](_dummyPy043.png)
  
  
  
***
  
Chapter 2 - Importing data from other file types  
  
Introduction to other files types - Excel spreadsheets, MATLAB, SAS, Stata, HDF5 (becoming a more relevant format for saving data):  
  
* There are also "pickled" files which are native to Python; idea is that you can serialize files like dictionaries or lists for later use in Python (rather than using json which is more human-readable)  
* Opening a pickled file: import pickle; with open("myFile,pkl", mode="rb") as file: data=pickle.load(file)  
* Excel files can generally be opened using data=pd.ExcelFile("myExcel.xlsx")  # assumes previous import pandas as pd; automatically loads the Excel sheet as a data frame  
    * data.sheet_names  # provides a list of the sheet names  
    * df1 = data.parse("sheetName")  # can pass either the index as a float or the sheet name as a string  
    * Can also skip rows and import only certain columns  
  
Importing SAS/Stata files using pandas:  
  
* SAS: Statistical Analysis System is common for business analytics and biostatistics  
* Stata: Statistics + Data is common for academic social sciences research  
* The most common SAS files have the extensions .sas7bdat and .sas7cdat  
	* from sas7bdat import SAS7BDAT  
    * with SAS7BDAT("mySASfile.sas7bdat") as file: df_sas=file.to_data_frame()  # as per previous examples  
* The Stata files can be imported directly using pd  
	* pd.read_stata("myStataFile.dta")  
  
Importing HDF5 (Hierarchical Data Format 5) files, quickly becoming the Python standard for storing large quantities of numerical data:  
  
* HDF5 can scale up to exabytes of data, and is commonly used for files of hundereds of gigabytes or even terabytes  
* import h5py; data=h5py.File("myHD5.hd5", "r"); for key in data.keys(): print(key)  
	* might have "meta", "quality", and "strain" for a specific LIGO data file  
    * could dive further in to any of the keys, for example for key in data["meta"].keys(): print(key)  
* The HDF project is formally managed by the HDF group, a Champaign-based spinoff of the University of Illinois  
  
Importing MATLAB (MATrix LABoratory) files - industry standard in engineering and science:  
  
* The library scipy has functions scipy.io.loadmat() and scipy.io.savemat()  
	* The loaded file will be a dictionary (keys are the variable names and values are the objects assigned to the variables)  
* COULD NOT GET scipy to import (lack of blas???)
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"

# Import pickle package
import pickle

# NEED PICKLE DATA - {'Mar': '84.4', 'June': '69.4', 'Airline': '8', 'Aug': '85'}
# Created using with open(myPath + "data.pkl", "wb") as file: pickle.dump(myDict, file)
# Open pickle file and load data: d
with open(myPath + 'data.pkl', mode="rb") as file:
    d = pickle.load(file)

# Print d
print(d)

# Print datatype of d
print(type(d))


# NEED BATTLE DEATHS DATA - https://www.prio.org/Data/Armed-Conflict/Battle-Deaths/The-Battle-Deaths-Dataset-version-30/ (downloaded and converted name to "battledeath.xlsx")
# Import pandas
import pandas as pd

# Assign spreadsheet filename: file
file = myPath + "battledeath.xlsx"

# Load spreadsheet: xl
xl = pd.ExcelFile(file)

# Print sheet names
print(xl.sheet_names)


# Load a sheet into a DataFrame by name: df1
# There is only one sheet absent converting "bdonly" to a file by year
df1 = xl.parse("bdonly")

# Print the head of the DataFrame df1
print(df1.head())

# Load a sheet into a DataFrame by index: df2
df2 = xl.parse(0)

# Print the head of the DataFrame df2
print(df2.head())


# Parse the first sheet and rename the columns: df1
df1 = xl.parse(0, skiprows=[0], parse_cols=[2, 9], names=["AAM due to War (2002)", "Country"])

# Print the head of the DataFrame df1
print(df1.head())

# Parse the tenth column of the first sheet and rename the column: df2
df2 = xl.parse(0, parse_cols=[9], skiprows=[0], names=["Country"])

# Print the head of the DataFrame df2
print(df2.head())


# DO NOT HAVE THIS FILE EITHER
# Import sas7bdat package
from sas7bdat import SAS7BDAT

# Save file to a DataFrame: df_sas
# with SAS7BDAT('sales.sas7bdat') as file:
#     df_sas = file.to_data_frame()

# Print head of DataFrame
# print(df_sas.head())

import matplotlib.pyplot as plt

# Plot histogram of DataFrame features (pandas and pyplot already imported)
# pd.DataFrame.hist(df_sas[['P']])
# plt.ylabel('count')
# plt.show()


# DO NOT HAVE THIS FILE EITHER
# Import pandas

# Load Stata file into a pandas DataFrame: df
# df = pd.read_stata("disarea.dta")

# Print the head of the DataFrame df
# print(df.head())

# Plot histogram of one column of the DataFrame
# pd.DataFrame.hist(df[['disa10']])
# plt.xlabel('Extent of disease')
# plt.ylabel('Number of coutries')
# plt.show()


# DO NOT HAVE THIS FILE EITHER
# Import packages
import numpy as np
import h5py

# Assign filename: file
# file = 'LIGO_data.hdf5'

# Load file: data
# data = h5py.File(file, "r")

# Print the datatype of the loaded file
# print(type(data))

# Print the keys of the file
# for key in data.keys():
#     print(key)


# Get the HDF5 group: group
# group = data["strain"]

# Check out keys of group
# for key in group.keys():
#     print(key)

# Set variable equal to time series data: strain
# strain = data['strain']['Strain'].value

# Set number of time points to sample: num_samples
# num_samples = 10000

# Set time vector
# time = np.arange(0, 1, 1/num_samples)

# Plot data
# plt.plot(time, strain[:num_samples])
# plt.xlabel('GPS Time (s)')
# plt.ylabel('strain')
# plt.show()


# DO NOT HAVE THIS FILE EITHER - see https://www.mcb.ucdavis.edu/faculty-labs/albeck/workshop.htm
# Import package (cannot get to download)
# import scipy.io

# Load MATLAB file: mat
# mat = scipy.io.loadmat('albeck_gene_expression.mat')

# Print the datatype type of mat
# print(type(mat))


# Print the keys of the MATLAB dictionary
# print(mat.keys())

# Print the type of the value corresponding to the key 'CYratioCyt'
# print(type(mat["CYratioCyt"]))

# Print the shape of the value corresponding to the key 'CYratioCyt'
# print(np.shape(mat["CYratioCyt"]))

# Subset the array and plot it
# data = mat['CYratioCyt'][25, 5:]
# fig = plt.figure()
# plt.plot(data)
# plt.xlabel('time (min.)')
# plt.ylabel('normalized fluorescence (measure of expression)')
# plt.show()

```
  
  
***
  
Chapter 3 - Relational databases  
  
Introduction to relational databases - standard discussion of how a relational database (system of tables) works:  
  
* Each of the tables is a data frame, keyed by a primary key (unique identifier for the row in question)  
* The tables are all linked by way of the primary keys, and the existence of these keys as columns in some of the other tables  
* The relational linking process saves a great deal of space  
* Many systems exist, such as PostgreSQL, MySQL, SQLite, and the like  
* SQL is an acronym for "Structured Query Language" which is a standard way for interacting with the relational databases  
  
Creating a database engine in Python - goal is to get data out of the relational database using SQL:  
  
* SQLite is nice since it is fast and simple, though other databases may have additional valuable features  
* The package "SQLAlchemy" works with many other RDBMS (relational database management systems)  
	* from sqlalchemy import create_engine  
    * engine = create_engine("mySQLDatabase.sqlite")  # may have different extensions if a different type of database  
    * engine.table_names()  # provides the names of all the tables in engine  
  
Querying relational databases in Python - connecting to the engine and then querying (getting data out from) the database:  
  
* SELECT * FROM myTable will bring over all columns of all rows  
* General workflow for SQL in Python include: 1) import packages, 2) create the DB engine, 3) connect to the engine, 4) query the database, 5) save query results to a DataFrame, and 6) close the connection  
	* Step 3: con = engine.connect()  
    * Step 4: rs = con.execute("valid SQL queries")  
    * Step 5: df = pd.DataFrame(rs.fetchall()) ; df.columns = rs.keys() # if wanting to bring over meaningful column names  
    * Step 6: con.close()  
* A context manager (with engine.connect() as con) can save the hassle of con.close(), or worse forgetting to close the connection  
* Note that rs.fetchmany(size=5) is an option for bringing over just 5 lines from the query (can use numbers other than 5 also)  
  
Querying relational databases directly with pandas - shortcut to the above process:  
  
* df = pd.read_sql_query("valid SQL code", engine)  # where import pandas as pd and engine = create_engine("mySQLConnection") have previously been run  
  
Advanced querying - exploiting table relationships (combining mutliple tables):  
  
* The SQL join to bring 2+ tables together  
* SELECT myVars FROM Table1 INNER JOIN Table2 ON joinCriteria  
    * Note that the format for variables is Table.Variable, so Orders.CustomerID = Customers.CustomerID  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"

# NEED FILE - may be able to get at http://chinookdatabase.codeplex.com/
# Downloaded the ZIP, extracted the SQLite, and renamed to Chinook.sqlite
# Import necessary module
from sqlalchemy import create_engine

# Create engine: engine
engine = create_engine('sqlite:///' + myPath + 'Chinook.sqlite')  # The sqlite:/// is called the 'connection string'


# Save the table names to a list: table_names
table_names = engine.table_names()

# Print the table names to the shell
print(table_names)


# Import packages
from sqlalchemy import create_engine
import pandas as pd

# Create engine: engine
engine = create_engine('sqlite:///' + myPath + 'Chinook.sqlite')

# Open engine connection: con
con = engine.connect()

# Perform query: rs
rs = con.execute("SELECT * FROM Album")

# Save results of the query to DataFrame: df
df = pd.DataFrame(rs.fetchall())

# Close connection
con.close()

# Print head of DataFrame df
print(df.head())


# Open engine in context manager
# Perform query and save results to DataFrame: df
with engine.connect() as con:
    rs = con.execute("SELECT LastName, Title FROM Employee")
    df = pd.DataFrame(rs.fetchmany(size=3))
    df.columns = rs.keys()

# Print the length of the DataFrame df
print(len(df))

# Print the head of the DataFrame df
print(df.head())


# Create engine: engine
engine = create_engine('sqlite:///' + myPath + 'Chinook.sqlite')

# Open engine in context manager
# Perform query and save results to DataFrame: df
with engine.connect() as con:
    rs = con.execute("SELECT * FROM Employee WHERE EmployeeID >= 6")
    df = pd.DataFrame(rs.fetchall())
    df.columns = rs.keys()

# Print the head of the DataFrame df
print(df.head())


# Create engine: engine
engine = create_engine('sqlite:///' + myPath + 'Chinook.sqlite')

# Open engine in context manager
with engine.connect() as con:
    rs = con.execute("SELECT * FROM Employee ORDER BY BirthDate")
    df = pd.DataFrame(rs.fetchall())
    
    # Set the DataFrame's column names
    df.columns = rs.keys()

# Print head of DataFrame
print(df.head())


# Import packages
from sqlalchemy import create_engine
import pandas as pd

# Create engine: engine
engine = create_engine('sqlite:///' + myPath + 'Chinook.sqlite')

# Execute query and store records in DataFrame: df
df = pd.read_sql_query("SELECT * FROM Album", engine)

# Print head of DataFrame
print(df.head())

# Open engine in context manager
# Perform query and save results to DataFrame: df1
with engine.connect() as con:
    rs = con.execute("SELECT * FROM Album")
    df1 = pd.DataFrame(rs.fetchall())
    df1.columns = rs.keys()

# Confirm that both methods yield the same result: does df = df1 ?
print(df.equals(df1))


# Import packages
from sqlalchemy import create_engine
import pandas as pd

# Create engine: engine
engine = create_engine('sqlite:///' + myPath + 'Chinook.sqlite')

# Execute query and store records in DataFrame: df
df = pd.read_sql_query("SELECT * FROM Employee WHERE EmployeeId >= 6 ORDER BY BirthDate", engine)

# Print head of DataFrame
print(df.head())


# Open engine in context manager
# Perform query and save results to DataFrame: df
with engine.connect() as con:
    rs = con.execute("SELECT Title, Name FROM Album INNER JOIN Artist ON Album.ArtistID = Artist.ArtistID")
    df = pd.DataFrame(rs.fetchall())
    df.columns = rs.keys()

# Print head of DataFrame df
print(df.head())


# Execute query and store records in DataFrame: df
df = pd.read_sql_query("SELECT * FROM PlaylistTrack INNER JOIN Track ON PlaylistTrack.TrackId = Track.TrackId WHERE Milliseconds < 250000", engine)

# Print head of DataFrame
print(df.head())


```
  
  
###_Importing Data in Python (Part II)_#
  
Chapter 1 - Importing Data from the Internet  
  
Importing flat files from the web - non-local files:  
  
* Clicking on URL and downloading files creates reproducibility problems and is non-scalable  
* Course covers 1) import and locally save from the web, 2) load datasets in to pandas DataFrames, 3) make HTTP requests, 4) scrape HTML (BeustifulSoup)  
* This course will particularly focus on "urllib" and "requests" packages  
* The "urllib" package has an interface for fetching data from across the web  
	* urllib.urlopen("myURL")  # Very similar to open() but takes an URL rather than a local file name  
    * from urllib.request import urlretrieve ; url = "myQuotedURL" ; urlretrieve(url, "myLocalFileName")  
  
HTTP requests to import files from the web - unpacking the urlretrieve from urllib.request:  
  
* URL is an acronym for Uniform/Universal Resource Locator (reference to web resources such as web addresses, FTP, and the like)  
* Ingredients for an URL include 1) protocol identifier (such as "http:") and a resource name (such as "datacamp.com")  
* HTTP is an acronym for Hyper-Text Transfer Protocol which is the foundation for data communication on the web  
	* Going to a website is the process of sending a GET request through HTTP ; the urlretrieve does this automatically  
* HTML is an acronym for HyperText Markup Language, which is the standard mark-up language used on the internet  
* Example process for GET requests using urllib  
	* from urllib.request import urlopen, Request  
    * url = "https://www.wikipedia.org/" ; request = Request(url) ; response = urlopen(request) ; html = response.read() ; response.close()  
* Can also send GET requests using "requests"", a commonly used package that simplifies the process  
	* import requests  
    * url = "https://www.wikipedia.org/" ; r = requests.get(url) ; text = r.text  
  
Scraping the web in Python using BeautifulSoup - make sense of the jumbled, unstructured HTML data:  
  
* Structured data has either 1) a pre-defined data model, or 2) organization in a defined manner  
* HTML is unstructured data, possessing neither of these properties  
* BeautifulSoup parses and extracts structured data from HTML  
* General usage would include  
	* from bs4 import BeautifulSoup ; import requests  
    * url = "https://www.crummy.com/software/BeautifulSoup/"  
    * r = requests.get(url) ; html_doc = r.text  
    * soup = BeautifulSoup(html_doc)  
    * print(soup.prettify()) # printes properly indented html code, easier for human parsing  
  
Example code includes:  
```{r engine='python'}

# Import package
from urllib.request import urlretrieve
import pandas as pd

# Assign url of file: url (ran once - no need to re-run)
# url = 'https://s3.amazonaws.com/assets.datacamp.com/production/course_1606/datasets/winequality-red.csv'

# Save file locally
# urlretrieve(url, 'winequality-red.csv')

# Read file into a DataFrame and print its head
df = pd.read_csv('winequality-red.csv', sep=';')
print(df.head())


# Import packages
import matplotlib.pyplot as plt
import pandas as pd

# Assign url of file: url (ran once - no need to re-run)
# url = 'https://s3.amazonaws.com/assets.datacamp.com/production/course_1606/datasets/winequality-red.csv'

# Read file into a DataFrame: df
# df = pd.read_csv(url, sep=";")

# Print the head of the DataFrame
# print(df.head())

# Plot first column of df
pd.DataFrame.hist(df.ix[:, 0:1])
plt.xlabel('fixed acidity (g(tartaric acid)/dm$^3$)')
plt.ylabel('count')
# plt.show()
plt.savefig("_dummyPy044.png", bbox_inches="tight")
plt.clf()


# Assign url of file: url
url = 'http://s3.amazonaws.com/assets.datacamp.com/course/importing_data_into_r/latitude.xls'

# Read in all sheets of Excel file: xl
xl = pd.read_excel(url, sheetname=None)

# Print the sheetnames to the shell
print(xl.keys())

# Print the head of the first sheet (using its name, NOT its index)
print(xl["1700"].head())


# Import packages
from urllib.request import urlopen, Request

# Specify the url
url = "http://www.datacamp.com/teach/documentation"

# This packages the request: request
request = Request(url)

# Sends the request and catches the response: response
response = urlopen(request)

# Print the datatype of response
print(type(response))

# Be polite and close the response!
response.close()


# Specify the url
url = "http://docs.datacamp.com/teach/"

# This packages the request
request = Request(url)

# Sends the request and catches the response: response
response = urlopen(request)

# Extract the response: html
html = response.read()

# Print the html
print(html)

# Be polite and close the response!
response.close()


import requests

# Specify the url: url
url = "http://docs.datacamp.com/teach/"

# Packages the request, send the request and catch the response: r
r = requests.get(url)

# Extract the response: text
text = r.text

# Print the html
print(text)


# Import packages
import requests
from bs4 import BeautifulSoup

# Specify url: url
url = 'https://www.python.org/~guido/'

# Package the request, send the request and catch the response: r
r = requests.get(url)

# Extracts the response as html: html_doc
html_doc = r.text

# Create a BeautifulSoup object from the HTML: soup
soup = BeautifulSoup(html_doc)

# Prettify the BeautifulSoup object: pretty_soup
pretty_soup = soup.prettify()

# Print the response
print(pretty_soup)


# Get the title of Guido's webpage: guido_title
guido_title = soup.title

# Print the title of Guido's webpage to the shell
print(guido_title)

# Get Guido's text: guido_text
guido_text = soup.get_text()

# Print Guido's text to the shell
print(guido_text)


# Find all 'a' tags (which define hyperlinks): a_tags
a_tags = soup.find_all("a")

# Print the URLs to the shell
for link in a_tags:
    print(link.get("href"))


```
  
  
**Acidity of Red Wine**:  
![](_dummyPy044.png)
  
***

Chapter 2 - Interacting with APIs  
  
Introduction to APIs (Application Programming Interface) and JSON (JavaScript Object Notation):  
  
* API is a protocol and routine for building and interacting with software applications  
* JSON helps with rel-time browser to server communication, developed by Douglas Crockford  
* JSON has name-value pairs, very similar to a Python dictionary  
* General process might include  
	* import json  
    * with open("snakes.json", "r") as json_file: json_data = json.load(json_file)  # json_data will be imported as a dictionary  
  
APIs and interacting with the world-wide web - what APIs are and why they are important:  
  
* The API is a set of protocols and routines for interacting with software programs  
* The "Open Movies Database" (OMDB) has an API, as do most websites that might be data sources  
* Example usage might include  
	* import requests  
    * url = "http://www.omdbapi.com/?t=hackers"  # the ? Represents a "query string", in this case asking for "t" (title) equals "hackers" (the movie "Hackers")  
    * r = requests.get(url)  
    * json_data = r.json()  
* Can get the OMDB API webpage for how they allow their data to be queried/used and how to fomat the relevant "query strings"  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"

# DO NOT HAVE FILE a_movie.json, which appears to be JSON for the movie Social Network (2010)
# Created and saved file
import json

# Load JSON: json_data
with open(myPath + "a_movie.json") as json_file:
    json_data = json.load(json_file)

# Print each key-value pair in json_data
for k in json_data.keys():
    print(k + ': ', json_data[k])


# PROBABLY DO NOT RUN; NEED API KEY
# Import requests package
import requests

# Assign URL to variable: url
url = 'http://www.omdbapi.com/?apikey=ff21610b&t=social+network'

# Package the request, send the request and catch the response: r
r = requests.get(url)

# Print the text of the response
print(r.text)

# Decode the JSON data into a dictionary: json_data
json_data = r.json()

# Print each key-value pair in json_data
for k in json_data.keys():
    print(k + ': ', json_data[k])


# Assign URL to variable: url
url = "https://en.wikipedia.org/w/api.php?action=query&prop=extracts&format=json&exintro=&titles=pizza"

# Package the request, send the request and catch the response: r
r = requests.get(url)

# Decode the JSON data into a dictionary: json_data
json_data = r.json()

# Print the Wikipedia page extract
pizza_extract = json_data['query']['pages']['24768']['extract']
print(pizza_extract)

```
  
  
***
  
Chapter 3 - Diving deeper in to the Twitter API  
  
Twitter API and Authentication - 1) Twitter API, 2) filtering tweets, 3) API Authentication and Oauth, 4) Python package "tweepy":  
  
* The Twitter API requires a Twitter account, then creating a new Twitter App, then copying over the Token and Token Secret  
* Twitter has many API including the REST API (Representational State API), which allows for reading and writing Twitter data  
* The Twitter Streaming API includes a "Public streams" for low-latency access to tweets  
* The Twitter Firehose API is not publicly avaiable, requires special permission, and would likely be very expensive  
* Tweets are generally returned as JSON  
* The "tweepy" package has a nice balance between functionality and usability  
	* auth = tweepy.OAuthHandler(consumer_key, consumer_secret)  
    * auth.set_access(access_token, access_token_secret)  
  
Example code includes:  
```{r engine='python', eval=FALSE}

# DO NOT RUN THIS - NO IDEA WHOSE KEYS THESE ARE (DataCamp???)
# Import package
import tweepy

# Store OAuth authentication credentials in relevant variables
access_token = "1092294848-aHN7DcRP9B4VMTQIhwqOYiB14YkW92fFO8k8EPy"
access_token_secret = "X4dHmhPfaksHcQ7SCbmZa2oYBBVSD2g8uIHXsp5CTaksx"
consumer_key = "nZ6EA0FxZ293SxGNg8g8aP0HM"
consumer_secret = "fJGEodwe3KiKUnsYJC3VRndj7jevVvXbK2D5EiJ2nehafRgA6i"

# Pass OAuth details to tweepy's OAuth handler
auth = tweepy.OAuthHandler(consumer_key, consumer_secret)
auth.set_access_token(access_token, access_token_secret)


# The class MyStreamListener is available at https://gist.github.com/hugobowne/18f1c0c0709ed1a52dc5bcd462ac69f4
# Initialize Stream listener
l = MyStreamListener()

# Create you Stream object with authentication
stream = tweepy.Stream(auth, l)

# Filter Twitter Streams to capture data by the keywords:
stream.filter(track=['clinton', 'trump', 'sanders', 'cruz'])


# Import package
import json

# String of path to file: tweets_data_path
tweets_data_path = "tweets.txt"

# Initialize empty list to store tweets: tweets_data
tweets_data = []

# Open connection to file
tweets_file = open(tweets_data_path, "r")

# Read in tweets and store in list: tweets_data
for line in tweets_file:
    tweet = json.loads(line)
    tweets_data.append(tweet)

# Close connection to file
tweets_file.close()

# Print the keys of the first tweet dict
print(tweets_data[0].keys())


# Import package
import pandas as pd

# Build DataFrame of tweet texts and languages
df = pd.DataFrame(tweets_data, columns=["text", "lang"])

# Print head of DataFrame
print(df.head())


def word_in_text(word, tweet):
    word = word.lower()
    text = tweet.lower()
    match = re.search(word, tweet)

    if match:
        return True
    return False


# Initialize list to store tweet counts
[clinton, trump, sanders, cruz] = [0, 0, 0, 0]

# Iterate through df, counting the number of tweets in which
# each candidate is mentioned
for index, row in df.iterrows():
    clinton += word_in_text('clinton', row['text'])
    trump += word_in_text('trump', row['text'])
    sanders += word_in_text('sanders', row['text'])
    cruz += word_in_text('cruz', row['text'])


# Import packages
import matplotlib.pyplot as plt
import seaborn as sns

# Set seaborn style
sns.set(color_codes=True)

# Create a list of labels:cd
cd = ['clinton', 'trump', 'sanders', 'cruz']

# Plot histogram
ax = sns.barplot(cd, [clinton, trump, sanders, cruz])
ax.set(ylabel="count")
plt.show()

```
  
  
###_Cleaning Data in Python_#
  
Chapter 1 - Exploring Your Data  
  
Diagnose data for cleaning - column names, missing data, outliers, duplicate rows, un-tidy data, unexpected data values, etc.:  
  
* Pandas can be identified/filtered using row/column names or row/column indices  
* Missing data are typically NaN in Python  
* For a pandas DataFrame df, df.head() and df.tail() will show the first/last 5 rows  
	* df.columns returns an index of column names, which can reveal leading/trailing spaces  
    * df.shape is analogous to dim() in R  
    * df.info() will give a summary of the frame, as well as the associated columns (data types, non-missing values, and the like) - note that type "object" means it is non-numeric  
  
Exploratory data analysis - suppose that a pandas DataFrame, df, has already been created:  
  
* To get frequency counts, use df.continent.value_counts(dropna=False)  # in this case "continent" is the column name (can also subset using bracket notation, which is required if name has any "problems"). . .   
	* Frequency counts will be in descending order  
    * df["continent"].value_counts(dropna=False) will return the same thing  
* To get summaries of numeric data, use df.describe()  # will only be run for numeric columns  
  
Visual exploratory data analysis - easy way to spot outliers and obvious errors - assume again that a pandas DataFrame, df, has already been explained:  
  
* Bar plots for discrete data  
* Histograms for contiuous data - df["myColumn"].plot("hist") will create the histogram, and plt.show() will then show the histogram  
* Data can be subset similar to R - df[df["myVar"] condition] will pull only the rows where the specified condition is met  
* Box plots can be handy ways to summarize the numerical data - df.boxplot(column="myColumn", by="myByVariable")  
* Scatter plots can be handy ways to look at relationships between two numeric columns  
  
Example code includes:  
```{r engine='python'}

# Downloaded small portion to myPath from https://data.cityofnewyork.us/Housing-Development/DOB-Job-Application-Filings/ic3t-wcy2/data

# tempData = pd.read_csv(myPath + "DOB_JOB_Application_Filings.csv")

# keyCols = ["Borough", "State", "Site Fill", "Existing Zoning Sqft", "Initial Cost", "Total Est. Fee"]
# useData = tempData[keyCols]
# useData.loc[:, "initial_cost"] = [float(d[1:]) for d in useData["Initial Cost"]]
# useData.loc[:, "total_est_fee"] = [float(d[1:]) for d in useData["Total Est. Fee"]]
# useData.to_csv(myPath + "dob_job_application_filings_subset.csv")

# MAY NEED TO GET DATA FROM https://opendata.cityofnewyork.us/
# Import pandas
import pandas as pd

myPath = "./PythonInputFiles/"


# Read the file into a DataFrame: df
df = pd.read_csv(myPath + 'dob_job_application_filings_subset.csv')

# Print the head of df
print(df.head())

# Print the tail of df
print(df.tail())

# Print the shape of df
print(df.shape)

# Print the columns of df
print(df.columns)

# Print the info of df
print(df.info())


# Print the value counts for 'Borough'
print(df['Borough'].value_counts(dropna=False))

# Print the value_counts for 'State'
print(df['State'].value_counts(dropna=False))

# Print the value counts for 'Site Fill'
print(df['Site Fill'].value_counts(dropna=False))


# Import matplotlib.pyplot
import matplotlib.pyplot as plt

# Plot the histogram
df['Existing Zoning Sqft'].plot(kind='hist', rot=70, logx=True, logy=True)

# Display the histogram
# plt.show()
plt.savefig("_dummyPy045.png", bbox_inches="tight")
plt.clf()

# Import necessary modules
import pandas as pd
import matplotlib.pyplot as plt

# Create the boxplot
df.boxplot(column="initial_cost", by="Borough", rot=90)

# Display the plot
# plt.show()
plt.savefig("_dummyPy046.png", bbox_inches="tight")
plt.clf()

# Import necessary modules
import pandas as pd
import matplotlib.pyplot as plt

# Create and display the first scatter plot
df.plot(kind="scatter", x="initial_cost", y="total_est_fee", rot=70)
# plt.show()
plt.savefig("_dummyPy047.png", bbox_inches="tight")
plt.clf()

```
  
  
**NYC Open Data Sub-sample (Building Permits - Existing Zoning Sq Ft)**:  
![](_dummyPy045.png)

**NYC Open Data Sub-sample (Building Permits - Initial Cost by Borough)**:  
![](_dummyPy046.png)

**NYC Open Data Sub-sample (Building Permits)**:  
![](_dummyPy047.png)


  
***
  
Chapter 2 - Tidying data for analysis  
  
Tidy data per the Hadley Wickham paper - "standard way to organize data within a dataset":  
  
* Columns should represent separate variables - if the values are in the column names, then the data need to be melted  
	* pd.melt(frame=myFrame, id_vars=["myID"], value_vars=["myValues"])  
    * id_vars will be held fixed; these are the columns that will not be changed during the melting process  
    * If the value_vars columns are not specified, Python will assume you want to melt all columns other than the ID variables  
    * The default outputs new columns "variable" and "value", though these can be over-ridden using var_name="myVarName" and value_name="myValName" inside melt  
* Rows should represent individual observations  
* Observational units should form tables  
* There are some trade-offs in reporting vs. data analysis, and tidying the data is primarily for making it easier to analyze  
  
Pivoting data is the opposite of melting; turn unique values in to separate columns (assuming again that the DataFrame, df, already exists):  
  
* To pivot the data, use df.pivot(index="myIndex", columns="myColumns", values="myValues")  
	* index is the columns to be fixed  
    * columns is what is to be pivoted in the new columns  
    * values is what is to be placed in to the new columns  
* If there is a duplicate value, the "pivot table" is required, specifying to Python how the duplicated value should be managed  
	* df.pivot_table(index="myIndex", columns="myColumns", values="myValues", aggfunc=myFunc) # same as .pivot, but specifying something like np.mean for how to handle duplicates  
  
Beyond melt and pivot - example from the Wickham data of having a single variable that combines sex and age-group (TB data) - common shape for reporting, but less than ideal for analysis:  
  
* First, melt the data so that all these columns become a single "variable" that contains the associated "value"  
* Second, create new variables for sex and age from the current variable named "variable"  
	* tb_melt["sex"] = tb_melt["variable"].str[0]  # will extract the first character, which is the sex in this case  
    * tb_melt["age"] = tb_melt["variable"].str[1:]  # will extract all but the first character  
  
Example code includes:  
```{r engine='python'}

# THIS SEEMS TO BE THE STANARD R datasets file as a pandas
# Saved airquality.csv to the ./PythonInputFiles

myPath = "./PythonInputFiles/"



import pandas as pd
import numpy as np

airquality = pd.read_csv(myPath + "airquality.csv")


# Print the head of airquality
print(airquality.head())

# Melt airquality: airquality_melt
airquality_melt = pd.melt(airquality, id_vars=["Month", "Day"])

# Print the head of airquality_melt
print(airquality_melt.head())


# Print the head of airquality
print(airquality.head())

# Melt airquality: airquality_melt
airquality_melt = pd.melt(airquality, id_vars=["Month", "Day"], var_name="measurement", value_name="reading")

# Print the head of airquality_melt
print(airquality_melt.head())


# Print the head of airquality_melt
print(airquality_melt.head())

# airquality_melt.pivot() would bomb out on this; not sure why . . . (may be due to having 2+ variables in the index
# Pivot airquality_melt: airquality_pivot
airquality_pivot = airquality_melt.pivot_table(index=["Month", "Day"], columns="measurement", values="reading")

# Print the head of airquality_pivot
print(airquality_pivot.head())


# Print the index of airquality_pivot
print(airquality_pivot.index)

# Reset the index of airquality_pivot: airquality_pivot
airquality_pivot = airquality_pivot.reset_index()

# Print the new index of airquality_pivot
print(airquality_pivot.index)

# Print the head of airquality_pivot
print(airquality_pivot.head())


# Pivot airquality_dup: airquality_pivot
# keyRows = [x for x in range(len(airquality.index))] + [2, 4, 6, 8, 10]
# airquality_dup = airquality.iloc[keyRows, :]
airquality_pivot = airquality_melt.pivot_table(index=["Month", "Day"], columns="measurement", values="reading", aggfunc=np.mean)

# Reset the index of airquality_pivot
airquality_pivot = airquality_pivot.reset_index()

# Print the head of airquality_pivot
print(airquality_pivot.head())

# Print the head of airquality
print(airquality.head())


# tb is 201x18 with variables ['country', 'year', 'm014', 'm1524', 'm2534', 'm3544', 'm4554', 'm5564', 'm65', 'mu', 'f014', 'f1524', 'f2534', 'f3544', 'f4554', 'f5564', 'f65', 'fu']
# year is set to be always 2000 with fu and mu always NaN
# Create dummy data for tb (just use 3 countries and the 014 and 1524 columns)
tb = pd.DataFrame( { "country":["USA", "CAN", "MEX"] , "year":2000 , "fu":np.nan , "mu":np.nan , "f014":[2, 3, 4] , "m014":[5, 6, 7] , "f1524": [8, 9, 0] , "m1524":[1, 2, 3] } )


# Melt tb: tb_melt
tb_melt = pd.melt(tb, id_vars=["country", "year"])

# Create the 'gender' column
tb_melt['gender'] = tb_melt.variable.str[0]

# Create the 'age_group' column
tb_melt['age_group'] = tb_melt.variable.str[1:]

# Print the head of tb_melt
print(tb_melt.head())  # Is now 3,216 x 6 ['country', 'year', 'variable', 'value', 'gender', 'age_group']


# Ebola dataset is available at https://data.humdata.org/dataset/ebola-cases-2014
# Variables are split by an underscore 'Date', 'Day', 'Cases_Guinea', 'Cases_Liberia', 'Cases_SierraLeone', 'Cases_Nigeria', 'Cases_Senegal', 'Cases_UnitedStates', 'Cases_Spain', 'Cases_Mali', 'Deaths_Guinea', 'Deaths_Liberia', 'Deaths_SierraLeone', 'Deaths_Nigeria', 'Deaths_Senegal', 'Deaths_UnitedStates', 'Deaths_Spain', 'Deaths_Mali'

# Downloaded file, then manipulated to be like the above as follows:
# ebola_test = pd.read_csv(myPath + "ebola_data_db_format.csv")
# ebola_test["UseCountry"] = ebola_test["Country"].str.replace(" ", "")
# ebola_test["UseCountry"] = ebola_test["UseCountry"].str.replace("2", "")
# keyIndic = ["Cumulative number of confirmed Ebola deaths", "Cumulative number of confirmed Ebola cases"]
# keyBool = [x in keyIndic for x in ebola_test["Indicator"]]
# ebola_test = ebola_test.loc[keyBool, :]
# indicMap = {keyIndic[0]:"Deaths", keyIndic[1]:"Cases"}
# ebola_test["UseIndicator"] = ebola_test["Indicator"].map(indicMap)
# ebolaPre = ebola_test[["Date", "UseCountry", "UseIndicator", "value"]]
# ebolaPre["CI"] = ebolaPre["UseIndicator"] + "_" + ebolaPre["UseCountry"]
# ebolaSave = ebolaPre.pivot_table(index="Date", columns="CI", values="value", aggfunc="max").fillna(method="ffill").fillna(0)
# ebolaSave.to_csv(myPath + "ebola.csv")

ebola = pd.read_csv(myPath + "ebola.csv", parse_dates=["Date"])


# Melt ebola: ebola_melt
ebola_melt = pd.melt(ebola, id_vars=["Date"], var_name="type_country", value_name="counts")

# Create the 'str_split' column
ebola_melt['str_split'] = ebola_melt["type_country"].str.split("_")

# Create the 'type' column
ebola_melt['type'] = ebola_melt['str_split'].str.get(0)

# Create the 'country' column
ebola_melt['country'] = ebola_melt['str_split'].str.get(1)

# Print the head of ebola_melt
print(ebola_melt.head())


# ebola_melt.to_csv(myPath + "ebola_melt.csv", index=False)
# Run outside of this shell so that the file is accessible later

```
  
  
***
  
Chapter 3 - Combining data for analysis  
  
Concatenating data - data may be in separate files (too many records, time series data by day, etc.), while you want to combine it:  
  
* Concatenating data (similar to rbind in R) in Python leaves the original row indices untouched, which can induce duplicate indices  
* The pd.concat([myFileList]) will place the frames together in a single frame # requires that import pandas as pd was called previously  
	* Using ignore_index=True inside pd.concat() will re-cast the row indices from 0 to n-1  
    * To instead concatenate columns (similar to cbind in R), declare the axis=1 option inside pd.concat()  
  
Finding and concatenating data - issue of many files needing to be concatenated:  
  
* The glob function from the glob library helps to find files based on a consistent search pattern  
	* The wildcards * and ? Are both available, with * being any number while ? Is a single character  
    * Basic usage would be glob.glob("mySearchString")  
* The basic plan would be to 1) load all the files to pandas, and then 2) make a list of the DataFrame names for concatenation  
  
Merge data - extension on concatenation (which is more piecing something back together that was originally one piece but became split):  
  
* Merging can manage joins of tables that never were one piece, combining disparate data based on common columns  
* The merge syntax is pd.merge(left=leftFrame, right=rightFrame, how=, on=, left_on=, right_on=)  # default is an INNER JOIN and need to specify either on= (common variables) or left_on=/right_on=  
	* The defaults for on, left_on, and right_on are all None  
    * The default is for how="inner" though options for "left", "right", and "outer" can also be declared  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"

import pandas as pd
import numpy as np


# uber datasets are a small subset from within http://data.beta.nyc/dataset/uber-trip-data-foiled-apr-sep-2014
# downloaded file "Uber-Jan-Feb-FOIL.csv" to myPath


uber = pd.read_csv(myPath + "Uber-Jan-Feb-FOIL.csv")

cuts = [round(len(uber.index) / 3), round(2 * len(uber.index) / 3)]

uber1 = uber.iloc[:cuts[0], :]
uber2 = uber.iloc[cuts[0]:cuts[1], :]
uber3 = uber.iloc[cuts[1]:, :]

# Save outside of this routine
# uber1.to_csv(myPath + "uber1.csv", index=False)
# uber2.to_csv(myPath + "uber2.csv", index=False)
# uber3.to_csv(myPath + "uber3.csv", index=False)


# Concatenate uber1, uber2, and uber3: row_concat
row_concat = pd.concat([uber1, uber2, uber3])

# Print the shape of row_concat
print(row_concat.shape)

# Print the head of row_concat
print(row_concat.head())

print(np.sum(row_concat != uber))


# ebola_melt is 1,952x4 of Date-Day-status_country-counts
# status_country is 1,952x2 of status-country (the previous status_country has been string split)
# Create this from the file in the previous exercise
ebola_melt = pd.read_csv(myPath + "ebola_melt.csv", parse_dates=["Date"])
ebola_melt.columns = ["Date", "status_country", "counts", "str_split", "status", "country"]

status_country = ebola_melt[["status", "country"]]
ebola_melt = ebola_melt[["Date", "status_country", "counts"]]

# Concatenate ebola_melt and status_country column-wise: ebola_tidy
ebola_tidy = pd.concat([ebola_melt, status_country], axis=1)

# Print the shape of ebola_tidy
print(ebola_tidy.shape)

# Print the head of ebola_tidy
print(ebola_tidy.head())


# Has files ['uber-raw-data-2014_06.csv', 'uber-raw-data-2014_04.csv', 'uber-raw-data-2014_05.csv'] available
# Date/Time-Lat-Lon-Base
# Import necessary modules
import glob
import pandas as pd

# Write the pattern: pattern
# This is designed to get the uber1.csv, uber2.csv, and uber3.csv files
pattern = myPath + 'uber?.csv'

# Save all file matches: csv_files
csv_files = glob.glob(pattern)

# Print the file names
print(csv_files)

# Load the second file into a DataFrame: csv2
csv2 = pd.read_csv(csv_files[1])

# Print the head of csv2
print(csv2.head())


# Create an empty list: frames
frames = []

#  Iterate over csv_files
for csv in csv_files:
    
    #  Read csv into a DataFrame: df
    df = pd.read_csv(csv)
    
    # Append df to frames
    frames.append(df)

# Concatenate frames into a single DataFrame: uber
uber = pd.concat(frames)

# Print the shape of uber
print(uber.shape)

# Print the head of uber
print(uber.head())


# site is a 3x3 with name-lat-long - name=["DR-1", "DR-3", "MSK-4"], lat=[-50, -47, -48.9], lon=[-129, -127, -123.4]
# visited is a 3x3 with ident-site-dated - ident=[619, 734, 837], site=["DR-1", "DR-3", "MSK-4"], dated=["1927-02", "1939-01", "1932-01"]

site = pd.DataFrame( { "name":["DR-1", "DR-3", "MSK-4"], "lat":[-50, -47, -48.9], "lon":[-129, -127, -123.4] } )
visited = pd.DataFrame( { "ident":[619, 734, 837], "site":["DR-1", "DR-3", "MSK-4"], "dated":["1927-02", "1939-01", "1932-01"] } )

# Merge the DataFrames: o2o
o2o = pd.merge(left=site, right=visited, left_on=["name"], right_on=["site"])

# Print o2o
print(o2o)


# now make visited 8x3 with ident=[619, 622, 734, 735, , 751, 752, 837, 844], site=['DR-1', 'DR-1', 'DR-3', 'DR-3', 'DR-3', 'DR-3', 'MSK-4', 'DR-1'], dated=['1927-02-08', '1927-02-10', '1939-01-07', '1930-01-12', '1930-02-26', nan, '1932-01-14', '1932-03-22']

visited = pd.DataFrame( {"ident":[619, 622, 734, 735, 751, 752, 837, 844], "site":['DR-1', 'DR-1', 'DR-3', 'DR-3', 'DR-3', 'DR-3', 'MSK-4', 'DR-1'], "dated":['1927-02-08', '1927-02-10', '1939-01-07', '1930-01-12', '1930-02-26', np.nan, '1932-01-14', '1932-03-22']} )

# Merge the DataFrames: m2o
m2o = pd.merge(left=site, right=visited, left_on=["name"], right_on=["site"])

# Print m2o
print(m2o)


# add an additional frame surveyed which is 21x4 with taken-person-quant-reading (taken matched ident in file visited)
# Merge site and visited: m2m
# m2m = pd.merge(left=site, right=visited, left_on=["name"], right_on=["site"])

# Merge m2m and survey: m2m
# m2m = pd.merge(left=m2m, right=survey, left_on=["ident"], right_on=["taken"])

# Print the first 20 lines of m2m
# print(m2m.head(20))

```
  
  
***
  
Chapter 4 - Cleaning data for analysis  
  
Data types and conversions - can see the data types using the df.dtypes attribute of a pandas DataFrame df:  
  
* Often helpful to convert strings to numerics or vice versa  
* The .astype() method will allow for type conversions  
	* df["a"] = df["a"].astype(str) will create a string variable  
    * df["a"] = df["a"].astype("category") will create a categorical (factor) variable  
    * df["a"] = pd.to_numeric(df["a"], errors="coerce") will create a numeric variable, with NaN written where the string is not a sensible numeric  
  
Using regular expressions to clean strings - the most common form of data cleaning is string manipulation:  
  
* As an example, monetary values can be represented in many ways  
* The "re" library is used for pattern matching (using regular expressions) within strings  
	* The asterisk (*) means "0 or more times"  
    * The plus sign (+) means "1 or more times"  
    * The \d represents any digit, broadly the same as [0-9], so \d* means zero or more consecutive digits  
    * The \$ means the actual "$" symbol, with the back-slash escaping the symbol from its default meaning as "end-of-string"; so \$\d* will match the dollar sign followed by 0+ digits  
    * The \. Means the actual "." symbol, with the back-slash escaping the default meaning of the period; so \$\d*\.\d* will maktc the dollar sign followed by 0+ digits followed by the period followed by 0+ digits 
    * The {2} means to have exactly two of the items; sp \$\d*\.\d{2} will match "$[0+ digits].[2 digits]"  
    * The carat means "at the start" and the dollar means "at the end", so ^\$\d*.\d{2}$ will not match anything with 3+ digits after the period, nor anything with text before the $  
* Best practices for using an re are to 1) compile the pattern first, then 2) apply the compiled pattern to the pattern  
	* pattern = re.compile("myRegEx") will compile the specified regular expression for use elsewhere  
    * result = pattern.match("myText") will then pull out the relevant matches to the compiled pattern  
    * bool(result) will return a True/False as to whether we made any matches  
  
Using functions to clean data - in particular, the .apply() function:  
  
* df.apply(myFunction, myAxis=)  # axis 0 is columns, axis 1 is rows, etc.  
* Example using a few columns with dollar data - check that valid numbers, remove the dollar sign, cast as numeric (NaN if invalid data), store as new column  
	* from numpy import NaN  
    * myVar.replace("$", "") will replace the "$" with "" (more or less, remove the leading dollar signs  
* Frequently, a function will be passed an entire row of data, so the cleaning can be done for all required variables in the same function  
	* df["myNewVar"] = df.apply(myFunc, axis=1, pattern=pattern)  # will pass the rows as argument 1 and pattern as argument 2 to myFunc, once for each row  
  
Duplicate and missing data - can skew results in undesirable manners:  
  
* The df.drop_duplicates() method will remove any rows that are exact duplicates of each other  
* The df.info() method is a nice way to see how much missing data there is by variable  
* The df.dropna() method will drop any rows that have any NaN included in them (keeps only the complete.cases() in R syntax)  
* The df.fillna() allows for replacing either a user-provided value or a calculated value (such as mean/median for the variable where it exists)  
	* Can run through multiple columns at the same time by encoding a list; df[[myList]] = df[[myList]].fillna(0) will make NaN in to zero in every column specified in myList  
  
Testing with asserts - early detection for problems that may plague the analysis later:  
  
* More or less, assert myExpression does nothing if True and errors out if False  
  
Example code includes:  
```{r engine='python'}

# The tips data is available at https://github.com/mwaskom/seaborn-data/blob/master/tips.csv

myPath = "./PythonInputFiles/"

import pandas as pd
import numpy as np

tips = pd.read_csv(myPath + "tips.csv")


# Convert the sex column to type 'category'
tips.sex = tips["sex"].astype("category")

# Convert the smoker column to type 'category'
tips.smoker = tips["smoker"].astype("category")

# Print the info of tips
print(tips.info())


# Convert 'total_bill' to a numeric dtype
tips['total_bill'] = pd.to_numeric(tips["total_bill"], errors="coerce")

# Convert 'tip' to a numeric dtype
tips['tip'] = pd.to_numeric(tips["tip"], errors="coerce")

# Print the info of tips
print(tips.info())


# Import the regular expression module
import re

# Compile the pattern: prog
prog = re.compile('\d{3}-\d{3}-\d{4}')

# See if the pattern matches
result = prog.match('123-456-7890')
print(bool(result))

# See if the pattern matches
result = prog.match("1123-456-7890")
print(bool(result))


# Import the regular expression module
import re

# Find the numeric values: matches
matches = re.findall('\d+', 'the recipe calls for 10 strawberries and 1 banana')

# Print the matches
print(matches)


# Write the first pattern
pattern1 = bool(re.match(pattern='\d{3}-\d{3}-\d{4}', string='123-456-7890'))
print(pattern1)

# Write the second pattern
pattern2 = bool(re.match(pattern='\$\d*\.\d{2}', string='$123.45'))
print(pattern2)

# Write the third pattern
pattern3 = bool(re.match(pattern='[A-Z]\w*', string='Australia'))
print(pattern3)


import numpy

# Define recode_sex()
def recode_sex(sex_value):
    
    # Return 1 if sex_value is 'Male'
    if sex_value == "Male":
        return 1
    
    # Return 0 if sex_value is 'Female'    
    elif sex_value == "Female":
        return 0
    
    # Return np.nan    
    else:
        return np.nan

# Apply the function to the sex column
tips['sex_recode'] = tips["sex"].apply(recode_sex)


# Create the total_dollar field
tips["total_dollar"] = "$" + tips["total_bill"].astype(str)

# Write the lambda function using replace
tips['total_dollar_replace'] = tips["total_dollar"].apply(lambda x: x.replace('$', ''))

# Write the lambda function using regular expressions
tips['total_dollar_re'] = tips["total_dollar"].apply(lambda x: re.findall('\d+\.\d+', x))

# Print the head of tips
print(tips.head())


# DO NOT HAVE DATASET "tracks"
# Create the new DataFrame: tracks
# tracks = billboard[['year', 'artist', 'track', 'time']]

# Print info of tracks
# print(tracks.info())

# Drop the duplicates: tracks_no_duplicates
# tracks_no_duplicates = tracks.drop_duplicates()

# Print info of tracks
# print(tracks_no_duplicates.info())


# SEEMS TO BE "airquality" as per the R datasets package
# Previously saved as myPath + "airquality.csv"
airquality = pd.read_csv(myPath + "airquality.csv")


# Calculate the mean of the Ozone column: oz_mean
oz_mean = airquality["Ozone"].mean()

# Replace all the missing values in the Ozone column with the mean
airquality['Ozone'] = airquality["Ozone"].fillna(oz_mean)

# Print the info of airquality
print(airquality.info())


# DO NOT HAVE FRAME ebola - 122 x 18 of Date-Day-Cases_[8 countries]-Deaths_[8 countries]
# Use the version saved previously
ebola = pd.read_csv(myPath + "ebola.csv", parse_dates=["Date"])

# Assert that there are no missing values
assert ebola.notnull().all().all()

# Assert that all values are >= 0
assert (ebola >= 0).all().all()

```
  
  
***
  
Chapter 5 - Case Study  
  
Putting it all together - Gapminder data (NPO supporting global sustainable development):  
  
* Dataset will be life expectancy by country and year  
* Goal is to clean and combine all of the data so there is a single file ready for further data analysis  
  
Initial impressions of the data - depending on the analysis needs, can melt (columns to rows) or pivot (new columns from column data) the data:  
  
* Can check the column types by using df.dftypes  
* Can change column types using .to_numeric() or .astype()  
* Can save a CSV using df.to_csv(myFile)  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"

# The DataFrame g1800s is a life expectancy table of 260 x 101 - "Life Expectancy" (country) followed by "1800" through "1899"
# Copied data from https://docs.google.com/spreadsheets/d/1H3nzTwbn8z4lJ5gJ_WfDgCeGEXK3PVGcNjQ_U5og8eo/pub as accessed from http://www.gapminder.org/data/ to myPath + "gapminder_lifeExp_1800_1916.xlsx"

import pandas as pd
gapExcel = pd.read_excel(myPath + "gapminder_lifeExp_1800_1916.xlsx")


# Convert column labels to text
gapExcel.columns = gapExcel.columns.astype(str)
assert gapExcel.columns[0] == "Life expectancy"

# Create booleans for 1800s, 1900s, and 2000s, including "Life expectancy" (country columns) as true in all
col1800s = gapExcel.columns.str.startswith("18")
col1900s = gapExcel.columns.str.startswith("19")
col2000s = gapExcel.columns.str.startswith("20")
col1800s[0] = True
col1900s[0] = True
col2000s[0] = True

# Create g1800s, g1900s, g2000s
g1800s = gapExcel.loc[:, col1800s]
g1900s = gapExcel.loc[:, col1900s]
g2000s = gapExcel.loc[:, col2000s]


# Import matplotlib.pyplot
import matplotlib.pyplot as plt

# Create the scatter plot
g1800s.plot(kind="scatter", x="1800", y="1899")

# Specify axis labels
plt.xlabel('Life Expectancy by Country in 1800')
plt.ylabel('Life Expectancy by Country in 1899')

# Specify axis limits
plt.xlim(20, 55)
plt.ylim(20, 55)

# Display the plot
# plt.show()
plt.savefig("_dummyPy048.png", bbox_inches="tight")
plt.clf()


import pandas as pd
import numpy as np


def check_null_or_valid(row_data):
    """Function that takes a row of data,
    drops all missing values,
    and checks if all remaining values are greater than or equal to 0
    """
    no_na = row_data.dropna()[1:-1]
    numeric = pd.to_numeric(no_na)
    ge0 = numeric >= 0
    return ge0

# Check whether the first column is 'Life expectancy'
assert g1800s.columns[0] == "Life expectancy"

# Check whether the values in the row are valid
assert g1800s.iloc[:, 1:].apply(check_null_or_valid, axis=1).all().all()

# Check that there is only one instance of each country
assert g1800s['Life expectancy'].value_counts()[0] == 1


# Also frames g1900s as 260x101 and g2000s as 260x18
# Concatenate the DataFrames row-wise
gapminder = pd.concat([g1800s, g1900s, g2000s])

# Print the shape of gapminder
print(gapminder.shape)

# Print the head of gapminder
print(gapminder.head())


# Melt gapminder: gapminder_melt
gapminder_melt = pd.melt(gapminder, id_vars="Life expectancy")

# Rename the columns
gapminder_melt.columns = ['country', 'year', 'life_expectancy']

# Print the head of gapminder_melt
print(gapminder_melt.head())


# Exercises used gapminder_melt as gapminder - keep copy before over-writing in case needed later
gapminder_old = gapminder.loc[:, :]
gapminder = gapminder_melt.loc[:, :]


# Convert the year column to numeric
gapminder.year = pd.to_numeric(gapminder.year)

# Test if country is of type object
assert gapminder.country.dtypes == np.object

# Test if year is of type int64
assert gapminder.year.dtypes == np.int64

# Test if life_expectancy is of type float64
assert gapminder.life_expectancy.dtypes == np.float64


# Create the series of countries: countries
countries = gapminder["country"]

# Drop all the duplicates from countries
countries = countries.drop_duplicates()

# Write the regular expression: pattern
pattern = '^[A-Za-z\.\s]*$'

# Create the Boolean vector: mask
mask = countries.str.contains(pattern)

# Invert the mask: mask_inverse
mask_inverse = ~mask  # The ~ is for inversion

# Subset countries using mask_inverse: invalid_countries
invalid_countries = countries.loc[mask_inverse]

# Print invalid_countries
print(invalid_countries)


# Assert that country does not contain any missing values
assert pd.notnull(gapminder.country).all()

# Assert that year does not contain any missing values
assert pd.notnull(gapminder.year).all()

# Print the shape of gapminder (prior to dropping NaN)
print(gapminder.shape)

# Drop the missing values
gapminder = gapminder.dropna()

# Print the shape of gapminder (after dropping NaN)
print(gapminder.shape)


# Add first subplot
plt.subplot(2, 1, 1) 

# Create a histogram of life_expectancy
gapminder["life_expectancy"].plot(kind="hist")

# Group gapminder: gapminder_agg
gapminder_agg = gapminder.groupby(by="year")["life_expectancy"].mean()

# Print the head of gapminder_agg
print(gapminder_agg.head())

# Print the tail of gapminder_agg
print(gapminder_agg.tail())


# Add second subplot
plt.subplot(2, 1, 2)

# Create a line plot of life expectancy per year
gapminder_agg.plot()

# Add title and specify axis labels
plt.title('Life expectancy over the years')
plt.ylabel('Life expectancy')
plt.xlabel('Year')

# Display the plots
plt.tight_layout()
# plt.show()
plt.savefig("_dummyPy049.png", bbox_inches="tight")
plt.clf()

# Save both DataFrames to csv files
gapminder.to_csv(myPath + "gapminder.csv")
gapminder_agg.to_csv(myPath + "gapminder_agg.csv")


```
  
  
**Gapminder Life Expectancy by Country (1899 vs 1800)**:  
![](_dummyPy048.png)

**Gapminder Life Expectancy**:  
![](_dummyPy049.png)


  
## Python Data Manipulation  
###_pandas Foundations_#
  
Chapter 1 - Data Ingestion and Inspection  
  
Review of pandas data frames - tabular data structure with labelled rows and columns:  
  
* Rows have an index - tabled list of labels  
* Can get the columns as a list (technically, pandas index) using myPD.columns  
* Can get the rows as a list (technically, pandas index) using myPD.index  
* Can filter using numeric indices using myPD.iloc[row, col]  # all row or all col is signalled with : and from start end at a-1 is :a and from a to end is a:  
	* The .loc accesser will instead access by way of indices  
* Can see the first few rows using myPD.head() and can see the last few rows using myPD.tail()  # put a number inside () if you do not want the default of 6 [indices 0-5]  
* Can get similar information to str() when using myPD.info()  
* Can use broadcasting with the :: operator - for example, myPD.iloc[::3, -1] will access every third row and the last column  
* The columns of a data frame are called a "series", has its own .head() method, and inherits its name from the master pandas data frame  
  
Building DataFrames from scratch:  
  
* Can load from flat files or other external data sources, such as pd.read_csv()  
* Can create from dictionaries (associative arrays) - the keys become the column names while the values (lists) become the column contents  
	* pd.DataFrame(myDict) will run the conversion, with row indices starting from 0 and running through n-1 created by default  
* Can create from zipped tuples of lists - assume that lists a, b, and c have already been created and are of the same length  
	* list_labels = ["a", "b", "c"] ; list_data = [a, b, c] ; zip_list = list(zip(list_labels, list_data))  
    * pd.DataFrame(dict(zip_list)) will then create the pandas DataFrame by way of the dictionary  
* New columns can be created on the fly (boradcasting), such as myPD["newCol"] = 0 # will put 0 in every row of newCol  
	* Broadcasting can also be done with the dictionary method, where a single value in a key-value pair will be broadcast to all rows of the DataFrame  
  
Importing and exporting data - example using ISSN_D_tot.csv, sunspot data:  
  
* Can read in the CSV using pd.read_csv("myCSV.csv")  
	* Appliyng the option header=None will work better for data where the first row does not contain the column labels  
    * Can also provide the option names=[myList] to assign myList as the column names  
    * Can also provide the na_values= option to assign NA; for example, na_values=" -1" if all the space followed by -1 are supposed to mean missing values  
    * Can also provide a dictionary by column names for the NA strings, such as {"sunspots":[" -1"]} to indicate that the sunspots data column in the CSV uses " -1" for NA  
    * Can also provide the option parse_dates([myList]) and the reader will do its best to take data in columns myList and amalgamate them to a date  
* Can keep only the desired columns of a pandas DataFrame by using df[myCols] where myCols is a list of columns desired to be kept  
* Can write the DataFrame to a CSV using df.to_csv()  # Can make other flat files using sep="", for example tab-delimited would be sep="\t"  
* Can write the DataFrame to Excel using df.to_excel()  
  
Plotting with pandas - can plot either the panda Series or the underlying numpy array - plt.plot() followed by plt.show() works on either/both:  
  
* myPD["myCol"].values will be the numpy array for column myCol  
* myPD["myCol"] will be the pandas Series for column myCol  
* Alternately, the pandas Series has a .plot() method, so myPD["myCol"].plot() rather than plt.plot(myPD["myCol"]) can be used  
	* Can also apply the .plot() method to the full pandas DataFrame, such as myPD.plot()  
* Can apply plt.yscale("log") to create a log-scale for the y-axis  
* Some additional options to .plot() include color=, style=, legend=  # colors are "r", "b" and the like while styles are " ." and " .-" and the like  
* Can save plots as various formats, inferred by the extension of the plt.savefig() call  
	* PNG plt.savefig("myFile.png")  
    * JPG plt.savefig("myFile.jpg")  
    * PDF plt.savefig("myFile.pdf")  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"

# NEED TO CREATE FRAME df - "Total Population" - [3034970564.0, 3684822701.0, 4436590356.0, 5282715991.0, 6115974486.0, 6924282937.0] indexed by "Year" [1960, 1970, 1980, 1990, 2000, 2010]
# Import numpy
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


df = pd.DataFrame( {"Total Population":[3034970564.0, 3684822701.0, 4436590356.0, 5282715991.0, 6115974486.0, 6924282937.0], "Year":[1960, 1970, 1980, 1990, 2000, 2010]} )
df.index = df["Year"]
del df["Year"]
world_population = df.copy()

# Create array of DataFrame values: np_vals
np_vals = df.values

# Create new array of base 10 logarithm values: np_vals_log10
np_vals_log10 = np.log10(np_vals)

# Create array of new DataFrame by passing df to np.log10(): df_log10
df_log10 = np.log10(df)

# Print original and new data containers
print(type(np_vals), type(np_vals_log10))
print(type(df), type(df_log10))


list_keys = ['Country', 'Total']
list_values = [['United States', 'Soviet Union', 'United Kingdom'], [1118, 473, 273]]

# Zip the 2 lists together into one list of (key,value) tuples: zipped
zipped = list(zip(list_keys, list_values))

# Inspect the list using print()
print(zipped)

# Build a dictionary with the zipped list: data
data = dict(zipped)

# Build and inspect a DataFrame from the dictionary: df
df = pd.DataFrame(data)
print(df)


tempDict = {"a":[1980, 1981, 1982] , "b":["Blondie", "Chris Cross", "Joan Jett"] , "c":["Call Me", "Arthurs Theme", "I Love Rock and Roll"], "d":[6, 3, 7]}
df = pd.DataFrame(tempDict)

# Build a list of labels: list_labels
list_labels = ['year', 'artist', 'song', 'chart weeks']

# Assign the list of labels to the columns attribute: df.columns
df.columns = list_labels
print(df)


cities = ['Manheim', 'Preston park', 'Biglerville', 'Indiana', 'Curwensville', 'Crown', 'Harveys lake', 'Mineral springs', 'Cassville', 'Hannastown', 'Saltsburg', 'Tunkhannock', 'Pittsburgh', 'Lemasters', 'Great bend']

# Make a string with the value 'PA': state
state = "PA"

# Construct a dictionary: data
data = {'state':state, 'city':cities}

# Construct a DataFrame from dictionary data: df
df = pd.DataFrame(data)

# Print the DataFrame
print(df)


# "world_population.csv is the same 6x2 population data as per the above
# Read in the file: df1
# df1 = pd.read_csv("world_population.csv")
# Skipped this part

# Create a list of the new column labels: new_labels
# new_labels = ["year", "population"]

# Read in the file, specifying the header and names parameters: df2
# df2 = pd.read_csv('world_population.csv', header=0, names=new_labels)
# Skipped this step

# Print both the DataFrames
# print(df1)
# print(df2)


# DO NOT HAVE the messy data - file_messy is "messy_stock_data.tsv"
# Read the raw file as-is: df1
# df1 = pd.read_csv(file_messy)

# Print the output of df1.head()
# print(df1.head())

# Read in the file with the correct parameters: df2
# df2 = pd.read_csv(file_messy, delimiter="\t", header=3, comment="#")

# Print the output of df2.head()
# print(df2.head())

# Save the cleaned up DataFrame to a CSV file without the index
# df2.to_csv(file_clean, index=False)

# Save the cleaned up DataFrame to an excel file without the index
# df2.to_excel('file_clean.xlsx', index=False)



# DO NOT HAVE DataFrame df, which is a 744x1 of "Temperature (deg F)" indexed automatically as 0-743
# Downloaded raw METAR data for KAUS using 0801100000 UTC - 0831102359 UTC
# Coded to a cleaned CSV as per below
# 
# 
# metarList = []
# for line in open(myPath + "KAUS_Metar_Aug2010.txt", "r"): metarList.append(line.rstrip())
# cleanMetar = []
# cleanLine = ""
# for recs in metarList:
#     if recs.startswith("#") or recs == "" : continue
#     if recs.startswith("2") : 
#         if cleanLine != "" : 
#             cleanMetar.append(cleanLine)
#         cleanLine = recs
#     else:
#         cleanLine = cleanLine + " " + recs.strip()
# 
# cleanMetar.append(cleanLine)
# 
# useMetar = [textBlock for textBlock in cleanMetar if "METAR" in textBlock]
# useSpeci = [textBlock for textBlock in cleanMetar if "SPECI" in textBlock]
# assert len(cleanMetar) == len(useMetar) + len(useSpeci)
# 
# import re
# 
# metTime = []
# tempF = []
# dewF = []
# altMG = []
# 
# for textBlock in useMetar:
#     if textBlock.endswith("NIL="):
#         print("Not using line", textBlock)
#         continue
#     
#     # print(textBlock)
#     dateUTC = textBlock.split()[0]
#     
#     tempData = re.findall("T([0-9][0-9][0-9][0-9])([0-9][0-9][0-9][0-9])", textBlock)
#     assert len(tempData) == 1
#     a, b = tempData[0]
#     tempC = float(a[1:])/10
#     dewC = float(b[1:])/10
#     if a[0] == "1" : tempC = -tempC
#     if b[0] == "1" : dewC = -dewC
#     
#     tF = round((9/5) * tempC + 32, 0)
#     dF = round((9/5) * dewC + 32, 0)
#     
#     altData = re.findall("A([0-9][0-9][0-9][0-9])", textBlock)
#     assert len(altData) == 1
#     
#     aMG = float(altData[0]) / 100
#     # print(dateUTC, tempC, dewC, altMG, tempF, dewF)
#     
#     metTime.append(dateUTC)
#     tempF.append(tF)
#     dewF.append(dF)
#     altMG.append(aMG)
# 
# metarKAUS = pd.DataFrame( {"DateTime (UTC)":metTime, "Temperature (deg F)":tempF , "Dew Point (deg F)":dewF, "Pressure (atm)":altMG} )
# metarKAUS.index = metarKAUS["DateTime (UTC)"]
# del metarKAUS["DateTime (UTC)"]
# 
# metarKAUS.to_csv(myPath + "KAUS_Metar_Aug2010_Clean.csv")


# Create or import the data
# import random
# df = pd.DataFrame( {"Temperature (deg F)":np.random.randint(low=60, high=100, size=744)} )
dfFull = pd.read_csv(myPath + "KAUS_Metar_Aug2010_Clean.csv")
df = dfFull.loc[:, "Temperature (deg F)"]

# Create a plot with color='red'
df.plot(color="red")

# Add a title
plt.title('Temperature in Austin')

# Specify the x-axis label
plt.xlabel('Hours since midnight August 1, 2010')

# Specify the y-axis label
plt.ylabel('Temperature (degrees F)')

# Display the plot
# plt.show()
plt.savefig("_dummyPy050.png", bbox_inches="tight")
plt.clf()


# DO NOT HAVE DataFrame df, which is a 744x3 of "Temperature (deg F)", "Dew Point (deg F)", "Pressure (atm)" indexed automatically as 0-743
# df["Dew Point (deg F)"] = df.iloc[:, 0] + np.random.randint(low=-30, high=0, size=744)
# df["Pressure (atm)"] = np.random.randint(low=980, high=1020, size=744)
# Use dfFull rather than manufacturing data

df = dfFull.copy()
df.index = [x[6:8] + "-" + "{0:0>2}".format(str(int(x[9:10]) + 1)) + "Z" for x in df["DateTime (UTC)"].astype(str)]
del df["DateTime (UTC)"]

# Plot all columns (default)
df.plot()
# plt.show()
plt.savefig("_dummyPy051.png", bbox_inches="tight")
plt.clf()


# Plot all columns as subplots
df.plot(subplots=True)
# plt.show()
plt.savefig("_dummyPy052.png", bbox_inches="tight")
plt.clf()


# Plot just the Dew Point data
column_list1 = ['Dew Point (deg F)']
df[column_list1].plot()
# plt.show()
plt.savefig("_dummyPy053.png", bbox_inches="tight")
plt.clf()


# Plot the Dew Point and Temperature data, but not the Pressure data
column_list2 = ['Temperature (deg F)','Dew Point (deg F)']
df[column_list2].plot()
# plt.show()
plt.savefig("_dummyPy054.png", bbox_inches="tight")
plt.clf()


```
  
  
**Temperature - Austin, TX (Aug 2010)**:  
![](_dummyPy050.png)

**METAR plots - Austin, TX (Aug 2010)**:  
![](_dummyPy051.png)

**METAR Sub-plots - Austin, TX (Aug 2010)**:  
![](_dummyPy052.png)

**Dew Point - Austin, TX (Aug 2010)**:  
![](_dummyPy053.png)

**Temperature and Dew Point - Austin, TX (Aug 2010)**:  
![](_dummyPy054.png)

  
***
  
Chapter 2 - Exploratory Data Analysis  
  
Visual exploratory data analysis - using Fisher's iris flower data (similar to the R dataset):  
  
* Can use df.plot(x="quotedVar1", y="quotedVar2", kind="scatter") followed by plt.show() for general DataFrame plotting  
	* The default is kind="line", though kind="scatter" often makes more sense for unordered and/or multi-dimensional data  
    * Can add plt.xlabel() and plt.ylabel() for labelling the axis dimensions  
    * Can also have types like kind="box" for box/whiskers, kind="hist" for histograms, etc.  
    * Further, can specify any matplotlib options inside DataFrame.plot() command - see the documentation  
* For histograms, cumulative=True will make the CDF rather than PDF while normed=True makes it probabilities rather than total counts  
* There are several manners (with slightly different defaults) for calling plots on a dataframe - df.plot(kind="hist"), df.plt.hist(), and df.hist()  
  
Statistical exploratory data analysis - starting with the .describe() method which is very similar to summary() in R - counts, means, quartiles, and the like:  
  
* These can be accessed individually, such as .count(), .mean(), .std(), .median(), .quantile(q) where q is between 0 and 1 and can be a list or array of values, .max(), .min()  
	* All of these statistics AVOID the null entries - the count is the count of non-null, the mean is the mean of the non-null, etc.  
  
Separating populations with boolean indexing - subsets of columns and/or rows for plotting, summarizing, and the like:  
  
* The .unique() method returns the unique factors of a categorical variable, suggesting subsets of interest for EDA  
* The typical filtering process would be to create a boolean, then myFilter = myDF[myBool, :]  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"


import pandas as pd
from datetime import datetime
import matplotlib.pyplot as plt


dummyStock = pd.read_csv(myPath + "StockChart_20170615.csv", header=None)
dummyStock.columns = ["Symbol", "Data"]
# Data is a single space-delimited string of Date - Open - High - Low - Close - Volume

dummyStockSplit = dummyStock["Data"].str.split()
dummyDates = [datetime.strptime(x[0], "%m/%d/%Y") for x in dummyStockSplit]
dummyClose = [float(x[4]) for x in dummyStockSplit]

dfStock = pd.DataFrame( {"date":dummyDates, "symbol":dummyStock["Symbol"] , "close":dummyClose} )
df = dfStock.pivot(index="date", columns="symbol", values="close").resample("M").max()


# df is 12 x 4 with columns Month-AAPL-GOOG-IBM
# Create a list of y-axis column names: y_columns
y_columns = ["AAPL", "IBM"]

# Generate a line plot
df.plot(y=y_columns)

# Add the title
plt.title('Monthly stock prices')

# Add the y-axis label
plt.ylabel('Price ($US)')

# Display the plot
# plt.show()
plt.savefig("_dummyPy055.png", bbox_inches="tight")
plt.clf()


# Here, df appears to be the mtcars data
# Saved file from R
df = pd.read_csv(myPath + "mtcars.csv", index_col=0)

# sizes is a pre-defined np.array(), not sure of what
sizes = df["cyl"]
# Generate a scatter plot
df.plot(kind="scatter", x='hp', y='mpg', s=5*(sizes-3))

# Add the title
plt.title('Fuel efficiency vs Horse-power')

# Add the x-axis label
plt.xlabel('Horse-power')

# Add the y-axis label
plt.ylabel('Fuel efficiency (mpg)')

# Display the plot
# plt.show()
plt.savefig("_dummyPy056.png", bbox_inches="tight")
plt.clf()


# Make a list of the column names to be plotted: cols
cols = ["wt", "mpg"]

# Generate the box plots
df[cols].plot(kind="box", subplots=True)

# Display the plot
# plt.show()
plt.savefig("_dummyPy057.png", bbox_inches="tight")
plt.clf()


# Here, df is the tipping data from the Seaborn package, with emphasis on the column "fraction"
# Create a reasonable analog based on the pre-made CSV
tips = pd.read_csv(myPath + "tips.csv")
tips.sex = tips["sex"].astype("category")
tips.smoker = tips["smoker"].astype("category")
tips['total_bill'] = pd.to_numeric(tips["total_bill"], errors="coerce")
tips['tip'] = pd.to_numeric(tips["tip"], errors="coerce")
tips["fraction"] = tips["tip"] / tips["total_bill"]
df = tips.copy()


# This formats the plots such that they appear on separate rows
fig, axes = plt.subplots(nrows=2, ncols=1)

# Plot the PDF and CDF on the two axes
df.fraction.plot(ax=axes[0], kind='hist', bins=30, normed=True, range=(0,.3))
df.fraction.plot(ax=axes[1], kind="hist", bins=30, normed=True, cumulative=True, range=(0,.3))
# plt.show()
plt.savefig("_dummyPy058.png", bbox_inches="tight")
plt.clf()


# df is degrees by gender from http://nces.ed.gov/programs/digest/2013menu_tables.asp
# DO NOT HAVE DATASET - skip
# Print the minimum value of the Engineering column
# print(df["Engineering"].min())

# Print the maximum value of the Engineering column
# print(df["Engineering"].max())

# Construct the mean percentage per year: mean
# mean = df.mean(axis="columns")

# Plot the average percentage per year
# mean.plot()

# Display the plot
# plt.show()


# Now, df appears to be the Titanic dataset (not the table)
df = pd.read_csv(myPath + "titanic.csv")

# Print summary statistics of the fare column with .describe()
print(df["Fare"].describe())

# Generate a box plot of the fare column
df["Fare"].plot(kind="box")

# Show the plot
# plt.show()
plt.savefig("_dummyPy059.png", bbox_inches="tight")
plt.clf()


# Now, df is the life-expectancy Gapminder data as 260x219
# Needs the encoding to load
df = pd.read_csv(myPath + "gapminder.csv", encoding="latin-1", index_col=0).pivot_table(index="country", columns="year", values="life_expectancy")

# Print the number of countries reported in 2015
print(df[2015].count())

# Print the 5th and 95th percentiles
print(df.quantile([0.05, 0.95]))

# Generate a box plot
years = [1800, 1850, 1900, 1950, 2000]
df[years].plot(kind='box')
# plt.show()
plt.savefig("_dummyPy060.png", bbox_inches="tight")
plt.clf()


# Now, df is Pittsburgh weather data from https://www.wunderground.com/history/
# NEED TO GET THIS DATA
# january and march are both 31x2 with the columns being Date-Temperature
df = pd.read_csv(myPath + "KPIT_Temps_Small.csv")

january = df[["Date", "jan"]]
march = df[["Date", "mar"]]

# Print the mean of the January and March data
print(january.mean(), "\n", march.mean())

# Print the standard deviation of the January and March data
print(january.std(), "\n", march.std())


# Here, df is again automobile data of shape (392, 9)
# NEED TO GET THIS DATA - using MASS::Cars93 instead
tempDF = pd.read_csv(myPath + "Cars93.csv")
tempDF["Origin"]
df = tempDF[["Origin", "MPG.city", "MPG.highway", "Weight", "Horsepower"]]


# Compute the global mean and global standard deviation: global_mean, global_std
global_mean = df.mean()
global_std = df.std()

# Filter the US population from the origin column: us
us = df.loc[df["Origin"] == "USA", :]

# Compute the US mean and US standard deviation: us_mean, us_std
us_mean = us.mean()
us_std = us.std()

# Print the differences
print(us_mean - global_mean)
print(us_std - global_std)


# titanic is 1309x14 of data from the titanic
titanic = pd.read_csv(myPath + "titanic.csv", index_col=0)


# Display the box plots on 3 separate rows and 1 column
fig, axes = plt.subplots(nrows=3, ncols=1)

# Generate a box plot of the fare prices for the First passenger class
titanic.loc[titanic['Pclass'] == 1].plot(ax=axes[0], y='Fare', kind='box')

# Generate a box plot of the fare prices for the Second passenger class
titanic.loc[titanic['Pclass'] == 2].plot(ax=axes[1], y='Fare', kind='box')

# Generate a box plot of the fare prices for the Third passenger class
titanic.loc[titanic['Pclass'] == 3].plot(ax=axes[2], y='Fare', kind='box')

# Display the plot
# plt.show()
plt.savefig("_dummyPy061.png", bbox_inches="tight")
plt.clf()


```
  
  
**Maximum Stock Price by Month**:  
![](_dummyPy055.png)

**MPG vs HP (sized by Cylinders)**:  
![](_dummyPy056.png)

**Box Plots for Weight and MPG (mtcars)**:  
![](_dummyPy057.png)

**PDF and CDF for Tip as Percentage of Total Bill**:  
![](_dummyPy058.png)

**Box Plots for Titanic Fares**:  
![](_dummyPy059.png)

**Box Plot for Life Expectancy by Country (Gapminder)**:  
![](_dummyPy060.png)

**Titanic Fares by Class (First, Second, Third)**:  
![](_dummyPy061.png)

  
***
  
Chapter 3 - Time series in pandas  
  
Indexing pandas time series - dates and times are stored in datetime options:  
  
* When reading from a CSV, the command parse_dates=True will convert the relevant column(s) to ISO-8601 formats (yyyy-mm-dd hh:mm:ss)  
* The index_col="myDateFieldFromCSV" option in a pd.read_csv() will set the relevant date column (assuming parse_dates=True) as the datetime index for the DataFrame  
* Assuming that a DataFrame is indexed by datetime, can pass a smaller string (e.g., 2012-2 rather than 2012-2-5 11:00:00) to df.loc[] and everything that matches all of the smaller string will be extracted  
* Pandas supports partial datetime string selection, and using many input formats  
	* df.loc["February 5, 2015"] or df.loc["2015-Feb-5"] or df.loc["2015"  
* Can also slice a datetime string, such as df.loc["2015-Jan":"2015-Mar"] to get the entire Q1 2015 data  
* Can convert objects to datetime using pd.to_datetime()  
* Can reindex the data using df.reindex(myTime, method=)  
	* The default method is to fill with np.nan, though can specify "ffill" or "bfill" to fill forwards or backwards  
  
Resampling pandas time series - taking statistical measures over different time intervals:  
  
* Downsampling is the process of reducing datetime rows to slower frequency (e.g., hourly to daily)  
	* df.resample("D").mean() will take the mean of the down-sampled data, with "D" meaning "daily"  
    * df.resample("W").mean() will take the mean of weekly data  
    * Can build longer chains where needed; for example, df.resample("D").sum().max() will be the maximum daily sum  
    * "min" or "T" is minute; "H" is hourly; "D" is daily; "B" is busines daily  
    * "W" is week; "M" is month; "Q" is quarter; "A" is year (annual)  
    * Can further using interval multiples, for example "3M" would be 3-monthly (essentially, quarterly)  
    * There are certain default to things like "#W", for example, aligning weekly data to report by Sundays  
* Upsampling is the process of increasing datetime rows to faster frequency (e.g., daily to hourly)  
	* A common upsampling approach would use "ffill" or "bfill" such as df.resample("4H").ffill() - interpolation  
  
Manipulating pandas time series - changing the data in one or more columns:  
  
* Can apply the string methods such as df["myCol"].str.upper() - note that this is NOT a transformation in place but rather a new series  
* Can apply the string method .contains() to search for a partial string, such as df["myCol"].str.contains("ello") - will return a boolean of the same length  
* Can access the .dt method (datetime method) and its features, such as df["myCol"].dt.hour - will extract the hour  
	* The .dt.tz_localize("US/Central") will convert everything to US Central Time  
    * The .dt.tz_convert("US/Eastern") will convert everything to US Eastern Time  
* Can also chain these, such as .dt.tz_localize("US/Central").dt.tz_convert("US/Eastern") - note that the second .dt is needed after the tz_localize, since that returned a new series and not a .dt  
* To run a linear interpolation, use df.resample("Y").first().interpolate("linear") - will do linear interpolation between the values that already exist  
  
Visualizing pandas time series - additional plotting techniques such line types, plot types, and sub-plots:  
  
* Using daily S&P 500 date from 2010-01-01 through 2015-12-31 - Open-High-Low-Close-Volume  
* When plotting, can run df.plot(title=) to set the title, and plt.ylabel() later to set the y-axis labels  
* By default, df.plot will use a blue line provided that df is a pandas DataFrame  
* Can pass "MATLAB-like style strings" to the .plot(style=) options for other than lines  
	* The string has 3 characters; color ("k" is black), market ("." is dot), and line type ("-", or hyphen, is solid) - so "k.-" means black, solid line with a dot marker  
    * Colors - "b" for blue, "g" for green, "r" for red", "c" for cyan  
    * Markers - "o" for circle, "*" for star, "s" for square, "+" for plus  
    * Line - ":" for dotted, "--" for dashed  
* Can also pass an argument to the .plot(kind=) to instead have "hist" or "area"  
* Can also pass the argument .plot(subplots=True) to have sub-plots created (on separate scales) for each of the data series  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"


import pandas as pd
import matplotlib.pyplot as plt


# GREAT data is available at https://mesonet.agron.iastate.edu/request/download.phtml?network=IL_ASOS
# Downloaded KORD data from 2010 to myPath + "KORD_2010_from_IAState.txt"
# First 5 rows are commented, the sixth row is the header, and the next 10,443 rows are the data

# Load the file
tmpORD = pd.read_csv(myPath + "KORD_2010_from_IAState.txt", header=5)
tmpORD.columns = tmpORD.columns.str.strip()
isMETAR = tmpORD.loc[:, "valid"].str.contains(":51")  # KORD METAR are taken at xx:51
useORD = tmpORD.loc[isMETAR, :]  # ends as 8709 x 22, probably the METAR check missed a few at "off" times

date_list = useORD["valid"]
temperature_list = list(useORD["tmpf"])

# This is 8,759 temperature observations refelecting 20100101 00:00 through 20101231 23:00 on an hourly basis
# Prepare a format string: time_format
time_format = '%Y-%m-%d %H:%M'

# Convert date_list into a datetime object: my_datetimes
my_datetimes = pd.to_datetime(date_list, format=time_format)  

# Construct a pandas Series using temperature_list and my_datetimes: time_series
# Something to explore later - this produced all np.nan if temperature_list were already a Series
ts0 = pd.Series(temperature_list, index=my_datetimes)

# Extract the hour from 9pm to 10pm on '2010-10-11': ts1
ts1 = ts0.loc['2010-10-11 20:51:00']

# Extract '2010-07-04' from ts0: ts2
ts2 = ts0.loc["2010-07-04"]

# Extract data from '2010-12-15' to '2010-12-31': ts3
ts3 = ts0.loc["2010-12-15":"2010-12-31"]


# Reindex without fill method: ts3
ts3 = ts2.reindex(ts0.index)

# Reindex with fill method, using forward fill: ts4
ts4 = ts2.reindex(ts0.index, method="ffill")

# Combine ts1 + ts2: sum12
sum12 = ts1 + ts2

# Combine ts1 + ts3: sum13
sum13 = ts1 + ts3

# Combine ts1 + ts4: sum14
sum14 = ts1 + ts4


# Still working with the temperature data, now renamed as df [technically, same index but containing Temperature-Dew Point-Pressure]
df = useORD[["tmpf", "dwpf", "alti"]]
df.index = my_datetimes
df.columns = ["Temperature", "DewPoint", "Pressure"]
saveWeather = df.copy()


# Downsample to 6 hour data and aggregate by mean: df1
df1 = df["Temperature"].resample("6H").mean()

# Downsample to daily data and count the number of data points: df2
df2 = df["Temperature"].resample("D").count()


# Extract temperature data for August: august
august = df.loc["2010-08", "Temperature"]

# Downsample to obtain only the daily highest temperatures in August: august_highs
august_highs = august.resample("D").max()

# Extract temperature data for February: february
february = df.loc["2010-02", "Temperature"]

# Downsample to obtain the daily lowest temperatures in February: february_lows
february_lows = february.resample("D").min()


# Extract data from 2010-Aug-01 to 2010-Aug-15: unsmoothed
unsmoothed = df['Temperature']["2010-08-01":"2010-08-15"]

# Apply a rolling mean with a 24 hour window: smoothed
smoothed = unsmoothed.rolling(window=24).mean()

# Create a new DataFrame with columns smoothed and unsmoothed: august
august = pd.DataFrame({'smoothed':smoothed, 'unsmoothed':unsmoothed})

# Plot both smoothed and unsmoothed data using august.plot().
august.plot()
# plt.show()
plt.savefig("_dummyPy062.png", bbox_inches="tight")
plt.clf()


# Extract the August 2010 data: august
august = df['Temperature']["2010-08"]

# Resample to daily data, aggregating by max: daily_highs
daily_highs = august.resample("D").max()

# Use a rolling 7-day window with method chaining to smooth the daily high temperatures in August
daily_highs_smoothed = daily_highs.rolling(window=7).mean()
print(daily_highs_smoothed)



# Plot the summer data
df = saveWeather.copy()
df.Temperature["2010-Jun":"2010-Aug"].plot()
# plt.show()
plt.savefig("_dummyPy063.png", bbox_inches="tight")
plt.clf()

# Plot the one week data
df.Temperature['2010-06-10':'2010-06-17'].plot()
# plt.show()
plt.savefig("_dummyPy064.png", bbox_inches="tight")
plt.clf()



# Now, df is 1741x17 of airline/airport data
# Saved the June 2011 data from hflights::hflights to csv
dfJun = pd.read_csv(myPath + "junFlights.csv")
dfJun["useMonth"] = ["{0:0>2}".format(x) for x in dfJun["Month"]]
dfJun["useDate"] = ["{0:0>2}".format(x) for x in dfJun["DayofMonth"]]
keyDates = dfJun["Year"].astype(str) + dfJun["useMonth"] + dfJun["useDate"]
time_format = '%Y%m%d'
useDates = pd.to_datetime(keyDates, format=time_format)  
dfJun.index = useDates

df = dfJun[["DayOfWeek", "Dest", "DepTime", "ArrTime", "UniqueCarrier", "FlightNum"]]
df.columns = ["Weekday", "Destination Airport", "Wheels-off Time", "Arrival Time", "Carrier", "Flight"]

# Strip extra whitespace from the column names: df.columns
df.columns = df.columns.str.strip()

# Extract data for which the destination airport is Dallas: dallas
dallas = df['Destination Airport'].str.contains("DAL")

# Compute the total number of Dallas departures each day: daily_departures
daily_departures = dallas.resample("D").sum()

# Generate the summary statistics for daily Dallas departures: stats
stats = daily_departures.describe()
print(stats)


# Reset the index of ts2 to ts1, and then use linear interpolation to fill in the NaNs: ts2_interp
# ts2_interp = ts2.reindex(ts1.index).interpolate("linear")

# Compute the absolute difference of ts1 and ts2_interp: differences 
# differences = np.abs(ts2_interp - ts1)

# Generate and print summary statistics of the differences
# print(differences.describe())


# Buid a Boolean mask to filter out all the 'LAX' departure flights: mask
import numpy as np
mask = df['Destination Airport'] == "LAX"

# Use the mask to subset the data: la
la = df[mask].dropna()
la["Date"] = la.index.astype(str)
la["Wheel Time"] = ["{0:0>4}".format(int(x)) for x in la["Wheels-off Time"]]

# Combine two columns of data to create a datetime series: times_tz_none 
times_tz_none = pd.to_datetime(la["Date"] + " " + la["Wheel Time"])

# Localize the time to US/Central: times_tz_central
times_tz_central = times_tz_none.dt.tz_localize("US/Central")

# Convert the datetimes from US/Central to US/Pacific
times_tz_pacific = times_tz_central.dt.tz_convert("US/Pacific")


newDF = pd.DataFrame( {"Date":keyDates, "Carrier":list(df["Carrier"]), "nFlight":1} )
useCarrier = [x in ["XE", "CO", "WN", "OO"] for x in newDF["Carrier"]]
useDF = newDF.loc[useCarrier].pivot_table(index="Date", columns=["Carrier"], values=["nFlight"], aggfunc=sum)

# Plot the raw data before setting the datetime index
useDF.plot()
# plt.show()
plt.savefig("_dummyPy065.png", bbox_inches="tight")
plt.clf()


# Convert the 'Date' column into a collection of datetime objects: df.Date
useDF["Date"] = pd.to_datetime(useDF.index)

# Set the index to be the converted 'Date' column
useDF.set_index("Date", inplace=True)  # inplace=True makes the conversion in place; no need to reassign

# Re-plot the DataFrame to see that the axis is now datetime aware!
useDF.plot()
# plt.show()
plt.savefig("_dummyPy066.png", bbox_inches="tight")
plt.clf()

```
  
  
**Chicago Temperatures (KORD) - August 2010**:  
![](_dummyPy062.png)


**Chicago Temperatures (KORD) - Summer 2010**:  
![](_dummyPy063.png)


**Chicago Temperatures (KORD) - June 10-17, 2010**:  
![](_dummyPy064.png)


**Flights per Day (Top 4 Carriers) - Houston, June 2011**:  
![](_dummyPy065.png)

**Index Formatted as Date-Time rather than String**:  
![](_dummyPy066.png)
 
  
***
  
Chapter 4 - Case Study - Sunlight in Austin  
  
Reading and cleaning the data - messy weather and climate data for Austin:  
  
* First dataset will be climate normals for Austin from 1981-2010 (NOAA, hourly averages)  
* Second dataset will be climate measurements for Austin from 2011 - needs cleaning  
  	
Statistical exploratory data analysis - slicing time series and the like:  
  
* .describe() is like the summary() call in R  
* .mean(), .count(), .median() and the like are all available individually  
  
Visual exploratory data analysis - histograms, line plots, box plots, and the like:  
  
* Pandas builds on matplotlib, allowing for further customization to make the plots pretty  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"


# Import pandas
import pandas as pd

# GREAT data is available at https://mesonet.agron.iastate.edu/request/download.phtml?network=TX_ASOS
# Downloaded KORD data from 2011 to myPath + "KAUS_2011_from_IAState.txt"
tmpAUS = pd.read_csv(myPath + "KAUS_2011_from_IAState.txt", header=5)
tmpAUS.columns = tmpAUS.columns.str.strip()
isMETAR = tmpAUS.loc[:, "valid"].str.contains(":53")  # KAUS METAR are taken at xx:53
useAUS = tmpAUS.loc[isMETAR, :]  # ends as 11,352 x 22, tons of duplicate METAR
useAUS = useAUS.drop_duplicates(subset=["valid"])  # ends as 8,432 x 22, some days with as few as 15 records


# First 5 rows are commented, the sixth row is the header, and the next 10,443 rows are the data
# Read in the data file: df
# df = pd.read_csv("data.csv")
df = useAUS.copy()

df["date"] = [x.split()[0] for x in df["valid"]]
df["time"] = [x.split()[1] for x in df["valid"]]
df["StationType"] = "Airport"
df["sky_condition"] = df["skyc1"] + df["skyc2"] + df["skyc3"] + df["skyc4"]

# Print the output of df.head()
print(df.head())


# This is the column_labels list (my data is different - modify)
# column_labels = "Wban,date,Time,StationType,sky_condition,sky_conditionFlag,visibility,visibilityFlag,wx_and_obst_to_vision,wx_and_obst_to_visionFlag,dry_bulb_faren,dry_bulb_farenFlag,dry_bulb_cel,dry_bulb_celFlag,wet_bulb_faren,wet_bulb_farenFlag,wet_bulb_cel,wet_bulb_celFlag,dew_point_faren,dew_point_farenFlag,dew_point_cel,dew_point_celFlag,relative_humidity,relative_humidityFlag,wind_speed,wind_speedFlag,wind_direction,wind_directionFlag,value_for_wind_character,value_for_wind_characterFlag,station_pressure,station_pressureFlag,pressure_tendency,pressure_tendencyFlag,presschange,presschangeFlag,sea_level_pressure,sea_level_pressureFlag,record_type,hourly_precip,hourly_precipFlag,altimeter,altimeterFlag,junk"

# list_to_drop = ['sky_conditionFlag', 'visibilityFlag', 'wx_and_obst_to_vision', 'wx_and_obst_to_visionFlag', 'dry_bulb_farenFlag', 'dry_bulb_celFlag', 'wet_bulb_farenFlag', 'wet_bulb_celFlag', 'dew_point_farenFlag', 'dew_point_celFlag', 'relative_humidityFlag', 'wind_speedFlag', 'wind_directionFlag', 'value_for_wind_character', 'value_for_wind_characterFlag', 'station_pressureFlag', 'pressure_tendencyFlag', 'pressure_tendency', 'presschange', 'presschangeFlag', 'sea_level_pressureFlag', 'hourly_precip', 'hourly_precipFlag', 'altimeter', 'record_type', 'altimeterFlag', 'junk']

# Desired variables to be kept
# final_keep = ["Wban", "StationType", "date", "Time", "dry_bulb_faren", "dew_point_faren", "wet_bulb_faren", "dry_bulb_cel", "dew_point_cel", "wet_bulb_cel", "sky_condition", "station_pressure", "sea_level_pressure", "relative humidity", "wind_direction", "wind_speed", "visibility"]

final_keep = ["Wban", "StationType", "date", "Time", "dry_bulb_faren", "dew_point_faren", "sky_condition", "station_pressure", "sea_level_pressure", "relative humidity", "wind_direction", "wind_speed", "visibility"]

# Remove the appropriate columns: df_dropped
# df_dropped = df.drop(list_to_drop, axis="columns")
df_dropped = df.iloc[:, [0, 24, 22, 23, 2, 3, 25, 8, 9, 4, 5, 6, 10]]
df_dropped.columns = final_keep


# Print the output of df_dropped.head()
print(df_dropped.head())
print(df_dropped.shape)


# Convert the date column to string: df_dropped['date']
# df_dropped['date'] = df_dropped["date"].astype(str)

# Pad leading zeros to the Time column: df_dropped['Time']
# df_dropped['Time'] = df_dropped['Time'].apply(lambda x:'{:0>4}'.format(x))

# Concatenate the new date and Time columns: date_string
date_string = df_dropped['date'] + " " + df_dropped['Time']

# Convert the date_string Series to datetime: date_times
date_times = pd.to_datetime(date_string, format='%Y-%m-%d %H:%M')

# Set the index to be the new date_times container: df_clean
df_clean = df_dropped.set_index(date_times)


# Eliminate straggler record with index in 2010
is2011 = df_clean.index.year == 2011
df_clean = df_clean.loc[is2011, :]

# Print the output of df_clean.head()
print(df_clean.head())
print(df_clean.shape)


# Print the dry_bulb_faren temperature between 8 AM and 9 AM on June 20, 2011
print(df_clean.loc["2011-06-20 08:00:00":"2011-06-20 09:00:00", "dry_bulb_faren"])

# Convert the dry_bulb_faren column to numeric values: df_clean['dry_bulb_faren']
df_clean['dry_bulb_faren'] = pd.to_numeric(df_clean['dry_bulb_faren'], errors="coerce")

# Print the transformed dry_bulb_faren temperature between 8 AM and 9 AM on June 20, 2011
print(df_clean.loc["2011-06-20 08:00:00":"2011-06-20 09:00:00", "dry_bulb_faren"])

# Convert the wind_speed and dew_point_faren columns to numeric values
df_clean['wind_speed'] = pd.to_numeric(df_clean['wind_speed'], errors="coerce")
df_clean['dew_point_faren'] = pd.to_numeric(df_clean['dew_point_faren'], errors="coerce")
df_clean['visibility'] = pd.to_numeric(df_clean['visibility'], errors="coerce")


# Print the median of the dry_bulb_faren column
print(df_clean["dry_bulb_faren"].median())

# Print the median of the dry_bulb_faren column for the time range '2011-Apr':'2011-Jun'
print(df_clean.loc["2011-04":"2011-06", 'dry_bulb_faren'].median())

# Print the median of the dry_bulb_faren column for the month of January
print(df_clean.loc["2011-01", 'dry_bulb_faren'].median())


# Downsample df_clean by day and aggregate by mean: daily_mean_2011
daily_mean_2011 = df_clean.resample("D").mean()

# Extract the dry_bulb_faren column from daily_mean_2011 using .values: daily_temp_2011
daily_temp_2011 = daily_mean_2011["dry_bulb_faren"].values


# NEED FILE!
# Downsample df_climate by day and aggregate by mean: daily_climate
# daily_climate = df_climate.resample("D").mean()

# Extract the Temperature column from daily_climate using .reset_index(): daily_temp_climate
# daily_temp_climate = daily_climate.reset_index()["Temperature"]

# Compute the difference between the two arrays and print the mean difference
# difference = daily_temp_2011 - daily_temp_climate
# print(difference.mean())


# Select days that are sunny: sunny
sunny = df_clean.loc[df_clean["sky_condition"].str.strip() == "CLR"]

# Select days that are overcast: overcast
overcast = df_clean.loc[df_clean["sky_condition"].str.contains("OVC")]

# Resample sunny and overcast, aggregating by maximum daily temperature
sunny_daily_max = sunny.resample("D").max()
overcast_daily_max = overcast.resample("D").max()

# Print the difference between the mean of sunny_daily_max and overcast_daily_max
print(sunny_daily_max.mean() - overcast_daily_max.mean())


# Import matplotlib.pyplot as plt
import matplotlib.pyplot as plt

# Select the visibility and dry_bulb_faren columns and resample them: weekly_mean
weekly_mean = df_clean[["visibility", "dry_bulb_faren"]].resample("W").mean()

# Print the output of weekly_mean.corr()
print(weekly_mean.corr())

# Plot weekly_mean with subplots=True
weekly_mean.plot(subplots=True)
# plt.show()
plt.savefig("_dummyPy067.png", bbox_inches="tight")
plt.clf()


# Create a Boolean Series for sunny days: sunny
sunny = df_clean["sky_condition"].str.strip() == "CLR"

# Resample the Boolean Series by day and compute the sum: sunny_hours
sunny_hours = sunny.resample("D").sum()

# Resample the Boolean Series by day and compute the count: total_hours
total_hours = sunny.resample("D").count()

# Divide sunny_hours by total_hours: sunny_fraction
sunny_fraction = sunny_hours / total_hours

# Make a box plot of sunny_fraction
sunny_fraction.plot(kind="box")
# plt.show()
plt.savefig("_dummyPy068.png", bbox_inches="tight")
plt.clf()


# Resample dew_point_faren and dry_bulb_faren by Month, aggregating the maximum values: monthly_max
monthly_max = df_clean[['dew_point_faren', 'dry_bulb_faren']].resample("M").max()

# Generate a histogram with bins=8, alpha=0.5, subplots=True
monthly_max.plot(kind="hist", bins=8, alpha=0.5, subplots=True)

# Show the plot
# plt.show()
plt.savefig("_dummyPy069.png", bbox_inches="tight")
plt.clf()


# Recall that df_climate is a separate dataset of the 1981-2010 data
# NEED DATASET
# Extract the maximum temperature in August 2010 from df_climate: august_max
# august_max = df_climate.loc["2010-Aug", "Temperature"].max()
# print(august_max)

# Resample the August 2011 temperatures in df_clean by day and aggregate the maximum value: august_2011
# august_2011 = df_clean.loc["2011-Aug", "dry_bulb_faren"].resample("D").max()

# Filter out days in august_2011 where the value exceeded august_max: august_2011_high
# august_2011_high = august_2011.loc[august_2011 > august_max]

# Construct a CDF of august_2011_high
# august_2011_high.plot(kind="hist", bins=25, normed=True, cumulative=True)

# Display the plot
# plt.show()

```
  
  
**Mean Visibility and Temperature - Austin, TX 2011**:  
![](_dummyPy067.png)

**Percentage of Time with Clear Skies (CLR/SKC) by Day - Austin, TX 2011**:  
![](_dummyPy068.png)

**Histogram for Maximum Monthly Temperature and Dew Point - Austin, TX 2011**:  
![](_dummyPy069.png)
  
  
###_Manipulating DataFrames with pandas_#
  
Chapter 1 - Extracting and transforming data  
  
Indexing DataFrames - multiple ways to extract data from the pandas DataFrame:  
  
* Bracketing methodology - myDF["myCol"]["myRow"] where myCol is the column name and myRow is the row index name  
* Column attribute methodology - myDF.myCol["myRow"] where myCol is the column name IFF it is also a valid Python name  
* Accessors such as .loc and .iloc are much more programatically reprducible ways to get access to the data  
	* The .loc accesses using labels  
    * The .iloc accesses using index positions  
* Using labels - myDF.loc["myRow", "myCol"]  
* Using indices - myDF.iloc[myRowIdx, myColIdx]  
* To ensure getting back a pandas DataFrame, use a nested list - for example, myDF[['myColB', 'myColA']] will return just myColA and myColB, with the result as a pandas DataFrame with myColB as the first column  
  
Slicing DataFrames - different return types that come from indexing a pandas DataFrame:  
  
* A simple extract such as df["myCol"] will return as pandas.core.series.Series, basically a 1-dimensional array that is a hybrid between a numpy array and a dictionary  
* A sliced extract such as df["myCol"][a:b] will convert back to a more basic type (the type associated with myCol of the pandas DataFrame  
	* Can use a:b:-1 to specify that the step size should be -1 rather than the default value of +1  
* Can also slice using names, and it INCLUDES both sides of the slice - df.loc[:, "myColA":"myColB'] will extract all rows, as well as myColA/myColB (and would be all columns FROM myColA TO myColB  
	* Can similarly slice on the row index names, such as myDF.loc["rowIndexA":"rowIndexB", :]  
    * Can slice both rows and columns at the same time also  
    * Can also slice using index numbers and .iloc()  
* Can also slice using lists - either inside the .loc() or inside the .iloc()  
* In case there is a need to keep a pandas DataFrame, use df[["myCol"]], as opposed to df["myCol"] which will return a pandas Series  
  
Filtering DataFrames - general tool for selecting part of the data based on its properties rather than its indices (typically by way of Booleans):  
  
* The basic example would be myDF[myDF["myCol"] > a], which will extract all the rows where myDF.myCol exceeds a  
* Filters can be combined using the &, |, and not operators  
* Selecting columns that have exclusively non-zero (note that NaN is not zero!), can be achieved using myDF.all() - so myDF.loc[:, myDF.all()]  
	* Alternately, can use myDF.any() to obtain every column that has 1+ non-zero values  
    * Alternately, can use myDF.isnull() to identify the NaN, so myDF.isnull().any() will be the columns that have 1+ NaN  
    * Similarly, can use myDF.notnull() to identify the non-NaN, so myDF.notnull().all() will be the columns that have 0 NaN  
* Can remove any rows with missing data using .dropna(), such as myDF.dropna(how="any") -- note that how = "any" drops ROWS with any NaN while how = "all" drops ROWS with only NaN  
* Can also run operations such as myDF["myColA"][myDF["myColB"] > x] += y to add y to the myColA any time the myColB exceeds x  
  
Transforming DataFrames - best practice is to use built-in pandas methods, and otherwise by universal numpy methods:  
  
* For example, myDF.floordiv(a) will take every column, divide by a, and the return the floor  
	* Could alternately run np.floor_divide(myDF, a)  
    * Whether using the pandas method or the numpy function, the operation is vectorized (run element by element)  
* Can also run a custom function using myDF.apply(myFunc), which defaults to running vectorized (element by element)  
	* Can also use lambda functions, such as myDF.apply(lambda x: x // a)  
* The default for all of these operations is to create a new pandas DataFrame, so the existing DataFrame is not touched; can assign the result as needed  
* Can access the indices for the DataFrame using myDF.index (this will be a list of strings)  
	* By using the .str operator, you can access all of the string operations - myDF.index.str.upper() will take all the index strings and convert them to upper  
* The index cannot use .apply() and instead uses .map() - myDF.index.map(str.lower) will convert all the index values to lower  
* Can consider .map() to be applying a dictionary to any specific piece of information  
	* As a result, the .map() can only be applied to a Series and not to a DataFrame  
* Can use arithmetic operations directly on the columns - myDF["myColA"] + myDF["myColB"] will add the columns together  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"
import pandas as pd


# NEED DATA FRAME election (67 x 8) - indexed by county with columns state (PA) - total - Obama - Romney - winner - voters - turnout - margin
# appears to be 2012 US general election data, with the Obama and Romney columns being percentages, total being total votes, and voters being registered voters
# Saved the DataCamp file to myPath + "PAElection_2012.csv"

electionPA = pd.read_csv(myPath + "PAElection_2012.csv", index_col="county")
election = electionPA.copy()


# Assign the row position of election.loc['Bedford']: x
x = 4

# Assign the column position of election['winner']: y
y = 4

# Print the boolean equivalence
print(election.iloc[x, y] == election.loc['Bedford', 'winner'])


# DO NOT RUN - downloaded to myPath + "PAElection2012.csv" instead
# filename = 'https://s3.amazonaws.com/assets.datacamp.com/production/course_1650/datasets/pennsylvania2012.csv'
# election = pd.read_csv(filename, index_col='county')

# Create a separate dataframe with the columns ['winner', 'total', 'voters']: results
results = election[['winner', 'total', 'voters']]

# Print the output of results.head()
print(results.head())


# Slice the columns from the starting column to 'Obama': left_columns
left_columns = election.loc[:, :"Obama"]

# Print the output of left_columns.head()
print(left_columns.head())

# Slice the columns from 'Obama' to 'winner': middle_columns
middle_columns = election.loc[:, "Obama":"winner"]

# Print the output of middle_columns.head()
print(middle_columns.head())

# Slice the columns from 'Romney' to the end: 'right_columns'
right_columns = election.loc[:, "Romney":]

# Print the output of right_columns.head()
print(right_columns.head())


# Create the list of row labels: rows
rows = ['Philadelphia', 'Centre', 'Fulton']

# Create the list of column labels: cols
cols = ['winner', 'Obama', 'Romney']

# Create the new DataFrame: three_counties
three_counties = election.loc[rows, cols]

# Print the three_counties DataFrame
print(three_counties)


# Create a turnout category
election["turnout"] = 100 * election["total"] / election["voters"]

# Create the boolean array: high_turnout
high_turnout = election["turnout"] > 70

# Filter the election DataFrame with the high_turnout array: high_turnout_df
high_turnout_df = election[high_turnout]

# Print the high_turnout_results DataFrame
print(high_turnout_df)


# Import numpy
import numpy as np

# Create the election["margin"] column
election["margin"] = abs(election["Obama"] - election["Romney"])

# Create the boolean array: too_close
too_close = election["margin"] < 1

# Assign np.nan to the 'winner' column where the results were too close to call
election["winner"][too_close] = np.nan

# Print the output of election.info()
print(election.info())


# NEED DATASET titanic (1309 x 14)
# User version saved previously
titanic = pd.read_csv(myPath + 'titanic.csv', index_col=0)


# Select the 'age' and 'cabin' columns: df
df = titanic[["Age", "Cabin"]]

# Print the shape of df
print(df.shape)

# Drop rows in df with how='any' and print the shape
print(df.dropna(how="any").shape)

# Drop rows in df with how='all' and print the shape
print(df.dropna(how="all").shape)

# Call .dropna() with thresh=1000 and axis='columns' and print the output of .info() from titanic
print(titanic.dropna(thresh=500, axis='columns').info())


# NEED DATASET weather which is 365 x 23 from Weather Underground, representing Pittsburgh weather data for 2013
# https://www.wunderground.com/history
# Use the KORD METAR data instead
# Load the file
tmpORD = pd.read_csv(myPath + "KORD_2010_from_IAState.txt", header=5)
tmpORD.columns = tmpORD.columns.str.strip()
isMETAR = tmpORD.loc[:, "valid"].str.contains(":51")  # KORD METAR are taken at xx:51
useORD = tmpORD.loc[isMETAR, :]  # ends as 8709 x 22, probably the METAR check missed a few at "off" times

date_list = useORD["valid"]
time_format = '%Y-%m-%d %H:%M'
my_datetimes = pd.to_datetime(date_list, format=time_format)  
useORD.index = my_datetimes

# Just keep the temperature and dew point
weather = useORD[["tmpf", "dwpf"]]
weather.columns = ['Mean TemperatureF','Mean Dew PointF']

# Write a function to convert degrees Fahrenheit to degrees Celsius: to_celsius
def to_celsius(F):
    return 5/9*(F - 32)

# Apply the function over 'Mean TemperatureF' and 'Mean Dew PointF': df_celsius
df_celsius = weather[['Mean TemperatureF','Mean Dew PointF']].apply(to_celsius)

# Reassign the columns df_celsius
df_celsius.columns = ['Mean TemperatureC', 'Mean Dew PointC']

# Print the output of df_celsius.head()
print(df_celsius.head())


# Create the dictionary: red_vs_blue
red_vs_blue = {"Obama":"blue", "Romney":"red"}

# Use the dictionary to map the 'winner' column to the new column: election['color']
election['color'] = election["winner"].map(red_vs_blue)

# Print the output of election.head()
print(election.head())


# Import zscore from scipy.stats
# Need to solve BLAS/LAPACK issue - cannot get scipy to download and install . . . 
# from scipy.stats import zscore

import numpy as np
def zscore(x):
    mu = np.mean(x)
    sd = np.std(x)
    return((x - mu) / sd)

# Call zscore with election['turnout'] as input: turnout_zscore
turnout_zscore = zscore(election["turnout"])

# Print the type of turnout_zscore
print(type(turnout_zscore))

# Assign turnout_zscore to a new column: election['turnout_zscore']
election["turnout_zscore"] = turnout_zscore

# Print the output of election.head()
print(election.head())

```
  
  
***
  
Chapter 2 - Advanced Indexing  
  
Index objects and labeled data - one of the key building blocks of the pandas Data Structures:  
  
* There are several key building blocks for a pandas DataFrame  
	* Indexes: Sequence of labels that must be immutable and homogenous in data type  
    * Series: 1D array with index  
    * DataFrames: 2D array with index  
* Can create a pandas Series using pd.Series(myList, index=myIndex) where the default for index is integers starting at 0  
	* The index can be sliced just like a list and always has the .name attribute (default at creation is None)  
* Sometimes, it is valuable to make one of the Series columns in the DataFrame in to the overall index  
	* myDF.index = myDF["keyCol"] will make the index assignment  
    * del myDF["keyCol"] will remove keyCol from the data  
* Can also set indices inside pd.read_csv by using the index_col= options  
  
Hierarchical indexing - representing multi-dimensional index data:  
  
* An example would be stock price data, which might be unique by Date-Symbol rather than just being unique by Date or Symbol  
* Can use tuples combined with .set_index() to solve this - myDF.set_index(["Symbol", "Date"])  
	* This will have myDF.index.name = None and myDF.index.names = ["Symbol", "Date"]  
* Can sort the MultiIndex using .sort_index(), which appears to sort by the first element (Symbol in this case), then the second element (Date in this case)  
* Can access from the MultiIndex using tuples, such as myDF.loc[('CSCO', '2016-10-01')] to get the row that contains the CSCO data from 2016-10-01  
	* Can further use slicing on the outermost index, such as myDF.loc['CSCO' : 'MSFT']  
    * Can further index on both components, such as myDF.loc[ (["AAPL", "CSCO"], "2016-10-05"), : ]  
* When slicing on both indices, the colon is not recognized as a key symbol  
	* The keyword slice() can be added, and can access slice(None) meaning "everything"  
    * myDF.loc[ (slice(None), slice("2016-10-03", "2016-10-05")), : ] enforces that the inner index should be sliced as 2016-10-03 : 2016-10-05  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"

import pandas as pd
import numpy as np

sales = pd.DataFrame()
sales["eggs"] = [47, 110, 221, 77, 132, 205]
sales["salt"] = [12, 50, 89, 87, np.nan, 60]
sales["spam"] = [17, 31, 72, 20, 52, 55]
sales.index = ["jan", "feb", "mar", "apr", "may", "jun"]


# Create the list of new indexes: new_idx
new_idx = [x.upper() for x in sales.index]

# Assign new_idx to sales.index
sales.index = new_idx

# Print the sales DataFrame
print(sales)


# Assign the string 'MONTHS' to sales.index.name
sales.index.name = "MONTHS"

# Print the sales DataFrame
print(sales)

# Assign the string 'PRODUCTS' to sales.columns.name 
sales.columns.name = "PRODUCTS"

# Print the sales dataframe again
print(sales)


# Generate the list of months: months
months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun']

# Assign months to sales.index
sales.index = months

# Print the modified sales DataFrame
print(sales)


# NEED TO MODIFY sales so it is the same data but indexed as CA/1, CA/2, NY/1, NY/2, TX/1, TX/2 (using state-month)
sales = sales.set_index([["CA", "CA", "NY", "NY","TX", "TX"], [1, 2, 1, 2, 1, 2]])

# Print sales.loc[['CA', 'TX']]
print(sales.loc[['CA', 'TX']])

# Print sales['CA':'TX']
print(sales['CA':'TX'])


# Now, sales is again a non-indexed DataFrame with sate-month as columns
# Set the index to be the columns ['state', 'month']: sales
states = [x for x, y in list(sales.index)]
months = [y for x, y in list(sales.index)]

sales.index = range(sales.shape[0])
sales["state"] = states
sales["month"] = months
oldSales = sales.copy()

sales = sales.set_index(['state', 'month'])

# Sort the MultiIndex: sales
sales = sales.sort_index(ascending=False)

# Print the sales DataFrame
print(sales)
multiSales = sales.copy()


# Go back to the sales as it was prior to indexing in the above step
# Set the index to the column 'state': sales
sales = oldSales.set_index(["state"])

# Print the sales DataFrame
print(sales)

# Access the data from 'NY'
print(sales.loc["NY"])


# Go back to sales as the Multi-Index dataset again . . . 
sales = multiSales.copy()
sales = sales.sort_index(ascending=True)  # Could not grab witout error unless ascending=True

# Look up data for NY in month 1: NY_month1
NY_month1 = sales.loc[ ("NY", 1) ]

# Look up data for CA and TX in month 2: CA_TX_month2
CA_TX_month2 = sales.loc[ (["CA", "TX"], 2) , :]

# Look up data for all states in month 2: all_month2
all_month2 = sales.loc[ (slice(None), 2), :]

```
  
  
***
  
Chapter 3 - Rearranging and Reshaping Data  
  
Pivoting DataFrames - changing shapes to one that better suits analysis needs:  
  
* The .pivot() method allows for specifying an index (row variables), a columns variable, and a values variable  
	* myDF.pivot(index="idxVar", columns="colVar", values="valVar") will create a table with idxVar as the rows, colVar as the columns, and valVar as the cell values  
    * If values= is omitted, then all other columns are used for values, with a separate set of columns made for each of those values variables  
  
Stacking and unstaking DataFrames - the idea of moving variables to/from the index so that the columns match data needs:  
  
* myDF.unstack(level="myVar") will move myVar out of the index and instead place it as a hieracrchical component of the column variables  
	* Can instead use an index number for the level=  
* myDF.stack(level="myVar") moves a hierarchical component of the column variables in to the index instead  
* myDF.swaplevel(0, 1) will change the hierarchy of the multi-index so that the first-order becomes the second-order and the second-order becomes the first-order  
	* myDF.sort_index() might then be needed since the .swaplevel() does not re-order the rows; it just changes who is first/second  
  
Melting DataFrames - converting pivoted data back in to a column format:  
  
* pd.melt(myDF, id_vars=) will convert everything other than the id_vars back to a column called "variable" and a column called "value"  
	* Can also use var_name= and value_name= with more descriptive strings to avoid the names "variable" and "value"  
* There is also the option to use value_vars= to specify the columns to un-pivot (default is everything not listed in id_vars)  
  
Pivot tables are needed when there are multiple rows with the same index (if pivoted) - need to specify how to manage the duplicates:  
  
* myDF.pivot_table(index=, columns=, values=, aggfunc=)  
	* The default is that aggfunc="mean" but can specify "sum" or "count" or the like instead  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"


import pandas as pd

users=pd.DataFrame()
users["weekday"] = ["Sun", "Sun", "Mon", "Mon"]
users["city"] = ["Austin", "Dallas", "Austin", "Dallas"]
users["visitors"] = [139, 237, 326, 456]
users["signups"] = [7, 12, 3, 5]


# Pivot the users DataFrame: visitors_pivot
visitors_pivot = users.pivot(index="weekday", columns="city", values="visitors")

# Print the pivoted DataFrame
print(visitors_pivot)


# Pivot users with signups indexed by weekday and city: signups_pivot
signups_pivot = users.pivot(index="weekday", columns="city", values="signups")

# Print signups_pivot
print(signups_pivot)


# Pivot users pivoted by both signups and visitors: pivot
pivot = users.pivot(index="weekday", columns="city")

# Print the pivoted DataFrame
print(pivot)


a = users.set_index(["city", "weekday"])
users = a.sort_index()


# Unstack users by 'weekday': byweekday
byweekday = users.unstack(level="weekday")

# Print the byweekday DataFrame
print(byweekday)

# Stack byweekday by 'weekday' and print it
print(byweekday.stack(level="weekday"))


# Unstack users by 'city': bycity
bycity = users.unstack(level="city")

# Print the bycity DataFrame
print(bycity)

# Stack bycity by 'city' and print it
print(bycity.stack(level="city"))


# Stack 'city' back into the index of bycity: newusers
newusers = bycity.stack(level="city")

# Swap the levels of the index of newusers: newusers
newusers = newusers.swaplevel(0, 1)

# Print newusers and verify that the index is not sorted
print(newusers)

# Sort the index of newusers: newusers
newusers = newusers.sort_index()

# Print newusers and verify that the index is now sorted
print(newusers)

# Verify that the new DataFrame is equal to the original
print(newusers.equals(users))


visitors_by_city_weekday = users[["visitors"]].unstack(level="city").reset_index()
visitors_by_city_weekday.columns = ["weekday", "Austin", "Dallas"]


# Reset the index: visitors_by_city_weekday
# visitors_by_city_weekday = visitors_by_city_weekday.reset_index()  # this needed to be done above to get the column names right . . . 

# Print visitors_by_city_weekday
print(visitors_by_city_weekday)

# Melt visitors_by_city_weekday: visitors
visitors = pd.melt(visitors_by_city_weekday, id_vars=["weekday"], value_name="visitors", var_name="city")

# Print visitors
print(visitors)


users=pd.DataFrame()
users["weekday"] = ["Sun", "Sun", "Mon", "Mon"]
users["city"] = ["Austin", "Dallas", "Austin", "Dallas"]
users["visitors"] = [139, 237, 326, 456]
users["signups"] = [7, 12, 3, 5]

# Melt users: skinny
skinny = pd.melt(users, id_vars = ["weekday", "city"], value_vars=["visitors", "signups"])

# Print skinny
print(skinny)


# Set the new index: users_idx
users_idx = users.set_index(['city', 'weekday'])

# Print the users_idx DataFrame
print(users_idx)

# Obtain the key-value pairs: kv_pairs
kv_pairs = pd.melt(users_idx, col_level=0)

# Print the key-value pairs
print(kv_pairs)


# Create the DataFrame with the appropriate pivot table: by_city_day
by_city_day = users.pivot_table(index="weekday", columns="city")

# Print by_city_day
print(by_city_day)


# Use a pivot table to display the count of each column: count_by_weekday1
count_by_weekday1 = users.pivot_table(index="weekday", aggfunc="count")

# Print count_by_weekday
print(count_by_weekday1)


# Replace 'aggfunc='count'' with 'aggfunc=len': count_by_weekday2
count_by_weekday2 = users.pivot_table(index="weekday", aggfunc=len)

# Verify that the same result is obtained
print('==========================================')
print(count_by_weekday1.equals(count_by_weekday2))


# Create the DataFrame with the appropriate pivot table: signups_and_visitors
signups_and_visitors = users.pivot_table(index="weekday", aggfunc=sum)

# Print signups_and_visitors
print(signups_and_visitors)

# Add in the margins: signups_and_visitors_total 
signups_and_visitors_total = users.pivot_table(index="weekday", aggfunc=sum, margins=True)

# Print signups_and_visitors_total
print(signups_and_visitors_total)

```
  
  
***
  
Chapter 4 - Grouping data  
  
Categoricals and groupby - using the .groupby() method and then chaining various commands to it:  
  
* myDF.groupby("myGroupVar").count() will provide a count summarized by myGroupVar (it is a count by column, though . . . )  
* In essence, this is running the split-apply-combine methodology, where the .groupby() is the split, the .count() is the apply, and the combine is the result by default  
* Can act on a subset of columns using myDF.groupby("myGroupVar")[["myColA", "myColB"]].sum() to get sums of myColA/myColB by myGroupVar  
	* Can also have a multi-level .groupby() such as myDF.groupby(["myGroupA", "myGroupB"]).mean()  
    * Can also use a .groupby(myVar) provided that myVar has been created to have the same index as the pandas DataFrame  
* With categorical data, use .unique() to get the unique values  
	* Create categorical variables using .astype("category")  
* Categorical variables use less memory and speed up group-by processing  
  
Groupby and aggregation - running mutlipe calculations after the split and before the combine:  
  
* Can use .agg(["max", "sum"]) to run both max() and sum() on the data (will get both values back in the results)  
	* Can pass a list of quoted strings that reflect built-in functions  
    * Can pass an unquoted function name that is a custom user-defined function  
    * Can pass in a dictionary where the keys are the variables and the values are the functions to be run on those variables  
  
Groupby and transformation - applying different transformations to different groups:  
  
* myDF.groupby("myGroupVar").transform(myFunc) will apply myFunc separately to each group of myGroupVar, returning the same index/order as myDF  
* The .transform() is applying an element-wise calculation within each of the groups  
* Can also use myDF.groupby("myGroupVar").apply(myFunc) if the myFunc is too complicated to be implemented by way of .transform()  
  
Groupby and filtering - filtering groups prior to aggregating:  
  
* The .groupby() is essentially creating a dictionary with keys being the groups and values being the associated data within that group  
	* So, if splitting = myDF.groupby("myGroupVar") then for groupName, groupData in splitting: is a valid syntax  
    * This opens up the ability to filter within a for loop, so that the results provided are just for the desired filtering criteria  
    * Can also use a dictionary comprehension {} to get these back as a dictionary, followed by pd.Series() to print the dictionary with keys as indices  
* Can also use booleans as part of the groupby() if the goal is to get (for example) averages by whether something is in/out of a certain key class  
	* myDF.groupby(["myGroupVar", myBoolSeries]).mean() will provide the mean grouped by myGroupVar and myBoolSeries  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"


# Need to bring in "titanic" (1309 x 14)
import pandas as pd
titanic = pd.read_csv(myPath + 'titanic.csv', index_col=0)

titanic.columns = ['id', 'survived', 'pclass', 'name', 'sex', 'age', 'sibsp', 'parch', 'ticket', 'fare', 'cabin', 'embarked']

# titanic.columns = ['pclass', 'survived', 'name', 'sex', 'age', 'sibsp', 'parch', 'ticket', 'fare', 'cabin', 'embarked', 'boat', 'body', 'home.dest']

# Group titanic by 'pclass'
by_class = titanic.groupby("pclass")

# Aggregate 'survived' column of by_class by count
count_by_class = by_class["survived"].count()

# Print count_by_class
print(count_by_class)

# Group titanic by 'embarked' and 'pclass'
by_mult = titanic.groupby(["embarked", "pclass"])

# Aggregate 'survived' column of by_mult by count
count_mult = by_mult["survived"].count()

# Print count_mult
print(count_mult)


# Saved to myPath as lifeSaved.csv and regionsSaved.csv
# life_f = 'https://s3.amazonaws.com/assets.datacamp.com/production/course_1650/datasets/life_expectancy.csv'
# regions_f = 'https://s3.amazonaws.com/assets.datacamp.com/production/course_1650/datasets/regions.csv'

life = pd.read_csv(myPath + "lifeSaved.csv", index_col='Country', encoding="latin-1")
regions = pd.read_csv(myPath + "regionsSaved.csv", index_col='Country', encoding="latin-1")

# Group life by regions['region']: life_by_region
life_by_region = life.groupby(regions["region"])

# Print the mean over the '2010' column of life_by_region
print(life_by_region["2010"].mean())


# Again using the titanic dataset (same as above)

# Group titanic by 'pclass': by_class
by_class = titanic.groupby("pclass")

# Select 'age' and 'fare'
by_class_sub = by_class[['age','fare']]

# Aggregate by_class_sub by 'max' and 'median': aggregated
aggregated = by_class_sub.agg(["max", "median"])

# Print the maximum age in each class
print(aggregated.loc[:, ('age','max')])

# Print the median fare in each class
print(aggregated.loc[:, ('fare', 'median')])


# Read the CSV file into a DataFrame and sort the index: gapminder
# NEED FILE!
# gapminder = pd.read_csv("gapminder.csv", index_col=['Year','region','Country']).sort_index()

# Group gapminder by 'Year' and 'region': by_year_region
# by_year_region = gapminder.groupby(level=["Year", "region"])

# Define the function to compute spread: spread
# def spread(series):
#     return series.max() - series.min()

# Create the dictionary: aggregator
# aggregator = {'population':'sum', 'child_mortality':'mean', 'gdp':spread}

# Aggregate by_year_region using the dictionary: aggregated
# aggregated = by_year_region.agg(aggregator)

# Print the last 6 entries of aggregated 
# print(aggregated.tail(6))


# NEED FILE
# Read file: sales
# sales = pd.read_csv("sales.csv", index_col="Date", parse_dates=True)

# Create a groupby object: by_day
# by_day = sales.groupby(sales.index.strftime('%a'))

# Create sum: units_sum
# units_sum = by_day.sum()

# Print units_sum
# print(units_sum)


# Import zscore
# from scipy.stats import zscore

# Group gapminder_2010: standardized
# standardized = gapminder_2010.groupby("region")[['life','fertility']].transform(zscore)

# Construct a Boolean Series to identify outliers: outliers
# outliers = (standardized['life'] < -3) | (standardized['fertility'] > 3)

# Filter gapminder_2010 by the outliers: gm_outliers
# gm_outliers = gapminder_2010.loc[outliers]

# Print gm_outliers
# print(gm_outliers)


# Create a groupby object: by_sex_class
by_sex_class = titanic.groupby(["sex", "pclass"])

# Write a function that imputes median
def impute_median(series):
    return series.fillna(series.median())

# Impute age and assign to titanic['age']
titanic.age = by_sex_class["age"].transform(impute_median)

# Print the output of titanic.tail(10)
print(titanic.tail(10))


def disparity(gr):
    # Compute the spread of gr['gdp']: s
    s = gr['gdp'].max() - gr['gdp'].min()
    # Compute the z-score of gr['gdp'] as (gr['gdp']-gr['gdp'].mean())/gr['gdp'].std(): z
    z = (gr['gdp'] - gr['gdp'].mean())/gr['gdp'].std()
    # Return a DataFrame with the inputs {'z(gdp)':z, 'regional spread(gdp)':s}
    return pd.DataFrame({'z(gdp)':z , 'regional spread(gdp)':s})


# NEED FILE!
# Group gapminder_2010 by 'region': regional
# regional = gapminder_2010.groupby("region")

# Apply the disparity function on regional: reg_disp
# reg_disp = regional.apply(disparity)

# Print the disparity of 'United States', 'United Kingdom', and 'China'
# print(reg_disp.loc[['United States','United Kingdom','China'], :])


def c_deck_survival(gr):
    c_passengers = gr['cabin'].str.startswith('C').fillna(False)
    return gr.loc[c_passengers, 'survived'].mean()


# Create a groupby object using titanic over the 'sex' column: by_sex
by_sex = titanic.groupby("sex")

# Call by_sex.apply with the function c_deck_survival and print the result
c_surv_by_sex = by_sex.apply(c_deck_survival)

# Print the survival rates
print(c_surv_by_sex)


# NEED FILE!
# Read the CSV file into a DataFrame: sales
# sales = pd.read_csv('sales.csv', index_col='Date', parse_dates=True)

# Group sales by 'Company': by_company
# by_company = sales.groupby("Company")

# Compute the sum of the 'Units' of by_company: by_com_sum
# by_com_sum = by_company["Units"].sum()
# print(by_com_sum)

# Filter 'Units' where the sum is > 35: by_com_filt
# by_com_filt = by_company.filter(lambda g:g['Units'].sum() > 35)
# print(by_com_filt)


# Create the Boolean Series: under10
under10 = (titanic['age'] < 10).map({True:'under 10', False:'over 10'})

# Group by under10 and compute the survival rate
survived_mean_1 = titanic.groupby(under10)["survived"].mean()
print(survived_mean_1)

# Group by under10 and pclass and compute the survival rate
survived_mean_2 = titanic.groupby([under10, "pclass"])["survived"].mean()
print(survived_mean_2)

```
  
  
***
  
Chapter 5 - Case Study (Summer Olympics)  
  
Introduction to the Summer Olympics data and analysis objectives:  
  
* Olympic medals dataset from 1896 to current - find patterns by countries/medals and the like  
* Indexing, pivoting, pivot_table(), groupby() will all be handy  
* Can use unique() and value_counts() to better understand categorical data and available levels  
  
Understanding the column labels - looking at the Gender and event_gender columns to understand how they are different:  
  
* Categorical data handling tools such as .value_counts()  
* Boolean processing to assess where values are true or false  
  
Constructing alternative country rankings:  
  
* Top 5 countries that have won medals in the most sports  
* Medal counts of USA vs USSR for 1952-1988  
* There are two valuable DataFrame methods for finding maxima and minima  
    * .idxmax() returns the label where the maximum value is located (much like which.max in R)  
    * .idxmin() returns the label where the maximum value is located (much like which.min in R)  
    * Including axis="columns" will run the search along the columns rather than the rows  
  
Reshaping DataFrames for visualization:  
  
* With plots, the labels come from the index by default  
* Generally, the matplotlib operations work best when there is a single-level index  
	* The .unstack() is a form of re-shaping that can help to achieve this  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"


import pandas as pd
import matplotlib.pyplot as plt


# Data is from https://www.theguardian.com/sport/datablog/2012/jun/25/olympic-medal-winner-list-data
# medals is 29216x10 with ['City', 'Edition', 'Sport', 'Discipline', 'Athlete', 'NOC', 'Gender', 'Event', 'Event_gender', 'Medal']
# Downloaded file from Guardian as myPath + "summerOlympics_Medalists_1896_2008.csv" - read file in
medals = pd.read_csv(myPath + "summerOlympics_Medalists_1896_2008.csv", header=4)



USA_edition_grouped = medals.loc[medals.NOC == 'USA'].groupby('Edition')

# Select the 'NOC' column of medals: country_names
country_names = medals["NOC"]

# Count the number of medals won by each country: medal_counts
medal_counts = country_names.value_counts()

# Print top 15 countries ranked by medals
print(medal_counts.head(15))


# Construct the pivot table: counted
counted = medals.pivot_table(index="NOC", columns="Medal", values="Athlete", aggfunc="count")

# Create the new column: counted['totals']
counted['totals'] = counted.sum(axis="columns")

# Sort counted by the 'totals' column
counted = counted.sort_values("totals", ascending=False)

# Print the top 15 rows of counted
print(counted.head(15))


# Select columns: ev_gen
ev_gen = medals[["Event_gender", "Gender"]]

# Drop duplicate pairs: ev_gen_uniques
ev_gen_uniques = ev_gen.drop_duplicates()

# Print ev_gen_uniques
print(ev_gen_uniques)


# Group medals by the two columns: medals_by_gender
medals_by_gender = medals.groupby(['Event_gender', 'Gender'])

# Create a DataFrame with a group count: medal_count_by_gender
medal_count_by_gender = medals_by_gender.count()

# Print medal_count_by_gender
print(medal_count_by_gender)


# Create the Boolean Series: sus
sus = (medals.Event_gender == 'W') & (medals.Gender == 'Men')

# Create a DataFrame with the suspicious row: suspect
suspect = medals.loc[sus, :]

# Print suspect
print(suspect)


# Group medals by 'NOC': country_grouped
country_grouped = medals.groupby("NOC")

# Compute the number of distinct sports in which each country won medals: Nsports
Nsports = country_grouped["Sport"].nunique()

# Sort the values of Nsports in descending order
Nsports = Nsports.sort_values(ascending=False)

# Print the top 15 rows of Nsports
print(Nsports.head(15))


# Extract all rows for which the 'Edition' is between 1952 & 1988: during_cold_war
during_cold_war = (medals["Edition"] >= 1952) & (medals["Edition"] <= 1988)

# Extract rows for which 'NOC' is either 'USA' or 'URS': is_usa_urs
is_usa_urs = medals.NOC.isin(["USA", "URS"])

# Use during_cold_war and is_usa_urs to create the DataFrame: cold_war_medals
cold_war_medals = medals.loc[during_cold_war & is_usa_urs]

# Group cold_war_medals by 'NOC'
country_grouped = cold_war_medals.groupby("NOC")

# Create Nsports
Nsports = country_grouped["Sport"].nunique().sort_values(ascending=False)

# Print Nsports
print(Nsports)


# Create the pivot table: medals_won_by_country
medals_won_by_country = medals.pivot_table(index="Edition", columns="NOC", values="Athlete", aggfunc="count")

# Slice medals_won_by_country: cold_war_usa_usr_medals
cold_war_usa_usr_medals = medals_won_by_country.loc[1952:1988, ["USA", "URS"]]

# Create most_medals 
most_medals = cold_war_usa_usr_medals.idxmax(axis="columns")

# Print most_medals.value_counts()
print(most_medals.value_counts())


# Create the DataFrame: usa
usa = medals.loc[medals["NOC"] == "USA"]

# Group usa by ['Edition', 'Medal'] and aggregate over 'Athlete'
usa_medals_by_year = usa.groupby(['Edition', 'Medal'])["Athlete"].count()

# Reshape usa_medals_by_year by unstacking
usa_medals_by_year = usa_medals_by_year.unstack(level="Medal")

# Plot the DataFrame usa_medals_by_year
usa_medals_by_year.plot()
# plt.show()
plt.savefig("_dummyPy070.png", bbox_inches="tight")
plt.clf()


# Create the DataFrame: usa
usa = medals[medals.NOC == 'USA']

# Group usa by 'Edition', 'Medal', and 'Athlete'
usa_medals_by_year = usa.groupby(['Edition', 'Medal'])['Athlete'].count()

# Reshape usa_medals_by_year by unstacking
usa_medals_by_year = usa_medals_by_year.unstack(level='Medal')

# Create an area plot of usa_medals_by_year
usa_medals_by_year.plot.area()
# plt.show()
plt.savefig("_dummyPy071.png", bbox_inches="tight")
plt.clf()


# Redefine 'Medal' as an ordered categorical
medals.Medal = pd.Categorical(values=medals.Medal, categories=['Bronze', 'Silver', 'Gold'], ordered=True)

# Create the DataFrame: usa
usa = medals[medals.NOC == 'USA']

# Group usa by 'Edition', 'Medal', and 'Athlete'
usa_medals_by_year = usa.groupby(['Edition', 'Medal'])['Athlete'].count()

# Reshape usa_medals_by_year by unstacking
usa_medals_by_year = usa_medals_by_year.unstack(level='Medal')

# Create an area plot of usa_medals_by_year
usa_medals_by_year.plot.area()
# plt.show()
plt.savefig("_dummyPy072.png", bbox_inches="tight")
plt.clf()

```
  
  
**Summer Olympics - USA Medals**:  
![](_dummyPy070.png)

**Summer Olympics - USA Medals**:  
![](_dummyPy071.png)

**Summer Olympics - USA Medals**:  
![](_dummyPy072.png)
  
  
###_Merging DataFrames with pandas_#
  
Chapter 1 - Preparing data  
  
Reading multiple data files - many tools such as pd.read_csv(), pd.read_excel(), pd.read_html(), pd.read_json():  
  
* Typically, loading multiple files leads to creating multiple pandas DataFrames  
* A typical way to vectorize file reading is with lists and a for loop - dataframes = [] ; for files in myFileList: dataframes.append(pd.read_csv(files))  
	* Alterantely, dataframes = [pd.read_csv(files) for files in myFileList] to use list comprehension rather than the FOR loop  
* The glob library can also be helpful to find things like glob("sales*.csv") - needs to be preceded with from glob import glob  
  
Reindexing DataFrames - essential for combining DataFrames, since indices are the means by which DataFrames are combined:  
  
* Can set the indices during pd.read_csv() using the index_col= option  
* Can access the indices using myDF.index  
* Indices can be reordered using a desired list; for example myDF.reindex(myOrderList) will re-index (not performed in place)  
	* If the myOrderList contains items that are not in the index for myDF, rows will be created with all values as np.nan  
    * If the myOrderList omits items that are in the index for myDF, then those items will be omitted  
* Can also do a straight sort of the index by using myDF.sort_index, which will typically recover the data to how it was on original load to DataFrames  
* Use of myDF.dropna() will remove entire rows that contain np.nan  
  
Arithmetic with Series and DataFrames - generally, scalar operations can be broadcast in Python:  
  
* Often need to use the .divide() method to run sensible division of DataFrame by DataSeries  
	* myDF.divide(mySeries, axis="rows") will divde each column of myDF by mySeries  
    * More or less, axis="rows" asks that mySeries be broadcast across the row, so that "a" becomes "a" "a" "a" to match up to the shape of myDF  
* Percentage change (current row vs previous row) can be accessed using myDF.percent_change()  
* When pandas Series are added together, the resulting index will be the union of the respective Series indices  
	* However, anything that is not in the index of ALL the underlying Series will come back as NaN  
* mySeriesA + mySeriesB will give the same result as mySeriesA.add(mySeriesB)  
	* Can add fill_value=0 to make the NaN in to 0 (the .add() is more flexible than the plus sign)  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"


# Import pandas
import pandas as pd

medals = pd.read_csv(myPath + "summerOlympics_Medalists_1896_2008.csv", header=4)



# Read 'Bronze.csv' into a DataFrame: bronze
# bronze = pd.read_csv("Bronze.csv")
bronze = medals.loc[medals["Medal"] == "Bronze"]

# Read 'Silver.csv' into a DataFrame: silver
# silver = pd.read_csv("Silver.csv")
silver = medals.loc[medals["Medal"] == "Silver"]

# Read 'Gold.csv' into a DataFrame: gold
# gold = pd.read_csv("Gold.csv")
gold = medals.loc[medals["Medal"] == "Gold"]


# Print the first five rows of gold
print(gold.head())


bronze.to_csv(myPath + "olymBronze.csv", index=False)
silver.to_csv(myPath + "olymSilver.csv", index=False)
gold.to_csv(myPath + "olymGold.csv", index=False)


# One time only - for use in next section
# bronze[["NOC", "Athlete"]].groupby("NOC").count().sort_values("Athlete", ascending=False).iloc[0:5, :].to_csv(myPath + "bronze_top5.csv")
# silver[["NOC", "Athlete"]].groupby("NOC").count().sort_values("Athlete", ascending=False).iloc[0:5, :].to_csv(myPath + "silver_top5.csv")
# gold[["NOC", "Athlete"]].groupby("NOC").count().sort_values("Athlete", ascending=False).iloc[0:5, :].to_csv(myPath + "gold_top5.csv")


# Create the list of file names: filenames
filenames = ['olymGold.csv', 'olymSilver.csv', 'olymBronze.csv']

# Create the list of three DataFrames: dataframes
dataframes = []
for filename in filenames:
    dataframes.append(pd.read_csv(myPath + filename, encoding="latin-1"))

# Print top 5 rows of 1st DataFrame in dataframes
print(dataframes[0].head())


uqNOC = set(list(gold["NOC"].unique()) + list(silver["NOC"].unique()) + list(bronze["NOC"].unique()))

totGold = gold["NOC"].value_counts()
totSilver = silver["NOC"].value_counts()
totBronze = bronze["NOC"].value_counts()

totDF = pd.DataFrame( {"Gold":totGold, "Silver":totSilver, "Bronze":totBronze} ).fillna(0)
totDF["Total"] = totDF["Gold"] + totDF["Silver"] + totDF["Bronze"]
totDF = totDF[["Total", "Gold", "Silver", "Bronze"]]
totDF = totDF.sort_values("Total", ascending=False)
print(totDF.head(20))


# The sole variable is called "Max TemperatureF" with the index being called "Month"
maxTemps = [68, 60, 68, 84, 88, 89, 91, 86, 90, 84, 72, 68]
maxIndex = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']


# Read 'monthly_max_temp.csv' into a DataFrame: weather1
# weather1 = pd.read_csv('monthly_max_temp.csv', index_col="Month")

weather1 = pd.DataFrame( {"Max TemperatureF":maxTemps}, index=maxIndex )

# Print the head of weather1
print(weather1.head())

# Sort the index of weather1 in alphabetical order: weather2
weather2 = weather1.sort_index()

# Print the head of weather2
print(weather2.head())

# Sort the index of weather1 in reverse alphabetical order: weather3
weather3 = weather1.sort_index(ascending=False)

# Print the head of weather3
print(weather3.head())

# Sort weather1 numerically using the values of 'Max TemperatureF': weather4
weather4 = weather1.sort_values("Max TemperatureF")

# Print the head of weather4
print(weather4.head())


# The variable is called "Mean TemperatureF" and the indexing is run by "Month"
# The dataset is then called weather1
meanTemps = [61.956043956043956, 32.133333333333333, 68.934782608695656, 43.434782608695649]
meanIndex = ["Apr", "Jan", "Jul", "Oct"]
year = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']


weather1 = pd.DataFrame( {"Mean TemperatureF":meanTemps}, index=meanIndex )
print(weather1.head())


# Reindex weather1 using the list year: weather2
weather2 = weather1.reindex(year)

# Print weather2
print(weather2)

# Reindex weather1 using the list year with forward-fill: weather3
weather3 = weather1.reindex(year).ffill()

# Print weather3
print(weather3)


# Baby names data is from https://www.data.gov/developers/baby-names-dataset/

yob1881 = pd.read_csv(myPath + "yob1881.txt", header=None)
yob1981 = pd.read_csv(myPath + "yob1981.txt", header=None)

yob1881.columns = ["Name", "Gender", "Count"]
yob1981.columns = ["Name", "Gender", "Count"]

yob1881 = yob1881.set_index("Name").sort_values("Count", ascending=False)
yob1981 = yob1981.set_index("Name").sort_values("Count", ascending=False)

print(yob1881.shape)
print(yob1981.shape)
print(yob1881.head(12))
print(yob1981.head(12))


# Reindex names_1981 with index of names_1881: common_names
# Take only top-200 names by year
pop1881 = yob1881.iloc[0:200, :]
pop1981 = yob1981.iloc[0:200, :]


common_names = pop1981.reindex(pop1881.index)

# Print shape of common_names
print(common_names.shape)
print(common_names.head(12))

# Drop rows with null counts: common_names
common_names = common_names.dropna()

# Print shape of new common_names
print(common_names.shape)
print(common_names.head(12))


# weather is 365x22 representing 2013 Pittsburgh weather data from Weather Underground
# Used package "weatherData" to grab this from R
# KPIT2013 <- weatherData::getWeatherForDate("KPIT", "2013-01-01", "2013-12-31", opt_all_columns = TRUE)
# write.csv(KPIT2013, "./PythonInputFiles/KPIT2013.csv", row.names=FALSE)

weather = pd.read_csv(myPath + "KPIT2013.csv")

# Extract selected columns from weather as new DataFrame: temps_f
temps_f = weather[['Min_TemperatureF', 'Mean_TemperatureF', 'Max_TemperatureF']]

# Convert temps_f to celsius: temps_c
temps_c = (temps_f - 32) * (5/9)

# Rename 'F' in column names with 'C': temps_c.columns
temps_c.columns = temps_c.columns.str.replace("F", "C")

# Print first 5 rows of temps_c
print(temps_c.head())


# Quarterly US GDP data from 1947-01-01 to 2016-04-01
# Downloaded from https://fred.stlouisfed.org/series/GDP as myPath + "US_GDP_1947_2016_StLouisFRED.csv"
# Read 'GDP.csv' into a DataFrame: gdp
gdp = pd.read_csv(myPath + "US_GDP_1947_2016_StLouisFRED.csv", parse_dates=True, index_col="DATE")

# Slice all the gdp data from 2008 onward: post2008
post2008 = gdp.loc["2008-01-01":, :]

# Print the last 8 rows of post2008
print(post2008.tail(8))

# Resample post2008 by year, keeping last(): yearly
yearly = post2008.resample("A").last()

# Print yearly
print(yearly)

# Compute percentage growth of yearly: yearly['growth']
yearly['growth'] = yearly.pct_change()*100

# Print yearly again
print(yearly)


# Import pandas
# import pandas as pd

# Read 'sp500.csv' into a DataFrame: sp500
# sp500 = pd.read_csv("sp500.csv", parse_dates=True, index_col="Date")

# Read 'exchange.csv' into a DataFrame: exchange
# exchange = pd.read_csv("exchange.csv", parse_dates=True, index_col="Date")

# Subset 'Open' & 'Close' columns from sp500: dollars
# dollars = sp500.loc[:, ["Open", "Close"]]

# Print the head of dollars
# print(dollars.head())

# Convert dollars to pounds: pounds
# pounds = dollars.multiply(exchange["GBP/USD"], axis="rows")

# Print the head of pounds
# print(pounds.head())

```
  
  
***
  
Chapter 2 - Concatenating Data  
  
Appending and concatenating Series - using .append() or pd.concat():  
  
* When invoked as DF1.append(DF2), the rows of DF2 will be placed beneath DF1  
	* This method will also work with Series, in addition to DataFrames  
    * The method .reset_index(drop=True) will create a new index and also delete the old indices (that is what the drop=True commands)  
* Alternately, pd.concat(DF1, DF2, DF3) can be used to concatenate the data  
	* This method can be run for rows (stacked data) or columns  
    * The option ignore_index=True will create a new index for the concatenated data  
* The appended data may have duplicates in the index, which is permissible but frequently undesirable  
	* The .reset_index(drop=True) or ignore_index=True are best practices for obtaining a unique index  
  
Appending and concatenating DataFrames:  
  
* If the data have different columns, then the stacking still occurs but with np.nan coerced in for missing values due to that not being part of the underlying row data  
* If the data have different index names, the data are still stacked under each other, but the index becomes un-named  
* Using the command axis=1 or axis="columns" inside of pd.concat() is a request for the columns to be placed to the right of the existing data rather than for the rows to be placed underneath it  
	* In this case, matching indices will lead to full data, while mismatched indices will fill with the appropriate amounts of np.nan  
  
Concatenation, keys, and MultiIndexes:  
  
* If using the keys=[] option inside pd.concat(), then an extra outer index will be created, with the items in keys corresponding to the DataFrames in the pd.concat() list  
* If concatenating using axis=1 / axis="columns", then there can be multiple columns with the same name  
	* The keys=[] work-around works here also, and the axis=1 means that they outer key will be placed on the columns rather than on the rows  
* If a dictionary is sent as the input to pd.concat({}), then the dictionary keys become the outer keys  
  
Outer and Inner Joins:  
  
* If using numpy, np.hstack() will stack horizontally and np.vstack() will stack vertically  
	* Can instead use np.concatenate([], axis=0/1) where axis=0 is the vstack and axis=1 is the hstack  
* Joins are the process of combining rows of multiple tables in a meaningful manner  
	* Outer joins are similar to the work above, where everything is kept with np.nan inserted as needed due to index mismatch  
    * Inner joins keep only the rows where the indices are common to both tables  
    * The option join="inner" can be included inside the pd.concat() call # the join="outer" is the default and can be excluded  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"



import pandas as pd
import numpy as np
import random

# Do not have these .csv files
# Created dummy data and saved .csv to myPath
# keyDates = pd.date_range("2015-01-01", "2015-03-31")
# utHardware = [random.randint(2, 10) for p in range(len(keyDates))]
# utSoftware = [random.randint(1, 50) for p in range(len(keyDates))]
# utService = [random.randint(0, 200) for p in range(len(keyDates))]
# totSales = pd.DataFrame( {"Date":[str(x).split()[0] for x in keyDates], "Hardware":utHardware, "Software":utSoftware, "Service":utService } )
# totSales["Units"] = totSales["Hardware"] + totSales["Software"] + totSales["Service"]
# totSales["Company"] = ["A", "B", "C"] * 30
# totSales.iloc[:31, :].to_csv(myPath + "sales-jan-2015.csv", index=False)
# totSales.iloc[31:59, :].to_csv(myPath + "sales-feb-2015.csv", index=False)
# totSales.iloc[59:, :].to_csv(myPath + "sales-mar-2015.csv", index=False)


# Load 'sales-jan-2015.csv' into a DataFrame: jan
jan = pd.read_csv(myPath + "sales-jan-2015.csv", parse_dates=True, index_col="Date")

# Load 'sales-feb-2015.csv' into a DataFrame: feb
feb = pd.read_csv(myPath + "sales-feb-2015.csv", parse_dates=True, index_col="Date")

# Load 'sales-mar-2015.csv' into a DataFrame: mar
mar = pd.read_csv(myPath + "sales-mar-2015.csv", parse_dates=True, index_col="Date")

# Extract the 'Units' column from jan: jan_units
jan_units = jan['Units']

# Extract the 'Units' column from feb: feb_units
feb_units = feb['Units']

# Extract the 'Units' column from mar: mar_units
mar_units = mar['Units']

# Append feb_units and then mar_units to jan_units: quarter1
quarter1 = jan_units.append(feb_units).append(mar_units)

# Print the first slice from quarter1
print(quarter1.loc['jan 27, 2015':'feb 2, 2015'])

# Print the second slice from quarter1
print(quarter1.loc['feb 26, 2015':'mar 7, 2015'])

# Compute & print total sales in quarter1
print(quarter1.sum())


# Initialize empty list: units
units = []

# Build the list of Series
for month in [jan, feb, mar]:
    units.append(month["Units"])

# Concatenate the list: quarter1
quarter1 = pd.concat(units, axis="rows")

# Print slices from quarter1
print(quarter1.loc['jan 27, 2015':'feb 2, 2015'])
print(quarter1.loc['feb 26, 2015':'mar 7, 2015'])


# Refers back to the names datasets from earlier in these chapters
yob1881 = pd.read_csv(myPath + "yob1881.txt", header=None)
yob1981 = pd.read_csv(myPath + "yob1981.txt", header=None)

yob1881.columns = ["Name", "Gender", "Count"]
yob1981.columns = ["Name", "Gender", "Count"]

names_1881 = yob1881.sort_values("Count", ascending=False)
names_1981 = yob1981.sort_values("Count", ascending=False)


# Add 'year' column to names_1881 and names_1981
names_1881['year'] = 1881
names_1981['year'] = 1981


# Append names_1981 after names_1881 with ignore_index=True: combined_names
combined_names = names_1881.append(names_1981, ignore_index=True)

# Print shapes of names_1981, names_1881, and combined_names
print(names_1981.shape)
print(names_1881.shape)
print(combined_names.shape)

# Print all rows that contain the name 'Morgan'
print(combined_names.loc[combined_names["Name"].str.contains("Morgan"), :])


# These data are the 4x1 of quarterly data from above in this workbook (Mean is actually the 12x1 with Max being the 4x1)
# The sole variable is called "Max TemperatureF" with the index being called "Month"
maxTemps = [68, 60, 68, 84, 88, 89, 91, 86, 90, 84, 72, 68]
maxIndex = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
meanTemps = [61.956043956043956, 32.133333333333333, 68.934782608695656, 43.434782608695649]
meanIndex = ["Apr", "Jan", "Jul", "Oct"]

weather_max = pd.DataFrame( {"Max TemperatureF":maxTemps}, index=maxIndex)
weather_mean = pd.DataFrame( {"Mean TemperatureF":meanTemps}, index=meanIndex)


# Concatenate weather_max and weather_mean horizontally: weather
weather = pd.concat([weather_max, weather_mean], axis=1).reindex(weather_max.index)

# Print weather
print(weather)


# This uses the Olympics medal datasets from previous

medal_types = ['bronze', 'silver', 'gold']
medals = []

for medal in medal_types:
    # Create the file name: file_name
    file_name = myPath + "%s_top5.csv" % medal  # Note that the %s followed later by % medal means to replace the %s with the value of medal
    
    # Create list of column names: columns
    columns = ['Country', medal]
    
    # Read file_name into a DataFrame: df
    medal_df = pd.read_csv(file_name, header=0, index_col="Country", names=columns)
    
    # Append medal_df to medals
    medals.append(medal_df)

# Concatenate medals horizontally: medals
medals = pd.concat(medals, axis="columns")

# Print medals
print(medals)


medals = []

for medal in medal_types:
    file_name = myPath + "%s_top5.csv" % medal
    
    # Read file_name into a DataFrame: medal_df
    medal_df = pd.read_csv(file_name, index_col="NOC")
    
    # Append medal_df to medals
    medals.append(medal_df)
    
# Concatenate medals: medals
medals = pd.concat(medals, keys=['bronze', 'silver', 'gold'])

# Print medals in entirety
print(medals)


# Sort the entries of medals: medals_sorted
medals_sorted = medals.sort_index(level=0)

# Print the number of Bronze medals won by Germany
print(medals_sorted.loc[('bronze','GER')])

# Print data about silver medals
print(medals_sorted.loc['silver'])

# Create alias for pd.IndexSlice: idx
idx = pd.IndexSlice

# Print all the data on medals won by the United Kingdom
print(medals_sorted.loc[idx[:,'GBR'], :])


# DO NOT HAVE THESE FILES - PROBABLY LINKED TO THE "sales" INPUTS FROM ABOVE
# Concatenate dataframes: february
# february = pd.concat(dataframes, axis=1, keys=['Hardware', 'Software', 'Service'])

# Print february.info()
# print(february.info())

# Assign pd.IndexSlice: idx
# idx = pd.IndexSlice

# Create the slice: slice_2_8
# slice_2_8 = february.loc['2015-02-02':'2015-02-08', idx[:, 'Company']]

# Print slice_2_8
# print(slice_2_8)


# CONTINUES TO BE jan/feb/mar FROM PREVIOUS "sales" INPUTS
# Make the list of tuples: month_list
month_list = [('january', jan), ('february', feb), ('march', mar)]

# Create an empty dictionary: month_dict
month_dict = {}

for month_name, month_data in month_list:
    
    # Group month_data: month_dict[month_name]
    month_dict[month_name] = month_data.groupby("Company").sum()

# Concatenate data in month_dict: sales
sales = pd.concat(month_dict)

# Print sales
print(sales)

# Print all sales by 'A'
idx = pd.IndexSlice
print(sales.loc[idx[:, 'A'], :])


# Again, the Olympics datasets (specifically, top-5 by medal type)
bronze_top5=pd.read_csv(myPath + "bronze_top5.csv", index_col="NOC")
silver_top5=pd.read_csv(myPath + "silver_top5.csv", index_col="NOC")
gold_top5=pd.read_csv(myPath + "gold_top5.csv", index_col="NOC")

# Create the list of DataFrames: medal_list
medal_list = [bronze_top5, silver_top5, gold_top5]

# Concatenate medal_list horizontally using an inner join: medals
medals = pd.concat(medal_list, axis=1, join="inner", keys=['bronze', 'silver', 'gold'])
medals.columns = ['bronze', 'silver', 'gold']

# Print medals
print(medals)


# US is quartely GDP starting 1947
# China is annual GDP starting 1966

# Resample and tidy china: china_annual
# china_annual = china.resample("A").pct_change(10).dropna()

# Resample and tidy us: us_annual
# us_annual = us.resample("A").pct_change(10).dropna()

# Concatenate china_annual and us_annual: gdp
# gdp = pd.concat([china_annual, us_annual], join="inner", axis=1)

# Resample gdp and print
# print(gdp.resample('10A').last())

```
  
  
***
  
Chapter 3 - Merging Data  
  
Merging DataFrames - an extension of concatenation that allows for merging on things other than the index:  
  
* Can use pd.merge(DF1, DF2) to merge on all the matching columns, defaulted to an inner join  
	* Adding on=[""] will allow for merging to take place only on the specified column(s), with any other duplicated column names taking on _x and _y suffixes  
    * Can add suffixes=[""] to replace _x and _y with the specified suffixes for the new variable names  
    * Can instead specify left_on=[""] and right_on=[""] to specify that differently named columns in the first and second DataFrame should be used for the merge  
  
Joining DataFrames - various types of joins, and implications on processing efficency:  
  
* The default for pd.merge() is an implied how="inner" argument  
	* The how="left" option will keep everything from the left dataset and only the matches from the right (non-matched data will be null-filled)  
    * The how="right" option will keep everything from the right dataset and only the matches from the left (non-matched data will be null-filled)  
    * The how="outer" will keep everything from either dataset  
* When using myDF.join(DF2), there is a default how="left" assumption such that everything in myDF will be kept, along with matching data from DF2  
	* This can be over-ridden by specifying the how= as "right" or "inner" or "outer"  
* Suggestions for data-combining techniques  
	* df1.append(df2) works fine for simple stacking vertically  
    * pd.concat([df1, df2]) adds flexibility, including the ability to stack horizontally and inner/outer joins  
    * df1.join(df2) expands to allow left/right joins in addition to inner/outer  
    * pd.merge([df1, df2]) adds the customization of multiple columns, mismatched column names, and the like  
  
Ordered merges - DataFrames where the underlying data has a natural order (such as time series data):  
  
* The pd.merge_ordered() call will default to an outer join that sorts by the first columns of the combined database  
	* Can specify on=[""] to define the columns to be merged  
    * Can specify fill_method="ffill" to forward-fill on any np.nan that would otherwise be generated  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"


import pandas as pd


revenue = pd.DataFrame({"branch_id" : [10, 20, 30, 47] , "city" : ["Austin", "Denver", "Springfield", "Mendocino"] , "revenue" : [100, 83, 4, 200] } )
managers = pd.DataFrame({"branch_id" : [10, 20, 47, 31] , "city" : ["Austin", "Denver", "Mendocino", "Springfield"] , "manager" : ["Charles", "Joel", "Brett", "Sally"] } )


# Merge revenue with managers on 'city': merge_by_city
merge_by_city = pd.merge(revenue, managers, on="city")

# Print merge_by_city
print(merge_by_city)

# Merge revenue with managers on 'branch_id': merge_by_id
merge_by_id = pd.merge(revenue, managers, on="branch_id")

# Print merge_by_id
print(merge_by_id)


revenue["state"] = ["TX", "CO", "IL", "CA"]
managers["state"] = ["TX", "CO", "CA", "MO"]

managers=managers.iloc[:, [1, 0, 2, 3]]
managers.columns = ["branch", "branch_id", "manager", "state"]

# Merge revenue & managers on 'city' & 'branch': combined
combined = pd.merge(revenue, managers, left_on="city", right_on="branch")

# Print combined
print(combined)


# Add 'state' column to revenue: revenue['state']
# revenue['state'] = ['TX','CO','IL','CA']  # already handled above

# Add 'state' column to managers: managers['state']
# managers['state'] = ['TX','CO','CA','MO']  # already handled above


managers = managers.iloc[:, [1, 0, 2, 3]]   # get back to how it was
managers.columns = ["branch_id", "city", "manager", "state"]

# Merge revenue & managers on 'branch_id', 'city', & 'state': combined
combined = pd.merge(revenue, managers, on=["branch_id", "city", "state"])

# Print combined
print(combined)


sales = pd.DataFrame( { "city" : ["Mendocino", "Denver", "Austin", "Springield", "Springfield"] , "state" : ["CA", "CO", "TX", "MO", "IL"] , "units" : [1, 4, 2, 5, 1] } )
managers=managers.iloc[:, [1, 0, 2, 3]]
managers.columns = ["branch", "branch_id", "manager", "state"]


# Merge revenue and sales: revenue_and_sales
revenue_and_sales = pd.merge(revenue, sales, how="right", on=['city', 'state'])

# Print revenue_and_sales
print(revenue_and_sales)

# Merge sales and managers: sales_and_managers
sales_and_managers = pd.merge(sales, managers, how="left", left_on=['city', 'state'], right_on=['branch', 'state'])

# Print sales_and_managers
print(sales_and_managers)


# Perform the first merge: merge_default
merge_default = pd.merge(sales_and_managers, revenue_and_sales)

# Print merge_default
print(merge_default)

# Perform the second merge: merge_outer
merge_outer = pd.merge(sales_and_managers, revenue_and_sales, how="outer")

# Print merge_outer
print(merge_outer)

# Perform the third merge: merge_outer_on
merge_outer_on = pd.merge(sales_and_managers, revenue_and_sales, on=['city','state'], how="outer")

# Print merge_outer_on
print(merge_outer_on)


austin = pd.DataFrame( { "date":pd.to_datetime(["2016-01-01", "2016-02-08", "2016-01-17"]), "ratings" : ["Cloudy", "Cloudy", "Sunny"] } )
houston = pd.DataFrame( { "date":pd.to_datetime(["2016-01-04", "2016-01-01", "2016-03-01"]), "ratings" : ["Rainy", "Cloudy", "Sunny"] } )

# Perform the first ordered merge: tx_weather
tx_weather = pd.merge_ordered(austin, houston)

# Print tx_weather
print(tx_weather)

# Perform the second ordered merge: tx_weather_suff
tx_weather_suff = pd.merge_ordered(austin, houston, on="date", suffixes=['_aus','_hus'])

# Print tx_weather_suff
print(tx_weather_suff)

# Perform the third ordered merge: tx_weather_ffill
tx_weather_ffill = pd.merge_ordered(austin, houston, on="date", suffixes=['_aus','_hus'], fill_method="ffill")

# Print tx_weather_ffill
print(tx_weather_ffill)


# Similar to pd.merge_ordered(), the pd.merge_asof() function will also merge values in order using the on column, but for each row in the left DataFrame, only rows from the right DataFrame whose 'on' column values are less than the left value will be kept.

# DO NOT HAVE THESE DATASETS
# Merge auto and oil: merged
# merged = pd.merge_asof(auto, oil, left_on="yr", right_on="Date")

# Print the tail of merged
# print(merged.tail())

# Resample merged: yearly
# yearly = merged.resample("A", on="Date")[['mpg','Price']].mean()

# Print yearly
# print(yearly)

# print yearly.corr()
# print(yearly.corr())

```
  
  
***
  
Chapter 4 - Case Study (Summer Olympics)  
  
Medals in the Summer Olympics - does a country win more medals when it is the host?:  
  
* Load and combine underlying .csv files from the Guardian  
  
Quantifying Performance:  
  
* Using a .pivot_table(index=, values=, columns=, aggfunc=) to define "success" for each country's athletes  
* Need to calculate fractions (percentage of total medals), and potentially zero-fill the NA data  
  
Reshaping and plotting:  
  
* Melting the data to be easier to work with  
* Merging in the host country information  
* Quantifying "home country" influence, and then plotting the findings  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"



import pandas as pd
import matplotlib.pyplot as plt


# Create files needed for reading in later
# medals = pd.read_csv(myPath + "summerOlympics_Medalists_1896_2008.csv", header=4)
# uqYears = medals["Edition"].value_counts().sort_index().index
# for x in uqYears: 
#     outFile = myPath + '_notuse_summer_{:d}.csv'.format(x)
#     outData = medals.loc[medals["Edition"] == x]
#     outData.to_csv(outFile, index=False)
# 

# Create file path: file_path
file_path = myPath + "summerOlympics_Hosts_1896_2008.txt"

# Load DataFrame from file_path: editions
editions = pd.read_csv(file_path, sep="\t")

# Extract the relevant columns: editions
editions = editions[['Edition', 'Grand Total', 'City', 'Country']]

# Print editions DataFrame
print(editions)


# Create the file path: file_path
file_path = myPath + 'olympicsCountryCodes.csv'

# Load DataFrame from file_path: ioc_codes
ioc_codes = pd.read_csv(file_path)
ioc_codes.columns = ["Country", "NOC", "ISO", "Country_1"]

# Extract the relevant columns: ioc_codes
ioc_codes = ioc_codes[["Country", "NOC"]]

# Print first and last 5 rows of ioc_codes
print(ioc_codes.head())
print(ioc_codes.tail())


# Create empty dictionary: medals_dict
medals_dict = {}

for year in editions['Edition']:
    
    # Create the file path: file_path
    file_path = myPath + '_notuse_summer_{:d}.csv'.format(year)
    
    # Load file_path into a DataFrame: medals_dict[year]
    medals_dict[year] = pd.read_csv(file_path, encoding="latin-1")
    
    # Extract relevant columns: medals_dict[year]
    medals_dict[year] = medals_dict[year][['Athlete', 'NOC', 'Medal']]
    
    # Assign year to column 'Edition' of medals_dict
    medals_dict[year]['Edition'] = year


# Concatenate medals_dict: medals
medals = pd.concat(medals_dict, ignore_index=True)

# Print first and last 5 rows of medals
print(medals.head())
print(medals.tail())


# Construct the pivot_table: medal_counts
medal_counts = medals.pivot_table(index="Edition", columns="NOC", values="Athlete", aggfunc="count")

# Print the first & last 5 rows of medal_counts
print(medal_counts.head())
print(medal_counts.tail())


# Set Index of editions: totals
totals = editions.set_index("Edition")

# Reassign totals['Grand Total']: totals
totals = totals["Grand Total"]

# Divide medal_counts by totals: fractions
fractions = medal_counts.divide(totals, axis="rows")

# Print first & last 5 rows of fractions
print(fractions.head())
print(fractions.tail())


# CHECK IN TO WHAT THE .expanding() does here . . . 
# Apply the expanding mean: mean_fractions
mean_fractions = fractions.expanding().mean()

# Compute the percentage change: fractions_change
fractions_change = mean_fractions.pct_change() * 100

# Reset the index of fractions_change: fractions_change
fractions_change = fractions_change.reset_index()

# Print first & last 5 rows of fractions_change
print(fractions_change.head())
print(fractions_change.tail())


# Left join editions and ioc_codes: hosts
hosts = pd.merge(editions, ioc_codes, how="left")

# Extract relevant columns and set index: hosts
hosts = hosts[["Edition", "NOC"]].set_index("Edition")

# Fix missing 'NOC' values of hosts
print(hosts.loc[hosts.NOC.isnull()])
hosts.loc[1972, 'NOC'] = 'FRG'
hosts.loc[1980, 'NOC'] = 'URS'
hosts.loc[1988, 'NOC'] = 'KOR'

# Reset Index of hosts: hosts
hosts = hosts.reset_index()

# Print hosts
print(hosts)


# Reshape fractions_change: reshaped
reshaped = pd.melt(fractions_change, id_vars="Edition", value_name="Change")

# Print reshaped.shape and fractions_change.shape
print(reshaped.shape, fractions_change.shape)

# Extract rows from reshaped where 'NOC' == 'CHN': chn
chn = reshaped[reshaped["NOC"] == "CHN"]

# Print last 5 rows of chn with .tail()
print(chn.tail())


# Merge reshaped and hosts: merged
merged = pd.merge(reshaped, hosts, how="inner")

# Print first 5 rows of merged
print(merged.head())

# Set Index of merged and sort it: influence
influence = merged.set_index("Edition").sort_index()

# Print first 5 rows of influence
print(influence.head())


# Import pyplot
import matplotlib.pyplot as plt

# Extract influence['Change']: change
change = influence["Change"]

# Make bar plot of change: ax
ax = change.plot(kind="bar")

# Customize the plot to improve readability
ax.set_ylabel("% Change of Host Country Medal Count")
ax.set_title("Is there a Host Country Advantage?")
ax.set_xticklabels(editions['City'])

# Display the plot
# plt.show()
plt.savefig("_dummyPy073.png", bbox_inches="tight")
plt.clf()

```
  
  
**Summer Olympics - % Change in Medals (Host Country)**:  
![](_dummyPy073.png)
  

###_Introduction to Databases in Python_#
  
Chapter 1 - Basics of Relational Databases  
  
Introduction to Databases - relational tables that store data (course features US Census data):  
  
* Columns are the name of the field/element, which must be of a single, consistent data type  
* Tables can be joined on common fields (even with the different names) - defined as the "relational model"  
  
Connecting to Your Database - tools in SQLAlchemy, which allows for writing SQL code using Python:  
  
* Core Model (Relational) will be the focus of this course  
* ORM (User Data Model) is an additional capability of SQLAlchemy  
* The key advantage of SQLAlchemy is the ability to work across database types (SQLite, PostgreSQL, MySQL, etc.)  
	* from sqlalchemy import create_engine  
    * engine = create_engine("sqlite:///[myFile].sqlite") to create the engine, which is the common interface to the database from SQLAlchemy  
    * connection = engine.connect()  
* The connection string (such as "sqlite:///census_nyc.sqlite") describes the database driver (sqlite:///) and the file-name (census_nyc.sqlite, which is in the ./ directory in this example)  
	* print(engine.table_names()) will return the table names in the relevant file  
* Reflection is a technique for reading the database and building the SQLAlchemy tables  
	* from sqlalchemy import Metadata, Table  
    * metadata = MetaData()  
    * census = Table("census", metadata, autoload=True, autoload_with=engine)  
    * print(repr(census)) # will show the column names and data types  
  
Introduction to SQL - basic commands:  
  
* SELECT column_name FROM table_name to select the specified column from the specified table (if column_name is * it means "all")  
	* Can create a variable, such as stmt = "SELECT * FROM people" ; newVar_proxy = connection.execute(stmt) ; newVar = newVar_proxy.fetchall()  
    * The "newVar_proxy" is of type "ResultProxy", and any commands returned, such as from a .fetchall(), are the "ResultSet"  
* SQLAlchemy allows for a Pythonic way to build complex SQL statements  
	* After creating the representation (such as census in the above block)  
    * Can then use the most basic command, such as stmt = select([census]), which will be the SQL equivalent of SELECT * FROM census  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"



import pandas as pd


# Appears that the SQL file has two tables, "census" and "state_fact"
# Downloaded a different version of the file from: 
# https://www.gfairchild.com/2011/12/13/2010-census-sqlite-database/
# This data contains ['counties', 'states', 'states_zctas', 'zctas']


# Import create_engine
from sqlalchemy import create_engine

# Create an engine that connects to the census.sqlite file: engine
engine = create_engine("sqlite:///" + myPath + "2010CensusPopulation.db")

# Print table names
print(engine.table_names())


from sqlalchemy import MetaData
metadata = MetaData()  # I think, it has already been loaded/created in the exercises . . . 

# Import Table
from sqlalchemy import Table

# Reflect census table from the engine: census (uses states instead . . . )
# census = Table("census", metadata, autoload=True, autoload_with=engine)
census = Table("states", metadata, autoload=True, autoload_with=engine)

# Print census table metadata
print(repr(census))

# Output in DataCamp example is: Table('census', MetaData(bind=None), Column('state', VARCHAR(length=30), table=<census>), Column('sex', VARCHAR(length=1), table=<census>), Column('age', INTEGER(), table=<census>), Column('pop2000', INTEGER(), table=<census>), Column('pop2008', INTEGER(), table=<census>), schema=None)
# MANY more columns using the data I have

# Reflect the census table from the engine: census (per previous, using 'states' instead)
census = Table("states", metadata, autoload=True, autoload_with=engine)

# Print the column names
print(census.columns.keys())

# Print full table metadata (per previous, using 'states' instead)
print(repr(metadata.tables["states"]))


# Build select statement for census table: stmt
# stmt = "SELECT * FROM census"
stmt = "SELECT * FROM states"

# Execute the statement and fetch the results: results
connection = engine.connect()  # Create connection to the engine defined above (not sure . . . )
results = connection.execute(stmt).fetchall()

# Print Results (too long to print the entire thing)
# print(results)
print(type(results))
print(len(results))
print(results[0])


# Import select
from sqlalchemy import select

# Reflect census table via engine: census (per previous, use states instead)
# census = Table('census', metadata, autoload=True, autoload_with=engine)
census = Table('states', metadata, autoload=True, autoload_with=engine)

# Build select statement for census table: stmt
stmt = select([census])

# Print the emitted statement to see the SQL emitted
print(stmt)

# Execute the statement and print the results (WAY TOO LONG!)
# print(connection.execute(stmt).fetchall())


# Get the first row of the results by using an index: first_row
first_row = results[0]

# Print the first row of the results
print(first_row)

# Print the first column of the first row by using an index
print(first_row[0])

# Print the 'state' column of the first row by using its name
print(first_row["state"])



# Make it a sensible DataFrame
myDF = pd.DataFrame(results)
myDF.columns = census.columns.keys()
print(myDF.shape)

# Melt the data down so that gender and age are the columns
# Key by id-state
# Ax total population and gender subtotals and centroids
colNamesNo = ["centroid_longitude", "centroid_latitude", "population_total", "population_male_total", "population_female_total"]
colNumsNo = [list(myDF.columns).index(x) for x in colNamesNo]

myBasic = myDF.iloc[:, [0, 1] + colNumsNo]  # [0, 1] are id-state
myPreMelt = myDF.iloc[:, [a not in colNumsNo for a in range(len(myDF.columns))]]

myMelt = myPreMelt.melt(id_vars=["id", "state"], var_name="gender_age", value_name="pop2010")
myMelt["gender"] = [x.split("_")[1] for x in myMelt["gender_age"]]
myMelt["age"] = [x.split("_")[2] for x in myMelt["gender_age"]]

print(myMelt.shape)
print(myMelt.head(10))
print(myMelt.tail(10))
print(myMelt["gender"].value_counts())
print(myMelt["age"].value_counts())
print(myMelt.info())

```
  
  
***
  
Chapter 2 - Applying Filtering, Ordering, etc.  
  
Filtering and Targeting Data - select subsets of records based on specified criteria:  
  
* In SQL, this would be run using WHERE, for example SELECT * FROM census WHERE state == "California"  
* Using sql alchemy, this is a two-line process with stmt = select([census]) ; stmt = stmt.where(census.columns.state == "California")  
	* results = connection.execute(stmt).fetchall()  
* There are additional expressions to add flexibility to the query statements  
	* in_(), like(), between() - these are available as methods on the column objects
    * stmt = stmt.where(census.columns.state.startswith("New")) will pull back the states that start with "New"  
    * and_(), or_(), and not_() are also available to allow for boolean operations - these can be nested, though that is not covered in this class  
  
Overview of Ordering - equivalent of the ORDER BY method of SQL:  
  
* Can be achieved in SQL Alchemy using stmt.order_by(myTable.columns.myColumn)  
* Can be achieved in SQL Alchemy using stmt.order_by(desc(myTable.columns.myColumn))  # will be a descending sort  
* Can pass multiple rows, such as stmt.order_by(myTable.columns.myColumn1, desc(myTable.columns.myColumn2))  
  
Counting, Summing, and Grouping Data - much more efficient to run these using SQL rather than to grab all the data and run these in Python:  
  
* Aggregation functions collapse many records in to one - sums or counts for example  
* There is a two-step process to acceess sum: 1) from sqlalchemy import func, followed by 2) using func.sum() inside the relevant code  
	* Import sum from sqlalchemy.func would be bad, as it would then conflict with sum from base Python  
* There is also a group_by command that is available for running GROUP BY commands  
* SQL Alchemy auto-generates "column names" for functions in the ResultSet, such as count_1 or sum_2  
	* Can instead append .label("myLabel") to the desired calculation, and then "myLabel" will replace sum_2  
  
Visualize Data using pandas and matplotlib:  
  
* Can create the DataFrame using df=pd.DataFrame(results), followed by df.columns = results[0].keys()  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"



import pandas as pd


# Import create_engine function
from sqlalchemy import create_engine, MetaData, Table, select

# Create an engine to the census database
# engine = create_engine('postgresql+psycopg2://' + 'student:datacamp' + '@postgresql.csrrinzqubik.us-east-1.rds.amazonaws.com' + ':5432/census')

# Created dummy data with real state-gender-age-pop2010 and totally fake pop2000 = (0.90, 1.05) * pop2010
engine = create_engine("sqlite:///" + myPath + "PartialFakeCensusExample.db")

# Use the .table_names() method on the engine to print the table names
print(engine.table_names())

# Create a select query: stmt
metadata = MetaData()
census = Table("census", metadata, autoload=True, autoload_with=engine)  # make sure this is set up
stmt = select([census])

# Add a where clause to filter the results to only those for New York
stmt = stmt.where(census.columns["state"] == "New York")

# Execute the query to retrieve all the data returned: results
# Execute the statement and fetch the results: results
connection = engine.connect()  # Create connection to the engine defined above (not sure . . . )
results = connection.execute(stmt).fetchall()

# Loop over the results and print the age, sex (gender), and pop2008 (pop2010)
for result in results:
    print(result.age, result.gender, result.pop2010)


states = ['New York', 'California', 'Texas']

# Create a query for the census table: stmt
stmt = select([census])

# Append a where clause to match all the states in_ the list states
stmt = stmt.where(census.columns.state.in_(states))

# Loop over the ResultProxy and print the state and its population in 2000
for x in connection.execute(stmt):
    print(x.state, x.pop2000)


# Import and_
from sqlalchemy import and_

# Build a query for the census table: stmt
stmt = select([census])

# Append a where clause to select only non-male records from California using and_
stmt = stmt.where(
    # The state of California with a non-male sex
    and_(census.columns.state == "California",
         census.columns.gender != "male"
         )
)

# Loop over the ResultProxy printing the age and sex
for result in connection.execute(stmt):
    print(result.age, result.gender)


# Build a query to select the state column: stmt
stmt = select([census.columns.state])

# Order stmt by the state column
stmt = stmt.order_by(census.columns.state)

# Execute the query and store the results: results
results = connection.execute(stmt).fetchall()

# Print the first 10 results
print(results[:10])


# Import desc
from sqlalchemy import desc

# Build a query to select the state column: stmt
stmt = select([census.columns.state])

# Order stmt by state in descending order: rev_stmt
rev_stmt = stmt.order_by(desc(census.columns.state))

# Execute the query and store the results: rev_results
rev_results = connection.execute(rev_stmt).fetchall()

# Print the first 10 rev_results
print(rev_results[:10])


# Build a query to select state and age: stmt
stmt = select([census.columns.state, census.columns.age])

# Append order by to ascend by state and descend by age
stmt = stmt.order_by(census.columns.state, desc(census.columns.age))

# Execute the statement and store all the records: results
results = connection.execute(stmt).fetchall()

# Print the first 20 results
print(results[:20])


from sqlalchemy import func

# Build a query to count the distinct states values: stmt
stmt = select([func.count(census.columns.state.distinct())])

# Execute the query and store the scalar result: distinct_state_count
distinct_state_count = connection.execute(stmt).scalar()

# Print the distinct_state_count
print(distinct_state_count)


# Import func
from sqlalchemy import func

# Build a query to select the state and count of ages by state: stmt
stmt = select([census.columns.state, func.count(census.columns.age)])

# Group stmt by state
stmt = stmt.group_by(census.columns.state)

# Execute the statement and store all the records: results
results = connection.execute(stmt).fetchall()

# Print results
print(results)

# Print the keys/column names of the results returned
print(results[0].keys())


# Import func
from sqlalchemy import func

# Build an expression to calculate the sum of pop2008 labeled as population
pop2010_sum = func.sum(census.columns.pop2010).label("population")

# Build a query to select the state and sum of pop2008: stmt
stmt = select([census.columns.state, pop2010_sum])

# Group stmt by state
stmt = stmt.group_by(census.columns.state)

# Execute the statement and store all the records: results
results = connection.execute(stmt).fetchall()

# Print results
print(results)

# Print the keys/column names of the results returned
print(results[0].keys())


# import pandas
import pandas as pd

# Create a DataFrame from the results: df
df = pd.DataFrame(results)

# Set column names
df.columns = results[0].keys()

# Print the Dataframe
print(df)


# Import Pyplot as plt from matplotlib
import matplotlib.pyplot as plt

# Plot the DataFrame
df.sort_values("population", ascending=False).set_index("state").plot.bar()
# plt.show()
plt.savefig("_dummyPy074.png", bbox_inches="tight")
plt.clf()


```
  
  
**Population (2010) by State**:  
![](_dummyPy074.png)
  
  
***
  
Chapter 3 - Advanced SQL Alchemy Queries  
  
Calculating Values in a Query - addition, subtraction, multiplication, and the like:  
  
* Can put calculations directly in the select statement, such as select([(census.columns.pop2008 - census.columns.pop2000).label("pop_change")])  
* Can limit the number of records pulled using .limit(5)  # will return 5 in this case; can use any number  
* Case statements can help with treating data differently based on a condition (includes a final else clause, represented as else_, for full-on mismatches)  
	* from sqlalchemy import case  
    * func.sum( case( [ (census.columns.state == "New York", census.columns.pop2008) ], else_=0 ))  
* Cast statements can be useful for converting among integers, floats, strings, and the like  
	* from sqlalchemy import case, cast, Float  
    * cast(func.sum(census.columns.pop2008), Float)  # will convert the sum of the population columns to a float  
  
SQL Relationships - bridging data that appears in multiple SQL tables:  
  
* Sometimes, an automatic join type is pre-defined in the database; if so, the simple select statement from multiple tables wil perform the join (???)  
* Can instead use the join clause to perform the join if it has not been pre-defined - should be directly after select()  
	* This is implemented in SQL Alchemy using the select_from() function  
    * stmt = select([func.sum(census.columns.pop2000)])  
    * stmt = stmt.select_from(census.join(state_fact))   # optionally, stmt = stmt.select_from(census.join(state_fact, census.columns.state == state_fact.columns.name))  
    * stmt = stmt.where(state_fact.columns.circuit_court == "10")  
  
Working with Hierarchical Tables (self-referential tables) - tables that refer to themselves:  
  
* The alias() method allows for referring to a table with two different names, making it possible to join columns from the same table to each other  
	* managers = employees.alias()  # managers will now refer to the employees table  
    * managers.columns.name.label("manager")  
    * employees.columns.name.label("employee")  
    * stmt = stmt.select_from(employees.join( managers, managers.columns.id == employees.columns.manager ))  
    * stmt = stmt.order_by(managers.columns.name)  
* The alias and the table name should both be used in the query, otherwise there was no reason to create the alias  
	* Be careful with group_by() and the like  
  
Dealing with large ResultSets - running out of memory or disk space or the like:  
  
* The fetchmany() method allows for retrieveing only a subset of the records from SQL, with the option to retrieve more records later  
	* Returns an empty list when there is nothing left to retrieve  
    * Need to close the ResultProxy afterwards  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"



import pandas as pd


# Import sqlalchemy functions
from sqlalchemy import create_engine, MetaData, Table, select, func, desc

# Create an engine to the census database
# engine = create_engine('mysql+pymysql://' + 'student:datacamp' + '@courses.csrrinzqubik.us-east-1.rds.amazonaws.com:3306/' + 'census')
# Created dummy data with real state-gender-age-pop2010 and totally fake pop2000 = (0.90, 1.05) * pop2010
engine = create_engine("sqlite:///" + myPath + "PartialFakeCensusExample.db")

# Print the table names
print(engine.table_names())

# General pre-amble to be able to access "census"
metadata = MetaData()
census = Table("census", metadata, autoload=True, autoload_with=engine)  # make sure this is set up
state_fact = Table("state_fact", metadata, autoload=True, autoload_with=engine)  # make sure this is set up

# Build query to return state names by population difference from 2008 (make 2010) to 2000: stmt
stmt = select([census.columns.state, (census.columns.pop2010 - census.columns.pop2000).label("pop_change")])

# Append group by for the state: stmt
stmt = stmt.group_by(census.columns.state)

# Append order by for pop_change descendingly: stmt
stmt = stmt.order_by(desc("pop_change"))

# Return only 5 results: stmt
stmt = stmt.limit(5)

# Use connection to execute the statement and fetch all results
connection = engine.connect()  # Create connection to the engine defined above (not sure . . . )
results = connection.execute(stmt).fetchall()

# Print the state and population change for each record
for result in results:
    print('{}:{}'.format(result.state, result.pop_change))


# import case, cast and Float from sqlalchemy
from sqlalchemy import case, cast, Float

# Build an expression to calculate female population in 2000
female_pop2000 = func.sum(
    case([
        (census.columns.gender == "female", census.columns.pop2000)
    ], else_=0))

# Cast an expression to calculate total population in 2000 to Float
total_pop2000 = cast(func.sum(census.columns.pop2000), Float)

# Build a query to calculate the percentage of females in 2000: stmt
stmt = select([female_pop2000 / total_pop2000* 100])

# Execute the query and store the scalar result: percent_female
percent_female = connection.execute(stmt).scalar()

# Print the percentage
print(percent_female)


# Build a statement to join census and state_fact tables: stmt
stmt = select([census.columns.pop2000, state_fact.columns.abbreviation])

# Execute the statement and get the first result: result
result = connection.execute(stmt).first()

# Loop over the keys in the result object and print the key and value
for key in result.keys():
    print(key, getattr(result, key))


# Build a statement to select the census and state_fact tables: stmt
stmt = select([census, state_fact])

# Add a select_from clause that wraps a join for the census and state_fact
# tables where the census state column and state_fact name column match
stmt = stmt.select_from(
    (census.join(state_fact, census.columns.state == state_fact.columns.name)))

# Execute the statement and get the first result: result
result = connection.execute(stmt).first()

# Loop over the keys in the result object and print the key and value
for key in result.keys():
    print(key, getattr(result, key))


# Build a statement to select the state, sum of 2008 (using 2010 instead) population and census
# division name: stmt
stmt = select([
    census.columns.state,
    func.sum(census.columns.pop2010),
    state_fact.columns.census_division_name
])

# Append select_from to join the census and state_fact tables by the census state and state_fact name columns
stmt = stmt.select_from(
    census.join(state_fact, census.columns.state == state_fact.columns.name)
)

# Append a group by for the state_fact name column
stmt = stmt.group_by(state_fact.columns.name)

# Execute the statement and get the results: results
results = connection.execute(stmt).fetchall()

# Loop over the the results object and print each record.
for record in results:
    print(record)


# Make an alias of the employees table: managers
# managers = employees.alias()

# Build a query to select manager's and their employees names: stmt
# stmt = select(
#     [managers.columns.name.label('manager'),
#      employees.columns.name.label("employee")]
# )

# Match managers id with employees mgr: stmt
# stmt = stmt.where(managers.columns.id == employees.columns.mgr)

# Order the statement by the managers name: stmt
# stmt = stmt.order_by(managers.columns.name)

# Execute statement: results
# results = connection.execute(stmt).fetchall()

# Print records
# for record in results:
#     print(record)


# Make an alias of the employees table: managers
# managers = employees.alias()

# Build a query to select managers and counts of their employees: stmt
# stmt = select([managers.columns.name, func.count(employees.columns.id)])

# Append a where clause that ensures the manager id and employee mgr are equal
# stmt = stmt.where(managers.columns.id == employees.columns.mgr)

# Group by Managers Name
# stmt = stmt.group_by(managers.columns.name)

# Execute statement: results
# results = connection.execute(stmt).fetchall()

# print manager
# for record in results:
#     print(record)


# Start a while loop checking for more results
# while more_results:
    # Fetch the first 50 results from the ResultProxy: partial_results
#     partial_results = results_proxy.fetchmany(50)

    # if empty list, set more_results to False
#     if partial_results == []:
#         more_results = False

    # Loop over the fetched records and increment the count for the state
#     for row in partial_results:
#         if row.state in state_count:
#             state_count[row.state] += 1
#         else:
#             state_count[row.state] = 1

# Close the ResultProxy, and thus the connection
# results_proxy.close()

# Print the count by state
# print(state_count)


```
  
  
***
  
Chapter 4 - Creating and Manipulating Databases  
  
Creating Databases and Tables - different by database types, and outside the scope of this course:  
  
* Inside SQLite, the create_engine() call will create the database and/or file if they do not already exist  
	* from sqlalchemy import (Table, Column, String, Integer, Decimal, Boolean)  
    * employees = Table("employees", metadata, Column("id", Integer()), Column("name", String(255)))  
    * metadata.create_all(engine)  
    * engine.table_names()  # verify that table "employees" has been created  
* Can set column options such as unique, nullable, etc,; default is chosen if none are selected  
	* These are each settings inside the Column() calls, such as unique=True, nullable=False, default=100.00, etc.  
    * Can check these with myTable.constraints()  
  
Inserting Data into a Table - done with the insert() command:  
  
* from sqlalchemy import insert  
* stmt = insert(employees).values(id=1, name="Jason")  
* Alternately, can insert multiple values using a list of dictionaries  
	* stmt = insert(employees)  
    * values_list = [ {"id":2, "name":"Rebecca"} , {"id":3, "name":"Bob"} ]  
    * result_proxy = connection.execute(stmt, values_list)  
  
Updating Data in a Database - done with the update() statement, like an insert() statement but with a where clause:  
  
* from sqlalchemy import update  
* stmt = update(employees)  
* stmt = stmt.where(employees.columns.id == 3)  
* stmt = stmt.values(active=True)  
* result_proxy = connection.execute(stmt)  
* Correlated Updated - using a select statement to find a key value that is then used to update other portions of the table  
  
Removing Data from a Database - done with the delete() statement - BE CAREFUL!:  
  
* from sqlalchemy import delete  
* stmt = select([func.count(extra_employees.columns.id)])  
* connection.execute(stmt).scalar()  
* delete_stmt = delete(extra_employees)  
* result_proxy = connection.execute(delete_stmt)  
* Can instead use where clauses, such as  
	* stmt = delete(employees).where(employees.columns.id == 3)  
* Dropping a table completely involves using the "drop" method on the table - metadata will still be in Python until the next re-start, though  
	* extra_employees.drop(engine)  
    * extra_employees.exists(engine)  # will now be False  
* Dropping all tables using the metadata - use the drop_all() command  
	* metadata.drop_all(engine)  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"



import pandas as pd


# Import sqlalchemy functions
from sqlalchemy import create_engine, MetaData, Table, select, func, desc

# Import Table, Column, String, Integer, Float, Boolean from sqlalchemy
from sqlalchemy import Table, Column, String, Integer, Float, Boolean


# Set up for a new FAKE database
engine = create_engine("sqlite:///" + myPath + "_notuse_CreatedFake.db")
print(engine.table_names())
metadata = MetaData()


# Define a new table with a name, count, amount, and valid column: data
data = Table('data', metadata,
             Column("name", String(255)),
             Column('count', Integer()),
             Column("amount", Float()),
             Column("valid", Boolean())
)

# Use the metadata to create the table
metadata.create_all(engine)

# Print table details
print(repr(data))


# Define a new table with a name, count, amount, and valid column: data
data02 = Table('data02', metadata,
               Column('name', String(255), unique=True),
               Column('count', Integer(), default=1),
               Column('amount', Float()),
               Column('valid', Boolean(), default=False)
)

# Use the metadata to create the table
metadata.create_all(engine)

# Print the table details
print(repr(metadata.tables['data02']))


# Import insert and select from sqlalchemy
from sqlalchemy import insert

# Build an insert statement to insert a record into the data table: stmt
stmt = insert(data02).values(name="Anna", count=1, amount=1000.00, valid=True)

# Execute the statement via the connection: results
connection = engine.connect()
results = connection.execute(stmt)

# Print result rowcount
print(results.rowcount)

# Build a select statement to validate the insert
stmt = select([data02]).where(data02.columns.name == "Anna")

# Print the result of executing the query.
print(connection.execute(stmt).first())


# Delete the row so the table is empty again
stmt = "DELETE FROM data02"  # Since there is no WHERE, this will delete everything
results = connection.execute(stmt)
print(results.rowcount)


# Build a list of dictionaries: values_list
values_list = [
    {'name': "Anna", 'count': 1, 'amount': 1000.00, 'valid': True},
    {'name': "Taylor", 'count': 1, 'amount': 750.00, 'valid': False}
]

# Build an insert statement for the data table: stmt
stmt = insert(data02)

# Execute stmt with the values_list: results
results = connection.execute(stmt, values_list)

# Print rowcount
print(results.rowcount)


# Place census data in the fake DB
census = Table('census', metadata,
               Column('state', String(255)),
               Column('gender', String(6)),
               Column('age', String(255)),
               Column('pop2000', Integer()),
               Column('pop2010', Integer())
)

metadata.create_all(engine)
print(repr(data))


# Create a insert statement for census: stmt
stmt = insert(census)

# Create an empty list and zeroed row count: values_list, total_rowcount
values_list = []
total_rowcount = 0



# Enumerate the rows of csv_reader
for idx, row in enumerate(open(myPath + "_notuse_census2000.csv", "r")):
    if idx == 0 : 
        print("Headers are: ", row)
        continue
    
    # Headers for this file are id,state,gender,age,pop2000,pop2010
    rowItems = row.split(",")
    data = {'state': rowItems[1], 'gender': rowItems[2], 'age': rowItems[3], 'pop2000': int(rowItems[4]),
            'pop2010': int(rowItems[5])}
    values_list.append(data)
    
    # Check to see if divisible by 51
    if idx % 51 == 0:
        results = connection.execute(stmt, values_list)
        total_rowcount += results.rowcount
        values_list = []

# Print total rowcount
print(total_rowcount)


# Place state_fact data in the fake DB
state_fact = Table('state_fact', metadata,
               Column('name', String(255)),
               Column('abbreviation', String(2)),
               Column('census_division_name', String(255)),
               Column('fips_state', Integer(), default=0),
               Column('notes', String(255), default="none")
)

metadata.create_all(engine)
print(repr(state_fact))


# Read CSV for state facts
stateFact = pd.read_csv(myPath + "_notuse_stateFact.csv")
values_list = []

for x in range(stateFact.shape[0]):
    y = stateFact.iloc[x, :]
    values_list.append( { "name":y["name"], "abbreviation":y["abbreviation"], "census_division_name":y["census_division_name"] })


# Create the table
stmt = insert(state_fact)
results = connection.execute(stmt, values_list)


# Build a select statement: select_stmt
select_stmt = select([state_fact]).where(state_fact.columns.name == "New York")

# Print the results of executing the select_stmt
print(connection.execute(select_stmt).fetchall())

# Build a statement to update the fips_state to 36: stmt
from sqlalchemy import update
stmt = update(state_fact).values(fips_state = 36)

# Append a where clause to limit it to records for New York state
stmt = stmt.where(state_fact.columns.name == "New York")

# Execute the statement: results
results = connection.execute(stmt)

# Print rowcount
print(results.rowcount)

# Execute the select_stmt again to view the changes
print(connection.execute(select_stmt).fetchall())


# Build a statement to update the notes to 'The Wild West': stmt
stmt = update(state_fact).values(notes = "The Wild West")

# Append a where clause to match the West census region records
stmt = stmt.where(state_fact.columns.census_division_name == "8 (West / Mountain)")

# Execute the statement: results
results = connection.execute(stmt)

# Print rowcount
print(results.rowcount)


# Build a statement to select name from state_fact: stmt
# fips_stmt = select([state_fact.columns.name])

# Append a where clause to Match the fips_state to flat_census fips_code
# fips_stmt = fips_stmt.where(
#     state_fact.columns.fips_state == flat_census.columns.fips_code)

# Build an update statement to set the name to fips_stmt: update_stmt
# update_stmt = update(flat_census).values(state_name=fips_stmt)

# Execute update_stmt: results
# results = connection.execute(update_stmt)

# Print rowcount
# print(results.rowcount)


# Import delete, select
from sqlalchemy import delete, select

# Build a statement to empty the census table: stmt
stmt = delete(census)

# Execute the statement: results
results = connection.execute(stmt)

# Print affected rowcount
print(results.rowcount)

# Build a statement to select all records from the census table
stmt = select([census])

# Print the results of executing the statement to verify there are no rows
print(connection.execute(stmt).fetchall())


# Build a statement to count records using the sex column for Men ('M') age 36: stmt
# stmt = select([func.count(census.columns.sex)]).where(
#     and_(census.columns.sex == 'M',
#          census.columns.age == 36)
# )

# Execute the select statement and use the scalar() fetch method to save the record count
# to_delete = connection.execute(stmt).scalar()

# Build a statement to delete records from the census table: stmt_del
# stmt_del = delete(census)

# Append a where clause to target Men ('M') age 36
# stmt_del = stmt_del.where(
#     and_(census.columns.sex == "M",
#          census.columns.age == 36)
# )

# Execute the statement: results
# results = connection.execute(stmt_del)

# Print affected rowcount and to_delete record count, make sure they match
# print(results.rowcount, to_delete)


# Drop the state_fact table
state_fact.drop(engine)

# Check to see if state_fact exists
print(state_fact.exists(engine))

# Drop all tables
metadata.drop_all(engine)

# Check to see if census exists
print(census.exists(engine))


# Get rid of all tables in the database
metadata.drop_all(engine)
connection.close()



```
  
  
***
  
Chapter 5 - Case Study  
  
Census Case Study - three components:  
  
* Prepare SQLAlchemy and the Database  
* Load data in to the Database  
* Solve Data Science Problems with the Database  
  
Populating the Database - using CSV file from the Census:  
  
* Define an empty list  
* Loop over the rows of the CSV  
* Make each row in to a dictionary  
* Append each dictionary to the list  
* Then, add everything to the table  
	* stmt = insert(employees)  
    * result_proxy = connection.execute(stmt, values_list)  
  
Example Queries:  
  
* Average age by gender  
* Percentage by gender by state  
* Difference in 2008 vs 2000 populations  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"



import pandas as pd


# Import sqlalchemy functions
from sqlalchemy import create_engine, MetaData, Table, select, func, desc
from sqlalchemy import Table, Column, String, Integer, Float, Boolean


# Define an engine to connect to chapter5.sqlite: engine
engine = create_engine('sqlite:///' + myPath + 'chapter5.sqlite')

# Initialize MetaData: metadata
metadata = MetaData()


# Build a census table: census
census = Table('census', metadata,
               Column('state', String(30)),
               Column("gender", String(6)),
               Column("age", Float()),
               Column("pop2000", Integer()),
               Column("pop2010", Integer()),
               Column("ageText", String(30))
               )

# Create the table in the database
metadata.create_all(engine)

# Create mapping of text ages to numeric ages
import numpy as np
tmpAge = list(pd.read_csv(myPath + "_notuse_census2000.csv")["age"].unique())
tmpNum = [np.mean([int(x.split("to")[0]), int(x.split("to")[1])]) if x.find("to") > -1 else 0 for x in tmpAge]
tmpNum[tmpAge.index("20")] = 20
tmpNum[tmpAge.index("21")] = 21
tmpNum[tmpAge.index("lt5")] = 2.5
tmpNum[tmpAge.index("ge85")] = 90

# Create an empty list: values_list
values_list = []

# Iterate over the rows
for idx, row in enumerate(open(myPath + "_notuse_census2000.csv", "r")):
    if idx == 0 : 
        print("Headers are: ", row)
        continue
    
    # Create a dictionary with the values
    rowItems = row.split(",")
    ageNum = tmpNum[tmpAge.index(rowItems[3])]
    data = {'state': rowItems[1], 'gender': rowItems[2], 'age': ageNum, 'pop2000': int(rowItems[4]),
            'pop2010': int(rowItems[5]), 'ageText':rowItems[3]}
    values_list.append(data)

# Import insert
from sqlalchemy import insert

# Build insert statement: stmt
stmt = insert(census)

# Use values_list to insert data: results
connection = engine.connect()
results = connection.execute(stmt, values_list)

# Print rowcount
print(results.rowcount)


# Import select
from sqlalchemy import select

# Calculate weighted average age: stmt
stmt = select([census.columns.gender,
               (func.sum(census.columns.age * census.columns.pop2010) /
                func.sum(census.columns.pop2010)).label("average_age")
               ])

# Group by sex
stmt = stmt.group_by(census.columns.gender)

# Execute the query and store the results: results
results = connection.execute(stmt).fetchall()


# Print the average age by sex
for x in results:
    print(x[0], x[1])


# import case, cast and Float from sqlalchemy
from sqlalchemy import case, cast, Float

# Build a query to calculate the percentage of females in 2010: stmt
stmt = select([census.columns.state,
    (func.sum(
        case([
            (census.columns.gender == 'female', census.columns.pop2010)
        ], else_=0)) /
     cast(func.sum(census.columns.pop2010), Float) * 100).label('percent_female')
])

# Group By state
stmt = stmt.group_by(census.columns.state)

# Execute the query and store the results: results
results = connection.execute(stmt).fetchall()

# Plot the results by state
import matplotlib.pyplot as plt

pctFemale = [y for x, y in results]
pctState = [x for x, y in results]
myDF = pd.DataFrame( {"% female":pd.to_numeric(pctFemale)}, index=pctState )
myDF.sort_values("% female", ascending=False).plot(kind="bar", ylim=(46, 54))
plt.title("% Female by State (2010 Census)")
# plt.show()
plt.savefig("_dummyPy075.png", bbox_inches="tight")
plt.clf()



# Print the percentage
# for result in results:
#     print(result.state, result.percent_female)


# Build query to return state name and population difference from 2008 to 2000
stmt = select([census.columns.state,
     (census.columns.pop2010 - census.columns.pop2000).label('pop_change')
])

# Group by State
stmt = stmt.group_by(census.columns.state)

# Order by Population Change
stmt = stmt.order_by(desc("pop_change"))

# Limit to top 10
stmt = stmt.limit(10)

# Use connection to execute the statement and fetch all results
results = connection.execute(stmt).fetchall()

# Print the state and population change for each record
for result in results:
    print('{}:{}'.format(result.state, result.pop_change))



# Calculate average age by state (2010)
stmt = select([census.columns.state,
               (func.sum(census.columns.age * census.columns.pop2010) /
                func.sum(census.columns.pop2010)).label("average_age")
               ])

# Group by sex
stmt = stmt.group_by(census.columns.state)

# Execute the query and store the results: results
results = connection.execute(stmt).fetchall()

myDF2 = pd.DataFrame( {"Avg. Age":pd.to_numeric([y for x, y in results])}, index=[x for x, y in results] )
myDF2.sort_values("Avg. Age", ascending=False).plot(kind="bar", ylim=(30, 45))
plt.title("Average Age by State (2010 Census)")
# plt.show()
plt.savefig("_dummyPy076.png", bbox_inches="tight")
plt.clf()


# Delete the DB
# Get rid of all tables in the database
metadata.drop_all(engine)
connection.close()

```

**% Female (2010 Census) by State**:  
![](_dummyPy075.png)
	
**Average Age (2010 Census) by State**:  
![](_dummyPy076.png)


###_Network Analysis in Python (Part II)_#  
  
Chapter 1 - Bipartite Graphs and Recommendation Systems  
  
Definitions and basic recap:  
  
* Network/Graph is comprised of two sets - nodes and edges (connections between nodes)  
* Undirected graphs (e.g., Facebook) have connections without any direction ("A connects B" and "B connects A" both mean the same thing)  
* Directed graphs (e.g., Twitter) have connections with direction ("A connects B" can happen even in the absence of "B connects A")  
* The "networkx" package has a library of functions and API for working with networks and graphs  
	* Typically, this is called using "import networkx as nx"  
    * For a given graph G, can call G.nodes() and G.edges() to get lists of the relevant data  
    * Running type(G) can return Graph, DiGraph, MultiGraph, and MultiDiGraph  
* The "nxviz" package has a simple API for visualization of networks in a rational manner  
	* Typically, this is called using "import nxviz as nv"  
    * Matrix, Arc, Circos, Hive - CircosPlot will be the most used in this course  
    * c = nv.CircosPlot(G)  
    * c.draw()  
    * plt.show()  
  
Bipartite graphs - graphs that are partitioned in to two sets, and with nodes that are only connected to nodes in other partitions:  
  
* Example might be customer nodes and product nodes, where the only connections will be customer/product  
* Typically, bipartite data will be encoded in the nodes using the "bipartite" keyword  
	* G.add_nodes_from(myListCustomers, bipartite="customers")  
    * G.add_nodes_from(myListProducts, bipartite="products")  
    * G.nodes(data=True)  # will show the nodes, including their attribute "bipartite"  
* "Degree centrality" is defined as # Neighbors / # Possible Neighbors  
	* For a bipartite graph, the "Possible Neighbors" are only the nodes in the OTHER partition  
    * Typically, list comprehensions are used to gather just the nodes that have one "bipartite": or the other  
    * Can then use this list of nodes from one partition with "nx.bipartite.degree_centrality(G, cust_nodes)", where cust_nodes is the list of nodes in ONE of the partitions  
  
Bipartite graphs and recommendation systems - extending from unipartite (users-only) to bipartite (repo-users):  
  
* This is a means of recommending repositories for users to work on ; based on set overlap  
* Often helpful to use node sets in code for these  
	* The command G.neighbors("myNode") returns a list of all the neighbors of "myNode"  
    * With two lists of nodes, could run set(nodeNeighbor1).intersection(nodeNeighbor3)  
    * Alternately, set(nodeNeighbor3).difference(nodeNeighbor1) will return items in nodeNeighbor3 but not in nodeNeighbor1  
  
Example code includes:  
```{r engine='python'}

# Import necessary modules
import networkx as nx
from nxviz import CircosPlot
import matplotlib.pyplot as plt


# Create a dummy bipartite graph
bpG = nx.Graph()

# Create 200 nodes of projects and 1000 nodes of users
bpProj = list(range(200))
bpUser = list(range(200, 1200))
bpG.add_nodes_from(bpProj, bipartite="projects")
bpG.add_nodes_from(bpUser, bipartite="users")


# Create roughly 10,000 edges (out of 200,000 possible)
# Make some projects much more prolific than others
# Project likelihood = 0.5 for [0-3], 0.25 for [4-9], and Proj / 3000 for all others
import random

for a in bpProj:
    for b in bpUser:
        # Set up the core likelihood based on project (a)
        if a <= 3: baseLike = 0.5
        elif a <= 9: baseLike = 0.25
        else: baseLike = (210-a) / 3000
        
        # Scale the likelihood by user
        finalLike = baseLike * (b + 300) / 1000
        if finalLike > random.random():
            bpG.add_edge(a, b)


# Add the degree centrality score of each node to their metadata dictionary
G = bpG.copy()
dcs = nx.degree_centrality(G)
for n in G.nodes():
    G.node[n]['centrality'] = dcs[n]

# Create the CircosPlot object: c
c = CircosPlot(G, node_color="bipartite", node_grouping="bipartite", node_order="centrality")

# Draw c to the screen (too time-consuming - large graphic)
# c.draw()

# Display the plot
# plt.show()


# Define get_nodes_from_partition()
def get_nodes_from_partition(G, partition):
    # Initialize an empty list for nodes to be returned
    nodes = []
    # Iterate over each node in the graph G
    for n in G.nodes():
        # Check that the node belongs to the particular partition
        if G.node[n]['bipartite'] == partition:
            # If so, append it to the list of nodes
            nodes.append(n)
    return nodes

# Print the number of nodes in the 'projects' partition
print(len(get_nodes_from_partition(G, "projects")))

# Print the number of nodes in the 'users' partition
print(len(get_nodes_from_partition(G, "users")))


# Import matplotlib
import matplotlib.pyplot as plt

# Get the 'users' nodes: user_nodes
user_nodes = get_nodes_from_partition(G, "users")

# Compute the degree centralities: dcs
dcs = nx.degree_centrality(G)

# Get the degree centralities for user_nodes: user_dcs
user_dcs = [dcs[n] for n in user_nodes]

# Plot the degree distribution of users_dcs
# plt.yscale('log')
plt.hist(user_dcs, bins=20)
# plt.show()


# Get the 'projects' nodes: project_nodes
project_nodes = [n for n, d in G.nodes(data=True) if d["bipartite"] == "projects"]

# Compute the degree centralities: dcs
dcs = nx.degree_centrality(G)

# Get the degree centralities for project_nodes: project_dcs
project_dcs = [dcs[n] for n in project_nodes]

# Plot the degree distribution of project_dcs
# plt.yscale('log')
plt.hist(project_dcs, bins=20)
# plt.show()


def shared_partition_nodes(G, node1, node2):
    # Check that the nodes belong to the same partition
    assert G.node[node1]['bipartite'] == G.node[node2]['bipartite']
    
    # Get neighbors of node 1: nbrs1
    nbrs1 = G.neighbors(node1)
    # Get neighbors of node 2: nbrs2
    nbrs2 = G.neighbors(node2)
    
    # Compute the overlap using set intersections
    overlap = set(nbrs1).intersection(nbrs2)
    return overlap

# Print the number of shared repositories between users 'u7909' and 'u2148'
print(len(shared_partition_nodes(G, 1050, 1100)))


def user_similarity(G, user1, user2, proj_nodes):
    # Check that the nodes belong to the 'users' partition
    assert G.node[user1]['bipartite'] == 'users'
    assert G.node[user2]['bipartite'] == 'users'
    
    # Get the set of nodes shared between the two users
    shared_nodes = shared_partition_nodes(G, user1, user2)
    
    # Return the fraction of nodes in the projects partition
    return len(shared_nodes) / len(proj_nodes)

# Compute the similarity score between users 'u4560' and 'u1880'
project_nodes = get_nodes_from_partition(G, "projects")
similarity_score = user_similarity(G, 1050, 1100, project_nodes)

print(similarity_score)


from collections import defaultdict

def most_similar_users(G, user, user_nodes, proj_nodes):
    # Data checks
    assert G.node[user]['bipartite'] == 'users'
    
    # Get other nodes from user partition
    user_nodes = set(user_nodes)
    user_nodes.remove(user)
    
    # Create the dictionary: similarities
    similarities = defaultdict(list)
    for n in user_nodes:
        similarity = user_similarity(G, user, n, proj_nodes)
        similarities[similarity].append(n)
    
    # Compute maximum similarity score: max_similarity
    max_similarity = max(similarities.keys())
    
    # Return list of users that share maximal similarity
    return similarities[max_similarity]

user_nodes = get_nodes_from_partition(G, 'users')
project_nodes = get_nodes_from_partition(G, 'projects')

print(most_similar_users(G, 1050, user_nodes, project_nodes))


def recommend_repositories(G, from_user, to_user):
    # Get the set of repositories that from_user has contributed to
    from_repos = set(G.neighbors(from_user))
    # Get the set of repositories that to_user has contributed to
    to_repos = set(G.neighbors(to_user))
    
    # Identify repositories that the from_user is connected to that the to_user is not connected to
    return from_repos.difference(to_repos)

# Print the repositories to be recommended
print(recommend_repositories(G, 1050, 1100))

```
  
  
Chapter 2 - Graph projections  
  
Concept of projection - investigating relationships between nodes in one partition CONDITIONAL on connections to nodes in the other partition:  
  
* An example would be that if customer1 and customer2 both bought product3, then customer1 and customer2 could be considered related by means of product3  
* Graphs on Disk - flat edge lists ; CSV files (nodelist + metadata , edgelist + metadata)  
	* Text file is space-delimited containing Person Club {metadata}  
    * A text file like the above can be read in directly using nx.read_edgelist("myTextFile.txt")  
* Can create a projection provided that one of the node types has already been created as a list  
	* G_cust = nx.bipartite.projected_graph(G, cust_nodes)  
    * G will have nodes as per cust_nodes and edges as per all common relationships found to the other partition  
* Can generate degree centrality in any of three manners  
	* nx.bipartite.degree_centrality(G, cust_nodes)  # denominator is only the OTHER partition  
    * nx.degree_centrality(G)  # denominator is everyone other than myself  
    * nx.degree_centrality(G_cust)  # denominator is everyone in MY partition  
  
Bipartite graphs as matrices - modifications to the MatrixPlot methodology for bipartite graphs:  
  
* Rows - nodes in one partition  
* Columns - nodes in other partition  
* Cells - 1 if edge exists, 0 if not  
* Can be generated using mat = nx.bipartite.biadjacency_matrix(G, row_order=cust_nodes, column_order = prod_nodes)  
	* The row_order and column_order are optional, passed if there is reason to want the row/column sorted in a particular manner  
    * The matrix returned is of type Sparse Matrix (memory-efficient matrices)  
* The projection can be calculated as mat %*% t(mat), where mat is per above  
	* The diagonals show the number of connections within the own partition for that node  
    * The off-diagonals show the projection based on connections to the other partition  
    * Can also run t(mat) %*% mat for the results based on the other of the two partitions  
* Matrix multiplication in Python is run using the "@" operator  
	* mat.T is the transpose of mat in Python  
  
Representing network data with pandas - human-readable graphs with CSV:  
  
* CSV files have many advantages - human-readable, easy for pandas to work with  
	* Primary disadvantage is disk space, as there is repetition that might be avoided in the binary coding for a network/graph  
* Node list - each row is one node, with each column being some of the metadata associated to that node  
* Edge list - each row is one edge, with each column being some of the metadata associated to that edge  
* For pandas, take the data in G.nodes(data=True) and create a dictionary for each node, with the dictionaries being in a list  
	* Can use the command dictA.update(dictB) and it will add the elements of dictB to dictA (seems like "append" for dictionaries)  
    * Can then run pd.DataFrame(nodeList) and a data frame will be created  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"



import pandas as pd



# Import networkx
import networkx as nx

# Read in the data: g (create from the CSV instead)
# G = nx.read_edgelist('american-revolution.edgelist')

# downloaded file from DataCamp
revMap = pd.read_csv(myPath + "revolution_network_flatfile.txt", index_col=0)
revPeople = list(revMap.index)
revClubs = list(revMap.columns)

G = nx.Graph()
G.add_nodes_from(revPeople + revClubs)

for m in range(revMap.shape[0]):
    for n in range(revMap.shape[1]):
        if revMap.iloc[m, n] == 1: G.add_edge(revPeople[m], revClubs[n])

# Assign nodes to 'clubs' or 'people' partitions
for n, d in G.nodes(data=True):
    if '.' in n:
        G.node[n]["bipartite"] = 'people'
    else:
        G.node[n]["bipartite"] = 'clubs'

# Print the edges of the graph (too many - skip)
# print(G.edges())


# Prepare the nodelists needed for computing projections: people, clubs
people = [n for n in G.nodes() if G.node[n]["bipartite"] == 'people']
clubs = [n for n, d in G.nodes(data=True) if d['bipartite'] == 'clubs']

# Compute the people and clubs projections: peopleG, clubsG
peopleG = nx.bipartite.projected_graph(G, people)
clubsG = nx.bipartite.projected_graph(G, clubs)


import matplotlib.pyplot as plt 

# Plot the degree centrality distribution of both node partitions from the original graph
plt.figure()
original_dc = nx.bipartite.degree_centrality(G, people)
plt.hist(list(original_dc.values()), alpha=0.5)
plt.yscale('log')
plt.title('Bipartite degree centrality')
# plt.show()


# Plot the degree centrality distribution of the peopleG graph
plt.figure()  
people_dc = nx.degree_centrality(peopleG)
plt.hist(list(people_dc.values()))
plt.yscale('log')
plt.title('Degree centrality of people partition')
# plt.show()


# Plot the degree centrality distribution of the clubsG graph
plt.figure() 
clubs_dc = nx.degree_centrality(clubsG)
plt.hist(list(clubs_dc.values()))
plt.yscale('log')
plt.title('Degree centrality of clubsG partition')
# plt.show()


# Copied function from above
# Define get_nodes_from_partition()
def get_nodes_from_partition(G, partition):
    # Initialize an empty list for nodes to be returned
    nodes = []
    # Iterate over each node in the graph G
    for n in G.nodes():
        # Check that the node belongs to the particular partition
        if G.node[n]['bipartite'] == partition:
            # If so, append it to the list of nodes
            nodes.append(n)
    return nodes

# Get the list of people and list of clubs from the graph: people_nodes, clubs_nodes
people_nodes = get_nodes_from_partition(G, "people")
clubs_nodes = get_nodes_from_partition(G, "clubs")


# Requires scipy::sparse
# Compute the biadjacency matrix: bi_matrix
# bi_matrix = nx.bipartite.biadjacency_matrix(G, row_order=people_nodes, column_order=clubs_nodes)

# Compute the user-user projection: user_matrix
# user_matrix = bi_matrix @ bi_matrix.T

# print(user_matrix)


import numpy as np

# Find out the names of people who were members of the most number of clubs
# diag = user_matrix.diagonal() 
# indices = np.where(diag == diag.max())[0]  
# print('Number of clubs: {0}'.format(diag.max()))
# print('People with the most number of memberships:')
# for i in indices:
#     print('- {0}'.format(people_nodes[i]))

# Set the diagonal to zero and convert it to a coordinate matrix format
# user_matrix.setdiag(0)
# users_coo = user_matrix.tocoo()

# Find pairs of users who shared membership in the most number of clubs
# indices = np.where(users_coo.data == users_coo.data.max())[0]
# print('People with most number of shared memberships:')
# for idx in indices:
#     print('- {0}, {1}'.format(people_nodes[users_coo.row[idx]], people_nodes[users_coo.col[idx]]))  


# Initialize a list to store each edge as a record: nodelist
nodelist = []
for n, d in peopleG.nodes(data=True):
    # nodeinfo stores one "record" of data as a dict
    nodeinfo = {'person': n} 
    
    # Update the nodeinfo dictionary 
    nodeinfo.update(d)
    
    # Append the nodeinfo to the node list
    nodelist.append(nodeinfo)
    

# Create a pandas DataFrame of the nodelist: node_df
node_df = pd.DataFrame(nodelist)
print(node_df.head())


# Initialize a list to store each edge as a record: edgelist
edgelist = []
for n1, n2, d in peopleG.edges(data=True):
    # Initialize a dictionary that shows edge information: edgeinfo
    edgeinfo = {'node1':n1, 'node2':n2}
    
    # Update the edgeinfo data with the edge metadata
    edgeinfo.update(d)
    
    # Append the edgeinfo to the edgelist
    edgelist.append(edgeinfo)

# Create a pandas DataFrame of the edgelist: edge_df
edge_df = pd.DataFrame(edgelist)
print(edge_df.head())

```
  
  
***
  
Chapter 3 - Comparing Graphs and Time-Dynamics  
  
Introduction to graph differences - time series analysis (graph statistic over time):  
  
* Evolving graphs - example is a communication network, which dynamically changes over time  
	* Could be constant nodes with evolving edges - easier to analyze  
    * Could be evolving nodes with evolving edges  
* Frequently, the simplifying assumption is made of constant nodes with evolving edges - so, "differences" means "change in edge sets"  
	* set(a).difference(set(b)) # will identify any items in a that are not in b  
    * Can also run nx.difference(G1, G2), which assumes constant nodes but evolving edges (will do things in G1 but not in G2)  
  
Evolving graph statistics - essentially, change in summary statistics (edges, degree centrality, degree distribution, activity spikes, etc.) over time:  
  
* For simple metrics, can use the edgelist data  
* For graph theoretic metrics, use the graph object  
* The ECDF (cumulative distribution function - normed and cumulative) is a compact way to represent many time periods in a single plot  
  
Zooming in and zooming out - overall graph summary vs. local graph summary:  
  
* Zooming on nodes involves 1) isolating a given set of nodes, and 2) plotting a node statistic over time  
* Example would be to analyze how purchasing patterns have changed over time  
	* Suppose that we want to run a deep-dive on noi="customer1" over a set of graphs Gs[.]  
    * degs = []  
    * for g in Gs : degs.append(len(g.neighbors(noi)))  
* Default dictionaries - defaultdict()  
	* from collections import defaultdict  
    * d = defaultdict(list)  
    * d["heathrow"].append(0.31) ; d["heathrow"].append(0.84)  
    * d  # defaultdict(<class 'list'>, {"heathrow" : [0.31, 0.84]})  
    * The main difference of a defaultdict() vs a dict() is that defaultdict() allows for appending to a key that does not yet exist (will create as the first item) rather than crashing out  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"


# Dummy up some data with senders and recipients, each being paired to each other at different times
sendList = ["S" + str(x) for x in range(200)]
receiveList = ["R" + str(x) for x in range(200)]

# Allow for 20,000 messages total, pulled at random and with random months
import numpy as np
import pandas as pd

dataSend = np.random.choice(sendList, 20000)
dataReceive = np.random.choice(receiveList, 20000)
dataMonth = np.random.choice(range(4, 11), 20000, p=[0.025, 0.05, 0.075, 0.125, 0.175, 0.225, 0.325])

data = pd.DataFrame( {"sender":dataSend, "recipient":dataReceive, "month":dataMonth} ).drop_duplicates()
print(data.info())
print(data.head())



import networkx as nx

months = range(4, 11)

# Initialize an empty list: Gs
Gs = []

for month in months:
    # Instantiate a new undirected graph: G
    G = nx.Graph()
    
    # Add in all nodes that have ever shown up to the graph
    G.add_nodes_from(data["sender"])
    G.add_nodes_from(data["recipient"])
    
    # Filter the DataFrame so that there's only the given month
    df_filtered = data[data['month'] == month]
    
    # Add edges from filtered DataFrame
    G.add_edges_from(zip(df_filtered["sender"], df_filtered["recipient"]))
    
    # Append G to the list of graphs
    Gs.append(G)

print(len(Gs))


import networkx as nx  
# Instantiate a list of graphs that show edges added: added
added = []
# Instantiate a list of graphs that show edges removed: removed
removed = []
# Here's the fractional change over time
fractional_changes = []
window = 1  
i = 0      

for i in range(len(Gs) - window):
    g1 = Gs[i]
    g2 = Gs[i + window]
    
    # Compute graph difference here
    added.append(nx.difference(g2, g1))  
    removed.append(nx.difference(g1, g2))
    
    # Compute change in graph size over time
    fractional_changes.append((len(g2.edges()) - len(g1.edges())) / len(g1.edges()))
    
    i += 1

# Print the fractional change
print(fractional_changes)


# Import matplotlib
import matplotlib.pyplot as plt

fig = plt.figure()
ax1 = fig.add_subplot(111)

# Plot the number of edges added over time
edges_added = [len(g.edges()) for g in added]
plot1 = ax1.plot(edges_added, label='added', color='orange')

# Plot the number of edges removed over time
edges_removed = [len(g.edges()) for g in removed]
plot2 = ax1.plot(edges_removed, label='removed', color='purple')

# Set yscale to logarithmic scale
ax1.set_yscale('log')  
ax1.legend()

# 2nd axes shares x-axis with 1st axes object
ax2 = ax1.twinx()

# Plot the fractional changes over time
plot3 = ax2.plot(fractional_changes, label='fractional change', color='green')

# Here, we create a single legend for both plots
lines1, labels1 = ax1.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax2.legend(lines1 + lines2, labels1 + labels2, loc=0)
plt.axhline(0, color='green', linestyle='--')
# plt.show()


# Import matplotlib
import matplotlib.pyplot as plt

fig = plt.figure()

# Create a list of the number of edges per month
edge_sizes = [len(g.edges()) for g in Gs]

# Plot edge sizes over time
plt.plot(edge_sizes)
plt.xlabel('Time elapsed from first month (in months).') 
plt.ylabel('Number of edges')                           
# plt.show() 


# Create a list of degree centrality scores month-by-month
cents = []
for G in Gs:
    cent = nx.degree_centrality(G)
    cents.append(cent)

# Create a function for ECDF (copy from statistics)
def ECDF(myData):
    """Compute ECDF for a one-dimensional array of measurements."""
    
    # Number of data points: n
    n = len(myData)
    
    # x-data for the ECDF: x
    x = np.sort(myData)
    
    # y-data for the ECDF: y
    y = np.arange(1, n+1) / n
    
    return x, y


# Plot ECDFs over time
fig = plt.figure()
for i in range(len(cents)):
    x, y = ECDF(list(cents[i].values()))
    plt.plot(x, y, label='Month {0}'.format(i+1)) 

plt.legend()   
# plt.show()


# Get the top 5 unique degree centrality scores: top_dcs
top_dcs = sorted(set(nx.degree_centrality(G).values()), reverse=True)[0:5]

# Create list of nodes that have the top 5 highest overall degree centralities
top_connected = []
for n, dc in nx.degree_centrality(G).items():
    if dc in top_dcs:
        top_connected.append(n)

# Print the number of nodes that share the top 5 degree centrality scores
print(len(top_connected))


# Import necessary modules
import matplotlib.pyplot as plt
from collections import defaultdict

# Create a defaultdict in which the keys are nodes and the values are a list of connectivity scores over time
connectivity = defaultdict(list)
for n in top_connected:
    for g in Gs:
        connectivity[n].append(len(g.neighbors(n)))

# Plot the connectivity for each node
fig = plt.figure() 
for n, conn in connectivity.items(): 
    plt.plot(conn, label=n) 

plt.legend()  
# plt.show()


```
  
  
***
  
Chapter 4 - Case Study (Tying Together)  
  
Introduction to the dataset - 6 months worth of student postings to college forums:  
  
* The nodes are bipartite (students and forums), with edges existing when a student posts to a forum  
	* Constructing a graph from a pandas DataFrame  
    * Constructing unipartite projections of a bipartite graph  
    * Visualization using CircosPlot  
    * Time series filtering and analysis  
* Graphs from DataFrames - G = nx.Graph() ; G.add_nodes_from(df["products"], bipartite="products")  
	* G.add_edges_from(zip(df["customers"], df["products"]))  
* Bipartite projections to unipartite - cust_nodes = [n for n in G.nodes() if G.node[n]["bipartite"] == "customers"]  
	* nx.bipartite.projected_graph(g, nodes = cust_nodes)  
  
Time-based filtering - including the datetime module:  
  
* Filtering edges - for example, [(u, v) for u, v, d in G.edges(data=True) if d["sale count"] >= 10]  
* Using datetime - from datetime import datetime, timedelta  
	* date1 = datetime(2011, 11, 6)  # will form 2011-11-6  
* Plotting - c = CircosPlot(G, node_grouping="bipartite", node_color="bipartite") ; c.draw() ; plt.show()  
  
Time series analysis - global vs. local (point in time) analysis:  
  
* The timedelta object from datetime allows for calculating time between two datetime  
	* td=timedelta(4) ; datetime.datetime(2011, 11, 10, 0, 0) + td = datetime.datetime(2011, 11, 14, 0, 0)  
* Degree centrality is nx.degree_centrality(G)  
	* For the bipartite (denominator only the OTHER partition), use nx.bipartite.degree_centrality(G, nodeType1List)  
  
Example code includes:  
```{r engine='python'}

myPath = "./PythonInputFiles/"



import pickle
import pandas as pd
import networkx as nx


# Downloaded key file "uci-forum.p" from DataCamp
with open(myPath + "uci-forum.p", "rb") as pFile: tmpGraph = pickle.load(pFile)

# Convert to a DataFrame with student-forum-date
# Grab the student-forum-date matches from the edges
edgeData = tmpGraph.edges(data=True)
studentData = [x[0] if x[0][0]=="s" else x[1] for x in edgeData]
forumData = [x[1] if x[0][0]=="s" else x[0] for x in edgeData]
dateData = pd.to_datetime([x[2]["date"] for x in edgeData])

# Check that the student data matches the nodes with bipartite="student"
studentNodes = set([x for x in tmpGraph.nodes() if tmpGraph.node[x]["bipartite"]=="student"])
forumNodes = set([x for x in tmpGraph.nodes() if tmpGraph.node[x]["bipartite"]=="forum"])

studentNodes.difference(set(studentData))
forumNodes.difference(set(forumData))
set(studentData).difference(studentNodes)
set(forumData).difference(forumNodes)

# Create the DataFrame
data = pd.DataFrame( {"student":studentData, "forum":forumData, "date":dateData} )
data.info()
data.head(10)




# Instantiate a new Graph: G
G = nx.Graph()

# Add nodes from each of the partitions
G.add_nodes_from(data["student"], bipartite="student")
G.add_nodes_from(data["forum"], bipartite="forum")

# Add in each edge along with the date the edge was created
for r, d in data.iterrows():
    G.add_edge(d["student"], d["forum"], date=d["date"])


# Import necessary modules
import matplotlib.pyplot as plt
import networkx as nx

# Get the student partition's nodes: student_nodes
student_nodes = [n for n, d in G.nodes(data=True) if d['bipartite'] == 'student']

# Create the students nodes projection as a graph: G_students
G_students = nx.bipartite.projected_graph(G, nodes=student_nodes)

# Calculate the degree centrality using nx.degree_centrality: dcs
dcs = nx.degree_centrality(G_students)

# Plot the histogram of degree centrality values
plt.hist(list(dcs.values()))
plt.yscale('log')  
# plt.show() 


# Import necessary modules
import matplotlib.pyplot as plt 
import networkx as nx

# Get the forums partition's nodes: forum_nodes
forum_nodes = [n for n, d in G.nodes(data=True) if d["bipartite"] == "forum"]

# Create the forum nodes projection as a graph: G_forum
G_forum = nx.bipartite.projected_graph(G, forum_nodes)

# Calculate the degree centrality using nx.degree_centrality: dcs
dcs = nx.degree_centrality(G_forum)

# Plot the histogram of degree centrality values
plt.hist(list(dcs.values()))
plt.yscale('log') 
# plt.show()  


import networkx as nx
from datetime import datetime

# Instantiate a new graph: G_sub
G_sub = nx.Graph()

# Add nodes from the original graph
G_sub.add_nodes_from(G.nodes(data=True))

# Add edges using a list comprehension with one conditional on the edge dates, that the date of the edge is earlier than 2004-05-16.
G_sub.add_edges_from([(u, v, d) for u, v, d in G.edges(data=True) if d['date'] < datetime(2004, 5, 16)])


# Import necessary modules
from nxviz import CircosPlot
import networkx as nx
import matplotlib.pyplot as plt

# Compute degree centrality scores of each node
dcs = nx.bipartite.degree_centrality(G, nodes=forum_nodes)
for n, d in G_sub.nodes(data=True):
    G_sub.node[n]['dc'] = dcs[n]

# Create the CircosPlot object: c
c = CircosPlot(G_sub, node_color = "bipartite", node_grouping="bipartite", node_order="dc")

# Draw c to screen
c.draw()

# Display the plot
# plt.show() 

from datetime import datetime
dayone = datetime(2004, 5, 14, 0, 0)
lastday = datetime(2004, 10, 26, 0, 0)

# Import necessary modules
from datetime import timedelta  
import matplotlib.pyplot as plt

# Define current day and timedelta of 2 days
curr_day = dayone
td = timedelta(days=2)

# Initialize an empty list of posts by day
n_posts = []
while curr_day < lastday:
    if curr_day.day == 1:
        print(curr_day) 
    # Filter edges such that they are within the sliding time window: edges
    edges = [(u, v, d) for u, v, d in G.edges(data=True) if d['date'] >= curr_day and d['date'] < curr_day + td]
    
    # Append number of edges to the n_posts list
    n_posts.append(len(edges))
    
    # Increment the curr_day by the time delta
    curr_day += td

# Create the plot
plt.plot(n_posts)  
plt.xlabel('Days elapsed')
plt.ylabel('Number of posts')
# plt.show()  


from datetime import datetime, timedelta
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

# Initialize a new list: mean_dcs
mean_dcs = []
curr_day = dayone
td = timedelta(days=2)

while curr_day < lastday:
    if curr_day.day == 1:
        print(curr_day)  
    # Instantiate a new graph containing a subset of edges: G_sub
    G_sub = nx.Graph()
    # Add nodes from G
    G_sub.add_nodes_from(G.nodes(data=True))
    # Add in edges that fulfill the criteria
    G_sub.add_edges_from([(u, v, d) for u, v, d in G.edges(data=True) if d['date'] >= curr_day and d['date'] < curr_day + td])
    
    # Get the students projection
    G_student_sub = nx.bipartite.projected_graph(G_sub, student_nodes)
    # Compute the degree centrality of the students projection
    dc = nx.degree_centrality(G_student_sub)
    # Append mean degree centrality to the list mean_dcs
    mean_dcs.append(np.mean(list(dc.values())))
    # Increment the time
    curr_day += td

plt.plot(mean_dcs)
plt.xlabel('Time elapsed')
plt.ylabel('Degree centrality.')
# plt.show()


# Import necessary modules
from datetime import timedelta
import networkx as nx
import matplotlib.pyplot as plt

# Instantiate a list to hold the list of most popular forums by day: most_popular_forums
most_popular_forums = []
# Instantiate a list to hold the degree centrality scores of the most popular forums: highest_dcs
highest_dcs = []
curr_day = dayone  
td = timedelta(days=1)  

while curr_day < lastday:  
    if curr_day.day == 1: 
        print(curr_day) 
    # Instantiate new graph: G_sub
    G_sub = nx.Graph()
    
    # Add in nodes from original graph G
    G_sub.add_nodes_from(G.nodes(data=True))
    
    # Add in edges from the original graph G that fulfill the criteria
    G_sub.add_edges_from([(u, v, d) for u, v, d in G.edges(data=True) if d['date'] >= curr_day and d['date'] < curr_day + td])
    
    # CODE CONTINUES ON NEXT EXERCISE
    curr_day += td


# Import necessary modules
from datetime import timedelta
import networkx as nx
import matplotlib.pyplot as plt

most_popular_forums = []
highest_dcs = []
curr_day = dayone 
td = timedelta(days=1)  

while curr_day < lastday:  
    if curr_day.day == 1:  
        print(curr_day)  
    G_sub = nx.Graph()
    G_sub.add_nodes_from(G.nodes(data=True))   
    G_sub.add_edges_from([(u, v, d) for u, v, d in G.edges(data=True) if d['date'] >= curr_day and d['date'] < curr_day + td])
    
    # Get the degree centrality 
    dc = nx.bipartite.degree_centrality(G_sub, forum_nodes)
    # Filter the dictionary such that there's only forum degree centralities
    forum_dcs = {n:dc for n, dc in dc.items() if n in forum_nodes}
    # Identify the most popular forum(s) 
    most_popular_forum = [n for n, dc in forum_dcs.items() if dc == max(forum_dcs.values()) and dc != 0] 
    most_popular_forums.append(most_popular_forum)
    # Store the highest dc values in highest_dcs
    highest_dcs.append(max(forum_dcs.values()))
    
    curr_day += td  

plt.figure(1) 
plt.plot([len(forums) for forums in most_popular_forums], color='blue', label='Forums')
plt.ylabel('Number of Most Popular Forums')
# plt.show()

plt.figure(2)
plt.plot(highest_dcs, color='orange', label='DC Score')
plt.ylabel('Top Degree Centrality Score')
# plt.show()

```
  
  

	
	
	

  
  
	


