---
title: "Weather Exploratory Data Analysis"
author: "davegoblue"
date: "5/27/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
The file 'WeatherDownloads_202005_v002.Rmd' contains code for dowloading and processing historical weather data as contained in METAR archives hosted by Iowa State University.

Data have been dowloaded and processed for several stations (airports) and years, with .rds files saved in "./RInputFiles/ProcessedMETAR".

This module will perform exploratory data analysis on the processed weather files.
  
#### _Data Availability_  
Each processed data file contains one year of hourly weather data for one station.  Files are saved as './RInputFiles/ProcessedMETAR/metar_kxxx_yyyy.rds' where xxx is the three-digit airport code and yyyy is the four-digit year.

Each file contains the following variables:  
  
* METAR (chr) - the extracted portion of the METAR based on a regex string  
* WindDir (chr) - the previaling wind direction in degrees, stored as a character since 'VRB' means variable  
* WindSpeed (int) - the prevailing wind speed in knots  
* WindGust (dbl) - the wind gust speed in knots (NA if there is no recorded wind gust at that hour)  
* Dummy (chr) - artifact, always a blank space  
* Visibility (dbl) - surface visibility in statute miles  
* TempC (int) - temperature in degrees Celsius  
* DewC (int) - dew point in degrees Celsius  
* Altimeter (int) - altimeter in inches of mercury  
* SLP (int) - the raw sea-level-pressure reading from the METAR  
* FahrC (chr) - the raw temperature string pulled from the METAR (Tttttdddd) where tttt is the Fahrenheit temperature recorded in Celsius and dddd is the Fahrenheit dew point recorded in Celsius  
* dtime (dttm) - the date-time associated with the observation  
* origMETAR (chr) - the full METAR associated with the observation  
* TempF (dbl) - the Fahrenheit temperature associated with converting FahrC to Fahrenheit  
* DewF (dbl) - the Fahrenheit dew point associated with converting FahrC to Fahrenheit  
* modSLP (dbl) - Sea-Level Pressure (SLP), adjusted to reflect that SLP is recorded as 0-1000 but reflects data that are 950-1050  
* nSKC (int) - number of times 'SKC' (human-confirmed cloud-free) is recorded in the observation (should be 0 or 1)  
* nCLR (int) - number of times 'CLR' (austomated-sensor cloud-free) is recorded in the observation (should be 0 or 1, and should never have both nSKC>0 and nCLR>0)  
* cloudn (chr) - the nth cloud layer recorded in the METAR (layers begin with FEW, SCT, BKN, OVC or VV)  
* cTypen (chr) - the cloud type of the nth cloud layer (FEW, BKN, SCT, OVC, or VV)  
* cLeveln (dbl) - the cloud height in feet of the nth cloud layer  
* wType (fct) - highest level of obscuration recorded in the METAR (VV > OVC > BKN > SCT > FEW > CLR/SKC)  
* year (dbl) - year of the observation  
* monthint (dbl) - month of the observation as a number (e.g., 6=June)  
* month (fct) - month of the observation as three-character abbreviation, saved as a factor (e.g., Jun=June)  
* day (int) - day of the month of the observation  
  
#### _Base Functions Available_  
There are several functions available for analysis:  
  
* plotCountsByMetric() - bar plots for counts by variable  
* plotNumCor() - plot two numeric variables against each other  
* plotFactorNumeric() - boxplot a numeric variable against a factor variable  

* corMETAR() - correlations between METAR variables  
* lmMETAR() - linear regression modeling for METAR variables  

* basicWindPlots() - plot wind speed and direction  
* getWindDirGroup() - convert wind direction to a grouping (e.g., N for 320-360-40)  
* consolidatePlotWind() - show frequency plots of wind direction, city, and month  
  
The tidyverse library is loaded and the 2016 Detroit data is read in to show examples of the functions:  
```{r}

library(tidyverse)

kdtw_2016 <- readRDS("./RInputFiles/ProcessedMETAR/metar_kdtw_2016.rds")

```
  
A variable mapping is created to allow for better readable variable names:  
```{r}

varMapper <- c(WindDir="Wind Direction (degrees)", 
               predomDir="General Prevailing Wind Direction",
               WindSpeed="Wind Speed (kts)",
               WindSpeed5="Wind Speed (kts), rounded to nearest 5 knots", 
               Visibility="Visibility (SM)", 
               TempC="Temperature (C)", 
               DewC="Dew Point (C)", 
               Altimeter="Altimeter (inches Hg)",
               Altimeter10="Altimeter (inches Hg), rounded to nearest 0.1 inHg", 
               modSLP="Sea-Level Pressure (hPa)", 
               TempF="Temperature (F)",
               DewF="Dew Point (F)", 
               TempF5="Temperature (F), rounded to nearest 5 degrees",
               DewF5="Dew Point (F), rounded to nearest 5 degrees", 
               cType1="First Cloud Layer Type", 
               cLevel1="First Cloud Layer Height (ft)",
               month="Month", 
               year="Year",
               wType="Greatest Sky Obscuration", 
               day="Day of Month"
               )

```
  
The function plotCountsByMetric() produces bar plots for counts by variable:  
```{r}

# Helper function for generating plots by key variables
plotcountsByMetric <- function(df, 
                               mets, 
                               title="", 
                               rotateOn=20, 
                               dropNA=TRUE, 
                               diagnose=FALSE,
                               mapper=varMapper,
                               facetOn=NULL, 
                               showCentral=FALSE
                               ) {
    
    # Function arguments
    # df: dataframe or tibble containing raw data
    # mets: character vector of variables for plotting counts
    # title: character vector for plot title
    # rotateOn: integer, x-axis labels will be rotated by 90 degrees if # categories >= rotateOn
    # dropNA: boolean for whether to drop all NA prior to plotting (recommended for avoiding warnings)
    # diagnose: boolean for whether to note in the log the number of NA observations dropped
    # mapper: named list containing mapping from variable name to well-formatted name for titles and axes
    # facetOn: a facetting variable for the supplied df (NULL for no faceting)
    # showCentral: boolean for whether to show the central tendency over-plotted on the main data
    
    # Function usage
    # 1.  By default, the function plots overall counts by metric for a given input
    # 2.  If facetOn is passed as a non-NULL, then the data in #1 will be facetted by facetOn
    # 3.  If showCentral=TRUE, then the overall mean will be plotted as a point on the main plot (only makes sense if facetOn has been selected)
    
    
    # Plot of counts by key metric
    for (x in mets) {
        # If a facetting variable is provided, need to include this in the group_by
        useVars <- x
        if (!is.null(facetOn)) { useVars <- c(facetOn, useVars) }
        dat <- df %>%
            group_by_at(vars(all_of(useVars))) %>%
            summarize(n=n())
        
        if (dropNA) {
            nOrig <- nrow(dat)
            sumOrig <- sum(dat$n)
            dat <- dat %>%
                filter_all(all_vars(!is.na(.)))
            if (diagnose & (nOrig > nrow(dat))) { 
                cat("\nDropping", 
                    nOrig-nrow(dat), 
                    "rows with", 
                    sumOrig-sum(dat$n), 
                    "observations due to NA\n"
                    )
            }
        }
        
        # Create the main plot
        p <- dat %>%
            ggplot(aes_string(x=x, y="n")) + 
            geom_col() + 
            labs(title=title,
                 subtitle=paste0("Counts By: ", mapper[x]), 
                 x=paste0(x, " - ", mapper[x]),
                 y="Count"
                 )
        # If the rotateOn criteria is exceeded, rotate the x-axis by 90 degrees
        if (nrow(dat) >= rotateOn) {
            p <- p + theme(axis.text.x=element_text(angle=90))
        }
        # If facetting has been requested, facet by the desired variable
        if (!is.null(facetOn)) {
            p <- p + facet_wrap(as.formula(paste("~", facetOn)))
        }
        # If showCentral=TRUE, add a dot plot for the overall average
        if (showCentral) {
            # Get the median number of observations by facet, or the total if facetOn=NULL
            if (is.null(facetOn)) {
                useN <- sum(dat$n)
            } else {
                useN <- dat %>%
                    group_by_at(vars(all_of(facetOn))) %>%
                    summarize(n=sum(n)) %>%
                    pull(n) %>%
                    median()
            }
            # Get the overall percentages by x
            centralData <- helperCountsByMetric(tbl=dat, ctVar=x, sumOn="n") %>%
                mutate(centralValue=nPct*useN)
            # Apply the median
            p <- p + geom_point(data=centralData, aes(y=centralValue), color="red", size=2)
        }
        # Print the plot
        print(p)
    }
}

# Example for Detroit 2016 - using WindDir, cType1, month, wType
plotcountsByMetric(kdtw_2016, 
                   mets=c("WindDir", "cType1", "month", "wType"), 
                   title="Detroit, MI (2016)"
                   )

```
  
The function plotNumCor() plots two numeric variables against one another:  
```{r}

# Create a function for plotting two variables against each other
plotNumCor <- function(met, 
                       var1, 
                       var2, 
                       title=NULL, 
                       subT="", 
                       dropNA=TRUE, 
                       diagnose=FALSE,
                       mapper=varMapper, 
                       facetOn=NULL, 
                       showCentral=FALSE
                       ) {
    
    # Function arguments
    # met: dataframe or tibble containing raw data
    # var1: character vector of variable to be used for the x-axis
    # var2: character vector of variable to be used for the y-axis
    # title: character vector for plot title
    # subT: character vector for plot subtitle
    # dropNA: boolean for whether to drop all NA prior to plotting (recommended for avoiding warnings)
    # diagnose: boolean for whether to note in the log the number of NA observations dropped
    # mapper: named list containing mapping from variable name to well-formatted name for titles and axes
    # facetOn: a facetting variable for the supplied met (NULL for no faceting)
    # showCentral: boolean for whether to show the central tendency over-plotted on the main data
    
    # Function usage
    # 1.  By default, the function plots overall counts by the provided x/y metrics, with each point sized based on the number of observations, and with an lm smooth overlaid
    # 2.  If facetOn is passed as a non-NULL, then the data in #1 will be facetted by facetOn
    # 3.  If showCentral=TRUE, then the lm smooth that best first to the overall data will be plotted (only makes sense if facetOn has been selected)
    
    # Create the title if not passed
    if (is.null(title)) { 
        title <- paste0("Hourly Observations of ", mapper[var1], " and ", mapper[var2]) 
    }

    # If a facetting variable is provided, need to include this in the group_by
    useVars <- c(var1, var2)
    if (!is.null(facetOn)) { useVars <- c(facetOn, useVars) }
        
    # Pull the counts by useVars
    dat <- met %>%
        group_by_at(vars(all_of(useVars))) %>%
        summarize(n=n()) 
    
    # If NA requested to be excluded, remove anything with NA
    if (dropNA) {
        nOrig <- nrow(dat)
        sumOrig <- sum(dat$n)
        dat <- dat %>%
            filter_all(all_vars(!is.na(.)))
        if (diagnose) { 
            cat("\nDropping", 
                nOrig-nrow(dat), 
                "rows with", 
                sumOrig-sum(dat$n), 
                "observations due to NA\n"
                )
        }
    }
    
    p <- dat %>%
        ggplot(aes_string(x=var1, y=var2)) + 
        geom_point(alpha=0.5, aes_string(size="n")) + 
        geom_smooth(method="lm", aes_string(weight="n")) + 
        labs(x=paste0(mapper[var1], " - ", var1), 
             y=paste0(mapper[var2], " - ", var2), 
             title=title, 
             subtitle=subT
             )
    
    # If facetting has been requested, facet by the desired variable
    if (!is.null(facetOn)) {
        p <- p + facet_wrap(as.formula(paste("~", facetOn)))
    }
    # If showCentral=TRUE, add a dashed line for the overall data
    if (showCentral) {
        p <- p + helperNumCor(dat, xVar=var1, yVar=var2, sumOn="n")
    }
    
    print(p)
}

# Example for Detroit 2016 - using TempC and TempF
plotNumCor(kdtw_2016, var1="TempC", var2="TempF", subT="Detroit, MI (2016)", diagnose=TRUE)

# Example for Detroit 2016 - using TempC and DewC
plotNumCor(kdtw_2016, var1="TempC", var2="DewC", subT="Detroit, MI (2016)", diagnose=TRUE)

# Example for Detroit 2016 - using Altimeter and modSLP
plotNumCor(kdtw_2016, var1="Altimeter", var2="modSLP", subT="Detroit, MI (2016)", diagnose=TRUE)

```
  
The function plotFactorNumeric() creates box plots for a numeric variable against a factor variable:  
```{r}

# Updated function for plotting numeric by factor
plotFactorNumeric <- function(met, 
                              fctVar, 
                              numVar, 
                              title=NULL, 
                              subT="", 
                              diagnose=TRUE,
                              showXLabel=TRUE,
                              mapper=varMapper,
                              facetOn=NULL, 
                              showCentral=FALSE
                              ) {
    
    # Function arguments
    # met: dataframe or tibble containing raw data
    # fctVar: character vector of variable to be used for the x-axis (factor in the boxplot)
    # numVar: character vector of variable to be used for the y-axis (numeric in the boxplot)
    # title: character vector for plot title
    # subT: character vector for plot subtitle
    # diagnose: boolean for whether to note in the log the number of NA observations dropped
    # showXLabel: boolean for whether to include the x-label (e.g., set to FALSE if using 'month')
    # mapper: named list containing mapping from variable name to well-formatted name for titles and axes
    # facetOn: a facetting variable for the supplied met (NULL for no faceting)
    # showCentral: boolean for whether to show the central tendency over-plotted on the main data
    
    # Function usage
    # 1.  By default, the function creates the boxplot of numVar by fctVar
    # 2.  If facetOn is passed as a non-NULL, then the data in #1 will be facetted by facetOn
    # 3.  If showCentral=TRUE, then the overall median of numVar by fctVar will be plotted as a red dot

    
    # Create the title if not passed
    if (is.null(title)) { 
        title <- paste0("Hourly Observations of ", mapper[numVar], " by ", mapper[fctVar])
    }
    
    # Remove the NA variables
    nOrig <- nrow(met)
    dat <- met %>%
        filter(!is.na(get(fctVar)), !is.na(get(numVar)))
    if (diagnose) { cat("\nRemoving", nOrig-nrow(dat), "records due to NA\n") }
    
    # Create the base plot
    p <- dat %>%
        ggplot(aes_string(x=fctVar, y=numVar)) + 
        geom_boxplot(fill="lightblue") + 
        labs(title=title, 
             subtitle=subT, 
             x=ifelse(showXLabel, paste0(mapper[fctVar], " - ", fctVar), ""), 
             y=paste0(mapper[numVar], " - ", numVar)
             )
    
    # If facetting has been requested, facet by the desired variable
    if (!is.null(facetOn)) {
        p <- p + facet_wrap(as.formula(paste("~", facetOn)))
    }
    
    # If showCentral=TRUE, add a dot plot for the overall average
    if (showCentral) {
        centData <- helperFactorNumeric(dat, .f=median, byVar=fctVar, numVar=numVar)
        p <- p + geom_point(data=centData, aes(y=helpFN), size=2, color="red")
    }

    # Render the final plot
    print(p)
    
}

# Example for Detroit 2016 - using TempF and month
plotFactorNumeric(kdtw_2016, 
                  fctVar="month", 
                  numVar="TempF", 
                  subT="Detroit, MI (2016)", 
                  showXLabel=FALSE,
                  diagnose=TRUE
                  )

# Example for Detroit 2016 - using WindSpeed and wType
plotFactorNumeric(kdtw_2016, 
                  fctVar="wType", 
                  numVar="WindSpeed", 
                  subT="Detroit, MI (2016)", 
                  showXLabel=TRUE,
                  diagnose=TRUE
                  )

# Example for Detroit 2016 - using Visibility and wType
plotFactorNumeric(kdtw_2016, 
                  fctVar="wType", 
                  numVar="Visibility", 
                  subT="Detroit, MI (2016)", 
                  showXLabel=TRUE,
                  diagnose=TRUE
                  )

```
  
An issue previous observed where visibility 1/16SM was interpreted as 16 statutory miles has been corrected in the 'WeatherDownloads_202005_v002' file.
  
The function corMETAR() calculates correlations among numeric variables in the METAR data:  
```{r}

# Function to calculate, display, and plot variable correlations
corMETAR <- function(met, numVars, subT="") {

    # Keep only complete cases and report on data kept
    dfUse <- met %>%
        select_at(vars(all_of(numVars))) %>%
        filter(complete.cases(.))
    
    nU <- nrow(dfUse)
    nM <- nrow(met)
    myPct <- round(100*nU/nM, 1)
    cat("\n *** Correlations use ", nU, " complete cases (", myPct, "% of ", nM, " total) ***\n", sep="")
    
    # Create the correlation matrix
    mtxCorr <- dfUse %>%
        cor()

    # Print the correlations
    mtxCorr %>%
        round(2) %>%
        print()

    # Display a heat map
    corrplot::corrplot(mtxCorr, 
                       method="color", 
                       title=paste0("Hourly Weather Correlations\n", subT), 
                       mar=c(0, 0, 2, 0)
                       )
}

# Example for Detroit, MI 2016
coreNum <- c("TempC", "TempF", "DewC", "DewF", 
             "Altimeter", "modSLP", "WindSpeed", "Visibility"
             )
corMETAR(kdtw_2016, numVars=coreNum, subT="Detroit, MI (2016) METAR")

```
  
The function lmMETAR() runs simple linear regression models on the METAR data:  
```{r}

# Function for linear regressions on METAR data
lmMETAR <- function(met, 
                    y, 
                    x, 
                    yName, 
                    subT=""
                    ) {
    
    # Convert to formula
    myChar <- paste0(y, " ~ ", x)
    cat("\n *** Regression call is:", myChar, "***\n")
    
    # Run regression
    regr <- lm(formula(myChar), data=met)
    
    # Summarize regression
    print(summary(regr))
    
    # Predict the new values
    pred <- predict(regr, newdata=met)
    
    # Plot the predictions
    p <- met %>%
        select_at(vars(all_of(y))) %>%
        mutate(pred=pred) %>%
        filter_all(all_vars(!is.na(.))) %>%
        group_by_at(vars(all_of(c(y, "pred")))) %>%
        summarize(n=n()) %>%
        ggplot(aes_string(x=y, y="pred")) + 
        geom_point(aes(size=n), alpha=0.25) + 
        geom_smooth(aes(weight=n), method="lm") + 
        labs(title=paste0("Predicted vs. Actual ", yName, " - ", x, " as Predictor"), 
             subtitle=subT, 
             x=paste0("Actual ", yName), 
             y=paste0("Predicted ", yName)
             )
    print(p)
    
}

# Examples for Detroit, MI 2016
lmMETAR(kdtw_2016, "modSLP", "Altimeter", yName="Sea Level Pressure", subT="Detroit, MI (2016)")
lmMETAR(kdtw_2016, "modSLP", "Altimeter + TempF", yName="Sea Level Pressure", subT="Detroit, MI (2016)")
lmMETAR(kdtw_2016, "TempC", "DewC", yName="Temperature (C)", subT="Detroit, MI (2016)")

```
  
The basicWindPlots() function creates plots for wind speed and direction:  
```{r}

# Generate basic wind plots
basicWindPlots <- function(met, 
                           dirVar="WindDir", 
                           spdVar="WindSpeed",
                           desc="", 
                           gran="", 
                           mapper=varMapper
                           ) {

    # Plot for the wind direction
    wDir <- met %>%
        ggplot(aes_string(x=dirVar)) + 
        geom_bar() + 
        labs(title=paste0(desc, " Wind Direction"), subtitle=gran, 
             y="# Hourly Observations", x=mapper[dirVar]
             ) + 
        theme(axis.text.x=element_text(angle=90))
    print(wDir)

    # Plot for the minimum, average, and maximum wind speed by wind direction
    # Wind direction 000 is reserved for 0 KT wind, while VRB is reserved for 3-6 KT variable winds
    wSpeedByDir <- met %>%
        filter(!is.na(get(dirVar))) %>%
        group_by_at(vars(all_of(dirVar))) %>%
        summarize(minWind=min(get(spdVar)), meanWind=mean(get(spdVar)), maxWind=max(get(spdVar))) %>%
        ggplot(aes_string(x=dirVar)) +
        geom_point(aes(y=meanWind), color="red", size=2) +
        geom_errorbar(aes(ymin=minWind, ymax=maxWind)) +
        labs(title=paste0(desc, " Wind Speed (Max, Mean, Min) By Wind Direction"), 
             subtitle=gran,
             y=mapper[spdVar], 
             x=mapper[dirVar]
             ) + 
        theme(axis.text.x=element_text(angle=90))
    print(wSpeedByDir)

    # Plot for the wind speed
    pctZero <- sum(pull(met, spdVar)==0, na.rm=TRUE) / nrow(met)
    wSpeed <- met %>%
        filter_at(vars(all_of(spdVar)), all_vars(!is.na(.))) %>%
        ggplot(aes_string(x=spdVar)) +
        geom_bar(aes(y=..count../sum(..count..))) +
        labs(title=paste0(round(100*pctZero), "% of wind speeds in ", desc, " measure 0 Knots"),
             subtitle=gran,
             y="% Hourly Observations", 
             x=mapper[spdVar]
             )
    print(wSpeed)
    
    # Polar plot for wind speed and wind direction
    wData <- met %>%
        filter_at(vars(all_of(dirVar)), all_vars(!is.na(.) & !(. %in% c("000", "VRB")))) %>%
        filter_at(vars(all_of(spdVar)), all_vars(!is.na(.))) %>%
        mutate_at(vars(all_of(dirVar)), as.numeric) %>%
        group_by_at(vars(all_of(c(dirVar, spdVar)))) %>%
        summarize(n=n())
        
    wPolarDirSpeed <- wData %>%
        ggplot(aes_string(x=spdVar, y=dirVar)) +
        geom_point(alpha=0.1, aes(size=n)) +
        coord_polar(theta="y") +
        labs(title=paste0(desc, " Direction vs. Wind Speed"), 
             subtitle=gran, 
             x=mapper[spdVar], 
             y=mapper[dirVar]
             ) +
        scale_y_continuous(limits=c(0, 360), breaks=c(0, 90, 180, 270, 360)) +
        scale_x_continuous(limits=c(0, 40), breaks=c(0, 5, 10, 15, 20, 25, 30, 35, 40)) +
        geom_point(aes(x=0, y=0), color="red", size=2)
    print(wPolarDirSpeed)

}

# Example for Detroit, MI 2016
basicWindPlots(kdtw_2016, desc="Detroit, MI (2016)", gran="KDTW METAR")

```
  
The getWindDirGroup() function maps wind direction to a category such as NNE.  Because the METAR data are recorded in units of 10 degrees, either 4 groupings (90 degrees each) or 12 groupings (30 degrees each) are preferred, so that each category has the same underlying number of buckets:  
```{r}

# Extract the wind direction data from a processed METAR file
getWindDirGroup <- function(met, src) {
    
    # Use the fullMETAR data and extract WindDir, WindSpeed, month
    windPlotData <- met %>%
        select(WindDir, WindSpeed, month) %>%
        mutate(windDirGroup=factor(case_when(WindSpeed==0 ~ "No Wind", 
                                             WindDir=="VRB" ~ "Variable", 
                                             WindDir %in% c("350", "360", "010") ~ "N", 
                                             WindDir %in% c("020", "030", "040") ~ "NNE", 
                                             WindDir %in% c("050", "060", "070") ~ "ENE", 
                                             WindDir %in% c("080", "090", "100") ~ "E", 
                                             WindDir %in% c("110", "120", "130") ~ "ESE",
                                             WindDir %in% c("140", "150", "160") ~ "SSE", 
                                             WindDir %in% c("170", "180", "190") ~ "S", 
                                             WindDir %in% c("200", "210", "220") ~ "SSW",
                                             WindDir %in% c("230", "240", "250") ~ "WSW", 
                                             WindDir %in% c("260", "270", "280") ~ "W", 
                                             WindDir %in% c("290", "300", "310") ~ "WNW", 
                                             WindDir %in% c("320", "330", "340") ~ "NNW", 
                                             TRUE ~ "Error"
                                             ), 
                                   levels=c("No Wind", "Variable", "Error", 
                                            "N", "NNE", "ENE", 
                                            "E", "ESE", "SSE", 
                                            "S", "SSW", "WSW", 
                                            "W", "WNW", "NNW"
                                            )
                                   )
               )
    
    # Rempve the errors and calculate percentages by month for the remainder
    processedWindData <- windPlotData %>%
        filter(windDirGroup != "Error") %>%
        group_by(month, windDirGroup) %>%
        summarize(n=n()) %>%
        ungroup() %>%
        group_by(month) %>%
        mutate(pct=n/sum(n)) %>%
        ungroup() %>%
        mutate(src=src)
    
    processedWindData

}

```
  
The function conslidatePlotWind() then calls getWindDirGroup() for any number of files:  
```{r}

# Consolidate and plot wind data
consolidatePlotWind <- function(files, names) {

    consFun <- function(x, y) { getWindDirGroup(met=x, src=y) }
    boundByRows <- map2_dfr(.x=files, .y=names, .f=consFun)

    # Show frequency by month for each city, faceted by wind direction
    p1 <- boundByRows %>%
        ggplot(aes(x=month, y=pct, color=src)) + 
        geom_line(aes(group=src)) + 
        facet_wrap(~windDirGroup) + 
        labs(title="Wind Frequency by Month", 
             x="Month", 
             y="Frequency of Wind Observations"
             ) +
        theme(axis.text.x=element_text(angle=90))
    print(p1)
    
    # Show frequency by wind direction for each city, faceted by month
    p2 <- boundByRows %>%
        ggplot(aes(x=windDirGroup, y=pct, color=src)) + 
        geom_line(aes(group=src)) + 
        facet_wrap(~month) + 
        labs(title="Wind Frequency by Wind Direction", 
             x="Wind Direction", 
             y="Frequency of Wind Observations"
             ) +
        theme(axis.text.x=element_text(angle=90))
    print(p2)
    
    boundByRows
    
}

# Load the Las Vegas data and New Orleans data for comparison
kmsy_2016 <- readRDS("./RInputFiles/ProcessedMETAR/metar_kmsy_2016.rds")
klas_2016 <- readRDS("./RInputFiles/ProcessedMETAR/metar_klas_2016.rds")

# Run wind by month comparisons for Detroit, Las Vegas, New Orleans
consolidatePlotWind(files=list(kdtw_2016, klas_2016, kmsy_2016), 
                    names=c("Detroit, MI (2016)", "Las Vegas, NV (2016)", "New Orleans, LA (2016)")
                    )

```
  
#### _Combining Functions_  
The functions can be combined so that a full process can be run for a given file:  
```{r}

# File name to city name mapper
cityNameMapper <- c(kdtw_2016="Detroit, MI (2016)", 
                    kewr_2016="Newark, NJ (2016)",
                    kgrb_2016="Green Bay, WI (2016)",
                    kgrr_2016="Grand Rapids, MI (2016)",
                    kiah_2016="Houston, TX (2016)",
                    kind_2016="Indianapolis, IN (2016)",
                    klas_2015="Las Vegas, NV (2015)",
                    klas_2016="Las Vegas, NV (2016)", 
                    klas_2017="Las Vegas, NV (2017)", 
                    klnk_2016="Lincoln, NE (2016)",
                    kmke_2016="Milwaukee, WI (2016)",
                    kmsn_2016="Madison, WI (2016)",
                    kmsp_2016="Minneapolis, MN (2016)",
                    kmsy_2015="New Orleans, LA (2015)",
                    kmsy_2016="New Orleans, LA (2016)", 
                    kmsy_2017="New Orleans, LA (2017)", 
                    kord_2015="Chicago, IL (2015)",
                    kord_2016="Chicago, IL (2016)", 
                    kord_2017="Chicago, IL (2017)", 
                    ksan_2015="San Diego, CA (2015)",
                    ksan_2016="San Diego, CA (2016)",
                    ksan_2017="San Diego, CA (2017)",
                    ktvc_2016="Traverse City, MI (2016)"
                    )

# This is a helper function to create a locale description
getLocaleDescription <- function(x, mapper=cityNameMapper) {
    
    # Initialize the description as NULL
    desc <- NULL
    
    for (potMatch in names(mapper)) {
        if (str_detect(string=x, pattern=potMatch)) {
            desc <- mapper[potMatch]
            break
        }
    }
    
    # If the mapping failed, use UNMAPPED_x as the description
    if (is.null(desc)) {
        desc <- paste0("UNMAPPED_", x)
        cat("\nUnable to find a description, will use ", desc, "\n\n", sep="")
    } else {
        cat("\nWill use ", desc, " as the description for ", x, "\n\n", sep="")
    }
    
    # Return the descriptive name
    desc
    
}

# The following function runs the functions that work on a single data source
combinedEDA <- function(filename=NULL, 
                        tbl=NULL,
                        desc=NULL,
                        mets=c("WindDir", "WindSpeed", "TempC", "DewC", "Altimeter", 
                               "modSLP", "cType1", "cLevel1", "month", "day"
                               ),
                        corPairs=list(c("TempC", "TempF"), 
                                      c("TempC", "DewC"), 
                                      c("Altimeter", "modSLP"), 
                                      c("Altimeter", "WindSpeed")
                                      ),
                        fctPairs=list(c("month", "TempF"), 
                                      c("month", "DewF"), 
                                      c("month", "WindSpeed"), 
                                      c("month", "Altimeter"), 
                                      c("wType", "Visibility"), 
                                      c("wType", "WindSpeed"), 
                                      c("WindDir", "WindSpeed"), 
                                      c("WindDir", "TempF")
                                      ),
                        heatVars=c("TempC", "TempF", 
                                   "DewC", "DewF", 
                                   "Altimeter", "modSLP", 
                                   "WindSpeed", "Visibility", 
                                   "monthint", "day"
                                   ),
                        lmVars=list(c("modSLP", "Altimeter"), 
                                    c("modSLP", "Altimeter + TempF"), 
                                    c("TempF", "DewF"), 
                                    c("WindSpeed", "Altimeter + TempF + DewF + month")
                                    ),
                        mapVariables=varMapper,
                        mapFileNames=cityNameMapper,
                        path="./RInputFiles/ProcessedMETAR/"
                        ) {
    
    # Require that either filename OR tbl be passed
    if (is.null(filename) & is.null(tbl)) {
        cat("\nMust provide either a filename or an already-loaded tibble\n")
        stop("\nfilename=NULL and tbl=NULL may not both be passed to combinedEDA()\n")
    }
    
    # Require that either 1) filename and mapFileNames, OR 2) desc be passed
    if ((is.null(filename) | is.null(mapFileNames)) & is.null(desc)) {
        cat("\nMust provide either a filename with mapFileNames or a file description\n")
        stop("\nWhen desc=NULL must have non-null entries for both filename= and mapFileNames=\n")
    }
    
    # Find the description if it is NULL (default)
    if (is.null(desc)) {
        desc <- getLocaleDescription(filename, mapper=mapFileNames)
    }
    
    # Warn if both filename and tbl are passed, since tbl will be used
    if (!is.null(filename) & !is.null(tbl)) {
        cat("\nA tibble has been passed and will be used as the dataset for this function\n")
        warning("\nArgument filename=", filename, " is NOT loaded since a tibble was passed\n")
    }
    
    # Read in the file unless tbl has already been passed to the routine
    if (is.null(tbl)) {
        tbl <- readRDS(paste0(path, filename))
    }
    
    # Plot counts by metric
    plotcountsByMetric(tbl, mets=mets, title=desc, diagnose=TRUE)
    
    # Plot relationships between two variables
    for (ys in corPairs) {
        plotNumCor(tbl, var1=ys[1], var2=ys[2], subT=desc, diagnose=TRUE)
    }
    
    # plot numeric vs. factor
    for (ys in fctPairs) {
        plotFactorNumeric(tbl, fctVar=ys[1], numVar=ys[2], subT=desc, showXLabel=FALSE, diagnose=TRUE)
    }
    
    # Heatmap for variable correlations
    corMETAR(tbl, numVars=heatVars, subT=paste0(desc, " METAR"))

    # Run linear rergression
    for (ys in lmVars) {
        lmMETAR(tbl, y=ys[1], x=ys[2], yName=varMapper[ys[1]], subT=desc)
    }
    
    # Run the basic wind plots
    basicWindPlots(tbl, desc=desc, gran="")
    
    # Return the tibble
    tbl
    
}

```
  
The process can then be run for each of Detroit (2016), Las Vegas (2016), and New Orleans (2016):  
```{r cache=TRUE}

# Retrieve the Detroit, MI (2016) data
kdtw_2016 <- combinedEDA("metar_kdtw_2016.rds")

```

```{r cache=TRUE}

# Retrieve the Las Vegas, NV (2016) data
klas_2016 <- combinedEDA("metar_klas_2016.rds")

```

```{r cache=TRUE}

# Retrieve the New Orleans, LA (2016) data
kmsy_2016 <- combinedEDA("metar_kmsy_2016.rds")

```
  
#### _Directing Output to a Separate File_  
There is a lot of good information in the EDA, but it can be overwhelming to have everything in one place.  Perhaps a wrapper function can be built allowing for outputs to be piped to a given file:  
```{r}

wrapCombinedEDA <- function(readFile, 
                            readPath="./RInputFiles/ProcessedMETAR/", 
                            mapFileNames=cityNameMapper,
                            desc=NULL,
                            writeLogFile=NULL,
                            writeLogPDF=NULL,
                            writeLogPath=NULL,
                            appendWriteFile=FALSE,
                            ...
                            ) {
    
    # Read in the requested file
    tbl <- readRDS(paste0(readPath, readFile))

    # Find the description if it has not been passed
    if (is.null(desc)) {
        desc <- getLocaleDescription(readFile, mapper=mapFileNames)
    }
    
    # Helper function that only runs the combinedEDA() routine
    coreFunc <- function() { combinedEDA(tbl=tbl, desc=desc, mapFileNames=mapFileNames, ...) }
    
    # If writeLogPDF is not NULL, direct the graphs to a suitable PDF
    if (!is.null(writeLogPDF)) {
        
        # Prepend the provided log path if it has not been made available
        if (!is.null(writeLogPath)) {
            writeLogPDF <- paste0(writeLogPath, writeLogPDF)
        }
        
        # Provide the location of the EDA pdf file
        cat("\nEDA PDF file is available at:", writeLogPDF, "\n")

        # Redirect the writing to writeLogPDF
        pdf(writeLogPDF)
    }
    
    # Run EDA on the tbl using capture.output to redirect to a log file if specified
    if (!is.null(writeLogFile)) {
        
        # Prepend the provided log path if it has not been made available
        if (!is.null(writeLogPath)) {
            writeLogFile <- paste0(writeLogPath, writeLogFile)
        }
        
        # Provide the location of the EDA log file
        cat("\nEDA log file is available at:", writeLogFile, "\n")
        
        # Run EDA such that the output goes to the log file
        capture.output(coreFunc(), 
                       file=writeLogFile, 
                       append=appendWriteFile
                       )
        
    } else {
        # Run EDA such that output stays in stdout
        coreFunc()
    }
    
    # If writeLogPDF is not NULL, redirect to stdout
    if (!is.null(writeLogPDF)) {
        dev.off()
    }
    
    # Return the tbl
    tbl
    
}

```
  
```{r cache=TRUE}

filePath <- "./RInputFiles/ProcessedMETAR/"

# Example for the basic function for Chicago, IL (2016) written to stdout
kord_2016 <- wrapCombinedEDA("metar_kord_2016.rds", readPath=filePath)

```
  
```{r cache=TRUE}

# Example for the basic function for San Diego, CA (2016) written to 'metar_ksan_2016_EDA.log'
ksan_2016 <- wrapCombinedEDA("metar_ksan_2016.rds", 
                             readPath=filePath, 
                             writeLogFile='metar_ksan_2016_EDA.log',
                             writeLogPDF='metar_ksan_2016_EDA.pdf', 
                             writeLogPath=filePath
                             )

```
  
Finally, a function can be called to create the inputs to wrapCombinedEDA() for lower typing:  
```{r}

logAndPDFCombinedEDA <- function(tblName, filePath="./RInputFiles/ProcessedMETAR/") {
    
    # Create the RDS file name
    rdsName <- paste0("metar_", tblName, ".rds")
    cat("\nRDS Name:", rdsName)
    
    # Create the log file name
    logName <- paste0("metar_", tblName, "_EDA.log")
    cat("\nLog Name:", logName)
    
    # Create the PDF file name
    pdfName <- paste0("metar_", tblName, "_EDA.pdf")
    cat("\nPDF Name:", pdfName)
    
    # Call wrapCombinedEDA()
    tbl <- wrapCombinedEDA(rdsName, 
                           readPath=filePath, 
                           writeLogFile=logName, 
                           writeLogPDF=pdfName,
                           writeLogPath=filePath
                           )
    
    # Return the tbl
    tbl
    
}

```
  
This function can then be run for all of the relevant files (cached to avoid multiple runs):  
```{r cache=TRUE}

# Run for 2016 only for kdtw, kewr, kgrb, kgrr, kiah, kind, klnk, kmke, kmsn, kmsp, ktvc
kdtw_2016 <- logAndPDFCombinedEDA("kdtw_2016")
kewr_2016 <- logAndPDFCombinedEDA("kewr_2016")
kgrb_2016 <- logAndPDFCombinedEDA("kgrb_2016")
kgrr_2016 <- logAndPDFCombinedEDA("kgrr_2016")
kiah_2016 <- logAndPDFCombinedEDA("kiah_2016")
kind_2016 <- logAndPDFCombinedEDA("kind_2016")
klnk_2016 <- logAndPDFCombinedEDA("klnk_2016")
kmke_2016 <- logAndPDFCombinedEDA("kmke_2016")
kmsn_2016 <- logAndPDFCombinedEDA("kmsn_2016")
kmsp_2016 <- logAndPDFCombinedEDA("kmsp_2016")
ktvc_2016 <- logAndPDFCombinedEDA("ktvc_2016")

```
  
```{r cache=TRUE}

# Run for 2015-2016-2017 for klas, kmsy, kord, ksan
klas_2015 <- logAndPDFCombinedEDA("klas_2015")
klas_2016 <- logAndPDFCombinedEDA("klas_2016")
klas_2017 <- logAndPDFCombinedEDA("klas_2017")
kmsy_2015 <- logAndPDFCombinedEDA("kmsy_2015")
kmsy_2016 <- logAndPDFCombinedEDA("kmsy_2016")
kmsy_2017 <- logAndPDFCombinedEDA("kmsy_2017")
kord_2015 <- logAndPDFCombinedEDA("kord_2015")
kord_2016 <- logAndPDFCombinedEDA("kord_2016")
kord_2017 <- logAndPDFCombinedEDA("kord_2017")
ksan_2015 <- logAndPDFCombinedEDA("ksan_2015")
ksan_2016 <- logAndPDFCombinedEDA("ksan_2016")
ksan_2017 <- logAndPDFCombinedEDA("ksan_2017")

```
  
Reload Traverse City, MI (2016) due to a previous error (short-term fix to avoid re-running a full cache):  
```{r cache=TRUE}
ktvc_2016 <- logAndPDFCombinedEDA("ktvc_2016")
```

The files are now available for further analysis, with individual PDF files for plots associated with each locale.
  
#### _Comparing Multiple Locales_  
With EDA about each locale saved to .pdf and .log files, it is interesting to investigate comparisons among the various locales.  For example, how do the temperature patterns by month for a given locale compare to the overall global median temperature patterns by month?
  
The existing functions contain most of the code needed to perform this.  The main steps to add are:  
  
1.  Combine processed data files  
2.  Adapt the base functions to create the overall mean or median, when requested by parameter  
3.  Adapt the base functions to add the overall mean or median to the plot, when requested by parameter  
4.  Facet the plot by locale, when requested by parameter  
  
The first step is to combine one or more processed files, with a column added for locale:  
```{r}

# Combine files from a character list
combineProcessedFiles <- function(charList, mapper=cityNameMapper) {
    
    # Combine the objects represented by charList, and name the list items using charList
    listFiles <- lapply(charList, FUN=function(x) { get(x) })
    names(listFiles) <- charList
    
    # Bind rows, and add the descriptive locale name as sourceName
    tblFiles <- bind_rows(listFiles, .id="source") %>%
        mutate(sourceName=mapper[source])
    
    tblFiles
    
}

```
  
The 2016 data will be used to run the combined process:  
```{r}

# Grab all the data that ends in _2016
locales2016 <- ls() %>%
    grep(pattern="_2016", value=TRUE)
cat("\nLocales used will be:\n\n", paste0(locales2016, collapse="\n"), "\n\n", sep="")

# Combine the 2016 data
all2016Data <- combineProcessedFiles(locales2016)

# Show counts by sourceName
all2016Data %>%
    count(source, sourceName)

```
  
The following global summaries will be useful:  
  
* plotCountsByMetric() - overall percentage by metric, applied to total counts for locale  
* plotNumCor() - overall geom_smooth()  
* plotFactorNumeric() - overall mean/median of numeric by factor  
* corMETAR() and lmMETAR() - not applicable, though could be run on full dataset  
* basicWindPlots() - tbd, perhaps adapt along with consolidatePlotWind  
* consolidatePlotWind() - tbd, perhaps adapt along with basicWindPlots  
  
Helper functions can be created for:  
  
* helperCountsByMetric() - get the overall percentage by metric for variable x  
* helperNumCor() - get an overall geom_smooth for variable y vs. variable x  
* helperFactorNumeric() - get the overall mean or median for numeric variable y by factor variable x  
  
The function helperFactorNumeric is created to apply function f to numeric variable y by factor variable x:  
```{r}

# Helper function to get overall percentage by metric for variable x
helperCountsByMetric <- function(tbl, ctVar, sumOn="dummyVar") {

    tbl %>%
        mutate(dummyVar=1) %>%
        select_at(vars(all_of(c(ctVar, sumOn)))) %>%
        filter_all(all_vars(!is.na(.))) %>%
        group_by_at(ctVar) %>%
        summarize(n=sum(get(sumOn))) %>%
        mutate(nPct=n/sum(n))
        
}

# Example run to get counts by greatest sky obscuration
helperCountsByMetric(all2016Data, ctVar="wType")


# Helper function to get a geom_smooth for variable y vs variable x
helperNumCor <- function(tbl, 
                         xVar, 
                         yVar, 
                         sumOn="dummyVar",
                         se=TRUE, 
                         color="red", 
                         method="lm", 
                         lty=2
                         ) {
    
    # Generate the overall totals for sumOn by xVar and yVar
    plotData <- tbl %>%
        mutate(dummyVar=1) %>%
        select_at(vars(all_of(c(xVar, yVar, sumOn)))) %>%
        filter_all(all_vars(!is.na(.))) %>%
        group_by_at(vars(all_of(c(xVar, yVar)))) %>%
        summarize(nTotal=sum(get(sumOn)))
    
    geom_smooth(data=plotData, 
                aes_string(x=xVar, y=yVar, weight="nTotal"), 
                se=se, 
                color=color, 
                method=method, 
                lty=lty
                )
    
}

# Example run to get TempC vs DewC
helperNumCor(all2016Data, xVar="TempC", yVar="DewC")

# Example for using the helper function on a plot
plotNumCor(kdtw_2016, var1="TempC", var2="DewC") + 
    helperNumCor(all2016Data, xVar="TempC", yVar="DewC")


# Helper function to calculate .f(numVar) by byVar
helperFactorNumeric <- function(tbl, .f, byVar, numVar, ...) {
    
    tbl %>%
        select_at(vars(all_of(c(byVar, numVar)))) %>%
        filter_all(all_vars(!is.na(.))) %>%
        group_by_at(byVar) %>%
        summarize(helpFN=.f(get(numVar), ...))
    
}

# Example for getting median TempF by month
helperFactorNumeric(all2016Data, .f=median, byVar="month", numVar="TempF")

```
  
The function plotCountsByMetric() has been updated above to allow for facetting and plotting of the overall central tendency.  Two examples are shown - the base from previous, and a facetted example:  
```{r}

# Previous Example for Detroit 2016 - using WindDir, cType1, month, wType
plotcountsByMetric(kdtw_2016, 
                   mets=c("WindDir", "cType1", "month", "wType"), 
                   title="Detroit, MI (2016)", 
                   dropNA=TRUE, 
                   diagnose=TRUE
                   )


# Facetted example for kdtw_2016, kord_2016, klas_2016, ksan_2016
useData <- all2016Data %>%
    filter(source %in% c("kdtw_2016", "klas_2016", "kord_2016", "ksan_2016"))

plotcountsByMetric(useData, 
                   mets=c("WindDir", "cType1", "month", "wType"), 
                   title="Comparison Across Locales (red dots are the median)", 
                   dropNA=TRUE, 
                   diagnose=TRUE, 
                   facetOn="sourceName", 
                   showCentral=TRUE
                   )

```
  
As observed previously, Las Vegas tends towards southerly winds while San Diego tends towards northwesterly winds and calm (direction 000) winds.  Detroit is most likely to be overcast, while Las Vegas is most likely to be clear.
  
The function plotNumCor() has been updated above to allow for facetting and plotting of the overall central tendency.  Two examples are shown - the base from previous, and a facetted example:  
```{r}

# Example for Detroit 2016 - using TempC and DewC
plotNumCor(kdtw_2016, var1="TempC", var2="DewC", subT="Detroit, MI (2016)", diagnose=TRUE)


# Facetted example for kdtw_2016, kord_2016, klas_2016, ksan_2016
useData <- all2016Data %>%
    filter(source %in% c("kdtw_2016", "klas_2016", "kord_2016", "ksan_2016"))

# Facetted plot for very highly correlated variables TempC and TempF
plotNumCor(useData, 
           var1="TempC", 
           var2="TempF", 
           subT="Comparison Across Locales (red dashed lines are the overall)", 
           dropNA=TRUE, 
           diagnose=TRUE, 
           facetOn="sourceName", 
           showCentral=TRUE
           )

# Facetted plot for highly correlated variables TempF and DewF
plotNumCor(useData, 
           var1="TempF", 
           var2="DewF", 
           subT="Comparison Across Locales (red dashed lines are the overall)", 
           dropNA=TRUE, 
           diagnose=TRUE, 
           facetOn="sourceName", 
           showCentral=TRUE
           )

```
  
The differences in the relationships between temperature and dew point stand out:  
  
* Chicago and Detroit have a wide spread of both temperature and dew point, and they tend to rise and fall together  
* San Diego has a narrow spread of both temperature and dew point, and they have a lesser tendency to rise and fall together  
* Las Vegas has very little change in average dew point wven as temperatures range from 30-100 degrees F  
  
In contrast, of course, temperatures measured in C and F all follow the same pattern regardless of city  
  
The function plotFactorNumeric() has been updated above to allow for facetting and plotting of the overall central tendency.  Two examples are shown - the base from previous, and a facetted example:  
```{r}

# Example for Detroit 2016 - using TempF and month
plotFactorNumeric(kdtw_2016, 
                  fctVar="month", 
                  numVar="TempF", 
                  subT="Detroit, MI (2016)", 
                  showXLabel=FALSE,
                  diagnose=TRUE
                  )


# Facetted example for kdtw_2016, kord_2016, klas_2016, ksan_2016
useData <- all2016Data %>%
    filter(source %in% c("kdtw_2016", "klas_2016", "kord_2016", "ksan_2016"))

plotFactorNumeric(useData, 
                  fctVar="month", 
                  numVar="TempF", 
                  subT="Overall median shown as red dot", 
                  showXLabel=FALSE,
                  diagnose=TRUE,
                  facetOn="sourceName", 
                  showCentral=TRUE
                  )

```
  
Las Vegas consistently runs above the overall median temperature, while Chicago and Detroit run below the overall median temperature, particularly during the cold season.  San Diego has little temperature variation by month and is thus below the median in the warm season and above the median in the cold season.
  
It is now possible to re-run the EDA plotting routines, focused on the 2016 data:  
```{r cache=TRUE}

# Create rounded TempF and DewF in all2016Data
all2016Data <- all2016Data %>%
    mutate(TempF5=5*round(round(TempF)/5), 
           DewF5=5*round(round(DewF)/5), 
           WindSpeed5=5*round(WindSpeed/5),
           Altimeter10=round(Altimeter, 1)
           )

# Counts by Metric for all 2016 data
plotcountsByMetric(all2016Data, 
                   mets=c("month", "year",
                          "WindDir", "WindSpeed5", 
                          "Visibility", "Altimeter10",
                          "TempF5", "DewF5", 
                          "wType"
                          ), 
                   title="Comparisons Across Locales (red dots are the median)", 
                   facetOn="sourceName",
                   showCentral=TRUE
                   )

```
  
The cross-locale comparisons bring out a few salient features:  
  
DATA VOLUMES:  
* All locales have roughly the same amount of data by year and month, focused on 2016 and with 1-2 days on either side  
  
WIND DIRECTION and WIND SPEED:  
* Las Vegas has an excess of no/variable wind and of southerly winds, both appropriate for a desert  
* Houston has an excess of no wind and southerly winds, both appropriate for the Gulf Coast  
* San Diego has an excess of no wind and of northwesterly wind, both appropriate for the Pacific coast  
* Chicago, Grand Rapids, Indianapolis, Minneapolis, and Newark all have lower occurences of no wind, appropriate for relatively cold mid-latitude cities  
* Lincoln looks "about normal", with the exception that it has slightly more southerly winds; Lincoln is the only Great Plains locale in the analysis, and it appears to be a blend of Gulf Coast and Wintry  
* Detroit, Green Bay, Milwaukee, and New Orleans all look "about average"; this is not surprising in the first three cases given the predominance of cold, mid-latitude locales, but is surprising for New Orleans  
* Madison and Traverse City are surprising in that both show a predominance of no/variable winds; this is uncommon for cold-weather cities in the mid-latitude and merits further examination  
  
VISIBILITY:  
* The overwhelming majority of visibilities are 10SM (the highest that is recorded; more or less means unlimited in the METAR)  
* There is a data issue with a Visibility > 10 that should be addressed  
* Las Vegas is slightly more likely than most to have unlimited Visibility and Detroit is slightly less likely than most to have unlimited visibility  
  
ALTIMETER:  
* Las Vegas skews low as appropriate for a high-altitude desert locale  
* New Orleans and Houston show less variance, perhaps driven by being roughly at sea level and in close proximity to the Gulf of Mexico  
* San Diego shows very low variance, perhaps driven by being roughly at sea level and in close proximity to the Pacific Ocean  
  
TEMPERATURE:  
* Houston, Las Vegas, and New Orleans skew warm as expected  
* San Diego has ver low variance as expected  
* At a gross level, the other cities look similar to the median, likely driven by the predominance of cold, mid-latitude locales in the data file  
  
DEW POINT:  
* Houston and New Orleans skew very high as expected  
* Las Vegas skews very low as expected  
* San Diego has very low variance as expected  
  
SKY OBSCURATION:  
* Lincoln and Green Bay are the most likely to be CLR (clear, no clouds on the automated sensor).  This may be driven by a difference in maximum sensor heights, and is unexpected in Green Bay which should be frequently cloudy due to its latitude and proximity to a large body of water  
* Detroit, Traverse City, Grand Rapids, and Minneapolis are especially likely to be overcast  
* Las Vegas is especially likely to have few clouds or to be clear  
  
Comparisons are run for a few of the numerical correlations:  
```{r cache=TRUE}

# Example for 2016 - using mixes of WindSpeed, Altimeter, TempF, DewF, TempC, DewC
numCorList <- list(c("TempC", "TempF"), 
                   c("DewC", "DewF"), 
                   c("TempF", "DewF"), 
                   c("Altimeter", "WindSpeed"), 
                   c("Altimeter", "TempF")
                   )

# Run the list through plotNumCor()
for (x in numCorList) {
    plotNumCor(all2016Data, 
               var1=x[1], 
               var2=x[2], 
               subT="Red dashed line is the overall slope", 
               diagnose=TRUE, 
               facetOn="sourceName", 
               showCentral=TRUE
               )
}

```
  
The cross-locale comparisons bring out a few salient features:  
  
FAHRENHEIT AND CELSIUS:  
* As expected, TempF/C are perfectly correlated and DewF/C are perfectly correlated.  Since the observations were taken in the US, the TempF/DewF data will be used (TempC/DewC are conversions from the measured TempF/DewF to match the international standard for METAR reporting)  
  
TEMPERATURE AND DEW POINT:  
* While many cities have different clusters of temperature/dew point, all but Las Vegas and San Diego follow a pattern where the temperature and the dew point tend to run together at a similar rate  
* In Las Vegas, the dew point is largely independent of the temperature  
* In San Diego, there is less variance in temperature and dew point, and a lower (but still obvious) tendency for tenmperature and dew point to rise/fall together  
  
ALTIMETER AND WIND SPEED:  
* As expected, when the altimeter rises, on average, the wind speed falls  
* This tendency is less pronounced in Houston and New Orleans; and more pronounced in Las Vegas, Dan Diego, and Indianapolis  
  
ALTIMETER AND TEMPERATURE:  
* Overall, low temperatures and high altimeters tend to be observed together  
* This is especially so in Houston, Las Vegas, and New Orleans  
* This is more modest in Grand Rapids, Green Bay, and Traverse City  
  
Comparisons are then run for numeric variables against factor variables:  
```{r cache=TRUE}

# Modify windDir so that it is just N, NE, E, SE, S, SW, W, NW, 000, Variable
mod2016Data <- all2016Data %>%
    mutate(tempDir=ifelse(is.na(WindDir) | WindDir %in% c("000", "VRB"), -1, as.numeric(WindDir)),
           predomDir=factor(case_when(is.na(WindDir) ~ "Error", 
                                      WindDir=="000" ~ "000", 
                                      WindDir=="VRB" ~ "VRB", 
                                      tempDir >= 337.5 ~ "N", 
                                      tempDir <= 22.5 ~ "N",
                                      tempDir <= 67.5 ~ "NE", 
                                      tempDir <= 112.5 ~ "E", 
                                      tempDir <= 157.5 ~ "SE", 
                                      tempDir <= 202.5 ~ "S", 
                                      tempDir <= 247.5 ~ "SW", 
                                      tempDir <= 292.5 ~ "W", 
                                      tempDir <= 337.5 ~ "NW",
                                      TRUE ~ "Error"
                                      ), 
                            levels=c("Error", "000", "VRB", "NE", "E", "SE", "S", "SW", "W", "NW", "N")
                            )
           )

# Key factor variables include month, wType, predomDir
# Key numeric variables include WindSpeed, Altimeter, TempF, DewF, Visibility
fctNumList <- list(c("month", "WindSpeed"), 
                   c("month", "Altimeter"), 
                   c("month", "TempF"), 
                   c("month", "DewF"), 
                   c("month", "Visibility"),
                   c("wType", "WindSpeed"),
                   c("wType", "Altimeter"),
                   c("wType", "Visibility"),
                   c("predomDir", "WindSpeed"),
                   c("predomDir", "Altimeter"),
                   c("predomDir", "TempF"),
                   c("predomDir", "DewF")
                   )

for (x in fctNumList) {
    plotFactorNumeric(mod2016Data, 
                      fctVar=x[1], 
                      numVar=x[2], 
                      subT="Red dots are the overall average", 
                      showXLabel=FALSE,
                      diagnose=TRUE, 
                      facetOn="sourceName",
                      showCentral=TRUE
                      )
}

```
  
The cross-locale comparisons bring out a few salient points:  
  
WIND SPEED BY MONTH:  
* The plot is too busy; need to rethink, potentially by removing the outliers and plotting only the box  
  
ALTIMETER BY MONTH:  
* Same as above; this plot is too busy  
  
TEMPERATURE BY MONTH:  
* Seasonal patterns are observed in most of the data, with a warm season centered around July and a cold season centered around December  
* Las Vegas stand out for running warmer than the overall average in every month  
* Houston, New Orleans, and San Diego stand out for running warmer than the overall average in the cold season and similar to the overall average in the warm season  
  
DEW POINT BY MONTH:  
* Seasonal patterns are observed in most of the data, with the humid seasons tracking with the warm seasons  
* Houston and New Orleans run consistently above the average dew point by month  
* San Diego runs above the average dew point during the cold season  
* Las Vegas runs below the average dew point during the warm season  
  
VISIBILITY BY MONTH:  
* Visibilities are overwhelmingly likely to be 10 SM  
* The Newark, NJ outlier described earlier (19 SM) should be deleted  
* Detroit is especially likely to have Visibility less than 10 SM  
* Grand Rapids and Traverse City have meaningul occurences of Visibility less than 10 SM during the cold season  
  
WIND SPEED BY SKY OBSCURATION:  
* This chart is too busy as per above  
  
ALTIMETER BY SKY OBSCURATION:  
* Not much at a glance  
  
VISIBILITY BY SKY OBSCURATION:  
* The VV and OVC sky obscurations are most associated with low visibilities; VV in particular is almost always associated with very low visibility  
  
WIND SPEED BY WIND DIRECTION:  
* Wind direction "000" is always associated with wind speed 0, as expected  
* Wind direction "VRB" is always associated with a low but non-zero wind speed, as expected  
* While some cities are windier than others, there is no pronounced tendency for wind speed to be highly associated with a given wind direction in any locale  
  
ALTIMETER BY WIND DIRECTION:  
* No gross trends observed  
* The plot is rather busy, especially given the low variance in median/IQR for altimeter relative to the outlier points  
  
TEMPERATURE/DEW POINT BY WIND DIRECTION:  
* Plot is not great for reading and interpreting  
  
Next steps are to modify a few of the plots for better interpretability (less busy, more variation of the core data metric relative to the full y-axis, etc.), investigate and rectify the data issues observed, and save a version of the file for further analysis.
  
A modified boxplot function is created to plot only the median and the IQR, with the goal of having more of the variance in the median visible on the plot:  
```{r}

plotMedianIQR <- function(met, 
                          fctVar, 
                          numVar, 
                          title=NULL, 
                          subT="", 
                          mid=0.5,
                          rng=c(0.25, 0.75),
                          diagnose=TRUE,
                          showXLabel=TRUE,
                          mapper=varMapper,
                          facetOn=NULL, 
                          showCentral=FALSE, 
                          ylimits=NULL
                          ) {
    
    # Function arguments
    # met: dataframe or tibble containing raw data
    # fctVar: character vector of variable to be used for the x-axis (factor in the boxplot)
    # numVar: character vector of variable to be used for the y-axis (numeric in the boxplot)
    # title: character vector for plot title
    # subT: character vector for plot subtitle
    # mid: float between 0 and 1 for the quantile to be used as the midpoint
    # rng: length-two float vector for (lo, hi) to be used as the dimensions of the box
    # diagnose: boolean for whether to note in the log the number of NA observations dropped
    # showXLabel: boolean for whether to include the x-label (e.g., set to FALSE if using 'month')
    # mapper: named list containing mapping from variable name to well-formatted name for titles and axes
    # facetOn: a facetting variable for the supplied met (NULL for no faceting)
    # showCentral: boolean for whether to show the central tendency over-plotted on the main data
    # ylimits: length-two numeric for the y-axis minimum and maximum (default NULL uses plot defaults)
    
    # Function usage
    # 1.  By default, the function creates a modified boxplot of numVar by fctVar - line at mid, box going from rng[1] to rng[2]
    # 2.  If facetOn is passed as a non-NULL, then the data in #1 will be facetted by facetOn
    # 3.  If showCentral=TRUE, then the overall median of numVar by fctVar will be plotted as a red dot

    
    # Check that the quantile variables are sensible
    if (length(mid) != 1 | length(rng) != 2) {
        stop("Must pass a single value as mid and a length-two vector as rng\n")    
    }
    if (min(c(mid, rng)) < 0 | max(c(mid, rng)) > 1) {
        stop("All values of mid and rng must be between 0 and 1, inclusive\n")
    }
    if ((mid < rng[1]) | (mid > rng[2])) {
        stop("mid must be at least as big as rng[1] and no greater than rng[2]\n")
    }
    quants <- paste0(round(100*c(rng[1], mid, rng[2]), 0), "%", collapse=" ")
    
    # Create the title if not passed
    if (is.null(title)) { 
        title <- paste0("Hourly Observations of ", mapper[numVar], " by ", mapper[fctVar])
    }
    
    # Remove the NA variables
    nOrig <- nrow(met)
    dat <- met %>%
        filter(!is.na(get(fctVar)), !is.na(get(numVar)))
    if (diagnose) { cat("\nRemoving", nOrig-nrow(dat), "records due to NA\n") }
    
    # Create the quantile data by fctVar and (if passed) facetOn
    groupVars <- fctVar 
    if (!is.null(facetOn)) { groupVars <- c(groupVars, facetOn) }
    plotData <- dat %>%
        group_by_at(groupVars) %>%
        summarize(midPoint=quantile(get(numVar), probs=mid), 
                  loPoint=quantile(get(numVar), probs=rng[1]),
                  hiPoint=quantile(get(numVar), probs=rng[2])
                  )
    
    # Create the base plot
    p <- plotData %>%
        ggplot(aes_string(x=fctVar, y="midPoint")) +
        geom_crossbar(aes(ymin=loPoint, ymax=hiPoint), fill="lightblue") +
        labs(title=title,
             subtitle=subT,
             x=ifelse(showXLabel, paste0(mapper[fctVar], " - ", fctVar), ""),
             y=paste0(mapper[numVar], " - ", numVar), 
             caption=paste0("Quantiles plotted: ", quants)
             )
    
    # If facetting has been requested, facet by the desired variable
    if (!is.null(facetOn)) {
        p <- p + facet_wrap(as.formula(paste("~", facetOn)))
    }
    
    # If showCentral=TRUE, add a dot plot for the overall value of 'mid'
    if (showCentral) {
        centData <- helperFactorNumeric(dat, .f=quantile, byVar=fctVar, numVar=numVar, probs=mid)
        p <- p + geom_point(data=centData, aes(y=helpFN), size=2, color="red")
    }
    
    # If ylim has been passed, use it
    if (!is.null(ylimits)) {
        p <- p + ylim(ylimits)
    }

    # Render the final plot
    print(p)
    
}

```
  
The function can then be applied in an attempt to get a better look at a few of the comparisons:  
```{r cache=TRUE}

# Key factor variables include month, wType, predomDir
# Key numeric variables include WindSpeed, Altimeter, TempF, DewF, Visibility
fctNumListIQR <- list(c("month", "WindSpeed"), 
                      c("month", "Altimeter"), 
                      c("wType", "WindSpeed"),
                      c("predomDir", "Altimeter"),
                      c("predomDir", "TempF"),
                      c("predomDir", "DewF")
                      )

for (x in fctNumListIQR) {
    plotMedianIQR(mod2016Data, 
                  fctVar=x[1], 
                  numVar=x[2], 
                  subT="Red dots are the overall mid-quantile", 
                  showXLabel=FALSE,
                  diagnose=TRUE, 
                  facetOn="sourceName",
                  showCentral=TRUE
                  )
}

```
  
Limiting the observations to Q1-Median-Q2 brings out a bit more information in the plots:  
  
WIND SPEED BY MONTH:  
* San Diego and Las Vegas are meaningfully less windy than the median, especially during the cold season  
  
ALTIMETER BY MONTH:  
* San Diego has very little variance in altimeter relative to the other locales  
* Las Vegas runs especially low on altimeter during the warm season  
* There is a seasonal pattern where altimeters tend to run lower during the warm season while also showing a much smaller Q1-Q3 range  
  
WIND SPEED BY SKY OBSCURATION:  
* Newark shows very high wind speeds when obscuration is VV  
* Should re-run with data y-axis capped at 15 to visualize the other locales  
  
ALTIMETER BY WIND DIRECTION:  
* Altimeters tend to be a bit lower when winds are from the S-SW-W-NW, a pattern that seems consistent across all locales  
* Las Vegas runs especially low on altimeter relative to other locales when winds are from E-SE-S    
  
TEMPERATURE BY WIND DIRECTION:  
* Variable winds are associated with higher temperatures than calm (speed 0) winds  
* Winds from W-NW are generally associated with somewhat lower temperatures  
  
DEW POINT BY WIND DIRECTION:  
* Winds from SW-W-NW-N are associated with generally lower dew points than winds from NE-E-SE-S  
* Las Vegas typically runs low on dew points while Houston and New Orleans typically run high on dew points  
* San Diego has little variance in dew points and does not see any dip when winds are from SW-W-NW-N  
  
The wind speed vs. sky obscuration plot is re-run with y-limits that suppress Newark VV:  
```{r cache=TRUE}

plotMedianIQR(mod2016Data, 
              fctVar="wType", 
              numVar="WindSpeed", 
              subT="Red dots are the overall mid-quantile", 
              showXLabel=FALSE,
              diagnose=TRUE, 
              facetOn="sourceName",
              showCentral=TRUE, 
              ylimits=c(0, 15)
              )

```
  
Low vertical visibilities (VV) are generally associated with lower winds.  There is also a slight tendency for more obscured skies (OVC) to be associated with slightly stronger winds.  

Further, the previous analysis for counts by wind direction is re-run using the predominant directions:  
```{r cache=TRUE}
# Counts by Metric for predomDir using mod2016Data
plotcountsByMetric(mod2016Data, 
                   mets=c("predomDir"), 
                   title="Comparisons Across Locales (red dots are the median)", 
                   facetOn="sourceName",
                   showCentral=TRUE
                   )

```
  
Findings include:  
* Across all locales, winds are more commonly from S-SW-W-NW-N than from NE-E-SE  
* San Diego is especially likely to have either 0 wind or wind from W-NW  
* Traverse City is especially likely to have 0 wind or variable wind (very surprising, and possibly a sign of anomalous data)  
* Minneapolis is especially likely to experience winds from NE  
* New Orleans and Houston rarely experience winds from SW-W-NW relative to other locales  
* Lincoln and Las Vegas are especially pronse to winds from S (and for Las Vegas SW)  
  
There are several issues identified that should be explored and fixed if appropriate:  
  
* Vertical visibility greater than 10 recorded  
* Tendency for maximum obscuration to be CLR in Lincoln and Green Bay  
* Tendency for Traverse City to have no or variable winds  
  
Cloud exploration can highlight whether all locales are being compared apples to apples.  This is especially the case if some locales have a different maximum sensor height:  
```{r}

# Select the source, sourceName, dtime and cLevel variables; pivot cLevel down
cLevels <- mod2016Data %>%
    select(source, sourceName, dtime, starts_with("cLevel")) %>%
    pivot_longer(-c(source, sourceName, dtime), names_to="level", values_to="height") %>%
    mutate(level=as.integer(str_replace(level, pattern="cLevel", replacement="")))

# Select the source, sourceName, dtime and cType variables; pivot cLevel down
cTypes <- mod2016Data %>%
    select(source, sourceName, dtime, starts_with("cType")) %>%
    pivot_longer(-c(source, sourceName, dtime), names_to="level", values_to="type") %>%
    mutate(level=as.integer(str_replace(level, pattern="cType", replacement="")))

cData <- cLevels %>%
    inner_join(cTypes, by=c("source", "sourceName", "dtime", "level"))

# Plot cloud heights, using only non-NA
cData %>%
    filter(!is.na(height)) %>%
    ggplot(aes(x=fct_reorder(sourceName, height, .fun=max, na.rm=TRUE), y=height)) + 
    geom_violin(fill="lightblue") + 
    coord_flip() + 
    labs(x="", y="Cloud Height (feet)", title="Density of cloud heights by locale")

```
  
There are clearly differences in maximum cloud height recorded by locale:  
  
* 4 locales record clouds up to 35,000 feet  
* 5 locales record clouds up to 30,000 feet; there appear to be few if any clouds recorded above 30,000 feet, so cloud distributions may not be meaningfully impacted by this  
* 3 locales record clouds up to 25,000 feet; there are meaningful clouds between 25,000 and 30,000 feet, so these locales may appear to be "more clear than normal" purely due to maximum recorded height  
* 2 locales record heights up to 12,000 feet (Lincoln and Green Bay); these are the cities that appeared anomalously clear in the EDA, and the reason is thet they exclude mid/high level cloudiness  
  
The distribution of cloud types observed can also be assessed:  
```{r}

# Plot cloud heights, using only non-""
fctLayers <- c("VV", "OVC", "BKN", "SCT", "FEW")

cData %>%
    filter(type!="") %>%
    mutate(type=factor(type, levels=fctLayers)) %>%
    ggplot(aes(x=fct_reorder(sourceName, height, .fun=max, na.rm=TRUE), fill=type)) + 
    geom_bar(position="stack") + 
    coord_flip() + 
    labs(x="", y="Cloud Layer Obscuration", title="Cloud obscuration by locale") + 
    scale_fill_discrete("", rev(fctLayers)) + 
    theme(legend.position="bottom")

```
  
Lincoln and Green Bay stand out for having fewer clouds, likely due to the inability to catch the higher altocumulus and any cirrus cloud (both very common in the mid-latitudes).

Supposing that only clouds of 12,000 feet and under are considered:  
```{r}

# Plot cloud heights, using only non-NA
cData %>%
    filter(!is.na(height)) %>%
    filter(height <= 12000) %>%
    ggplot(aes(x=sourceName, y=height)) + 
    geom_violin(fill="lightblue") + 
    coord_flip() + 
    labs(x="", y="Cloud Height (feet)", title="Density of cloud heights by locale")

cData %>%
    filter(type!="") %>%
    filter(height <= 12000) %>%
    mutate(type=factor(type, levels=fctLayers)) %>%
    ggplot(aes(x=fct_reorder(sourceName, sourceName, .fun=length), fill=type)) + 
    geom_bar(position="stack") + 
    coord_flip() + 
    labs(x="", y="Cloud Layer Obscuration", title="Cloud obscuration by locale (up to 12,000 feet)") + 
    scale_fill_discrete("", rev(fctLayers)) + 
    theme(legend.position="bottom")

```
  
The patterns are much more plausible:  
  
* San Diego, known for marine layer, has clouds that skew very low and more obscured  
* Las Vegas, a desert, has clouds that skew higher and less obscured    
* The remaining cities have maximum cloud densities in the 2500-5000 foot range, very common cloud heights in the US  
* Lincoln and Green Bay remain among the least cloudy locales, though this may be due to hitting OVC (cloud layers above an OVC layer are not observed by the sensor/human and thus not recorded)  
  
Further investigation of the cloud data may be interesting.
  
A function is written to take only cloud data up through height x, and to add a layer of clouds that are "clear" at a height that is out-of-interval:  
```{r}

# Filter to only clouds up to and including height
cloudsLevel0 <- function(df, 
                         maxHeight, 
                         byVars,
                         baseLevel=0,
                         heightBase=-100,
                         typeBase="CLR"
                         ) {
    
    # Function assumptions
    # Input data are unique by byVars-level and with columns 'height' and 'type'
    # Clouds increase in height with level
    # Clouds are non-decreasing in type (VV > OVC > BKN > SCT > FEW) with level
    
    # FUNCTION ARGUMENTS:
    # df: tibble or dataframe contiaining the clouds data
    # maxHeight: the maximum height to consider (delete all heights above this level)
    # byVars: the variables that make up a unique observation (df should be unique by byVars-level)
    # baseLevel: the level to be created as the base level (by default, level 0)
    # heightBase: the height to be provided to the base level (by default, -100 feet)
    # typeBase: the type of obscuration observed at the base level (by default, CLR)
    
    # Add a cloud level 0 that has height -100 (by default)
    # Include only levels where the cloud height is not NA
    # Include only levels where the cloud height is less than or equal to maxHeight
    modData <- df %>% 
        group_by_at(vars(all_of(byVars))) %>% 
        summarize(level=baseLevel, height=heightBase, type=typeBase) %>% 
        ungroup() %>% 
        bind_rows(df) %>% 
        arrange_at(vars(all_of(c(byVars, "level")))) %>% 
        filter(!is.na(height)) %>% 
        filter(height <= maxHeight)
    
    modData
    
}

```
  
The function is then run using the existing cData:  
```{r}

modCData <- cloudsLevel0(cData, maxHeight=12000, byVars=c("source", "sourceName", "dtime"))
modCData <- modCData %>%
    mutate(type=factor(type, levels=c("VV", "OVC", "BKN", "SCT", "FEW", "CLR")))
modCData

```
  
An additional function is written to take processed cloud data and to designate 1) the minimum cloud height, 2) the minimum cloud ceiling (a ceiling exists with BKN, OVC, or VV layers), and 3) the maximum obscuration level (using CLR if no clouds exist in that area):  
```{r}

# Helper function to pull out the minimum cloud height, limited to certain obscurations
getMinimumHeight <- function(df, 
                             byVars, 
                             types, 
                             baseLevel=0
                             ) {
    
    # Split the data in to the baseLevel and all other levels
    baseData <- df %>%
        filter(level==baseLevel)
    layerData <- df %>%
        filter(level!=baseLevel)
        
    # Take the layerData, limit to type in types, and find the minimum level
    layerData <- layerData %>%
        filter(type %in% types) %>%
        group_by_at(vars(all_of(byVars))) %>%
        filter(level==min(level)) %>%
        ungroup()
    
    # Put the data back together
    # Keep the maximum level for each set of byVars (will be 0 if no data for byVars in layerData)
    cloudData <- baseData %>%
        bind_rows(layerData) %>%
        arrange_at(vars(all_of(c(byVars, "level")))) %>%
        group_by_at(vars(all_of(byVars))) %>%
        filter(level==max(level))
    
}

# Extract the minimum cloud height, minimum ceiling height, and maximum obscuration
hgtCeilObsc <- function(df, 
                        byVars,
                        baseLevel=0
                        ) {

    # Function assumptions
    # Input data are unique by byVars-level and with columns 'height' and 'type'
    # For each byVars, a row with level=baseLevel, height=heightBase, type=typeBase has been created
    # Clouds increase in height with level
    # Clouds are non-decreasing in type (VV > OVC > BKN > SCT > FEW) with level
    
    # FUNCTION ARGUMENTS:
    # df: tibble or dataframe contiaining the clouds data
    # byVars: the variables that make up a unique observation (df should be unique by byVars-level)
    # baseLevel: the base level in df (by default, level 0)
    # heightBase: the height of the base level in df (by default, -100 feet)
    # typeBase: the type of obscuration at the base level in df (by default, CLR)
    
    # Get the maximum obscuration
    maxObsc <- df %>%
        group_by_at(vars(all_of(byVars))) %>% 
        filter(level==max(level)) %>%
        ungroup()
    
    # Get the minimum height (any type)
    minHeight <- getMinimumHeight(df, 
                                  byVars=byVars, 
                                  types=c("VV", "OVC", "BKN", "SCT", "FEW"), 
                                  baseLevel=baseLevel
                                  )
    
    # Get the minimum ceiling height (VV, OVC, BKN)
    minCeiling <- getMinimumHeight(df, 
                                   byVars=byVars, 
                                   types=c("VV", "OVC", "BKN"), 
                                   baseLevel=baseLevel
                                   )

    # Put the file together
    minCeiling <- minCeiling %>%
        rename(ceilingHeight=height, ceilingType=type, ceilingLevel=level)
    minHeight <- minHeight %>%
        rename(cloudHeight=height, cloudType=type, cloudLevel=level)
    maxObsc <- maxObsc %>%
        rename(obscHeight=height, obscType=type, obscLevel=level)
    
    # Merge
    cloudSummary <- maxObsc %>%
        full_join(minHeight, by=byVars) %>%
        full_join(minCeiling, by=byVars)
    
    cloudSummary
    
}

```
  
The function can then be run on the modified clouds data:  
```{r}

# Get the key clouds data
cloudSummary <- hgtCeilObsc(modCData, byVars=c("source", "sourceName", "dtime"))

# Check for consistency
cloudSummary %>%
    count(ceilingType, obscType)
cloudSummary %>%
    count(cloudType, ceilingType)
cloudSummary %>%
    count(cloudType, obscType)

```
  
Plots for the maximum obscuration (through 12,000 feet) can then be created:  
```{r}

plotMaxObsc <- function(df, 
                        xVar, 
                        fillVar, 
                        title, 
                        subtitle="Up to and including 12,000 feet",
                        orderByVariable=NULL,
                        orderByValue=NULL,
                        posnBar="stack",
                        yLabel="# Hourly Observations",
                        legendLabel="",
                        facetOn=NULL
                        ) {

    # Get the levels to be used
    cLevels <- levels(df %>% pull(fillVar))
    
    # Create the main plot
    p1 <- df %>%
        ggplot(aes_string(fill=fillVar))
    if (!is.null(orderByVariable)) {
        p1 <- p1 + 
            geom_bar(aes(x=fct_reorder(get(xVar), get(orderByVariable)==orderByValue, .fun=sum)),
                     position=posnBar
                     )
    } else {
        p1 <- p1 + 
            geom_bar(aes_string(x=xVar), position=posnBar)
    }
    p1 <- p1 + 
        coord_flip() + 
        labs(x="", 
             y=yLabel, 
             title=title, 
             subtitle=subtitle
             ) + 
        theme(legend.position="bottom") + 
        scale_fill_discrete(legendLabel, rev(cLevels)) + 
        guides(fill=guide_legend(nrow=1))
    if (!is.null(facetOn)) {
        p1 <- p1 + facet_wrap(as.formula(paste("~", facetOn)))
    }
    print(p1)
    
}

# Cloud obscuration by source
plotMaxObsc(cloudSummary, 
            xVar="sourceName", 
            fillVar="obscType", 
            title="Maximum Cloud Obscuration", 
            orderByVariable="obscType",
            orderByValue="CLR"
            )

# Cloud obscuration by month
cloudSummary <- cloudSummary %>%
    mutate(month=lubridate::month(dtime), 
           hour=lubridate::hour(dtime), 
           monthfct=factor(month.abb[month], levels=month.abb[1:12])
           )
plotMaxObsc(cloudSummary, 
            xVar="monthfct", 
            fillVar="obscType", 
            title="Maximum Cloud Obscuration", 
            posnBar="fill"
            )

```
  
A few salient observations stand out about the maximum obscuration level:  
  
* Las Vegas is almost always clear or has just a few clouds up to 12,000 feet  
* Lincoln and Green Bay tend to be either clear up to 12,000 feet or to have an overcast  
* Traverse City is especially prone to being overcast and not having clear skied to 12,000 feet  
* Clear skies to 12,000 feet are roughly as likely in any month, but overcast by 12,000 feet is much more common in the cold season while FEW/SCT are more common during the warm season
  
Groups of cities can be examined, faceted by month:  
```{r}

cityCloudList <- list(c("klas_2016", "ksan_2016", "kiah_2016", "kmsy_2016"), 
                      c("kgrb_2016", "kgrr_2016", "kdtw_2016", "ktvc_2016"), 
                      c("klnk_2016", "kmsp_2016", "kmsn_2016", "kind_2016"), 
                      c("kmke_2016", "kord_2016", "kewr_2016")
                      )

for (x in cityCloudList) {
    cloudUse <- cloudSummary %>%
        filter(source %in% x)
    plotMaxObsc(cloudUse, 
                xVar="monthfct", 
                fillVar="obscType", 
                title="Maximum Cloud Obscuration", 
                facetOn="sourceName", 
                posnBar="fill"
                )
}

```
  
A few findings include:  
  
* While there may be some small seasonal patterns, observations in Las Vegas are almost always CLR/FEW  
* Houston and New Orleans both have few clear observations and few overcasts during June-September  
* San Diego has most of its overcasts during May-Septemver and most of its clear observations from October-April  
* Most of the remaining locales show a seasonal pattern with overcasts more common during the cold season  
* Newark is at a glance less seasonal than the midwestern locales  
  
The ceiling heights can also be assessed:  
```{r}

cloudSummary <- cloudSummary %>%
    mutate(ceilFactor=factor(case_when(ceilingHeight == -100 ~ "None", 
                                       ceilingHeight <= 1000 ~ "0-1000", 
                                       ceilingHeight <= 3000 ~ "1000-3000", 
                                       ceilingHeight <= 6000 ~ "3000-6000",
                                       ceilingHeight <= 12000 ~ "6000-12000"
                                       ), 
                             levels=c("None", "6000-12000", "3000-6000", "1000-3000", "0-1000")
                             )
           )

plotMaxObsc(cloudSummary, 
            xVar="sourceName", 
            fillVar="ceilFactor", 
            title="Ceiling Height", 
            orderByVariable="ceilFactor",
            orderByValue="None"
            )

for (x in cityCloudList) {
    cloudUse <- cloudSummary %>%
        filter(source %in% x)
    plotMaxObsc(cloudUse, 
                xVar="monthfct", 
                fillVar="ceilFactor", 
                title="Ceiling Height", 
                facetOn="sourceName", 
                posnBar="fill"
                )
}

```

Findings for ceiling height broadly line up with findings for maximum cloud obscuration, as expected:  
  
* Las Vegas is least likely to have a ceiling under 12,000 feet, followed by New Orleans, Lincoln, and Houston  
* San Diego is especially likely to have a ceiling of 1000-3000 feet relative to other locales, likely driven by marine layer  
  
Next steps are to extract and explore the precipitation data contained in the METAR.