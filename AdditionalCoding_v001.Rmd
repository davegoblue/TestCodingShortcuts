---
title: "Additional Coding Examples"
author: "davegoblue"
date: "August 14, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background  
This document is for additional coding examples, using some DataCamp_Insights_v001 materials where applicable.  To start, this program looks at hands that can be made in a game of Three Card Poker (TCP).  Specifically, a TCP hand consists of three cards from a standard 52-card deck.  Suits do not matter (there is no master or trump suit), though three cards of the same suit form a flush.  Further, three cards of consecutive rank (A-K-Q and 3-2-A are both counted) are considered to be a straight.
  
## Simulations  
### Potential Hand Types  
The card deck will be considered to be 1-52, where 1-13, 14-26, 27-39, and 40-52 shall each be the suits.  Further, the lowest number of each suit shall be considered the Ace, and the highest shall be considered the King.  There are 52c3 or 22,100 possible hands that can be made in this game:  
```{r}
choose(52, 3)
```
  
First, each of these 22,100 hands is created using a for loop:  
```{r}
# matrix will be index 1, index 2, index 3
allHands <- matrix(data=0L, nrow=choose(52, 3), ncol=3)

intCtr <- 1
for (i in 1:50) {
    for (j in (i+1):51) {
        for (k in (j+1):52) {
           allHands[intCtr, ] <- c(i, j, k)
           intCtr <- intCtr + 1
        }
    }
}
```
  
Next, each of the hands is scored based on whether it meets the following criteria (a hand may fall in multiple categories, or in to none):  
  
* Three of a Kind  
* Straight  
* Flush  
* Pair (note that all Three of a Kind by definition will be part of Pair)  
  
```{r}
## Find the flushes
isFlush <- apply(allHands, 1, FUN = function(x) { diff(range( (x-1) %/% 13 )) == 0 })

## Find the trips
isTrips <- apply(allHands, 1, FUN = function(x) { diff(range( (x-1) %% 13 )) == 0 })

## Find the pairs (n.b. that all trips will also be defined as pairs)
isPair <- apply(allHands, 1, FUN = function(x) { !identical(x %% 13, unique(x %% 13)) })

## Find the posible straights (2-gappers using only Ace-low)
isStraightALow <- apply(allHands, 1, FUN = function(x) { diff(range( (x-1) %% 13 )) == 2 })

## Find the possible straights (2-gappers using only Ace-high)
isStraightAHigh <- apply(allHands, 1, FUN = function(x) { diff(range( (x-2) %% 13 )) == 2 })

## Consolidate (a straight is a 2-gapper that is not paired)
isStraight <- (isStraightALow | isStraightAHigh) & !isPair

```
  
Report on all of the potential hand types:  
```{r}
print(sum(isStraight & isFlush))  # Straight Flushes
print(sum(isTrips))  # Three of a Kind
print(sum(isStraight & !isFlush))  # Straight (but not SF)
print(sum(!isStraight & isFlush))  # Flush (but not SF)
print(sum(isPair & !isTrips))  # Pair (but not Trips)
print(sum(!isStraight & !isFlush & !isPair))  # Nothing

```
  
Lastly, a table of hand values is created:  
```{r}
handValues <- rep(-1, nrow(allHands))  # Default hand value is -1
handValues[isPair] <- 1  # Convert pairs to +1 (trips will be over-written later)
handValues[isFlush] <- 3  # Convert flushes to +3 (SF will be over-written later)
handValues[isStraight] <- 6  # Convert straights to +6 (SF will be over-written later)
handValues[isTrips] <- 30  # Convert trips to +30 (previous +1 for pair over-written)
handValues[isFlush & isStraight] <- 40  # Convert SF to +40 (previous +3/+6 for flush/straight over-written)

sum(handValues)
sum(handValues) / length(handValues)  # Overall return
table(handValues)
round(table(handValues) / length(handValues), 5)  # Probabilities
```
  
These values all match the published literature.  