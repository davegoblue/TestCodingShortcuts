<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Chapter 4 Cells vs. Vectors</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>This document captures some useful tips and tricks from John Taveras&#39; book &ldquo;R for Excel Users&rdquo;.  John has a nice style for comparing Excel with R.  One of my objectives is to get R to &ldquo;behave more like Excel&rdquo; in some instances.</p>

<h3>Chapter 4 Cells vs. Vectors</h3>

<p>This chapter contains some useful string functions.  I expand on them a bit with some other searching.</p>

<p>####<em>Standard Excel text functions</em><br/>
Standard Excel functions like LEN, SUBSTR, UPPER, and LOWER can be replicated:  </p>

<pre><code class="r">fakeName &lt;- &quot;AbcDe FFGhiJL mfoP&quot;

nchar(fakeName)  ## Number of characters including spaces - 18
</code></pre>

<pre><code>## [1] 18
</code></pre>

<pre><code class="r">length(fakeName)  ## Not what you want!  It is of length 1 (1 item)
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">substr(fakeName,1,3)  ## Start at position 1 and stop at position 3 (left(fakeName,3))
</code></pre>

<pre><code>## [1] &quot;Abc&quot;
</code></pre>

<pre><code class="r">substr(fakeName,nchar(fakeName)-2,nchar(fakeName))  ## Start at len-2 and stop at len (right(fakeName,3))
</code></pre>

<pre><code>## [1] &quot;foP&quot;
</code></pre>

<pre><code class="r">toupper(fakeName)
</code></pre>

<pre><code>## [1] &quot;ABCDE FFGHIJL MFOP&quot;
</code></pre>

<pre><code class="r">tolower(fakeName)
</code></pre>

<pre><code>## [1] &quot;abcde ffghijl mfop&quot;
</code></pre>

<p>####<em>String splitting is available</em><br/>
Additionally, a string can be split on a key character, with the results then manipulated as needed in one of many different ways:  </p>

<pre><code class="r">strsplit(fakeName,&quot; &quot;)  ## Split by &quot; &quot;
</code></pre>

<pre><code>## [[1]]
## [1] &quot;AbcDe&quot;   &quot;FFGhiJL&quot; &quot;mfoP&quot;
</code></pre>

<pre><code class="r">length(strsplit(fakeName,&quot; &quot;))  ## It is still 1 because it is a list
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">nchar(strsplit(fakeName,&quot; &quot;))  ## It is now 29!  Not totally sure why though . . . 
</code></pre>

<pre><code>## [1] 29
</code></pre>

<pre><code class="r">strsplit(fakeName,&quot; &quot;)[c(1,3)]  ## Prints the full list, with 3 being NULL (list has only 1 item)
</code></pre>

<pre><code>## [[1]]
## [1] &quot;AbcDe&quot;   &quot;FFGhiJL&quot; &quot;mfoP&quot;   
## 
## [[2]]
## NULL
</code></pre>

<pre><code class="r">strsplit(fakeName,&quot; &quot;)[[1]][1:3]  ## Prints each item separately (list of length 3)
</code></pre>

<pre><code>## [1] &quot;AbcDe&quot;   &quot;FFGhiJL&quot; &quot;mfoP&quot;
</code></pre>

<pre><code class="r">length(strsplit(fakeName,&quot; &quot;)[[1]])  ## 3
</code></pre>

<pre><code>## [1] 3
</code></pre>

<pre><code class="r">length(strsplit(fakeName,&quot; &quot;)[[1]][1:3])  ## 3
</code></pre>

<pre><code>## [1] 3
</code></pre>

<pre><code class="r">nchar(strsplit(fakeName,&quot; &quot;)[[1]][1:3])  ## 5 7 4
</code></pre>

<pre><code>## [1] 5 7 4
</code></pre>

<pre><code class="r">sum(nchar(strsplit(fakeName,&quot; &quot;)[[1]][1:3]))  ## 16 (5+7+4)
</code></pre>

<pre><code>## [1] 16
</code></pre>

<pre><code class="r">strsplit(fakeName,&quot; &quot;)[[1]][c(1,3)]  ## Grab the first and third item - &quot;AbcDe&quot; and &quot;mfoP&quot;
</code></pre>

<pre><code>## [1] &quot;AbcDe&quot; &quot;mfoP&quot;
</code></pre>

<p>####<em>Pattern substitution is available:</em><br/>
Pattern substitution is available, with sub finding/replacing the first instance with gsub finding/replacing all instances:  </p>

<pre><code class="r">sub(pattern=&quot; &quot;,replacement=&quot;_-_&quot;,fakeName)  ## Replace just the first space
</code></pre>

<pre><code>## [1] &quot;AbcDe_-_FFGhiJL mfoP&quot;
</code></pre>

<pre><code class="r">gsub(pattern=&quot; &quot;,replacement=&quot;_-_&quot;,fakeName)  ## Replace all spaces
</code></pre>

<pre><code>## [1] &quot;AbcDe_-_FFGhiJL_-_mfoP&quot;
</code></pre>

<pre><code class="r">nchar(gsub(pattern=&quot; &quot;,replacement=&quot;_-_&quot;,fakeName))  ## Grew from 18-&gt;22 due to each space getting 2 bigger
</code></pre>

<pre><code>## [1] 22
</code></pre>

<pre><code class="r">gsub(pattern=&quot; &quot;,replacement=&quot;&quot;,fakeName)  ## compressed vector
</code></pre>

<pre><code>## [1] &quot;AbcDeFFGhiJLmfoP&quot;
</code></pre>

<pre><code class="r">nchar(gsub(pattern=&quot; &quot;,replacement=&quot;&quot;,fakeName))  ## Shrank from 18-&gt;16 by compressing away the fakes
</code></pre>

<pre><code>## [1] 16
</code></pre>

<p>####<em>Pattern identification and location ID is available</em><br/>
The regexpr function finds the first match and provides a list with attributes about it:  </p>

<pre><code class="r">regexpr(&quot;f&quot;,fakeName)  ## Provides first match, length of match, and then useBytes
</code></pre>

<pre><code>## [1] 16
## attr(,&quot;match.length&quot;)
## [1] 1
## attr(,&quot;useBytes&quot;)
## [1] TRUE
</code></pre>

<pre><code class="r">regexpr(&quot;f&quot;,fakeName)[1]  ## shows the location of the first match
</code></pre>

<pre><code>## [1] 16
</code></pre>

<pre><code class="r">attr(regexpr(&quot;f&quot;,fakeName),&quot;match.length&quot;)  ## Shows the length of match
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">attr(regexpr(&quot;f&quot;,fakeName),&quot;useBytes&quot;)  ## Shows the useBytes of match (TRUE/FALSE)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">regexpr(&quot;f&quot;,fakeName,ignore.case=TRUE)  ## finds the F which comes before f
</code></pre>

<pre><code>## [1] 7
## attr(,&quot;match.length&quot;)
## [1] 1
## attr(,&quot;useBytes&quot;)
## [1] TRUE
</code></pre>

<pre><code class="r">regexpr(&quot;f&quot;,fakeName,ignore.case=TRUE)[1] ## shows the location of the first match
</code></pre>

<pre><code>## [1] 7
</code></pre>

<pre><code class="r">regexpr(&quot;2/4&quot;,&quot;2/4/16&quot;)  ## Returns 1 3 TRUE (result is 1 with match.length 3 and useBytes TRUE)
</code></pre>

<pre><code>## [1] 1
## attr(,&quot;match.length&quot;)
## [1] 3
## attr(,&quot;useBytes&quot;)
## [1] TRUE
</code></pre>

<pre><code class="r">regexpr(&quot;2/4&quot;,&quot;2/4/16&quot;,fixed=TRUE)  ## No difference
</code></pre>

<pre><code>## [1] 1
## attr(,&quot;match.length&quot;)
## [1] 3
## attr(,&quot;useBytes&quot;)
## [1] TRUE
</code></pre>

<p>####<em>This can be expanded to identify all instances of the pattern</em><br/>
The gregexpr does the same thing but returns the lists/attributes for all the matches:  </p>

<pre><code class="r">gregexpr(&quot;f&quot;,fakeName,ignore.case=TRUE)  ## Finds positions 7, 8, and 16
</code></pre>

<pre><code>## [[1]]
## [1]  7  8 16
## attr(,&quot;match.length&quot;)
## [1] 1 1 1
## attr(,&quot;useBytes&quot;)
## [1] TRUE
</code></pre>

<pre><code class="r">length(gregexpr(&quot;f&quot;,fakeName,ignore.case=TRUE)[[1]]) ## Reports the 3 matches
</code></pre>

<pre><code>## [1] 3
</code></pre>

<pre><code class="r">gregexpr(&quot;f&quot;,fakeName,ignore.case=TRUE)[[1]][1] ## Returns 7
</code></pre>

<pre><code>## [1] 7
</code></pre>

<pre><code class="r">gregexpr(&quot;f&quot;,fakeName,ignore.case=TRUE)[[1]][2] ## Returns 8
</code></pre>

<pre><code>## [1] 8
</code></pre>

<pre><code class="r">gregexpr(&quot;f&quot;,fakeName,ignore.case=TRUE)[[1]][3] ## Returns 16
</code></pre>

<pre><code>## [1] 16
</code></pre>

<pre><code class="r">attr(gregexpr(&quot;f&quot;,fakeName,ignore.case=TRUE)[[1]],&quot;match.length&quot;) ## Returns 1 1 1
</code></pre>

<pre><code>## [1] 1 1 1
</code></pre>

<pre><code class="r">attr(gregexpr(&quot;f&quot;,fakeName,ignore.case=TRUE)[[1]],&quot;match.length&quot;)[2] ## Returns 1
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">gregexpr(&quot;fGh&quot;,fakeName,ignore.case=TRUE)  ## Finds just position 8 with length 3
</code></pre>

<pre><code>## [[1]]
## [1] 8
## attr(,&quot;match.length&quot;)
## [1] 3
## attr(,&quot;useBytes&quot;)
## [1] TRUE
</code></pre>

<p>####<em>Not sure I understand this</em><br/>
There is also a regexec command, but I do not yet see where it comes in handy:  </p>

<pre><code class="r">regexec(&quot;f&quot;,fakeName,ignore.case=TRUE) ## Not so sure, get back 7 and attr(,&quot;match.lenght&quot;) 1
</code></pre>

<pre><code>## [[1]]
## [1] 7
## attr(,&quot;match.length&quot;)
## [1] 1
</code></pre>

<pre><code class="r">regexec(&quot;fGh&quot;,fakeName,ignore.case=TRUE)  ## Not so sure, get back 8 and 3
</code></pre>

<pre><code>## [[1]]
## [1] 8
## attr(,&quot;match.length&quot;)
## [1] 3
</code></pre>

<p>####<em>There are a few handy preset variables available in base</em><br/>
Further, R contains some handy presets to help with common processing needs:  </p>

<pre><code class="r">letters ## all the lower case letters a-z
</code></pre>

<pre><code>##  [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot;
## [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot;
</code></pre>

<pre><code class="r">length(letters)  ## 26
</code></pre>

<pre><code>## [1] 26
</code></pre>

<pre><code class="r">letters[c(1,4,9,16,25)]  ## a d i p y
</code></pre>

<pre><code>## [1] &quot;a&quot; &quot;d&quot; &quot;i&quot; &quot;p&quot; &quot;y&quot;
</code></pre>

<pre><code class="r">nchar(letters[c(1,4,9,16,25)])  ## 1 1 1 1 1
</code></pre>

<pre><code>## [1] 1 1 1 1 1
</code></pre>

<pre><code class="r">LETTERS ## all the upper case letters A-Z
</code></pre>

<pre><code>##  [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot;
## [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot;
</code></pre>

<pre><code class="r">month.abb ## all the 3-character month abbreviations in form Jan
</code></pre>

<pre><code>##  [1] &quot;Jan&quot; &quot;Feb&quot; &quot;Mar&quot; &quot;Apr&quot; &quot;May&quot; &quot;Jun&quot; &quot;Jul&quot; &quot;Aug&quot; &quot;Sep&quot; &quot;Oct&quot; &quot;Nov&quot;
## [12] &quot;Dec&quot;
</code></pre>

<pre><code class="r">month.abb[c(1,10)]  ## &quot;Jan&quot; &quot;Oct&quot;
</code></pre>

<pre><code>## [1] &quot;Jan&quot; &quot;Oct&quot;
</code></pre>

<pre><code class="r">month.name ## full month names in form February
</code></pre>

<pre><code>##  [1] &quot;January&quot;   &quot;February&quot;  &quot;March&quot;     &quot;April&quot;     &quot;May&quot;      
##  [6] &quot;June&quot;      &quot;July&quot;      &quot;August&quot;    &quot;September&quot; &quot;October&quot;  
## [11] &quot;November&quot;  &quot;December&quot;
</code></pre>

<pre><code class="r">length(month.name) ## 12
</code></pre>

<pre><code>## [1] 12
</code></pre>

<pre><code class="r">nchar(month.name) ## 7 8 5 5 3 4 4 6 9 7 8 8
</code></pre>

<pre><code>##  [1] 7 8 5 5 3 4 4 6 9 7 8 8
</code></pre>

<pre><code class="r">month.name[c(1,13)]  ## &quot;January&quot; NA
</code></pre>

<pre><code>## [1] &quot;January&quot; NA
</code></pre>

<pre><code class="r">length(month.name[c(1,13)])  ## 2
</code></pre>

<pre><code>## [1] 2
</code></pre>

<pre><code class="r">month.name[c(0,12)]  ## &quot;December&quot;
</code></pre>

<pre><code>## [1] &quot;December&quot;
</code></pre>

<pre><code class="r">length(month.name[c(0,12)])  ## 1
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">month.name[c(0,13)]  ## NA
</code></pre>

<pre><code>## [1] NA
</code></pre>

<pre><code class="r">length(month.name[c(0,13)])  ## 1
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">pi ## 3.141593 etc.
</code></pre>

<pre><code>## [1] 3.141593
</code></pre>

<h3>Chapter 5 Formulae vs. Functions</h3>

<p>I am mostly OK with functions already, but it will be good to have a few key operations documented.  </p>

<p>####<em>Rounding functions</em><br/>
It will be helpful to document how R handles a few key rounding functions:  </p>

<pre><code class="r">## Note that there is no option to pass a digit to ceiling - it is always to nearest 1
ceiling(0.2)  ## 1
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">ceiling(0)  ## 0
</code></pre>

<pre><code>## [1] 0
</code></pre>

<pre><code class="r">ceiling (-0.2) ## 0
</code></pre>

<pre><code>## [1] 0
</code></pre>

<pre><code class="r">ceiling(10*pi)/10 ## 3.2 (this will round up to the nearest 0.1)
</code></pre>

<pre><code>## [1] 3.2
</code></pre>

<pre><code class="r">floor(0.2) ## 0
</code></pre>

<pre><code>## [1] 0
</code></pre>

<pre><code class="r">floor(0) ## 0
</code></pre>

<pre><code>## [1] 0
</code></pre>

<pre><code class="r">floor(-0.2)  ## -1
</code></pre>

<pre><code>## [1] -1
</code></pre>

<pre><code class="r">floor(10*pi)/10 ## 3.1 (this will round down to the nearest 0.1)
</code></pre>

<pre><code>## [1] 3.1
</code></pre>

<pre><code class="r">round(2.6)  ## 3 (default is round to nearest integer)
</code></pre>

<pre><code>## [1] 3
</code></pre>

<pre><code class="r">round(2.5)  ## 2 (NOTE the goof-ball algorithm where 0.5 always rounds to even)
</code></pre>

<pre><code>## [1] 2
</code></pre>

<pre><code class="r">round(1.5)  ## 2 (default is round to nearest integer)
</code></pre>

<pre><code>## [1] 2
</code></pre>

<pre><code class="r">round(-2.5)  ## -2 (NOTE the goof-ball algorithm where 0.5 always rounds to even)
</code></pre>

<pre><code>## [1] -2
</code></pre>

<pre><code class="r">round(-1.5)  ## -2 (default is round to nearest integer)
</code></pre>

<pre><code>## [1] -2
</code></pre>

<pre><code class="r">round(pi,4)  ## 3.1416 (the four means four post-decimal)
</code></pre>

<pre><code>## [1] 3.1416
</code></pre>

<pre><code class="r">signif(pi,4)  ## 3.142 (the four means four total)
</code></pre>

<pre><code>## [1] 3.142
</code></pre>

<pre><code class="r">round(pi/1000,4)  ## .0031 (still four post-decimal)
</code></pre>

<pre><code>## [1] 0.0031
</code></pre>

<pre><code class="r">signif(pi/1000,4) ## .003142 (still four total)
</code></pre>

<pre><code>## [1] 0.003142
</code></pre>

<pre><code class="r">trunc (1.8)  ## 1 (truncate is TOWARDS 0)
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">trunc(-1.8)  ## -1 (truncate is TOWARDS 0)
</code></pre>

<pre><code>## [1] -1
</code></pre>

<pre><code class="r">log(10)  ## default is LN
</code></pre>

<pre><code>## [1] 2.302585
</code></pre>

<pre><code class="r">log(10, base=10)  ## back to 1
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">log10(10)  ## Same as setting log and base=10 but may be faster
</code></pre>

<pre><code>## [1] 1
</code></pre>

<p>####<em>Ranking variables in R</em><br/>
It is also handy sometimes to gather the rank of something - see below:  </p>

<pre><code class="r">str(rank)
</code></pre>

<pre><code>## function (x, na.last = TRUE, ties.method = c(&quot;average&quot;, &quot;first&quot;, &quot;random&quot;, 
##     &quot;max&quot;, &quot;min&quot;))
</code></pre>

<pre><code class="r">## na.last: default TRUE (NA last) or FALSE (NA first) or NA (NA removed) or &quot;keep&quot; (rank NA)
## ties.method: default &quot;average&quot; (all ties get their average rank) or &quot;random&quot; (ties break randomly)
##              or &quot;min&quot; (typicaly sports ranking, all ties get the best rank)
##              or &quot;max&quot; (all ties get worst rank) or &quot;first&quot; (ties break by order found)

set.seed(0218160926)
x &lt;- c(1,2,2,2,3,4,NA,NA,7,7,9,10)

rank(x)  ## The 2 all get rank 3, the 7 both get rank 7.5 and the NA get rank 11 and 12
</code></pre>

<pre><code>##  [1]  1.0  3.0  3.0  3.0  5.0  6.0 11.0 12.0  7.5  7.5  9.0 10.0
</code></pre>

<pre><code class="r">rank(x,na.last=TRUE)  ## Same
</code></pre>

<pre><code>##  [1]  1.0  3.0  3.0  3.0  5.0  6.0 11.0 12.0  7.5  7.5  9.0 10.0
</code></pre>

<pre><code class="r">rank(x,na.last=FALSE)  ## NA promoted to 1 and 2
</code></pre>

<pre><code>##  [1]  3.0  5.0  5.0  5.0  7.0  8.0  1.0  2.0  9.5  9.5 11.0 12.0
</code></pre>

<pre><code class="r">rank(x,na.last=NA)  ## NA vector shortened as NA discarded from results vector (seems risky . . . )
</code></pre>

<pre><code>##  [1]  1.0  3.0  3.0  3.0  5.0  6.0  7.5  7.5  9.0 10.0
</code></pre>

<pre><code class="r">rank(x,na.last=&quot;keep&quot;)  ## Same as above, but vector stays same length with rank as NA
</code></pre>

<pre><code>##  [1]  1.0  3.0  3.0  3.0  5.0  6.0   NA   NA  7.5  7.5  9.0 10.0
</code></pre>

<pre><code class="r">rank(x,ties.method=&quot;average&quot;)  ## Same as default
</code></pre>

<pre><code>##  [1]  1.0  3.0  3.0  3.0  5.0  6.0 11.0 12.0  7.5  7.5  9.0 10.0
</code></pre>

<pre><code class="r">rank(x,ties.method=&quot;first&quot;)  ## Ties broken so the 2&#39;s rank 2 3 4 and the 7&#39;s rank 7 8
</code></pre>

<pre><code>##  [1]  1  2  3  4  5  6 11 12  7  8  9 10
</code></pre>

<pre><code class="r">rank(x,ties.method=&quot;random&quot;)  ## Ties broken so the 2&#39;s rank randomly 2-4 and the 7&#39;s rank randomly 7-8
</code></pre>

<pre><code>##  [1]  1  3  4  2  5  6 11 12  8  7  9 10
</code></pre>

<pre><code class="r">rank(x,ties.method=&quot;random&quot;)  ## Ranks change with different random numbers
</code></pre>

<pre><code>##  [1]  1  2  4  3  5  6 11 12  8  7  9 10
</code></pre>

<pre><code class="r">rank(x,ties.method=&quot;max&quot;)  ## The 2&#39;s all rank 4 and the 7&#39;s both rank 8
</code></pre>

<pre><code>##  [1]  1  4  4  4  5  6 11 12  8  8  9 10
</code></pre>

<pre><code class="r">rank(x,ties.method=&quot;min&quot;)  ## The 2&#39;s all rank 2 and the 7&#39;s both rank 7
</code></pre>

<pre><code>##  [1]  1  2  2  2  5  6 11 12  7  7  9 10
</code></pre>

<h3>Chapter 7: Data Inspection</h3>

<p>Remember the unique() call which is handy in certain cases:  </p>

<pre><code class="r">fakeName &lt;- &quot;AbcDe FFGhiJL mfoP&quot;
unique(strsplit(toupper(fakeName),&quot;&quot;)[[1]])  ## A B C D E &quot; &quot; F G H I J K L M O P
</code></pre>

<pre><code>##  [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot; &quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;L&quot; &quot;M&quot; &quot;O&quot; &quot;P&quot;
</code></pre>

<p>Remember also the pairs() function for getting pairwise plots:  </p>

<pre><code class="r">pairs(iris)  ## Default dataset in R
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-11"/></p>

<p>There may be benefit to further studying xtabs (cross tabulation):  </p>

<pre><code class="r">str(xtabs)
</code></pre>

<pre><code>## function (formula = ~., data = parent.frame(), subset, sparse = FALSE, 
##     na.action, exclude = c(NA, NaN), drop.unused.levels = FALSE)
</code></pre>

<pre><code class="r">xtabs(~ Species + Petal.Width, data=iris) ## counts of Species x Petal.Width
</code></pre>

<pre><code>##             Petal.Width
## Species      0.1 0.2 0.3 0.4 0.5 0.6  1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8
##   setosa       5  29   7   7   1   1  0   0   0   0   0   0   0   0   0
##   versicolor   0   0   0   0   0   0  7   3   5  13   7  10   3   1   1
##   virginica    0   0   0   0   0   0  0   0   0   0   1   2   1   1  11
##             Petal.Width
## Species      1.9  2 2.1 2.2 2.3 2.4 2.5
##   setosa       0  0   0   0   0   0   0
##   versicolor   0  0   0   0   0   0   0
##   virginica    5  6   6   3   8   3   3
</code></pre>

<pre><code class="r">xtabs(Petal.Width ~ Species, data=iris) ## Sum of Petal.Width by Species
</code></pre>

<pre><code>## Species
##     setosa versicolor  virginica 
##       12.3       66.3      101.3
</code></pre>

<pre><code class="r">xtabs(Petal.Width + Petal.Length ~ Species, data=iris) ## Straight sums Width/Length, by Species
</code></pre>

<pre><code>## Species
##     setosa versicolor  virginica 
##       85.4      279.3      378.9
</code></pre>

<pre><code class="r">xtabs(Petal.Length ~ Species + Petal.Width, data=iris) ## Sum of Petal Length for Species x Petal Width
</code></pre>

<pre><code>##             Petal.Width
## Species       0.1  0.2  0.3  0.4  0.5  0.6    1  1.1  1.2  1.3  1.4  1.5
##   setosa      6.9 41.9 10.0 11.0  1.7  1.6  0.0  0.0  0.0  0.0  0.0  0.0
##   versicolor  0.0  0.0  0.0  0.0  0.0  0.0 25.4 10.7 21.2 54.3 31.5 45.8
##   virginica   0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  5.6 10.1
##             Petal.Width
## Species       1.6  1.7  1.8  1.9    2  2.1  2.2  2.3  2.4  2.5
##   setosa      0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
##   versicolor 14.3  5.0  4.8  0.0  0.0  0.0  0.0  0.0  0.0  0.0
##   virginica   5.8  4.5 59.2 26.6 33.3 34.7 18.1 45.6 16.3 17.8
</code></pre>

<h3>Chapter 8: Column Operations</h3>

<p>I am mostly OK with these, but good to have a refresher of ifelse()  </p>

<pre><code class="r">ifelse(iris$Species[c(1:2,100,150)]==&quot;setosa&quot;,&quot;yes&quot;,&quot;no&quot;)  ## yes yes no no
</code></pre>

<pre><code>## [1] &quot;yes&quot; &quot;yes&quot; &quot;no&quot;  &quot;no&quot;
</code></pre>

<p>Quick refresher on some some helpful grep syntax:  </p>

<pre><code class="r">fakeName &lt;- &quot;AbcDe FFGhiJL mfoP&quot;
grep(&quot;$&quot;,strsplit(gsub(&quot; &quot;,&quot;$&quot;,fakeName),&quot;&quot;)[[1]])  ## Returns 1 2 3 4 . . . $ is a special character
</code></pre>

<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18
</code></pre>

<pre><code class="r">grep(&quot;\\$&quot;,strsplit(gsub(&quot; &quot;,&quot;$&quot;,fakeName),&quot;&quot;)[[1]])  ## Returns 6 14 since $ is escaped by \\
</code></pre>

<pre><code>## [1]  6 14
</code></pre>

<pre><code class="r">grep(&quot;\\$|f|F&quot;,strsplit(gsub(&quot; &quot;,&quot;$&quot;,fakeName),&quot;&quot;)[[1]])  ## Returns 6 7 8 14 16 since | is OR
</code></pre>

<pre><code>## [1]  6  7  8 14 16
</code></pre>

<p>####<em>Removing unwanted columns</em><br/>
Sometimes you do not want a column anymore &ndash; there are several ways to delete it:  </p>

<pre><code class="r">## myFrame$badColumn &lt;- NULL ## Incredibly, thet gets rid of a column!
## myFrame &lt;- myFrame[ , c(-2,-4,-6)]  ## Will remove columns 2, 4, 6
</code></pre>

<h3>Chapter 10: sqldf and dplyr</h3>

<p>Some examples for running SQL code or dplyr.  </p>

<p>####<em>Running sqldf</em><br/>
With sqldf, you basically have access to on-board SQL but without the hassles of loading RMySQL:  </p>

<pre><code class="r">library(sqldf) ## The sqldf library
batting &lt;- read.csv(&quot;Lahman/Batting.csv&quot;,stringsAsFactors=FALSE) ## The baseball dataset

sqldf(&quot;SELECT playerID, yearID, teamID, AB  
       FROM batting                         
       WHERE yearID=2009                    
       ORDER BY AB DESC                     
       LIMIT 10&quot;)
</code></pre>

<pre><code>##     playerID yearID teamID  AB
## 1   hillaa01   2009    TOR 682
## 2  rolliji01   2009    PHI 672
## 3  markani01   2009    BAL 642
## 4  suzukic01   2009    SEA 639
## 5   canoro01   2009    NYA 637
## 6  braunry02   2009    MIL 635
## 7  tejadmi01   2009    HOU 635
## 8  jeterde01   2009    NYA 634
## 9  roberbr01   2009    BAL 632
## 10 grandcu01   2009    DET 631
</code></pre>

<p>####<em>Manipulating data with dplyr (basics)</em><br/>
The dplyr package is an amazing way to work with data - key verbs:  </p>

<ul>
<li>select() select columns<br/></li>
<li>mutate() add or reformat columns<br/></li>
<li>filter() select rows<br/></li>
<li>arrange() sort rows<br/></li>
<li>summarize() summarize datasets<br/></li>
</ul>

<pre><code class="r">library(dplyr)
## Core frame is listed first in each of the calls

## Select just takes the requested columns
head(select(batting,playerID,yearID))  
</code></pre>

<pre><code>##    playerID yearID
## 1 aardsda01   2004
## 2 aardsda01   2006
## 3 aardsda01   2007
## 4 aardsda01   2008
## 5 aardsda01   2009
## 6 aardsda01   2010
</code></pre>

<pre><code class="r">## Mutate creates new variables based on existing variables
myTemp &lt;- mutate(batting,avg=H/AB,shortID=substr(playerID,1,5))
head(select(myTemp,playerID,shortID,H,AB,avg))
</code></pre>

<pre><code>##    playerID shortID H AB avg
## 1 aardsda01   aards 0  0 NaN
## 2 aardsda01   aards 0  2   0
## 3 aardsda01   aards 0  0 NaN
## 4 aardsda01   aards 0  1   0
## 5 aardsda01   aards 0  0 NaN
## 6 aardsda01   aards 0  0 NaN
</code></pre>

<pre><code class="r">tail(select(myTemp,playerID,shortID,H,AB,avg))
</code></pre>

<pre><code>##        playerID shortID   H  AB       avg
## 97884 zieglbr01   ziegl   0   2 0.0000000
## 97885 zimmejo02   zimme   8  65 0.1230769
## 97886 zimmery01   zimme 156 568 0.2746479
## 97887  zitoba01   zitob   5  34 0.1470588
## 97888 zobribe01   zobri 168 612 0.2745098
## 97889 zuninmi01   zunin  37 173 0.2138728
</code></pre>

<pre><code class="r">## Filter subsets the data based on criteria with each , being and (use | for or)
filter(batting,yearID==2010,teamID==&quot;NYA&quot; | teamID==&quot;NYN&quot;,AB&gt;600)[,1:5]
</code></pre>

<pre><code>##    playerID yearID stint teamID lgID
## 1  canoro01   2010     1    NYA   AL
## 2 jeterde01   2010     1    NYA   AL
## 3 teixema01   2010     1    NYA   AL
</code></pre>

<pre><code class="r">## Arrange runs the sorting for you - no need to use the x[order(x)] concept
head(arrange(batting,desc(yearID),teamID,desc(AB)))[,1:5]
</code></pre>

<pre><code>##    playerID yearID stint teamID lgID
## 1 pradoma01   2013     1    ARI   NL
## 2 goldspa01   2013     1    ARI   NL
## 3 parrage01   2013     1    ARI   NL
## 4 polloaj01   2013     1    ARI   NL
## 5 montemi01   2013     1    ARI   NL
## 6 gregodi01   2013     1    ARI   NL
</code></pre>

<p>####<em>Expanding dplyr with group_by()</em><br/>
The dplyr functionality can then be expanded with the group_by() call, which creates an internal grouping without actually modifying the data.  See below for example usages:  </p>

<pre><code class="r">library(dplyr)
set.seed(0218160926)

## By-group processing (keep n results from n items)
x &lt;- filter(batting, yearID==2013)  ## take only 2013
x &lt;- group_by(x, teamID)  ## create an internal grouping (no real data change)
x &lt;- arrange(x, teamID, desc(HR))  ## sort by teamID, then descending HR

## Now, the mutate below will be running everything by teamID -- rank, cumulative, cumulative %
x &lt;- mutate(x, rank=rank(desc(HR), ties.method=&quot;min&quot;), cum_HR=cumsum(HR), 
            cum_HR_pct = round(cumsum(HR)/sum(HR),2))

x[1:10,c(&quot;teamID&quot;,&quot;playerID&quot;,&quot;HR&quot;,&quot;rank&quot;,&quot;cum_HR&quot;,&quot;cum_HR_pct&quot;)]
</code></pre>

<pre><code>## Source: local data frame [10 x 6]
## Groups: teamID [1]
## 
##    teamID  playerID    HR  rank cum_HR cum_HR_pct
##     (chr)     (chr) (int) (int)  (int)      (dbl)
## 1     ARI goldspa01    36     1     36       0.28
## 2     ARI pradoma01    14     2     50       0.38
## 3     ARI  hillaa01    11     3     61       0.47
## 4     ARI montemi01    11     3     72       0.55
## 5     ARI parrage01    10     5     82       0.63
## 6     ARI chaveer01     9     6     91       0.70
## 7     ARI polloaj01     8     7     99       0.76
## 8     ARI  rossco01     8     7    107       0.82
## 9     ARI gregodi01     7     9    114       0.88
## 10    ARI kubelja01     5    10    119       0.92
</code></pre>

<pre><code class="r">x[sample(1:nrow(x),10,replace=FALSE),c(&quot;teamID&quot;,&quot;playerID&quot;,&quot;HR&quot;,&quot;rank&quot;,&quot;cum_HR&quot;,&quot;cum_HR_pct&quot;)]
</code></pre>

<pre><code>## Source: local data frame [10 x 6]
## Groups: teamID [8]
## 
##    teamID  playerID    HR  rank cum_HR cum_HR_pct
##     (chr)     (chr) (int) (int)  (int)      (dbl)
## 1     BAL flahery01    10     7    169       0.80
## 2     LAN rodrist02     0    21    138       1.00
## 3     SEA wilheto01     0    21    188       1.00
## 4     LAA troutmi01    27     2     61       0.37
## 5     LAN ramirha01    20     2     42       0.30
## 6     BOS berryqu01     1    15    174       0.98
## 7     PIT harrijo05     3    12    152       0.94
## 8     COL tulowtr01    25     2     51       0.32
## 9     HOU  penaca01     8     5     97       0.66
## 10    LAN garcion01     0    21    138       1.00
</code></pre>

<pre><code class="r">x &lt;- filter(x, rank &lt;= 5)
x[1:15,c(&quot;teamID&quot;,&quot;playerID&quot;,&quot;HR&quot;,&quot;rank&quot;,&quot;cum_HR&quot;,&quot;cum_HR_pct&quot;)]  ## Top 5 players on first 3 teams
</code></pre>

<pre><code>## Source: local data frame [15 x 6]
## Groups: teamID [3]
## 
##    teamID  playerID    HR  rank cum_HR cum_HR_pct
##     (chr)     (chr) (int) (int)  (int)      (dbl)
## 1     ARI goldspa01    36     1     36       0.28
## 2     ARI pradoma01    14     2     50       0.38
## 3     ARI  hillaa01    11     3     61       0.47
## 4     ARI montemi01    11     3     72       0.55
## 5     ARI parrage01    10     5     82       0.63
## 6     ATL uptonju01    27     1     27       0.15
## 7     ATL freemfr01    23     2     50       0.28
## 8     ATL ugglada01    22     3     72       0.40
## 9     ATL gattiev01    21     4     93       0.51
## 10    ATL mccanbr01    20     5    113       0.62
## 11    BAL davisch02    53     1     53       0.25
## 12    BAL jonesad01    33     2     86       0.41
## 13    BAL hardyjj01    25     3    111       0.52
## 14    BAL wietema01    22     4    133       0.63
## 15    BAL machama01    14     5    147       0.69
</code></pre>

<pre><code class="r">myTest &lt;- filter(x, rank &lt;= 3)
myTest[1:10,c(&quot;teamID&quot;,&quot;playerID&quot;,&quot;HR&quot;,&quot;rank&quot;,&quot;cum_HR&quot;,&quot;cum_HR_pct&quot;)]  ## keeps tie
</code></pre>

<pre><code>## Source: local data frame [10 x 6]
## Groups: teamID [3]
## 
##    teamID  playerID    HR  rank cum_HR cum_HR_pct
##     (chr)     (chr) (int) (int)  (int)      (dbl)
## 1     ARI goldspa01    36     1     36       0.28
## 2     ARI pradoma01    14     2     50       0.38
## 3     ARI  hillaa01    11     3     61       0.47
## 4     ARI montemi01    11     3     72       0.55
## 5     ATL uptonju01    27     1     27       0.15
## 6     ATL freemfr01    23     2     50       0.28
## 7     ATL ugglada01    22     3     72       0.40
## 8     BAL davisch02    53     1     53       0.25
## 9     BAL jonesad01    33     2     86       0.41
## 10    BAL hardyjj01    25     3    111       0.52
</code></pre>

<p>####<em>Expanding dplyr by skipping new column creation</em><br/>
The dplyr code above can be consolidated, avoiding the need to create new variables (maybe harder to read and debug, but with the reward of greater efficiency):  </p>

<pre><code class="r">library(dplyr)

## Sam as previous
x &lt;- filter(batting, yearID==2013)  ## take only 2013
x &lt;- group_by(x, teamID)  ## create an internal grouping (no real data change)
x &lt;- arrange(x, teamID, desc(HR))  ## sort by teamID, then descending HR

## Skip creating columns and updating databases
x &lt;- filter(x, rank(desc(HR), ties.method=&quot;min&quot;) &lt;= 5)
x[1:15,c(&quot;teamID&quot;,&quot;playerID&quot;,&quot;yearID&quot;,&quot;HR&quot;)]  ## Top 5 players on first 3 teams
</code></pre>

<pre><code>## Source: local data frame [15 x 4]
## Groups: teamID [3]
## 
##    teamID  playerID yearID    HR
##     (chr)     (chr)  (int) (int)
## 1     ARI goldspa01   2013    36
## 2     ARI pradoma01   2013    14
## 3     ARI  hillaa01   2013    11
## 4     ARI montemi01   2013    11
## 5     ARI parrage01   2013    10
## 6     ATL uptonju01   2013    27
## 7     ATL freemfr01   2013    23
## 8     ATL ugglada01   2013    22
## 9     ATL gattiev01   2013    21
## 10    ATL mccanbr01   2013    20
## 11    BAL davisch02   2013    53
## 12    BAL jonesad01   2013    33
## 13    BAL hardyjj01   2013    25
## 14    BAL wietema01   2013    22
## 15    BAL machama01   2013    14
</code></pre>

<p>####<em>Expanding dplyr by chaining</em><br/>
The %&gt;% operator in dplyr lets many of these operations run in order.  For example:  </p>

<pre><code class="r">library(dplyr)

## Old code for reference
x &lt;- filter(batting, yearID==2013)  ## take only 2013
x &lt;- group_by(x, teamID)  ## create an internal grouping (no real data change)
x &lt;- arrange(x, teamID, desc(HR))  ## sort by teamID, then descending HR
x &lt;- mutate(x, rank=rank(desc(HR), ties.method=&quot;min&quot;), cum_HR=cumsum(HR), 
            cum_HR_pct = round(cumsum(HR)/sum(HR),2))
x &lt;- filter(x, rank &lt;= 5)
x[1:15,c(&quot;teamID&quot;,&quot;playerID&quot;,&quot;HR&quot;,&quot;rank&quot;,&quot;cum_HR&quot;,&quot;cum_HR_pct&quot;)]  ## Top 5 players on first 3 teams
</code></pre>

<pre><code>## Source: local data frame [15 x 6]
## Groups: teamID [3]
## 
##    teamID  playerID    HR  rank cum_HR cum_HR_pct
##     (chr)     (chr) (int) (int)  (int)      (dbl)
## 1     ARI goldspa01    36     1     36       0.28
## 2     ARI pradoma01    14     2     50       0.38
## 3     ARI  hillaa01    11     3     61       0.47
## 4     ARI montemi01    11     3     72       0.55
## 5     ARI parrage01    10     5     82       0.63
## 6     ATL uptonju01    27     1     27       0.15
## 7     ATL freemfr01    23     2     50       0.28
## 8     ATL ugglada01    22     3     72       0.40
## 9     ATL gattiev01    21     4     93       0.51
## 10    ATL mccanbr01    20     5    113       0.62
## 11    BAL davisch02    53     1     53       0.25
## 12    BAL jonesad01    33     2     86       0.41
## 13    BAL hardyjj01    25     3    111       0.52
## 14    BAL wietema01    22     4    133       0.63
## 15    BAL machama01    14     5    147       0.69
</code></pre>

<pre><code class="r">## Use chaining to filter, then group_by, then arrange, then mutate, then filter again
y &lt;- filter(batting, yearID==2013) %&gt;%
     group_by(teamID) %&gt;%
     arrange(teamID, desc(HR)) %&gt;%
     mutate(rank=rank(desc(HR),ties.method=&quot;min&quot;),cum_HR=cumsum(HR),
            cum_HR_pct=round(cum_HR/sum(HR),2)
            ) %&gt;%
     filter(rank &lt;= 5)
y[1:15,c(&quot;teamID&quot;,&quot;playerID&quot;,&quot;HR&quot;,&quot;rank&quot;,&quot;cum_HR&quot;,&quot;cum_HR_pct&quot;)]  ## Top 5 players on first 3 teams
</code></pre>

<pre><code>## Source: local data frame [15 x 6]
## Groups: teamID [3]
## 
##    teamID  playerID    HR  rank cum_HR cum_HR_pct
##     (chr)     (chr) (int) (int)  (int)      (dbl)
## 1     ARI goldspa01    36     1     36       0.28
## 2     ARI pradoma01    14     2     50       0.38
## 3     ARI  hillaa01    11     3     61       0.47
## 4     ARI montemi01    11     3     72       0.55
## 5     ARI parrage01    10     5     82       0.63
## 6     ATL uptonju01    27     1     27       0.15
## 7     ATL freemfr01    23     2     50       0.28
## 8     ATL ugglada01    22     3     72       0.40
## 9     ATL gattiev01    21     4     93       0.51
## 10    ATL mccanbr01    20     5    113       0.62
## 11    BAL davisch02    53     1     53       0.25
## 12    BAL jonesad01    33     2     86       0.41
## 13    BAL hardyjj01    25     3    111       0.52
## 14    BAL wietema01    22     4    133       0.63
## 15    BAL machama01    14     5    147       0.69
</code></pre>

<pre><code class="r">identical(x,y)  ## The results are exactly, 100% the same
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<h3>Chapter 11: merge()</h3>

<p>Per Taveras, merge() is more or less the equivalent of VLOOKUP in R.  The advantages seem to be that you can do a multi-column lookup and/or value-gathering.  The downside is that it is always doing a ,FALSE where the lookup needs to exactly match.  My Exercise001 code is designed to allow for ,1 and ,-1 lookup also.  </p>

<pre><code class="r">players &lt;- read.csv(&quot;Lahman/Master.csv&quot;,stringsAsFactors=FALSE) ## The master players data

## merge(x, y, 
##       by=intersect(names(x),names(y)), by.x=by, by.y=by, 
##       all=FALSE, all.x=all, all.y=all
##       sort=TRUE, suffixes=c(&quot;.x&quot;,&quot;.y&quot;), incomparables=NULL)
##
## can declare both dataset columns using by= or single dataset columns using by.x= and by.y=
## notably, the by variables need not match names; by.x=Player_ID, by.y=IDPLAYER
## default is inner join; can override with all.x=TRUE (left) or all.y=TRUE (right) or all=TRUE (outer)
## sort=TRUE sorts the result by the by columns

battingCountry &lt;- merge(batting, players[ ,c(&quot;playerID&quot;,&quot;birthCountry&quot;,&quot;birthState&quot;)])

## Note that dplyr has merge functions also, which may be handy when more advanced programming is needed
</code></pre>

<h3>Chapter 12: summarize()</h3>

<p>The summarize() call in dplyr can give you totals by the group_by variables (this no longer has the property that n-inputs keeps n-outputs):  </p>

<pre><code class="r">library(dplyr)

mySummary &lt;- filter(batting, yearID&gt;=2008, !is.na(AB)) %&gt;%
             group_by(teamID, yearID) %&gt;%
             summarize(RBI_sum=sum(RBI),sd_RBI=round(sd(RBI),1),
                       avg=round(sum(H)/sum(AB),3),size=n_distinct(playerID)
                       )

mySummary[1:15,]
</code></pre>

<pre><code>## Source: local data frame [15 x 6]
## Groups: teamID [3]
## 
##    teamID yearID RBI_sum sd_RBI   avg  size
##     (chr)  (int)   (int)  (dbl) (dbl) (int)
## 1     ARI   2008     683   26.0 0.251    41
## 2     ARI   2009     686   24.4 0.253    45
## 3     ARI   2010     691   26.8 0.250    48
## 4     ARI   2011     702   22.7 0.250    51
## 5     ARI   2012     710   25.7 0.259    48
## 6     ARI   2013     647   25.1 0.259    44
## 7     ATL   2008     721   24.9 0.270    49
## 8     ATL   2009     700   24.6 0.263    45
## 9     ATL   2010     699   23.8 0.258    43
## 10    ATL   2011     606   23.8 0.243    45
## 11    ATL   2012     660   27.4 0.247    41
## 12    ATL   2013     656   26.0 0.249    44
## 13    BAL   2008     750   32.7 0.267    36
## 14    BAL   2009     708   28.9 0.268    35
## 15    BAL   2010     577   23.2 0.259    36
</code></pre>

<pre><code class="r">## Can always use aggregate from base for simpler versions
altApproach &lt;- aggregate(RBI ~ teamID, data=batting[batting$yearID==2008,], FUN=sum)
altApproach[1:15,]
</code></pre>

<pre><code>##    teamID RBI
## 1     ARI 683
## 2     ATL 721
## 3     BAL 750
## 4     BOS 807
## 5     CHA 785
## 6     CHN 811
## 7     CIN 677
## 8     CLE 772
## 9     COL 714
## 10    DET 780
## 11    FLO 741
## 12    HOU 684
## 13    KCA 650
## 14    LAA 721
## 15    LAN 659
</code></pre>

<h3>Chapter 13: Reshaping the data</h3>

<p>The data can be reshaped using Wickham&#39;s package reshape.  I am not yet sure whether-how this relates to Wickham&#39;s tidyr package but it has two examples that are very commonly useful.  </p>

<ul>
<li>melt coverts wide data to long<br/></li>
<li>dcast converts long data to wide<br/></li>
</ul>

<p>####<em>Basic philosophy of melting</em><br/>
Melting consists of making two decisions:<br/>
1.  What represents a single object?  These become id.vars<br/>
2.  What columns represent the measures per object?  These become measure.vars  </p>

<pre><code class="r">library(reshape2)

wide_data &lt;- data.frame(player=c(1,2,3),points_Age25=c(263, 279, 172),points_Age28=c(111,117,221),
                        fake=c(&quot;Who&quot;,&quot;needs&quot;,&quot;these&quot;)
                        )

wide_data
</code></pre>

<pre><code>##   player points_Age25 points_Age28  fake
## 1      1          263          111   Who
## 2      2          279          117 needs
## 3      3          172          221 these
</code></pre>

<pre><code class="r">melt(wide_data,id.vars=c(&quot;player&quot;),measure.vars=c(&quot;points_Age25&quot;,&quot;points_Age28&quot;),
     value.name=&quot;Points&quot;,variable.name=&quot;Age&quot;)
</code></pre>

<pre><code>##   player          Age Points
## 1      1 points_Age25    263
## 2      2 points_Age25    279
## 3      3 points_Age25    172
## 4      1 points_Age28    111
## 5      2 points_Age28    117
## 6      3 points_Age28    221
</code></pre>

<pre><code class="r">## Could gsub away the Points_Age in Age and convert to numeric
</code></pre>

<p>####<em>Basic philosophy of dcast</em><br/>
To dcast requires making three decisions:<br/>
1.  Which column(s) represent the object?<br/>
2.  Which column(s) do you want to transpose over?<br/>
3.  Which column contains the measure?  </p>

<pre><code class="r">library(reshape2)

long_data &lt;- data.frame(player=c(1,1,2,2,3,3),age=c(25,28,25,28,25,28),
                        points=c(263,111,279,117,172,221),fake=c(&quot;do&quot;,&quot;not&quot;,&quot;want&quot;,&quot;these&quot;,&quot;to&quot;,&quot;stay&quot;)
                        )

long_data
</code></pre>

<pre><code>##   player age points  fake
## 1      1  25    263    do
## 2      1  28    111   not
## 3      2  25    279  want
## 4      2  28    117 these
## 5      3  25    172    to
## 6      3  28    221  stay
</code></pre>

<pre><code class="r">dcast(long_data, player ~ age, value.var=&quot;points&quot;)
</code></pre>

<pre><code>##   player  25  28
## 1      1 263 111
## 2      2 279 117
## 3      3 172 221
</code></pre>

<pre><code class="r">long_data_2 &lt;- data.frame(player=c(1,1,2,2,3,3,1,1,2,2,3,3),
                          age=c(25,28,25,28,25,28,25,28,25,28,25,28),
                          points=c(263,111,279,117,172,221,269,113,285,119,178,223),
                          day_night=c(rep(&quot;D&quot;,6),rep(&quot;N&quot;,6)),
                          fake = LETTERS[1:12]
                          )

long_data_2
</code></pre>

<pre><code>##    player age points day_night fake
## 1       1  25    263         D    A
## 2       1  28    111         D    B
## 3       2  25    279         D    C
## 4       2  28    117         D    D
## 5       3  25    172         D    E
## 6       3  28    221         D    F
## 7       1  25    269         N    G
## 8       1  28    113         N    H
## 9       2  25    285         N    I
## 10      2  28    119         N    J
## 11      3  25    178         N    K
## 12      3  28    223         N    L
</code></pre>

<pre><code class="r">dcast(long_data_2,player ~ day_night + age, value.var=&quot;points&quot;)
</code></pre>

<pre><code>##   player D_25 D_28 N_25 N_28
## 1      1  263  111  269  113
## 2      2  279  117  285  119
## 3      3  172  221  178  223
</code></pre>

</body>

</html>
