---
title: "Data Camp Insights"
author: "davegoblue"
date: "June 1, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}

library(tidyverse)

```

## Background and Overview  
DataCamp offer interactive courses related to R Programming.  While some is review, it is helpful to see other perspectives on material.  As well, DataCamp has some interesting materials on packages that I want to learn better (ggplot2, dplyr, ggvis, etc.).  This document summarizes a few key insights from:  

This document is currently split between _v003 and _v003_a and _v003_b and _v003_c due to the need to keep the number of DLL that it opens below the hard-coded maximum.  This introductory section needs to be re-written, and the contents consolidated, at a future date.
  
* R Programming (Introductory R, Intermediate R, Writing Functions in R, Object Oriented Programming in R, Introduction to Tidyverse)  
* Importing and Cleaning Data (Cleaning Data in R, Importing Data in to R)  
* Data Manipulation (dplyr, data.table, xts/zoo, dplyr joins, cases for EDA/Time Series/Pitch Data)  
* Data Visualization (base, ggplot2 parts I/II/III, ggvis, geospatial)  
* Statistics (8 refresher modules)  
* Machine Learning (3 modules + 1 text mining case)  
* R Studio (2 parts) and R Markdown (1 module)  
  
The original DataCamp_Insights_v001 and DataCamp_Insights_v002 documents have been split for this document:  
  
* This DataCamp_Insights_v003 document contains evolving sections on R Programming, Machine Learning, and RStudio / R Markdown  
* Importing and Cleaning Data components have been moved to DataCamp_ImportClean_v002  
* Data Manipulation components have been moved to DataCamp_DataManipulation_v002  
* Visualization components have been moved to DataCamp_Visualization_v002  
* Statistics components have been moved to DataCamp_Statistics_v002  
  
  
***
  

###_Hierarchical and Mixed Effects Models_  
  
Chapter 1 - Overview and Introduction  
  
What is a hierarchical model?  
  
* Hierarchical data is nested within itself, and can be analyzed using the lme package  
	* Example of students in a classroom - may not all be independent of each other due to teacher quality, building conditions, etc.  
    * Hierarchical models can help with pooling means across small sample sizes  
    * Repeated measurements (test scores each year) are also a common example of data that are not truly independent  
* Hierarchical models can include nested models and multi-level models  
* Regression frameworks can include pool information and random effects (vs. fixed effects) and mixed-effects and linear mixed-effects  
* Repeated sampling can have repeated measures modeling  
  
Parts of a regression:  
  
* Linear regression and linear model can be used interchangeably for this course - epsilon is the error term, assumed to be normal with zero mean and constant variance  
* The linear model in R is closely related to analysis of variance (ANOVA)  
	* lm (y ~ x, myData)  
    * anova( lm (y ~ x, myData) )  
* The most basic regression has an intercept, a slope, a single predictor, and an error term  
	* The concept can be extended to multiple regression with additional predictors  
* There are some limitations to the multiple regression approach  
	* Parameter estimates can be very sensitive to other variables - Simpson's paradox and the like  
    * Need to note that the regression coefficient is "after controlling for . . . " (all the other variables)  
    * Interaction terms can be important as well  
* Regressions in R for an intercept for every group are called as lm(y ~ x - 1)  
* The interaction term x1*x2 is the same as x1 + x2 + x1:x2  
  
Random effects in regression:  
  
* Nested relationships tend to be hierarchical in nature - students are part of classes are part of schools and the like  
	* Mathematically, this is referred to as a mapping among the distributions  
* The algebraic representation is that y ~ B*x + eps, with B ~ N(mu, sigma**2)  
	* library(lme4) is the best packages for this in R  
    * lme4::lmer(y ~ x + (1|randomGroup), data=myData)  
    * lme4::lmer(y ~ x + (randomSlope|randomGroup), data=myData)  
  
School data:  
  
* Appliciation of multi-level models to school data - influence of sex, teacher training, plotting parameter estmates  
  
Example code includes:  
```{r}

rawStudent <- read.csv("./RInputFiles/classroom.csv")

studentData <- rawStudent %>%
    mutate(sex=factor(sex, labels=c("male", "female")), minority=factor(minority, labels=c("no", "yes")))


# Plot the data
ggplot(data = studentData, aes(x = housepov, y = mathgain)) +
    geom_point() +
    geom_smooth(method = 'lm')

# Fit a linear model
summary( lm(mathgain ~ housepov , data = studentData))


# I have aggregated the data for you into two new datasets at the classroom- and school-levels (As a side note, if you want to learn how to aggregate data, the dplyr or data.table courses teach these skills)
# We will also compare the model outputs across all three outputs
# Note: how we aggregate the data is important
# I aggregated the data by taking the mean across the student data (in pseudo-code: mean(mathgain) by school or mean(mathgain) by classroom), 
# but another reasonable method for aggregating the data would be to aggregate by classroom first and school second

classData <- studentData %>%
    group_by(schoolid, classid) %>%
    summarize_at(vars(mathgain, mathprep, housepov, yearstea), mean, na.rm=TRUE)
str(classData)

schoolData <- studentData %>%
    group_by(schoolid) %>%
    summarize_at(vars(mathgain, mathprep, housepov, yearstea), mean, na.rm=TRUE)
str(schoolData)


# First, plot the hosepov and mathgain at the classroom-level from the classData data.frame
ggplot(data = classData, aes(x = housepov, y = mathgain)) +
    geom_point() +
    geom_smooth(method = 'lm')

# Second, plot the hosepov and mathgain at the school-level from the schoolData data.frame
ggplot(data = schoolData, aes(x = housepov, y = mathgain)) +
    geom_point() +
    geom_smooth(method = 'lm')

# Third, compare your liner regression results from the previous expercise to the two new models
summary( lm(mathgain ~ housepov, data = studentData)) ## student-level data
summary( lm(mathgain ~ housepov, data = classData)) ## class-level data
summary( lm(mathgain ~ housepov, data = schoolData)) ## school-level data


# Plot the means of your data, predictor is your x-variable, response is your y-variable, and intDemo is your data.frame
intDemo <- data.frame(predictor=factor(c(rep("a", 5), rep("b", 5), rep("c", 5))), 
                      response=c(-1.207, 0.277, 1.084, -2.346, 0.429, 5.759, 4.138, 4.18, 4.153, 3.665, 9.046, 8.003, 8.447, 10.129, 11.919)
                      )
str(intDemo)


ggIntDemo <- ggplot(intDemo, aes(x = predictor, y = response) ) +
    geom_point() +
    theme_minimal() + stat_summary(fun.y = "mean", color = "red",
                                   size = 3, geom = "point") +
    xlab("Intercept groups")
print(ggIntDemo)

# Fit a linear model to your data where response is "predicted by"(~) predictor
intModel <- lm( response ~ predictor - 1 , data = intDemo)
summary(intModel)


extractAndPlotResults <- function(intModel){
    intCoefPlot <- broom::tidy(intModel)
    intCoefPlot$term <- factor(gsub("predictor", "", intCoefPlot$term))

    plotOut <- ggIntDemo + geom_point(data = intCoefPlot,
                           aes(x = term, y = estimate),
                           position = position_dodge(width = 0.4),
                           color = 'blue', size = 8, alpha = 0.25)
    print(plotOut)
}


# Run the next code that extracts out the model's coeffiecents and plots them 
extractAndPlotResults(intModel)


multIntDemo <- data.frame(group=factor(c(rep("a", 5), rep("b", 5), rep("c", 5))), 
                          x=rep(0:4, times=3), 
                          intercept=c(4.11, -1.69, 1.09, 1.9, 1.21, 4.63, 10.29, 4.67, 12.06, 4.78, 15.22, 19.15, 4.44, 8.88, 9.47), 
                          response=c(4.11, 2.31, 9.09, 13.9, 17.21, 4.63, 14.29, 12.67, 24.06, 20.78, 15.22, 23.15, 12.44, 20.88, 25.47)
                          )
str(multIntDemo)

plot_output1 <- function(out1){
    ggmultIntgDemo <- ggplot( multIntDemo, aes(x = x, y = response) ) +
        geom_point(aes(color = group)) +
        theme_minimal() +
        scale_color_manual(values = c("blue", "black", "red")) +
        stat_smooth(method = 'lm', fill = NA, color = 'orange', size = 3)
    print(ggmultIntgDemo)
}

plot_output2 <- function(out2){
    out2Tidy <- broom::tidy(out2)
    out2Tidy$term <- gsub("group", "", out2Tidy$term)
    out2Plot <- data.frame(group = pull(out2Tidy[ -1, 1]),
                           slope = pull(out2Tidy[ 1, 2]),
                           intercept = pull(out2Tidy[ -1, 2])
                           )
    ggmultIntgDemo2 <- ggplot( multIntDemo, aes(x = x, y = response) ) +
        geom_point(aes(color = group))+
        theme_minimal() +
        scale_color_manual(values = c("blue", "black", "red")) +
        geom_abline(data = out2Plot,
                    aes(intercept = intercept, slope = slope, color = group))
    print(ggmultIntgDemo2)
}

plot_output3 <- function(out3){
    ggmultIntgDemo3 <- ggplot( multIntDemo, aes(x = x, y = response) ) +
        geom_point(aes(color = group)) +
        theme_minimal() +
        scale_color_manual(values = c("blue", "black", "red")) +
        stat_smooth(method = 'lm', aes(color = group), fill = NA)
    print(ggmultIntgDemo3)
}

# First, run a model without considering different intercept for each group
out1 <- lm( response ~ x, data=multIntDemo )
summary(out1)
plot_output1(out1)

# Considering same slope but different intercepts
out2 <- lm( response ~ x + group - 1, data=multIntDemo )
summary(out2)
plot_output2(out2)

# Consdering different slope and intercept for each group (i.e., an interaction)
out3 <- lm( response ~ x + group - 1 + x:group, multIntDemo)
summary(out3)
plot_output3(out3)


multIntDemo$intercept <- c(-0.87, 3.35, 1.25, 0.88, -1.05, 4.55, 1.22, 3.34, 1.26, 3.75, 7.71, 9.59, 2.28, 1.9, 13.35)
multIntDemo$response <- c(-0.87, 6.35, 7.25, 9.88, 10.95, 4.55, 4.22, 9.34, 10.26, 15.75, 7.71, 12.59, 8.28, 10.9, 25.35)

# Run model
outLmer <- lme4::lmer( response ~ x + ( 1 | group), multIntDemo)

# Look at model outputs 
summary( outLmer )
broom::tidy( outLmer )


extractAndPlotOutput <- function(outLmer, slope=3){
    multIntDemo$lmerPredict <- predict(outLmer)
    ggmultIntgDemo2 <- ggplot( multIntDemo, aes(x = x, y = response) ) +
        geom_point(aes(color = group))+
        theme_minimal() +
        scale_color_manual(values = c("blue", "black", "red")) +
        geom_abline(data = multIntDemo,
                    aes(intercept = intercept, slope = slope, color = group))
    outPlot <-  ggmultIntgDemo2 +
                geom_line( data =  multIntDemo,
                      aes(x = x, y = lmerPredict, color = group),
                      linetype = 2)
    print(outPlot)
}


# Extract predictor variables and plot
extractAndPlotOutput(outLmer)


# Random effect slopes
multIntDemo$response <- c(-0.72, 1.5, 4.81, 6.61, 13.62, 10.21, 9.64, 11.91, 16.39, 16.97, 8.76, 14.79, 15.83, 15.27, 17.36)
multIntDemo$intercept <- c(-0.72, -1.5, -1.19, -2.39, 1.62, 10.21, 6.64, 5.91, 7.39, 4.97, 8.76, 11.79, 9.83, 6.27, 5.36)

outLmer2 <- lme4::lmer( response ~ ( x|group ), multIntDemo)
summary(outLmer2)
broom::tidy(outLmer2)


plotOutput <- function(outLmer2){
    multIntDemo$lmerPredict2 <- predict(outLmer2)
    ggmultIntgDemo3 <- ggplot( multIntDemo, aes(x = x, y = response) ) +
        geom_point(aes(color = group)) +
        theme_minimal() +
        scale_color_manual(values = c("blue", "black", "red")) +
        stat_smooth(method = 'lm', aes(color = group), fill = NA)
    plotOut <- ggmultIntgDemo3 +
            geom_line( data =  multIntDemo,
                      aes(x = x, y = lmerPredict2, color = group),
                      linetype = 2)
    print(plotOut)
}


# Extract and plot
plotOutput(outLmer2)


# Mixed effect model
lmerModel <- lme4::lmer(mathgain ~ sex + 
                  mathprep + mathknow + (1|classid) +
                  (1|schoolid), data = studentData, na.action = "na.omit",
                  REML = TRUE)
summary(lmerModel)


extractAndPlot <- function(lmerModel){
    modelOutPlot <- broom::tidy(lmerModel, conf.int = TRUE)
    modelOutPlot <- modelOutPlot[ modelOutPlot$group =="fixed" &
                               modelOutPlot$term != "(Intercept)", ]
    plotOut <- ggplot(modelOutPlot, aes(x = term, y = estimate,
                             ymin = conf.low,
                             ymax = conf.high)) +
            theme_minimal() +
            geom_hline(yintercept = 0.0, color = 'red', size = 2.0) +
            geom_point() +
            geom_linerange() + coord_flip()
    print(plotOut)
}


# Extract and plot 
extractAndPlot(lmerModel)

```
  
  
  
***
  
Chapter 2 - Linear Mixed-Effect Models  
  
Linear mixed effect model - Birth rates data:  
  
* Small populations are highly sensitive to stochastic effects - if the mean is 1, a group of 5 might have 0 or 10  
* Questions about how counties may impact birth rates, over and above other demographic factors  
	* Example of plotting birth rate vs. county - will see both the highest and lowest birth rates in the smallest counties  
* Random effect syntax for the lmer model includes  
	* (1 | group) - random intercept with fixed mean  
    * (1 | g1/g2) - intercepts vary among g1 and g2 within g2  
    * (1 | g1) + (1 | g2) - random intercepts for two variables  
    * x + (x | g) - correlated random slope and intercept  
    * x + (x || g) - uncorrelated random slope and intercept  
    * See lme4 documentation for additional details  
  
Understanding and reporting the outputs of lmer:  
  
* The output from lmer is similar to the output from lm, but with some key differences - if using print(), will see  
	* The method used is REML - restricted maximum likelihood - which tends to solve better than maximum likelihood for these problems  
    * There is an REML convergence criteria, which can be a helpful diagnostic  
    * Can see the standard deviations for both the state and the residual, along with the number of observations  
    * Get the fixed effects coefficients in a similar form as lm()  
* The summary() call on lmer produces several additional outputs  
	* Residuals summary  
    * Fixed effects estimates include SE and t-values (but not p-values)  
    * Correlations of fixed effects  
* Can grab only the fixed effects using fixef(myLMERObject)  
	* Can grab only the random effects using ranef(myLMERObject), though these will not have confidence intervals  
    * The random effects confidence intervals could be estimated using bootstrapping or Bayesian methods per the author of lme4 - but actual random effects are just unobserved random variables rather than parameters  
* Can grab only the confidence intervals using confint(myLMERObject)  
* Need to be careful in reporting the results - figures vs. tables vs. in-line descriptions  
  
Statistical inference with Maryland crime data:  
  
* The Maryland crime data is available on data.gov - interesting for many public and private purposes  
* The null hypothsis test can be used with LMER - frequentist approach  
	* By default, lmer does not provide p-values, as there is ongoing debate as to the degrees of freedom and impact on reported results  
    * Can use lmerTest package to calculate and report on the p-values  
* Can use ANOVA to look at the variability explained by one model versus another model, and the associated degrees of freedom needed  
  
Example code includes:  
```{r}

# Read in births data
rawBirths <- read.csv("./RInputFiles/countyBirthsDataUse.csv")
countyBirthsData <- rawBirths
str(countyBirthsData)


# First, build a lmer with state as a random effect. Then look at the model's summary and the plot of residuals. 
birthRateStateModel <- lme4::lmer(BirthRate ~ (1|State), data=countyBirthsData)
summary(birthRateStateModel)
plot(birthRateStateModel)

# Next, plot the predicted values from the model ontop of the plot shown during the video.
countyBirthsData$birthPredictState <- predict(birthRateStateModel, countyBirthsData)
ggplot() + theme_minimal() +
    geom_point(data =countyBirthsData, aes(x = TotalPopulation, y = BirthRate)) + 
    geom_point(data = countyBirthsData, aes(x = TotalPopulation, y = birthPredictState),
               color = 'blue', alpha = 0.5
               )

# Include the AverageAgeofMother as a fixed effect within the lmer and state as a random effect
ageMotherModel <- lme4::lmer( BirthRate ~ AverageAgeofMother + (1|State), data=countyBirthsData)
summary(ageMotherModel)

# Compare the random-effect model to the linear effect model 
summary(lm(BirthRate ~ AverageAgeofMother, data = countyBirthsData))


# Include the AverageAgeofMother as a correlated random-effect slope parameter
ageMotherModelRandomCorrelated <- lme4::lmer(BirthRate ~ AverageAgeofMother + (AverageAgeofMother|State),
                       countyBirthsData)
summary(ageMotherModelRandomCorrelated)


# Include the AverageAgeofMother as a correlated random-effect slope parameter
ageMotherModelRandomUncorrelated <- lme4::lmer(BirthRate ~ AverageAgeofMother + 
                                                    (AverageAgeofMother || State), data=countyBirthsData
                                               )
summary(ageMotherModelRandomUncorrelated)


out <- ageMotherModelRandomUncorrelated

# Extract the fixed-effect coefficients
lme4::fixef(out)

# Extract the random-effect coefficients
lme4::ranef(out)

# Estimate the confidence intervals 
(ciOut <- confint(out))


# Technical note: Extracting out the regression coefficients from lmer is tricky (see discussion between the lmer and broom authors development)
# Extract out the parameter estimates and confidence intervals and manipulate the data
dataPlot <- data.frame(cbind( lme4::fixef(out), ciOut[ 4:5, ]))
rownames(dataPlot)[1] <- "Intercept"
colnames(dataPlot) <- c("mean", "l95", "u95")
dataPlot$parameter <- rownames(dataPlot)

# Print the new dataframe
print(dataPlot)

# Plot the results using ggplot2
ggplot(dataPlot, aes(x = parameter, y = mean,
                     ymin = l95, ymax = u95)) +
    geom_hline( yintercept = 0, color = 'red' ) +
    geom_linerange() + geom_point() + coord_flip() + theme_minimal()



# Read in crime data
rawCrime <- read.csv("./RInputFiles/MDCrime.csv")
MDCrime <- rawCrime
str(MDCrime)


plot1 <- ggplot(data = MDCrime, aes(x = Year, y = Crime, group = County)) +
    geom_line() + theme_minimal() +
    ylab("Major crimes reported per county")
print(plot1)

plot1 + geom_smooth(method = 'lm')


# Null hypothesis testing uses p-values to see if a variable is "significant"
# Recently, the abuse and overuse of null hypothesis testing and p-values has caused the American Statistical Association to issue a statement about the use of p-values
# Because of these criticisms and other numerical challenges, Doug Bates (the creator of the lme4 package) does not include p-values as part of his package
# However, you may still want to estimate p-values, because p-values are sill commonly used. Several packages exist, including the lmerTest package
# https://www.amstat.org/asa/files/pdfs/P-ValueStatement.pdf

# Load lmerTest
# library(lmerTest)

# Fit the model with Year as both a fixed and random-effect
lme4::lmer(Crime ~ Year + (1 + Year | County) , data = MDCrime)

# Fit the model with Year2 rather than Year
out <- lme4::lmer(Crime ~ Year2 + (1 + Year2 | County) , data = MDCrime)

# Examine the model's output
summary(out)


## Build the Null model with only County as a random-effect
null_model <- lme4::lmer(Crime ~ (1 | County) , data = MDCrime)

## Build the Year2 model with Year2 as a fixed and random slope and County as the random-effect
year_model <- lme4::lmer(Crime ~ Year2 + (1 + Year2 | County) , data = MDCrime)

## Compare the two models using an anova
anova(null_model, year_model)

```
  
  
  
***
  
Chapter 3 - Generalized Linear Mixed-Effect Models  
  
Crash course on GLMs - relaxing the assumptions around normality of the residuals:  
  
* Non-normal data can be transformed using arcsin or the like  
* However, with advances in methodology, it is possible to more directly model the data using binomial and poisson distributions  
* The basic glm call is glm(y ~ x, family="")  # default is family="gaussian", which same as the lm()  
* The Poisson distribution is frequently best for count data, such as website visitors per hour - mean equals variance (generally best for small counts less than 30; can use normals for large counts)  
* For logistic regression, data can be entered in any of three formats  
	* Binary (y=0 or 1) - glm(y ~ x, family="binomial")  
    * Wilkinson-Rogers - glm(cbind(success, failure) ~ x, family="binomial")  
    * Weighted - glm(y ~ x, weights=weights, family="binomial")  
    * These methods differ primarily in the degrees of freedom (and thus deviance)  
  
Binomial data - modeling data with only two outcomes:  
  
* Traditional method for analysis includes looking at proportion of successes  
* The GLM allows for direct looks at the data - logistic regression (logit)  
* Binomial data can be fit using glmer(y ~ x + (1/group), family="error term")  
* The regression coefficients can be difficult to explain, sometimes leading to the use of odds ratios instead  
	* The odds ratio of 2.0 would mean 2:1 odds for that specific group  
  
Count data:  
  
* Examples like number of events per hour (website hits) or counts per area (birds)  
* The count data differs from the binomial in that there is no pre-specified upper boundary  
* While Chi-squared is often used for goodness of fit or test of association for count data, the Poisson GLM can be a nice alternative  
	* glm(y ~ x, family="poisson")  
    * glmer(y ~ x + (1|group), family="poisson")  
  
Example code includes:  
```{r cache=TRUE}

# In this case study, we will be working with simulated dose-response data
# The response is mortality (1) or survival (0) at the end of a study. During this exercise, we will fit a logistic regression using all three methods described in the video
# You have been given two datasets. dfLong has the data in a "long" format with each row corresponding to an observation (i.e., a 0 or 1)
# dfShort has the data in an aggregated format with each row corresponding to a treatment (e.g., 6 successes, 4 failures, number of replicates = 10, proportion = 0.6)

dfLong <- data.frame(dose=c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10), 
                     mortality=c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1)
                     )
str(dfLong)

dfShort <- dfLong %>% 
    group_by(dose) %>%
    summarize(mortality=sum(mortality), nReps=n()) %>%
    mutate(survival=nReps-mortality, mortalityP=mortality/nReps)
dfShort


# Fit a glm using data in a long format
fitLong <- glm(mortality ~ dose, data = dfLong, family = "binomial")
summary(fitLong)

# Fit a glm using data in a short format with two columns
fitShort <- glm( cbind(mortality , survival ) ~ dose , data = dfShort, family = "binomial")
summary(fitShort)

# Fit a glm using data in a short format with weights
fitShortP <- glm( mortalityP ~ dose , data = dfShort, weights = nReps , family = "binomial")
summary(fitShortP)


y <- c(0, 1, 0, 1, 0, 1, 0, 1, 0, 2, 1, 2, 0, 1, 1, 0, 1, 5, 1, 1)
x <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)


# Fit the linear model
summary(lm(y ~ x))

# Fit the generalized linear model
summary(glm(y ~ x, family = "poisson"))


# Often, we want to "look" at our data and trends in our data
# ggplot2 allows us to add trend lines to our data
# The defult lines are created using a technique called local regression
# However, we can specify different models, including GLMs
# During this exercise, we'll see how to plot a GLM

# Plot the data using jittered points and the default stat_smooth
ggplot(data = dfLong, aes(x = dose, y = mortality)) + 
    geom_jitter(height = 0.05, width = 0.1) +
    stat_smooth(fill = 'pink', color = 'red') 

# Plot the data using jittered points and the the glm stat_smooth
ggplot(data = dfLong, aes(x = dose, y = mortality)) + 
    geom_jitter(height = 0.05, width = 0.1) +
    stat_smooth(method = 'glm',  method.args = list(family = "binomial"))


# library(lmerTest)

df <- data.frame(dose=rep(rep(c(0, 2, 4, 6, 8, 10), each=20), times=3), 
                 mortality=c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1), 
                 replicate=factor(rep(letters[1:3], each=120))
                 )
str(df)


glmerOut <- lme4::glmer(mortality ~ dose + (1|replicate), family = 'binomial', data = df)
summary(glmerOut)


# library(lmerTest)
# Fit the model and look at its summary 
# modelOut <- lme4::glmer( cbind(Purchases, Pass) ~ friend + ranking + (1|city), data = allData, family = 'binomial')
# summary( modelOut) 

# Compare outputs to a lmer model
# summary(lme4::lmer( Purchases/( Purchases + Pass) ~ friend + ranking + (1|city), data = allData))


# Run the code to see how to calculate odds ratios
# summary(modelOut) 
# exp(fixef(modelOut)[2])
# exp(confint(modelOut)[3, ])


# Load lmerTest
# library(lmerTest)


userGroups <- data.frame(group=factor(rep(rep(LETTERS[1:4], each=10), times=2)), 
                         webpage=factor(rep(c("old", "new"), each=40)), 
                         clicks=c(0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 1, 1, 1, 2, 0, 1, 1, 0, 3, 2, 3, 1, 2, 4, 2, 1, 0, 2, 0, 1, 2, 0, 2, 1, 1, 2, 4, 2, 8, 1, 1, 1, 2, 1, 1, 0, 0, 3, 0, 1, 4, 1, 2, 0, 1, 1, 0, 0, 3, 2, 0, 3, 1, 2, 2, 0, 2, 3, 1, 3, 2, 4, 4, 2, 1, 5, 2)
                         )
str(userGroups)


# Fit a Poisson glmer
summary( lme4::glmer(clicks ~ webpage + (1|group), family = 'poisson', data = userGroups))


# library(lmerTest)


rawIL <- read.csv("./RInputFiles/ILData.csv")
ILdata <- rawIL
str(ILdata)

# Age goes before year
modelOut <- lme4::glmer(count ~ age + year + (year|county), family = 'poisson', data = ILdata)
summary(modelOut)


# Extract out fixed effects
lme4::fixef(modelOut)

# Extract out random effects 
lme4::ranef(modelOut)


# Run code to see one method for plotting the data
ggplot(data = ILdata, aes(x = year, y = count, group = county)) +
    geom_line() +
    facet_grid(age ~ . ) +
    stat_smooth( method = 'glm',
                method.args = list( family = "poisson"), se = FALSE,
                alpha = 0.5) +
    theme_minimal()

```
  
  
  
***
  
Chapter 4 - Repeated Measures  
  
An introduction to repeated measures:  
  
* Sampling the same thing over time is a repeated measure, a specific example of a mixed effects model  
	* Follow the same individual through time - cohorts allow for controlling for individuality  
    * The paired t-test is often used for assessing a repeated measures dataset - t.test(x1, x2, paired=TRUE)  # x1 and x2 need to be the same length and each element needs to be the same individual  
* Repeated measures ANOVA is a conceptual extension of the paired t-test - are the means constant over time  
	* anova(lmer(y ~ time + (1|individual)))  
    * Can be used with glmer() also  
    * Note that degrees of freedom is still an open question - different packages calculate this differently  
  
Sleep study:  
  
* Applying LMER to the sleep study dataset - impact of drugs on sleep patterns for 10 patients followed over time  
	* This is the classic "Student" dataset due to Guinness at the time not allowing its employees to publish  
    * Ho will be that the amount of sleep does not vary with the treatments  
    * Modeling will be done using a linear mixed model  
* Modeling approach - iteratively;  
	* EDA  
    * Simple regression  
    * Model of interest  
    * Extract information from model  
    * Visualize final data  
  
Hate in NY state?  
  
* Change in rate of hate crimes over time by county - available from data.gov for 2010-2016  
* Level of technical details in reporting should vary significantly by audience - blend data in to story for wider audiences, while being reporducible/technical for a scientifc audience  
  
Wrap up:  
  
* Hiearchical data, mixed effects models, case studies  
* Start with the LME4 documentation for additional explorations and details  
  
Example code includes:  
```{r}

y <- c(0.23, 2.735, -0.038, 6.327, -0.643, 1.69, -1.378, -1.228, -0.252, 2.014, -0.073, 6.101, 0.213, 3.127, -0.29, 8.395, -0.33, 2.735, 0.223, 1.301)
treat <- rep(c("before", "after"), times=10)
x <- rep(letters[1:10], each=2)

# Run a standard, non-paired t-test
t.test(y[treat == "before"], y[treat == "after"], paired = FALSE)

# Run a standard, paired t-test
t.test(y[treat == "before"], y[treat == "after"], paired = TRUE)


library(lmerTest)
library(lme4)

# Run the paired-test like before
t.test(y[treat == "before"], y[treat == "after"], paired = TRUE)

# Run a repeated-measures ANOVA
anova(lmer( y ~ treat + (1|x)))


data(sleepstudy, package="lme4")
str(sleepstudy)

# Plot the data
ggplot(data = sleepstudy) +
    geom_line(aes(x = Days, y = Reaction, group = Subject)) +
    stat_smooth(aes(x = Days, y = Reaction), method = 'lm', size = 3, se = FALSE)

# Build a lm 
lm( Reaction ~ Days, data = sleepstudy)

# Build a lmer
(lmerOut <- lmer( Reaction ~ Days + (1|Subject), data = sleepstudy))


# The lmer model you built during the previous exercise has been saved as lmerOut
# During this exercise, you will examine the effects of drug type using both an ANOVA framework and a regression framework

# Run an anova
anova(lmerOut)

# Look at the regression coefficients
summary(lmerOut)


# Read in NY hate data
rawHate <- read.csv("./RInputFiles/hateNY.csv")
hate <- rawHate
str(hate)


ggplot( data = hate, aes(x = Year, y = TotalIncidents, group = County)) +
    geom_line() + 
    geom_smooth(method = 'lm', se = FALSE)


# During this exercise, you will build a glmer
# Because most of the incidents are small count values, use a Poisson (R function family poisson) error term
# First, build a model using the actually year (variable Year, such as 2006, 2007, etc) - this model will fail
# Second, build a model using the rescaled year (variable Year2, such as 0, 1, 2, etc)
# This demonstrates the importance of considering where the intercept is located when building regression models
# Recall that a variable x can be both a fixed and random effect in a lmer() or glmer(): for example lmer(y ~ x + (x| group) demonstrates this syntax

# glmer with raw Year
glmer(TotalIncidents ~ Year + (Year|County), data = hate, family = "poisson")

# glmer with scaled Year, Year2
glmerOut <- glmer(TotalIncidents ~ Year2 + (Year2|County), data = hate, family = "poisson")
summary(glmerOut)


# Extract and manipulate data
countyTrend <- ranef(glmerOut)$County
countyTrend$county <- factor(row.names(countyTrend), levels =row.names(countyTrend)[order(countyTrend$Year2)])

# Plot results 
ggplot(data = countyTrend, aes(x = county, y = Year2)) + geom_point() +
    coord_flip() + 
    ylab("Change in hate crimes per year")  +
    xlab("County")

```
  
  
  
***
  
###_Forecasting Product Demand in R_  
  
Chapter 1 - Forecasting Demand with Time Series  
  
Loading data in to an xts object:  
  
* The xts object will be the buidling block for the course - extensible time series (xts) is an extension of the zoo package - basically, a time index attached to the data matrix  
* Can create dates using dates=seq(as.Date("MM-DD-YYYY"), length=, by="weeks")  # to create weekly data  
	* xts(myData, order.by=dates)  # will create an XTS using dates as the index  
  
ARIMA Time Series 101:  
  
* AR - AutoRegressive (lags help to determine today's values - "long memory models")  
* MA - Moving Average (shocks/errors help to determine today's shocks/errors - "short memory models" due to dissipation)  
* I - Integrated (does the data have a dependency across time, and how long does it last) - make the time series stationary  
	* Stationarity is the idea that effects disipate over time - today has more impact on tomorrow than on time periods in the future  
    * Differencing (monthly, seasonal, etc.) the data can be a useful approach for data with stationarity  
* Begin by creating training dataset and valiadation training dataset  
* The auto.arima() function tries to estimate the best ARIMA for a given data series  
	* ARIMA(p, d, q) is ARIMA(AR, Differencing, MA)  
  
Forecasting and Evaluating:  
  
* Can use the ARIMA data to forecast the data forward - extrapolating the signal (forecasting) and estimating the amount of noise (error or CI)  
* The forecast() function in R simplifies the process - forecast(myModel, h=) which will forecast forward h time periods  
* Two common error measurements include MAE (mean average error) and MAPE (mean average percentage error)  
	* MAPE is better at putting things on a common scale  
  
Example code includes:  
```{r}


# Read in beverages data
rawBev <- read.csv("./RInputFiles/Bev.csv")
bev <- rawBev
str(bev)


# Load xts package 
library(xts)
library(forecast)


# Create the dates object as an index for your xts object
dates <- seq(as.Date("2014-01-19"), length = 176, by = "weeks")

# Create an xts object called bev_xts
bev_xts <- xts(bev, order.by = dates)


# Create the individual region sales as their own objects
MET_hi <- bev_xts[,"MET.hi"]
MET_lo <- bev_xts[,"MET.lo"]
MET_sp <- bev_xts[,"MET.sp"]

# Sum the region sales together
MET_t <- MET_hi + MET_lo + MET_sp

# Plot the metropolitan region total sales
plot(MET_t)


# Split the data into training and validation
MET_t_train <- MET_t[index(MET_t) < "2017-01-01"]
MET_t_valid <- MET_t[index(MET_t) >= "2017-01-01"]

# Use auto.arima() function for metropolitan sales
MET_t_model <- auto.arima(MET_t_train)


# Forecast the first 22 weeks of 2017
forecast_MET_t <- forecast(MET_t_model, h = 22)

# Plot this forecast #
plot(forecast_MET_t)


# Convert to numeric for ease
for_MET_t <- as.numeric(forecast_MET_t$mean)
v_MET_t <- as.numeric(MET_t_valid)

# Calculate the MAE
MAE <- mean(abs(for_MET_t - v_MET_t))

# Calculate the MAPE
MAPE <- 100*mean(abs(for_MET_t - v_MET_t)/v_MET_t)

# Print to see how good your forecast is!
print(MAE)
print(MAPE)


# Convert your forecast to an xts object
for_dates <- seq(as.Date("2017-01-01"), length = 22, by = "weeks")
for_MET_t_xts <- xts(forecast_MET_t$mean, order.by = for_dates)

# Plot the validation data set
plot(for_MET_t_xts, main = 'Forecast Comparison', ylim = c(4000, 8500))

# Overlay the forecast of 2017
lines(MET_t_valid, col = "blue")


# Plot the validation data set
plot(MET_t_valid, main = 'Forecast Comparison', ylim = c(4000, 8500))

# Overlay the forecast of 2017
lines(for_MET_t_xts, col = "blue")

# Convert the limits to xts objects
lower <- xts(forecast_MET_t$lower[, 2], order.by = for_dates)
upper <- xts(forecast_MET_t$upper[, 2], order.by = for_dates)

# Adding confidence intervals of forecast to plot
lines(lower, col = "blue", lty = "dashed")
lines(upper, col = "blue", lty = "dashed")

```
  
  
  
***
  
Chapter 2 - Components of Demand  
  
Price elasticity:  
  
* Price is one of the obvious factors that impacts demand, with the relationship called price elasticity (% dDemand / % dPrice)  
	* Elastic goods have elasticity > 1, meaning demand changes more quickly (percentage wise) than price  
    * Inelastic goods have elasticity < 1, for example gasoline  
    * Unit elastic goods have elasticity = 1, meaning that X% increase in price drives X% decrease in demand  
    * Linear regression can be employed to estimate the elasticity for a given product - the log-log transform helps get the % vs % coefficients  
  
Seasonal/holiday/promotional effects:  
  
* Seasonal products are common - can be bought any time of the year, though certain seasons have higher demand (holidays are a common example)  
* Promotions are attempts by companies to influence demand  
* Linear regression can help determine relationships between demand and many other factors  
	* If an xts vector has been created for key dates, can merge(train, holiday, fill=0) and the holiday column will be 0 wherever there is no match to holiday  
  
Forecasting with regression:  
  
* Forecasting with time series is straightforward due to the lag nature of the models - tomorrow forecasts today and today forecasts tomorrow and etc.  
* Forecasting with regression can be more tricky, particularly since we need the future inputs (such as price) in order to predict the future demand  
	* Even when there are contractually fixed prices, promotions can effectively create a de facto price change anyways  
* Need to have the same column names in the test/validation dataset as were used in the modeling  
	* Then, can use predict(myModel, myData)  
    * May need to exponentiate in case the data are currently on the log scale rather than the absolute scale  
  
Example code includes:  
```{r}

bev_xts_train <- bev_xts[index(bev_xts) < "2017-01-01"]
bev_xts_valid <- bev_xts[index(bev_xts) >= "2017-01-01"]

# Save the prices of each product
l_MET_hi_p <- log(as.vector(bev_xts_train[, "MET.hi.p"]))

# Save as a data frame
MET_hi_train <- data.frame(as.vector(log(MET_hi[index(MET_hi) < "2017-01-01"])), l_MET_hi_p)
colnames(MET_hi_train) <- c("log_sales", "log_price")

# Calculate the regression
model_MET_hi <- lm(log_sales ~ log_price, data = MET_hi_train)


# Plot the product's sales
plot(MET_hi)

# Plot the product's price
MET_hi_p <- bev_xts_train[, "MET.hi.p"]
plot(MET_hi_p)


# Create date indices for New Year's week
n.dates <- as.Date(c("2014-12-28", "2015-12-27", "2016-12-25"))

# Create xts objects for New Year's
newyear <- as.xts(rep(1, 3), order.by = n.dates)

# Create sequence of dates for merging
dates_train <- seq(as.Date("2014-01-19"), length = 154, by = "weeks")

# Merge training dates into New Year's object
newyear <- merge(newyear, dates_train, fill = 0)


# Add newyear variable to your data frame
MET_hi_train <- data.frame(MET_hi_train, newyear=as.vector(newyear))

# Build regressions for the product
model_MET_hi_full <- lm(log_sales ~ log_price + newyear, data = MET_hi_train)


# Subset the validation prices #
l_MET_hi_p_valid <- log(as.vector(bev_xts_valid[, "MET.hi.p"]))

# Create a validation data frame #
MET_hi_valid <- data.frame(l_MET_hi_p_valid)
colnames(MET_hi_valid) <- "log_price"


# Predict the log of sales for your high end product
pred_MET_hi <- predict(model_MET_hi, MET_hi_valid)

# Convert predictions out of log scale
pred_MET_hi <- exp(pred_MET_hi)


# Convert to an xts object
dates_valid <- seq(as.Date("2017-01-01"), length = 22, by = "weeks")
pred_MET_hi_xts <- xts(pred_MET_hi, order.by = dates_valid)

# Plot the forecast
plot(pred_MET_hi_xts)

# Calculate and print the MAPE
MET_hi_v <- bev_xts_valid[,"MET.hi"]

MAPE <- 100*mean(abs((pred_MET_hi_xts - MET_hi_v)/MET_hi_v))
print(MAPE)

```
  
  
  
***
  
Chapter 3 - Blending Regression with Time Series  
  
Residuals from regression model:  
  
* The residuals from the regression models can be used for further modeling - see if the residuals are related over time, and model them with time series if so  
* Need to start by gathering the residuals and then converting them to an XTS object - explore for patterns in this XTS object  
  
Forecasting residuals:  
  
* When the residuals are related across time, we can use time series to model the residuals - basically, patterns to the errors provide an opportunity for further modeling  
* Can use auto.arima() on the residuals data, to see what the best ARIMA model for the residuals is  
	* Can then forecast the residuals in to the future using forecast(myModel, h=) # h being the time periods to predict forward  
  
Transfer functions and ensembling:  
  
* Techniques for combining forecasts - single model (transfer function) or averaging of models (ensembling)  
* Demand can be based on both regression (modeling external factors) and time series (residuals)  
* Ensembling is a combination (blend) of the forecasts, with simple averaging being the simplest approach  
	* Basically, build a stand-alone time series model and a stand-alone regression model  
    * The ensemble forecast can be better or worse than any of the stand-alone models  
  
Example code includes:  
```{r}

# Calculate the residuals from the model
MET_hi_full_res <- resid(model_MET_hi_full)

# Convert the residuals to an xts object
MET_hi_full_res <- xts(MET_hi_full_res, order.by = dates_train)


# Plot the histogram of the residuals
hist(MET_hi_full_res)

# Plot the residuals over time
plot(MET_hi_full_res)


# Build an ARIMA model on the residuals: MET_hi_arima
MET_hi_arima <- auto.arima(MET_hi_full_res)

# Look at a summary of the model
summary(MET_hi_arima)


# Forecast 22 weeks with your model: for_MET_hi_arima
for_MET_hi_arima <- forecast(MET_hi_arima, h=22)

# Print first 10 observations
head(for_MET_hi_arima$mean, n = 10)


# Convert your forecasts into an xts object
dates_valid <- seq(as.Date("2017-01-01"), length = 22, by = "weeks")
for_MET_hi_arima <- xts(for_MET_hi_arima$mean, order.by = dates_valid)

# Plot the forecast
plot(for_MET_hi_arima)


# Convert your residual forecast to the exponential version
for_MET_hi_arima <- exp(for_MET_hi_arima)

# Multiply your forecasts together!
for_MET_hi_final <- for_MET_hi_arima * pred_MET_hi_xts


# Plot the final forecast - don't touch the options!
plot(for_MET_hi_final, ylim = c(1000, 4300))

# Overlay the validation data set
lines(MET_hi_v, col = "blue")


# Calculate the MAE
MAE <- mean(abs(for_MET_hi_final - MET_hi_v))
print(MAE)

# Calculate the MAPE
MAPE <- 100 * mean(abs(for_MET_hi_final - MET_hi_v)/MET_hi_v)
print(MAPE)


# Build an ARIMA model using the auto.arima function
MET_hi_model_arima <- auto.arima(MET_hi)

# Forecast the ARIMA model
for_MET_hi <- forecast(MET_hi_model_arima, h = length(MET_hi_v))

# Save the forecast as an xts object
dates_valid <- seq(as.Date("2017-01-01"), length = 22, by = "weeks")
for_MET_hi_xts <- xts(for_MET_hi$mean, order.by = dates_valid)

# Calculate the MAPE of the forecast
MAPE <- 100 * mean(abs(for_MET_hi_xts - MET_hi_v) / MET_hi_v)
print(MAPE)


# Ensemble the two forecasts together
for_MET_hi_en <- 0.5 * (for_MET_hi_xts + pred_MET_hi_xts)

# Calculate the MAE and MAPE
MAE <- mean(abs(for_MET_hi_en - MET_hi_v))
print(MAE)

MAPE <- 100 * mean(abs(for_MET_hi_en - MET_hi_v) / MET_hi_v)
print(MAPE)

```
  
  
  
***
  
Chapter 4 - Hierarchical Forecasting  
  
Bottom-Up Hierarchical Forecasting:  
  
* The hierarchical data structuring can be an advantage in forecasting, provided that the data has a natural hierarchy  
* The sum of all the lower-level forecasts should equal the higher-level forecasts  
	* Bottom-up: Forecast at the lowest level and aggregate (easiest but requires the most number of forecasts)  
    * Top-down: Forecast at the top level and the apply downwards  
    * Middle-out: Forecast at the middle levels and then apply both upwards and downwards  
  
Top-Down Hierarchical Forecasting:  
  
* The top-down forecasting process is typically quicker but less accurate than the bottom-up forecasting process  
* Two techniques available for top-down reconciliation  
	* Average of historical proportions - mean percentage that each component contributes to the total (calculated by sub-component such as week)  
    * Proportion of historical averages - mean percentage that each component contributes to the total (calculated by aggregate)  
* Reconciled forecasts at lower levels are typically less accurate than the direct forecast of the lower levels  
  
Middle-Out Hierarchical Forecasting:  
  
* Bottom-up forecasting is higher quality but more time-consuming than top-down forecasting  
* The middle-out forecasting method is a sometimes successful blend of the methods, getting decent accuracy at a lesser time commitment  
  
Wrap up:  
  
* Using time series to forecast demand forward  
* Incorporating external factors using linear regression  
* Blending time series and regression approaches  
* Top-down, bottom-up, middle-out approaches to aggregation and forecasting at various levels (hierarchical)  
* Can extend by looking at cross-elasticities (impact of competitor pricing)  
* Can better forecast proportions using time series analysis  
* Additional demand forecasting models include neural networks, exponential smoothing, etc.  
  
Example code includes:  
```{r}

# Build a time series model 
MET_sp_model_arima <- auto.arima(MET_sp)

# Forecast the time series model for 22 periods
for_MET_sp <- forecast(MET_sp_model_arima, h=22)

# Create an xts object
for_MET_sp_xts <- xts(for_MET_sp$mean, order.by=dates_valid)

MET_sp_v <- MET_sp["2017"]

# Calculate the MAPE
MAPE <- 100 * mean(abs(for_MET_sp_xts - MET_sp_v) / MET_sp_v)
print(MAPE)


MET_sp_train <- bev_xts_train %>%
    transform(log_sales = log(MET.sp), log_price=log(MET.sp.p))
MET_sp_train <- MET_sp_train[, c("log_sales", "log_price")]
MET_sp_train$newyear <- 0
MET_sp_train$valentine <- 0
MET_sp_train$christmas <- 0
MET_sp_train$mother <- 0

MET_sp_train[index(MET_sp_train) %in% as.Date(c("2014-12-28", "2015-12-27", "2016-12-25")), "newyear"] <- 1
MET_sp_train[index(MET_sp_train) %in% as.Date(c("2014-02-09", "2015-02-08", "2016-02-07")), "valentine"] <- 1
MET_sp_train[index(MET_sp_train) %in% as.Date(c("2014-12-21", "2015-12-20", "2016-12-18")), "christmas"] <- 1
MET_sp_train[index(MET_sp_train) %in% as.Date(c("2014-05-04", "2015-05-03", "2016-05-01")), "mother"] <- 1


# THE BELOW IS TOTAL NONSENSE
# Build a regression model
model_MET_sp <- lm(log_sales ~ log_price + newyear + valentine + christmas + mother, data = MET_sp_train)


MET_sp_valid <- as.data.frame(bev_xts_valid) %>%
    mutate(log_sales = log(MET.sp), log_price=log(MET.sp.p)) %>%
    select("log_sales", "log_price")
MET_sp_valid$newyear <- 0
MET_sp_valid$valentine <- 0
MET_sp_valid$christmas <- 0
MET_sp_valid$mother <- 0  

MET_sp_valid[7, "valentine"] <- 1
MET_sp_valid[19, "mother"] <- 1
MET_sp_valid$log_sales <- NULL


# Forecast the regression model using the predict function 
pred_MET_sp <- predict(model_MET_sp, MET_sp_valid)

# Exponentiate your predictions and create an xts object
pred_MET_sp <- exp(pred_MET_sp)
pred_MET_sp_xts <- xts(pred_MET_sp, order.by = dates_valid)

# Calculate MAPE
MAPE <- 100*mean(abs((pred_MET_sp_xts - MET_sp_v)/MET_sp_v))
print(MAPE)


# Ensemble the two forecasts
for_MET_sp_en <- 0.5 * (for_MET_sp_xts + pred_MET_sp_xts)

# Calculate the MAPE
MAPE <- 100 * mean(abs(for_MET_sp_en - MET_sp_v) / MET_sp_v)
print(MAPE)


# Copy over pred_MET_lo_xts
pred_MET_lo_xts <- xts(c(2960.6, 2974.1, 2943.2, 2948.6, 2915.6, 2736.4, 2953.9, 3199.4, 2934, 2898.7, 3027.7, 3165.9, 3073.1, 2842.7, 2928.7, 3070.2, 2982.2, 3018, 3031.9, 2879.4, 2993.2, 2974.1), order.by=dates_valid)


# Calculate the metropolitan regional sales forecast
for_MET_total <- pred_MET_hi_xts + for_MET_sp_en + pred_MET_lo_xts

# Calculate a validation data set 
MET_t_v <- bev_xts_valid[,"MET.hi"] + bev_xts_valid[,"MET.lo"] + bev_xts_valid[,"MET.sp"]

# Calculate the MAPE
MAPE <- 100 * mean(abs(for_MET_total - MET_t_v) / MET_t_v)
print(MAPE)


# Create the MET_total data
MET_total <- xts(data.frame(MET.hi=c(5942, 5600, 5541, 6892, 5586, 5943, 6329, 6693, 6938, 6138, 6361, 6378, 5423, 5097, 4937, 5496, 6870, 6626, 6356, 5657, 6577, 7202, 7381, 7404, 7204, 6667, 6153, 6035, 5633, 5283, 5178, 4758, 5058, 5254, 5954, 6166, 6247, 6304, 7202, 6662, 6814, 6174, 5412, 5380, 5674, 6472, 6912, 7404, 8614, 8849, 7174, 6489, 7174, 6555, 6402, 7671, 5012, 4790, 5075, 5238, 5615, 6113, 7706, 7811, 7898, 7232, 6585, 5870, 7084, 5125, 5330, 5553, 6349, 6195, 6271, 5851, 5333, 5854, 5609, 5649, 6051, 6409, 5786, 5190, 5085, 4949, 5151, 5147, 5426, 5509, 6956, 7870, 8224, 6685, 6153, 5802, 5244, 5162, 5036, 5025, 8378, 8944, 7109, 7605, 7846, 7598, 8012, 9551, 6102, 5366, 4932, 4962, 5392, 6194, 7239, 7621, 7460, 7097, 6596, 5848, 8306, 5344, 5848, 6341, 7364, 7269, 7053, 6682, 6971, 7521, 7063, 6298, 6003, 5227, 5047, 4877, 4851, 4628, 4516, 4442, 4935, 5181, 5431, 5866, 5919, 5704, 5957, 6019, 5962, 6021, 5880, 5674, 7439, 7415)),
                 order.by=dates_train
                 )

# Build a regional time series model
MET_t_model_arima <- auto.arima(MET_total)

# Calculate a 2017 forecast for 22 periods
for_MET_t <- forecast(MET_t_model_arima, h=22)

# Make an xts object from your forecast
for_MET_t_xts <- xts(for_MET_t$mean, order.by=dates_valid)

# Calculate the MAPE
MAPE <- 100 * mean(abs(for_MET_t_xts - MET_t_v) / MET_t_v)
print(MAPE)


# Calculate the average historical proportions
prop_hi <- mean(MET_hi/MET_total)
prop_lo <- mean(MET_lo/MET_total)
prop_sp <- mean(MET_sp/MET_total)

# Distribute out your forecast to each product
for_prop_hi <- prop_hi*for_MET_t_xts
for_prop_lo <- prop_lo*for_MET_t_xts
for_prop_sp <- prop_sp*for_MET_t_xts

# Calculate the MAPE's for each product
MAPE_hi <- 100 * mean(abs(for_prop_hi - MET_hi_v) / MET_hi_v)
print(MAPE_hi)

MET_lo_v <- bev_xts_valid[,"MET.lo"]
MAPE_lo <- 100 * mean(abs(for_prop_lo - MET_lo_v) / MET_lo_v)
print(MAPE_lo)

MAPE_sp <- 100 * mean(abs(for_prop_sp - MET_sp_v) / MET_sp_v)
print(MAPE_sp)


# Calculate the average historical proportions
prop_hi_2 <- mean(MET_hi) / mean(MET_total)
prop_lo_2 <- mean(MET_lo) / mean(MET_total)
prop_sp_2 <- mean(MET_sp) / mean(MET_total)

# Distribute out your forecast to each product
for_prop_hi_2 <- prop_hi_2 * for_MET_t_xts
for_prop_lo_2 <- prop_lo_2 * for_MET_t_xts
for_prop_sp_2 <- prop_sp_2 * for_MET_t_xts

# Calculate the MAPE's for each product
MAPE_hi <- 100 * mean(abs(for_prop_hi_2 - MET_hi_v) / MET_hi_v)
print(MAPE_hi)
MAPE_lo <- 100 * mean(abs(for_prop_lo_2 - MET_lo_v) / MET_lo_v)
print(MAPE_lo)
MAPE_sp <- 100 * mean(abs(for_prop_sp_2 - MET_sp_v) / MET_sp_v)
print(MAPE_sp)


SEC_total <- xts(data.frame(SEC.hi=c(700, 775, 789, 863, 765, 759, 757, 747, 746, 709, 749, 786, 796, 726, 727, 723, 778, 755, 739, 740, 723, 695, 727, 707, 725, 684, 667, 698, 727, 722, 748, 695, 742, 739, 715, 724, 686, 671, 688, 682, 710, 700, 672, 680, 695, 780, 751, 693, 809, 881, 703, 712, 768, 796, 808, 904, 641, 662, 693, 725, 719, 736, 715, 722, 732, 745, 689, 705, 811, 739, 744, 700, 745, 735, 732, 722, 721, 732, 750, 714, 752, 677, 731, 674, 720, 675, 741, 722, 715, 719, 649, 697, 743, 733, 772, 698, 690, 734, 713, 644, 788, 833, 749, 731, 670, 675, 675, 993, 773, 751, 697, 677, 750, 723, 780, 763, 721, 701, 704, 684, 985, 791, 731, 714, 704, 694, 685, 652, 708, 754, 747, 705, 711, 699, 712, 745, 706, 665, 666, 692, 676, 696, 689, 697, 689, 717, 697, 708, 660, 707, 715, 680, 922, 888)), order.by=dates_train
                 )

# Build a time series model for the region
SEC_t_model_arima <- auto.arima(SEC_total)

# Forecast the time series model
for_SEC_t <- forecast(SEC_t_model_arima, h=22)

# Make into an xts object
for_SEC_t_xts <- xts(for_SEC_t$mean, order.by=dates_valid)

SEC_t_v <- bev_xts_valid$SEC.hi + bev_xts_valid$SEC.lo
# Calculate the MAPE
MAPE <- 100 * mean(abs(for_SEC_t_xts - SEC_t_v) / SEC_t_v)
print(MAPE)


SEC_hi <- bev_xts_train[, "SEC.hi"]
SEC_lo <- bev_xts_train[, "SEC.lo"]
SEC_hi_v <- bev_xts_valid[, "SEC.hi"]
SEC_lo_v <- bev_xts_valid[, "SEC.lo"]

# Calculate the average of historical proportions
prop_hi <- mean(SEC_hi / SEC_total)
prop_lo <- mean(SEC_lo / SEC_total)

# Distribute the forecast
for_prop_hi <- prop_hi * for_SEC_t_xts
for_prop_lo <- prop_lo * for_SEC_t_xts

# Calculate a MAPE for each product
MAPE_hi <- 100 * mean(abs(for_prop_hi - SEC_hi_v) / SEC_hi_v)
print(MAPE_hi)

MAPE_lo <- 100 * mean(abs(for_prop_lo - SEC_lo_v) / SEC_lo_v)
print(MAPE_lo)


# Copy over for_M_t_xts data
for_M_t_xts <- xts(c(2207, 2021, 2010, 2052, 2075, 2074, 2065, 2058, 2056, 2055, 2053, 2052, 2050, 2049, 2048, 2047, 2046, 2045, 2044, 2043, 2043, 2042), order.by=dates_valid)

# Calculate the state sales forecast: for_state
for_state = for_SEC_t_xts + for_MET_t_xts + for_M_t_xts

# See the forecasts
for_state

```
  
  
  
***
  
###_HR Analytics in R: Exploring Employee Data_  
  
Chapter 1 - Identifying the Best Recruiting Source  
  
Introduction - Ben Teusch, HR Analytics Consultant:  
  
* HR analytics has many other names - people analytics, workforce analytics, etc.  
* Identify groups for comparison - high vs. low performers, groups with high vs. low turnover, etc.  
	* Exploratory analysis and statistics for each group, including plots of key differences  
* Course is outlines as a series of case studies, with one case per chapter  
  
Recruiting and quality of hire:  
  
* Where are the best hires coming from, and how can you get more of them  
	* Defining quality of hire is challenging - some mix of productivity, satisfaction, retention, performance reviews, etc.  
    * Attrition can be defined as the mean of a 1, 0 vector of "did the person leave in the time period T"  
  
Visualizing recruiting data:  
  
* Helpful for communicating findings to decision makers  
* The geom_col() in ggplot will make a bar chart, with the y aestehtic being the bar height  
  
Example code includes:  
```{r}

# Import the recruitment data
recruitment <- readr::read_csv("./RInputFiles/recruitment_data.csv")

# Look at the first few rows of the dataset
head(recruitment)

# Get an overview of the recruitment data
summary(recruitment)

# See which recruiting sources the company has been using
recruitment %>% 
  count(recruiting_source)


# Find the average sales quota attainment for each recruiting source
avg_sales <- recruitment %>% 
  group_by(recruiting_source) %>% 
  summarize(avg_sales_quota_pct=mean(sales_quota_pct))

# Display the result
avg_sales


# Find the average attrition for the sales team, by recruiting source, sorted from lowest attrition rate to highest
avg_attrition <- recruitment %>%
  group_by(recruiting_source) %>% 
  summarize(attrition_rate=mean(attrition)) %>%
  arrange(attrition_rate)

# Display the result
avg_attrition

# Plot the bar chart
avg_sales %>% ggplot(aes(x=recruiting_source, y=avg_sales_quota_pct)) + geom_col()

# Plot the bar chart
avg_attrition %>% ggplot(aes(x=recruiting_source, y=attrition_rate)) + geom_col()

```
  
  
  
***
  
Chapter 2 - What is driving low employee engagement  
  
Analyzing employee engagement:  
  
* Gallup defines engaged employees as those who are involved in, enthusiastic about, and committed to their workplace  
* Survey data are available in the example case study  
	* Will use both mutate() and ifelse()  
    * The ifelse() is needed for vectors of length > 1 since it can work in a vectorized manner (and is thus OK inside the mutate call)  
  
Visualizing the engagement data:  
  
* Multiple attributes in a single place can make for a more compelling report  
* The tidyr package is part of the tidyverse, and hslps arrange the data properly for plotting  
	* tidyr::gather(columns, key="key", value="value") will be the package used in this example - pull the data from the columns down to the rows  
    * ggplot(survey_gathered, aes(x = key, y = value, fill = department)) + geom_col(position = "dodge")  
    * ggplot(survey_gathered, aes(x = key, y = value, fill = department)) + geom_col(position = "dodge") + facet_wrap(~ key, scales = "free")  
  
Are differences meaningful?  
  
* Can use significance testing to assess likelhood (p-value) that the second sample could have come from the same population as the first sample  
	* This course will use t-test (continuous variables) and chi-squared test (categorical variables)  
    * t.test(tenure ~ is_manager, data = survey)  
    * chisq.test(survey$left_company, survey$is_manager)  # no data= argument is available in the function  
  
Example code includes:  
```{r}

# Import the data
survey <- readr::read_csv("./RInputFiles/survey_data.csv")

# Get an overview of the data
summary(survey)

# Examine the counts of the department variable
survey %>% count(department)


# Output the average engagement score for each department, sorted
survey %>%
  group_by(department) %>%
  summarize(avg_engagement=mean(engagement)) %>%
  arrange(avg_engagement)


# Create the disengaged variable and assign the result to survey
survey_disengaged <- survey %>% 
  mutate(disengaged = ifelse(engagement <= 2, 1, 0)) 

survey_disengaged

# Summarize the three variables by department
survey_summary <- survey_disengaged %>%
  group_by(department) %>%
  summarize(pct_disengaged=mean(disengaged), 
            avg_salary=mean(salary), 
            avg_vacation_taken=mean(vacation_days_taken)
            )

survey_summary


# Gather data for plotting
survey_gathered <- survey_summary %>% 
  gather(key = "measure", value = "value",
         pct_disengaged, avg_salary, avg_vacation_taken)

# Create three bar charts
ggplot(survey_gathered, aes(x=measure, y=value, fill=department)) +
  geom_col(position="dodge") + 
  facet_wrap(~ measure, scales="free")


# Add the in_sales variable
survey_sales <- survey %>%
  mutate(in_sales = ifelse(department == "Sales", "Sales", "Other"), 
         disengaged = ifelse(engagement < 3, 1L, 0L)
         )

# Test the hypothesis using survey_sales
chisq.test(survey_sales$disengaged, survey_sales$in_sales)
t.test(disengaged ~ in_sales, data=survey_sales)


# Test the hypothesis using the survey_sales data
t.test(vacation_days_taken ~ in_sales, data = survey_sales)

```
  
  
  
***
  
Chapter 3 - Are new hires getting paid too much?  
  
Paying new hires fairly:  
  
* Sometimes, current employees get paid less than new employees, which can drive low engagement and turnover  
* Case study will have a simulated pay dataset available for analysis  
* Can use broom::tidy() to return the outputs in a nicely formatted data frame  
	* chisq.test(survey$in_sales, survey$disengaged) %>% tidy()  
  
Omitted variable bias:  
  
* Key assumption of the tests is that the groups are the same, with the exception of the variables being tested  
* Omitted variable bias occurs when both 1) the omitted variable is correlated with the dependent variable, and 2) the omitted variable is correlated with an explanatory variable  
	* Omitted variables are often known as confounders  
    * Plotting can help to identify the issue, particularly with a stacked (to 100%) bar chart  
    * pay %>% ggplot(aes(x = new_hire, fill = department)) + geom_bar(position = "fill")  
    * The geom_bar() object has height that is fully dependent on x, in contrast to geom_col() which has a y-aestehtic  
  
Linear regression helps to test the multivariate impacts of variables:  
  
* lm(salary ~ new_hire, data = pay) %>% tidy()  # single dependent variable  
* lm(salary ~ new_hire + department, data = pay) %>% tidy()  # multiple dependent variables  
* lm(salary ~ new_hire + department, data = pay) %>% summary()  # more detailed summary of the linear regression  
  
Example code includes:  
```{r}

# Import the data
pay <- readr::read_csv("./RInputFiles/fair_pay_data.csv")

# Get an overview of the data
summary(pay)

# Check average salary of new hires and non-new hires
pay %>% 
  group_by(new_hire) %>%
  summarize(avg_salary=mean(salary))


# Perform the correct statistical test
t.test(salary ~ new_hire, data = pay)
t.test(salary ~ new_hire, data = pay) %>%
  broom::tidy()


# Create a stacked bar chart
pay %>%
  ggplot(aes(x=new_hire, fill=job_level)) + 
  geom_bar(position="fill")

# Calculate the average salary for each group of interest
pay_grouped <- pay %>% 
  group_by(new_hire, job_level) %>% 
  summarize(avg_salary = mean(salary))
  
# Graph the results using facet_wrap()  
pay_grouped %>%
  ggplot(aes(x=new_hire, y=avg_salary)) + 
  geom_col() + 
  facet_wrap(~ job_level)


# Filter the data to include only hourly employees
pay_filter <- pay %>%
  filter(job_level == "Hourly")

# Test the difference in pay
t.test(salary ~ new_hire, data=pay_filter) %>%
  broom::tidy()


# Run the simple regression
model_simple <- lm(salary ~ new_hire, data = pay)

# Display the summary of model_simple
model_simple %>% 
  summary()

# Display a tidy summary
model_simple %>% 
  broom::tidy()


# Run the multiple regression
model_multiple <- lm(salary ~ new_hire + job_level, data = pay)

# Display the summary of model_multiple
model_multiple %>% 
  summary()

# Display a tidy summary
model_multiple %>% 
  broom::tidy()

```
  
  
  
***
  
Chapter 4 - Are performance ratings being given consistently?  
  
Joining HR data:  
  
* Employee data tend to be stored in different locations, requiring joins (merges) prior to running analyses  
	* dplyr::left_join(hr_data, bonus_pay_data, by = "employee_id")  
    * All employees in hr_data will be kept, even if there is no matching record in bonus_pay_data  
    * Employee ID (or similar) is by far the best way to join data - names tend to be non-unique and can differ in different systems  
  
Performance ratings and fairness:  
  
* Performance ratings are inherently subjective and thus prone to bias  
* Unconscious bias is based on the brain's heuristics, and may include preferences for members of various groups (biases, as reflected in hiring, promotion, etc.)  
  
Logistic regression is especially helpful for modeling binary response variables:  
  
* glm(high_performer ~ salary, data = hr, family = "binomial") %>% tidy()  
* glm(high_performer ~ salary + department, data = hr, family = "binomial") %>% tidy()  
  
Example code includes:  
```{r}

# Import the data
hr_data <- readr::read_csv("./RInputFiles/hr_data.csv")
performance_data <- readr::read_csv("./RInputFiles/performance_data.csv")

# Examine the datasets
summary(hr_data)
summary(performance_data)


# Join the two tables
joined_data <- left_join(hr_data, performance_data, by = "employee_id")

# Examine the result
summary(joined_data)

# Check whether the average performance rating differs by gender 
joined_data %>%
  group_by(gender) %>%
  summarize(avg_rating = mean(rating))


# Add the high_performer column
performance <- joined_data %>%  
  mutate(high_performer = ifelse(rating >= 4, 1, 0))

# Test whether one gender is more likely to be a high performer
chisq.test(performance$gender, performance$high_performer)   
 
# Do the same test, and tidy the output
chisq.test(performance$gender, performance$high_performer) %>% broom::tidy()


# Visualize the distribution of high_performer by gender
performance %>%
  ggplot(aes(x=gender, fill=factor(high_performer))) + 
  geom_bar(position="fill")

# Visualize the distribution of all ratings by gender
performance %>%
  ggplot(aes(x=gender, fill=factor(rating))) + 
  geom_bar(position="fill")

# Visualize the distribution of job_level by gender
performance %>%
  ggplot(aes(x = gender, fill = job_level)) +
  geom_bar(position = "fill")
 
# Test whether men and women have different job level distributions
chisq.test(performance$gender, performance$job_level) 


# Visualize the distribution of high_performer by gender, faceted by job level
performance %>%
  ggplot(aes(x = gender, fill = factor(high_performer))) +
  geom_bar(position = "fill") + 
  facet_wrap(~ job_level)


# Run a simple logistic regression
logistic_simple <- glm(high_performer ~ gender, family = "binomial", data = performance) 

# View the result with summary()
logistic_simple %>%
  summary()

# View a tidy version of the result
logistic_simple %>%
  broom::tidy()


# Run a multiple logistic regression
logistic_multiple <- glm(high_performer ~ gender + job_level, family = "binomial", data = performance)

# View the result with summary() or tidy()
logistic_multiple %>% broom::tidy()

```
  
  
  
***
  
Chapter 5 - Improving employee safety with data  
  
Employee safety - looking at accident rates and drivers:  
  
* Requires joining data on multiple variables  
	* joined_data <- left_join(hr_data, safety_data, by = c("year", "employee_id"))  
    * joined_data %>% filter(is.na(accident_time)) # use is.na() instead  
  
Focusing on the location of interest:  
  
* May want to run comparisons of the same location over time  
* May want to assess differences by locations to see if they may be explanatory variables  
  
Explaining the increase in accidents:  
  
* Can use multiple regression to help test for explanatory variables that impact the accident rate  
  
Wrap up:  
  
* Key tools from the Tidyverse (ggplot2, broom, dplyr, etc.) to assess HR data  
* Analytics usage within HR, including differences in HR and other data  
* Can apply additional data science techniques on HR data  
  
Example code includes:  
```{r}

# Import the data 
hr_data <- readr::read_csv("./RInputFiles/hr_data_2.csv")
accident_data <- readr::read_csv("./RInputFiles/accident_data.csv")

# Create hr_joined with left_join() and mutate()
hr_joined <- left_join(hr_data, accident_data, by=c("year", "employee_id")) %>% 
  mutate(had_accident=ifelse(is.na(accident_type), 0, 1))
  
hr_joined


# Find accident rate for each year
hr_joined %>% 
  group_by(year) %>% 
  summarize(accident_rate = mean(had_accident))

# Test difference in accident rate between years
chisq.test(hr_joined$year, hr_joined$had_accident)

# Which location had the highest acccident rate?
hr_joined %>%
  group_by(location) %>%
  summarize(accident_rate=mean(had_accident)) %>%
  arrange(-accident_rate)


# Compare annual accident rates by location
accident_rates <- hr_joined %>% 
  group_by(location, year) %>% 
  summarize(accident_rate = mean(had_accident))
  
accident_rates

# Graph it
accident_rates %>% 
  ggplot(aes(factor(year), accident_rate)) +
  geom_col() +
  facet_wrap(~location)


# Filter out the other locations
southfield <- hr_joined %>% 
  filter(location == "Southfield")

# Find the average overtime hours worked by year
southfield %>%
  group_by(year) %>% 
  summarize(average_overtime_hours = mean(overtime_hours))

# Test difference in Southfield's overtime hours between years
t.test(overtime_hours ~ year, data=southfield) 


# Import the survey data
survey_data <- readr::read_csv("./RInputFiles/survey_data_2.csv")

# Create the safety dataset
safety <- left_join(hr_joined, survey_data, by=c("employee_id", "year")) %>%
  mutate(disengaged=ifelse(engagement <= 2, 1, 0), year=factor(year))


# Visualize the difference in % disengaged by year in Southfield
safety %>% 
    filter(location=="Southfield") %>%
    ggplot(aes(x = year, fill = factor(disengaged))) +
    geom_bar(position = "fill")
 
# Test whether one year had significantly more disengaged employees
southSafety <- safety %>% 
    filter(location=="Southfield")
chisq.test(southSafety$disengaged, southSafety$year)


# Filter out Southfield
other_locs <- safety %>% 
  filter(location != "Southfield")

# Test whether one year had significantly more overtime hours worked
t.test(overtime_hours ~ year, data = other_locs) 

# Test whether one year had significantly more disengaged employees
chisq.test(other_locs$year, other_locs$disengaged)


# Use multiple regression to test the impact of year and disengaged on accident rate in Southfield
regression <- glm(had_accident ~ year + disengaged, family = "binomial", data = southSafety)

# Examine the output
regression %>% broom::tidy()

```
  
  
  
***
  
###_Supervised Learning in R: Case Studies_  
  
Chapter 1 - Cars Data  
  
Making predictions using machine learning:  
  
* Course focuses on applied skills from predictive learning, using regression and classification as well as EDA  
	* Regression tends to be for predicting continuous, numeric variables  
    * Classification tends to be for predicting categorical variables  
* Case studies include 1) fuel efficiency, 2) Stack Overflow developer survey, 3) voter turnout, and 4) ages of nuns  
* The fuel efficiency data is stored in cars2018 and is based on data from the US Department of Energy  
	* Variables names with spaces can be handled by surrounding them with backticks  
    * Tidyverse includes tibble, readr, ggplot2, dplyr, tidyr, purrr, etc. - can be loaded as a package using library(tidyverse)  
  
Getting started with caret:  
  
* The caret package is useful for predictive modeling - full process including the test/train split for the raw dataset  
	* in_train <- createDataPartition(cars_vars$Aspiration, p = 0.8, list = FALSE)  # will stratify on 'Aspiration' variable  
    * training <- cars_vars[in_train,]  
    * testing <- cars_vars[-in_train,]  
* Can then train the model using only the training dataset  
	* fit_lm <- train(log(MPG) ~ ., method = "lm", data=training, trControl=trainControl(method = "none"))  
    * Can then use the yardstick package to assess the quality of the model  
  
Sampling data:  
  
* Bootstrap resampling means sampling with replacement, and then fitting on the resampled dataset (run multiple times)  
	* cars_rf_bt <- train(log(MPG) ~ ., method = "rf", data = training, trControl = trainControl(method = "boot"))  # default 25 resamples  
    * Can both visualize the models and assess the model statistically  
  
Example code includes:  
```{r cache=TRUE}

cars2018 <- readr::read_csv("./RInputFiles/cars2018.csv")
str(cars2018, give.attr = FALSE)
summary(cars2018)

# Print the cars2018 object
cars2018

# Plot the histogram
ggplot(cars2018, aes(x = MPG)) +
    geom_histogram(bins = 25) +
    labs(y = "Number of cars",
         x = "Fuel efficiency (mpg)")


# Deselect the 2 columns to create cars_vars
cars_vars <- cars2018 %>%
    select(-Model, -`Model Index`)

# Fit a linear model
fit_all <- lm(MPG ~ ., data = cars_vars)

# Print the summary of the model
summary(fit_all)


# Load caret
library(caret)

# Split the data into training and test sets
set.seed(1234)
in_train <- createDataPartition(cars_vars$Transmission, p = 0.8, list = FALSE)
training <- cars_vars[in_train, ]
testing <- cars_vars[-in_train, ]

# Train a linear regression model
fit_lm <- train(log(MPG) ~ ., method = "lm", data = training,
                trControl = trainControl(method = "none"))

# Print the model object
fit_lm


# Train a random forest model
fit_rf <- train(log(MPG) ~ ., method = "rf", data = training,
                trControl = trainControl(method = "none"))

# Print the model object
fit_rf


# Create the new columns
results <- training %>%
    mutate(`Linear regression` = predict(fit_lm, training),
           `Random forest` = predict(fit_rf, training))

# Evaluate the performance
yardstick::metrics(results, truth = MPG, estimate = `Linear regression`)
yardstick::metrics(results, truth = MPG, estimate = `Random forest`)


# Create the new columns
results <- testing %>%
    mutate(`Linear regression` = predict(fit_lm, testing),
           `Random forest` = predict(fit_rf, testing))

# Evaluate the performance
yardstick::metrics(results, truth = MPG, estimate = `Linear regression`)
yardstick::metrics(results, truth = MPG, estimate = `Random forest`)


# Fit the models with bootstrap resampling
cars_lm_bt <- train(log(MPG) ~ ., method = "lm", data = training,
                   trControl = trainControl(method = "boot"))
cars_rf_bt <- train(log(MPG) ~ ., method = "rf", data = training,
                   trControl = trainControl(method = "boot"))
                   
# Quick look at the models
cars_lm_bt
cars_rf_bt


results <- testing %>%
    mutate(`Linear regression` = predict(cars_lm_bt, testing),
           `Random forest` = predict(cars_rf_bt, testing))

yardstick::metrics(results, truth = MPG, estimate = `Linear regression`)
yardstick::metrics(results, truth = MPG, estimate = `Random forest`)

results %>%
    gather(Method, Result, `Linear regression`:`Random forest`) %>%
    ggplot(aes(log(MPG), Result, color = Method)) +
    geom_point(size = 1.5, alpha = 0.5) +
    facet_wrap(~Method) +
    geom_abline(lty = 2, color = "gray50") +
    geom_smooth(method = "lm")

```
  
  
  
***
  
Chapter 2 - Stack Overflow Developer Data  
  
Essential copying and pasting from Stack Overflow (largest and most trusted developer community):  
  
* Annual survey of developer perspectives on Stack Overflow - can be used for predictive modeling  
* Data is made available publicly at insights.stackoverflow.com/survey  
* Key question is "what makes a developer more likely to work remotely" (size of company, geography of employee, etc.)  
	* Data are calss imbalanced, with many more Non-Remote employees than Remote employees  
    * Best first step is the simplest model - logit, without any tricks  
    * simple_glm <- stackoverflow %>% select(-Respondent) %>% glm(Remote ~ ., family = "binomial", + data = .)  # Remote ~ . Means "all variables" while data=. Means from the piped dataset  
  
Dealing with imbalanced data:  
  
* Class imbalance is a common problem that can negatively impact model performance  
	* This dataset has 10x the number of non-remote, which can influence models to just start predicting non-remote in all cases  
* One approach to class imbalance is upsampling, basically running resampling with replacement on the small class until it is the same size as the large class  
	* Simple to implement, but with the risk of over-fitting  
    * up_train <- upSample(x = select(training, -Remote), y = training$Remote, yname = "Remote") %>% as_tibble()  
    * stack_glm <- train(Remote ~ ., method = "glm", family = "binomial", data = training, trControl = trainControl(method = "boot", sampling = "up"))  
  
Predicting remote status:  
  
* Classification models can include logistic regression and random forests  
	* stack_glm <- train(Remote ~ ., method = "glm", family = "binomial", data = training, trControl = trainControl(method = "boot", sampling = "up"))  
    * stack_rf <- train(Remote ~ ., method = "rf", data = training, trControl = trainControl(method = "boot", sampling = "up"))  
* Classification models can be evaluated using the confusion matrix  
	* confusionMatrix(predict(stack_glm, testing), testing$Remote)  
    * yardstick::accuracy(testing_results, truth = Remote, estimate = `Logistic regression`)  
    * yardstick::ppv(testing_results, truth = Remote, estimate = `Logistic regression`)  
    * yardstick::npv(testing_results, truth = Remote, estimate = `Logistic regression`)  
  
Example code includes:  
```{r cache=TRUE}

stackoverflow <- readr::read_csv("./RInputFiles/stackoverflow.csv")
stackoverflow$Remote <- factor(stackoverflow$Remote, levels=c("Not remote", "Remote"))
str(stackoverflow, give.attr = FALSE)


# Print stackoverflow
stackoverflow

# First count for Remote
stackoverflow %>% 
    count(Remote, sort = TRUE)

# then count for Country
stackoverflow %>% 
    count(Country, sort = TRUE)


ggplot(stackoverflow, aes(x=Remote, y=YearsCodedJob)) +
    geom_boxplot() +
    labs(x = NULL,
         y = "Years of professional coding experience") 


# Build a simple logistic regression model
simple_glm <- stackoverflow %>%
        select(-Respondent) %>%
        glm(Remote ~ .,
            family = "binomial",
            data = .)

# Print the summary of the model
summary(simple_glm)


stack_select <- stackoverflow %>%
    select(-Respondent)

# Split the data into training and testing sets
set.seed(1234)
in_train <- caret::createDataPartition(stack_select$Remote, p=0.8, list = FALSE)
training <- stack_select[in_train,]
testing <- stack_select[-in_train,]


up_train <- caret::upSample(x = select(training, -Remote), y = training$Remote, yname = "Remote") %>%
    as_tibble()

up_train %>%
    count(Remote)


# Sub-sample to 5% of original
inUse <- sample(1:nrow(training), round(0.05*nrow(training)), replace=FALSE)
useTrain <- training[sort(inUse), ]

# Build a logistic regression model
stack_glm <- caret::train(Remote ~ ., method="glm", family="binomial", data = training, 
                          trControl = trainControl(method = "boot", sampling = "up")
                          )

# Print the model object 
stack_glm


# Build a random forest model
stack_rf <- caret::train(Remote ~ ., method="rf", data = useTrain, 
                         trControl = trainControl(method = "boot", sampling="up")
                         )

# Print the model object
stack_rf


# Confusion matrix for logistic regression model
caret::confusionMatrix(predict(stack_glm, testing), testing$Remote)

# Confusion matrix for random forest model
caret::confusionMatrix(predict(stack_rf, testing), testing$Remote)


# Predict values
testing_results <- testing %>%
    mutate(`Logistic regression` = predict(stack_glm, testing), `Random forest` = predict(stack_rf, testing))

## Calculate accuracy
yardstick::accuracy(testing_results, truth = Remote, estimate = `Logistic regression`)
yardstick::accuracy(testing_results, truth = Remote, estimate = `Random forest`)

## Calculate positive predict value
yardstick::ppv(testing_results, truth = Remote, estimate = `Logistic regression`)
yardstick::ppv(testing_results, truth = Remote, estimate = `Random forest`)

```
  
  
  
***
  
Chapter 3 - Voting  
  
Predicting voter turnout from survey data:  
  
* Survey data available from https://www.voterstudygroup.org/publications/2016-elections/data  
	* Opinions about political and economic topics  
    * Includes whether the voter turned out (voted), based on self-reporting, in the 2016 election  
    * Data are coded as integers, requiring a data dictionary to map the questions and responses to what they mean  
  
Vote 2016:  
  
* Exploratory data analysis will help with learning about the underlying dataset  
	* There are differences on many of the individual dimensions between voters and non-voters  
    * A good first step can be to start with the very simplest model, Dependent ~ .  
  
Cross-validation is the process of sub-dividing the data into folds, with each fold used once as the validation set:  
  
* Allows for more accurate estimates of model performance on out-of-sample error  
* Each process of CV will work through the data k times (assuming there are k folds)  
	* Repeated CV is the process of running CV multiple times (this is particularly well suited to parallel processing)  
  
Comparing model performance:  
  
* Random forest models tend to be more powerful and capable of classifying the training data (and thus subject to risk of overfits and associated poor quality of test set predictions)  
  
Example code includes:  
```{r cache=TRUE}

voters <- readr::read_csv("./RInputFiles/voters.csv")
voters$turnout16_2016 <- factor(voters$turnout16_2016, levels=c("Did not vote", "Voted"))
str(voters, give.attr = FALSE)

# Print voters
voters

# How many people voted?
voters %>%
    count(turnout16_2016)


# How do the reponses on the survey vary with voting behavior?
voters %>%
    group_by(turnout16_2016) %>%
    summarize(`Elections don't matter` = mean(RIGGED_SYSTEM_1_2016 <= 2),
              `Economy is getting better` = mean(econtrend_2016 == 1),
              `Crime is very important` = mean(imiss_a_2016 == 2))


## Visualize difference by voter turnout
voters %>%
    ggplot(aes(econtrend_2016, ..density.., fill = turnout16_2016)) +
    geom_histogram(alpha = 0.5, position = "identity", binwidth = 1) +
    labs(title = "Overall, is the economy getting better or worse?")


# Remove the case_indetifier column
voters_select <- voters %>%
        select(-case_identifier)

# Build a simple logistic regression model
simple_glm <- glm(turnout16_2016 ~ .,  family = "binomial", 
                  data = voters_select)

# Print the summary                  
summary(simple_glm)


# Split data into training and testing sets
set.seed(1234)
in_train <- caret::createDataPartition(voters_select$turnout16_2016, p = 0.8, list = FALSE)
training <- voters_select[in_train, ]
testing <- voters_select[-in_train, ]


# Perform logistic regression with upsampling and no resampling
vote_glm_1 <- caret::train(turnout16_2016 ~ ., method = "glm", family = "binomial", data = training,
                           trControl = trainControl(method = "none", sampling = "up")
                           )

# Print vote_glm
vote_glm_1


useSmall <- sort(sample(1:nrow(training), round(0.1*nrow(training)), replace=FALSE))
trainSmall <- training[useSmall, ]

# Logistic regression
vote_glm <- caret::train(turnout16_2016 ~ ., method = "glm", family = "binomial", data = trainSmall,
                         trControl = trainControl(method = "repeatedcv", repeats = 2, sampling = "up")
                         )

# Print vote_glm
vote_glm


# Random forest
vote_rf <- caret::train(turnout16_2016 ~ ., method = "rf", data = trainSmall,
                        trControl = trainControl(method="repeatedcv", repeats=2, sampling = "up")
                        )

# Print vote_rf
vote_rf


# Confusion matrix for logistic regression model on training data
caret::confusionMatrix(predict(vote_glm, trainSmall), trainSmall$turnout16_2016)

# Confusion matrix for random forest model on training data
caret::confusionMatrix(predict(vote_rf, trainSmall), trainSmall$turnout16_2016)

# Confusion matrix for logistic regression model on testing data
caret::confusionMatrix(predict(vote_glm, testing), testing$turnout16_2016)

# Confusion matrix for random forest model on testing data
caret::confusionMatrix(predict(vote_rf, testing), testing$turnout16_2016)

```
  
  
  
***
  
Chapter 4 - Nuns  
  
Catholic sisters survey from 1967 - https://curate.nd.edu/show/0r967368551 with codebook at https://curate.nd.edu/downloads/0v838051f6x	 
	
* Responses from 130,000 sisters in ~400 congergations  
* There was significant change occuring during this time period, both in society at large and within the community of nuns  
* Age has been binned in groups of 10 years (has been recoded as a numeric at the top of the range, so 20 will mean 11-20 and 30 will mean 21-30 and the like)  
* Historical dataset, centered in the context of nuns in 1967  
* Good first step is to tidy the data, so that it is easier for exploratory data analysis  
	* sisters67 %>% select(-sister) %>% gather(key, value, -age)  
  
Exploratory data analysis with tidy data:  
  
* Easy to see levels of agreement (overall) using dplyr::count()  
* Agreement with specific questions by age  
	* tidy_sisters %>% filter(key %in% paste0("v", 153:170)) %>% group_by(key, value) %>% summarise(age = mean(age)) %>% ggplot(aes(value, age, color = key)) + geom_line(alpha = 0.5, size = 1.5) + geom_point(size = 2) + facet_wrap(~key)  
	* Can use the mix of responses to make estimates about the ages of the nuns  
* Data will be split in to training, validation, and test sets  
	* The validation set will be used for model selection  
  
Predicting age with supervised learning:  
  
* "rpart" - building a tree-based (CART) model  
* "xgbLinear" - extreme gradient boosting  
* "gbm" - gradient boosted ensembles  
* Validation datasets are useful for assessing hyper-parameters and model choices, leaving the test dataset pure for a final out-of-sample error estimate  
  
Wrap up:  
  
* Train-Validation-Test to select the best models, tune the parameters, and estimate the out-of-sample error rates  
* Dealing with class imbalances; improving performance with resamples (bootstraps, cross-validation, etc.)  
* Hyper-parameter tuning can be valuable, but the time investment in other areas can often generate a greater return  
* Gradient boosting and random forests tend to perform very well, but there is always value in trying out multiple models  
	* Start with EDA and begin with a very simple model  
  
Example code includes:  
```{r cache=TRUE}

sisters67 <- readr::read_csv("./RInputFiles/sisters.csv")
str(sisters67, give.attr = FALSE)


# View sisters67
glimpse(sisters67)

# Plot the histogram
ggplot(sisters67, aes(x = age)) +
    geom_histogram(binwidth = 10)


# Tidy the data set
tidy_sisters <- sisters67 %>%
    select(-sister) %>%
    gather(key, value, -age)

# Print the structure of tidy_sisters
glimpse(tidy_sisters)


# Overall agreement with all questions varied by age
tidy_sisters %>%
    group_by(age) %>%
    summarize(value = mean(value, na.rm = TRUE))

# Number of respondents agreed or disagreed overall
tidy_sisters %>%
    count(value)


# Visualize agreement with age
tidy_sisters %>%
    filter(key %in% paste0("v", 153:170)) %>%
    group_by(key, value) %>%
    summarize(age = mean(age, na.rm = TRUE)) %>%
    ggplot(aes(value, age, color = key)) +
    geom_line(show.legend = FALSE) +
    facet_wrap(~key, nrow = 3)


# Remove the sister column
sisters_select <- sisters67 %>% 
    select(-sister)

# Build a simple linear regression model
simple_lm <- lm(age ~ ., 
                data = sisters_select)

# Print the summary of the model
summary(simple_lm)


# Split the data into training and validation/test sets
set.seed(1234)
in_train <- caret::createDataPartition(sisters_select$age, p = 0.6, list = FALSE)
training <- sisters_select[in_train, ]
validation_test <- sisters_select[-in_train, ]

# Split the validation and test sets
set.seed(1234)
in_test <- caret::createDataPartition(validation_test$age, p = 0.5, list = FALSE)
testing <- validation_test[in_test, ]
validation <- validation_test[-in_test, ]


# Fit a CART model
sisters_cart <- caret::train(age ~ ., method = "rpart", data = training)

# Print the CART model
sisters_cart


inSmall <- sample(1:nrow(training), 500, replace=FALSE)
smallSisters <- training[sort(inSmall), ]

sisters_xgb <- caret::train(age ~ ., method = "xgbTree", data = smallSisters)
sisters_gbm <- caret::train(age ~ ., method = "gbm", data = smallSisters, verbose=FALSE)

# Make predictions on the three models
modeling_results <- validation %>%
    mutate(CART = predict(sisters_cart, validation),
           XGB = predict(sisters_xgb, validation),
           GBM = predict(sisters_gbm, validation))

# View the predictions
modeling_results %>% 
    select(CART, XGB, GBM)


# Compare performace
yardstick::metrics(modeling_results, truth = age, estimate = CART)
yardstick::metrics(modeling_results, truth = age, estimate = XGB)
yardstick::metrics(modeling_results, truth = age, estimate = GBM)


# Calculate RMSE
testing %>%
    mutate(prediction = predict(sisters_gbm, testing)) %>%
    yardstick::rmse(truth = age, estimate = prediction)

```
  
  
  
***
  
###_Business Process Analytics in R_  
  
Chapter 1 - Introduction to Process Analysis  
  
Introduction and overview:  
  
* Efficient processes are core to many businesses, and improved data makes further analysis possible  
* The "internet of things" has created significant amounts of event data - why, what, and who  
	* Why is the purpose  
    * What is the steps in the process  
    * Who is the person responsible for the activity (can be machines or IS or the like; referred to as "resources")  
* Process workflow is iterative across Extraction-Processing-Analysis  
  
Activities as cornerstones of processes:  
  
* Data from an online learning platform; activities are captured and can be used for further analysis  
* Activities describe the flow of the process, and are one of the most important components of the process  
	* bupaR::activities_labels() is like names() for activities data  
    * bupaR::activities() is like summary() for activities data  
* Each case is described by the sequence of activities, known as its "trace"  
	* bupaR::traces() will create a frequency table of the traces  
    * bupaR::trace_explorer() will visualize the cases  
  
Components of process data:  
  
* Cases are the objects flowing through the process, while activities are the actions performed on them  
	* An activity instance is the occurrence of an activity (which can be a series of events) - specific action, case, time, etc.  
    * The "lifecycle status" is an area like Scheduled, Started, Completed, and the like  
    * The "event log" is the journal of the events  
    * The "resources" are the actors in the process  
* Can create an event log using the eventlog() function  
	* event_data %>% eventlog(case_id = "patient", activity_id = "handling", activity_instance_id = "handling_id", timestamp = "time", lifecycle_id = "registration_type", resource = "employee")  
  
Example code includes:  
```{r}

# Load the processmapR package using library
library(processmapR)
library(bupaR)


handling <- c('Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Blood test', 'Blood test', 'Blood test', 'Blood test', 'Blood test', 'Blood test', 'Blood test', 'Blood test', 'MRI SCAN', 'MRI SCAN', 'MRI SCAN', 'MRI SCAN', 'MRI SCAN', 'MRI SCAN', 'MRI SCAN', 'MRI SCAN', 'X-Ray', 'X-Ray', 'X-Ray', 'X-Ray', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Registration', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Triage and Assessment', 'Blood test', 'Blood test', 'Blood test', 'Blood test', 'Blood test', 'Blood test', 'Blood test', 'Blood test', 'MRI SCAN', 'MRI SCAN', 'MRI SCAN', 'MRI SCAN', 'MRI SCAN', 'MRI SCAN', 'MRI SCAN', 'MRI SCAN', 'X-Ray', 'X-Ray', 'X-Ray', 'X-Ray', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Discuss Results', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out', 'Check-out')
patient <- c('43', '155', '156', '170', '172', '184', '221', '278', '348', '420', '455', '493', '43', '155', '156', '170', '172', '184', '221', '278', '348', '420', '455', '493', '43', '156', '170', '172', '184', '278', '348', '420', '43', '156', '170', '172', '184', '278', '348', '420', '155', '221', '455', '493', '43', '155', '156', '170', '172', '184', '221', '278', '348', '420', '455', '493', '43', '155', '156', '170', '172', '184', '221', '278', '348', '420', '455', '493', '43', '155', '156', '170', '172', '184', '221', '278', '348', '420', '455', '493', '43', '155', '156', '170', '172', '184', '221', '278', '348', '420', '455', '493', '43', '156', '170', '172', '184', '278', '348', '420', '43', '156', '170', '172', '184', '278', '348', '420', '155', '221', '455', '493', '43', '155', '156', '170', '172', '184', '221', '278', '348', '420', '455', '493', '43', '155', '156', '170', '172', '184', '221', '278', '348', '420', '455', '493')
employee <- c('r1', 'r1', 'r1', 'r1', 'r1', 'r1', 'r1', 'r1', 'r1', 'r1', 'r1', 'r1', 'r2', 'r2', 'r2', 'r2', 'r2', 'r2', 'r2', 'r2', 'r2', 'r2', 'r2', 'r2', 'r3', 'r3', 'r3', 'r3', 'r3', 'r3', 'r3', 'r3', 'r4', 'r4', 'r4', 'r4', 'r4', 'r4', 'r4', 'r4', 'r5', 'r5', 'r5', 'r5', 'r6', 'r6', 'r6', 'r6', 'r6', 'r6', 'r6', 'r6', 'r6', 'r6', 'r6', 'r6', 'r7', 'r7', 'r7', 'r7', 'r7', 'r7', 'r7', 'r7', 'r7', 'r7', 'r7', 'r7', 'r1', 'r1', 'r1', 'r1', 'r1', 'r1', 'r1', 'r1', 'r1', 'r1', 'r1', 'r1', 'r2', 'r2', 'r2', 'r2', 'r2', 'r2', 'r2', 'r2', 'r2', 'r2', 'r2', 'r2', 'r3', 'r3', 'r3', 'r3', 'r3', 'r3', 'r3', 'r3', 'r4', 'r4', 'r4', 'r4', 'r4', 'r4', 'r4', 'r4', 'r5', 'r5', 'r5', 'r5', 'r6', 'r6', 'r6', 'r6', 'r6', 'r6', 'r6', 'r6', 'r6', 'r6', 'r6', 'r6', 'r7', 'r7', 'r7', 'r7', 'r7', 'r7', 'r7', 'r7', 'r7', 'r7', 'r7', 'r7')
handling_id <- c('43', '155', '156', '170', '172', '184', '221', '278', '348', '420', '455', '493', '543', '655', '656', '670', '672', '684', '721', '778', '848', '920', '955', '993', '1020', '1072', '1081', '1082', '1088', '1127', '1163', '1199', '1257', '1309', '1318', '1319', '1325', '1364', '1400', '1436', '1557', '1587', '1710', '1730', '1777', '1889', '1890', '1904', '1906', '1918', '1955', '2012', '2082', '2154', '2189', '2227', '2272', '2384', '2385', '2399', '2401', '2413', '2450', '2507', '2577', '2649', '2684', '2720', '43', '155', '156', '170', '172', '184', '221', '278', '348', '420', '455', '493', '543', '655', '656', '670', '672', '684', '721', '778', '848', '920', '955', '993', '1020', '1072', '1081', '1082', '1088', '1127', '1163', '1199', '1257', '1309', '1318', '1319', '1325', '1364', '1400', '1436', '1557', '1587', '1710', '1730', '1777', '1889', '1890', '1904', '1906', '1918', '1955', '2012', '2082', '2154', '2189', '2227', '2272', '2384', '2385', '2399', '2401', '2413', '2450', '2507', '2577', '2649', '2684', '2720')
registration_type <- c('start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete')
rTime <- c('2017-02-19 04:38:51', '2017-06-03 10:05:28', '2017-06-03 10:05:28', '2017-06-17 15:10:30', '2017-06-17 23:00:33', '2017-06-27 07:48:22', '2017-08-03 17:05:27', '2017-09-26 20:22:49', '2017-11-24 08:28:44', '2018-02-08 03:39:21', '2018-03-14 21:04:28', '2018-04-29 04:55:10', '2017-02-19 07:28:53', '2017-06-04 06:27:00', '2017-06-03 13:23:14', '2017-06-17 16:31:58', '2017-06-18 18:29:13', '2017-06-28 00:14:50', '2017-08-04 07:22:06', '2017-09-27 22:57:03', '2017-11-24 10:33:00', '2018-02-08 17:33:12', '2018-03-15 15:12:41', '2018-04-30 19:40:22', '2017-02-20 19:59:18', '2017-06-04 15:18:50', '2017-06-18 22:51:07', '2017-06-21 02:43:27', '2017-07-01 23:55:10', '2017-09-28 22:58:23', '2017-11-25 12:06:18', '2018-02-12 09:01:38', '2017-02-21 06:49:49', '2017-06-04 23:23:28', '2017-06-19 06:44:30', '2017-06-21 11:16:30', '2017-07-02 11:16:08', '2017-09-29 07:28:10', '2017-11-25 21:54:56', '2018-02-12 19:43:42', '2017-06-05 00:12:24', '2017-08-05 08:25:17', '2018-03-17 10:30:24', '2018-05-02 07:32:45', '2017-02-21 14:50:43', '2017-06-05 14:03:19', '2017-06-05 10:26:16', '2017-06-19 22:46:10', '2017-06-22 04:39:35', '2017-07-03 01:28:49', '2017-08-05 22:06:23', '2017-09-29 19:13:51', '2017-11-26 06:52:23', '2018-02-17 02:44:58', '2018-03-18 00:20:51', '2018-05-02 18:14:11', '2017-02-24 14:58:43', '2017-06-05 15:58:53', '2017-06-05 15:58:53', '2017-06-20 03:48:37', '2017-06-22 08:40:55', '2017-07-03 03:39:51', '2017-08-08 23:17:45', '2017-09-29 21:16:01', '2017-11-27 04:56:53', '2018-02-20 09:49:29', '2018-03-18 08:12:07', '2018-05-03 00:11:10', '2017-02-19 07:28:53', '2017-06-03 14:19:00', '2017-06-03 13:23:14', '2017-06-17 16:31:58', '2017-06-18 01:07:42', '2017-06-27 12:22:51', '2017-08-03 19:25:12', '2017-09-26 22:17:18', '2017-11-24 10:33:00', '2018-02-08 06:01:38', '2018-03-15 00:34:01', '2018-04-29 07:39:14', '2017-02-19 21:58:08', '2017-06-04 14:23:26', '2017-06-04 06:27:00', '2017-06-18 04:14:55', '2017-06-19 00:40:19', '2017-06-28 12:48:20', '2017-08-04 21:09:17', '2017-09-28 12:00:12', '2017-11-25 00:44:30', '2018-02-09 07:05:52', '2018-03-16 04:08:03', '2018-05-01 10:37:51', '2017-02-21 03:12:26', '2017-06-04 19:35:51', '2017-06-19 03:01:11', '2017-06-21 08:02:20', '2017-07-02 07:43:48', '2017-09-29 04:58:49', '2017-11-25 18:30:43', '2018-02-12 13:57:13', '2017-02-21 09:57:05', '2017-06-05 02:46:59', '2017-06-19 11:40:53', '2017-06-21 16:09:26', '2017-07-02 16:03:16', '2017-09-29 12:44:39', '2017-11-26 02:40:30', '2018-02-12 23:53:46', '2017-06-05 04:39:38', '2017-08-05 13:56:39', '2018-03-17 14:09:40', '2018-05-02 12:24:41', '2017-02-21 17:57:58', '2017-06-05 15:58:53', '2017-06-05 14:03:19', '2017-06-20 01:44:29', '2017-06-22 08:40:55', '2017-07-03 03:39:51', '2017-08-05 23:53:27', '2017-09-29 21:16:01', '2017-11-26 09:44:37', '2018-02-17 06:17:57', '2018-03-18 03:22:17', '2018-05-02 21:17:12', '2017-02-24 16:03:49', '2017-06-05 17:22:16', '2017-06-05 17:15:30', '2017-06-20 05:36:40', '2017-06-22 10:59:58', '2017-07-03 05:00:48', '2017-08-09 00:13:39', '2017-09-29 23:42:48', '2017-11-27 06:53:23', '2018-02-20 12:04:00', '2018-03-18 10:48:34', '2018-05-03 02:11:42')
rOrder <- c(43, 155, 156, 170, 172, 184, 221, 278, 348, 420, 455, 493, 543, 655, 656, 670, 672, 684, 721, 778, 848, 920, 955, 993, 1020, 1072, 1081, 1082, 1088, 1127, 1163, 1199, 1257, 1309, 1318, 1319, 1325, 1364, 1400, 1436, 1557, 1587, 1710, 1730, 1777, 1889, 1890, 1904, 1906, 1918, 1955, 2012, 2082, 2154, 2189, 2227, 2272, 2384, 2385, 2399, 2401, 2413, 2450, 2507, 2577, 2649, 2684, 2720, 2764, 2876, 2877, 2891, 2893, 2905, 2942, 2999, 3069, 3141, 3176, 3214, 3264, 3376, 3377, 3391, 3393, 3405, 3442, 3499, 3569, 3641, 3676, 3714, 3741, 3793, 3802, 3803, 3809, 3848, 3884, 3920, 3978, 4030, 4039, 4040, 4046, 4085, 4121, 4157, 4278, 4308, 4431, 4451, 4498, 4610, 4611, 4625, 4627, 4639, 4676, 4733, 4803, 4875, 4910, 4948, 4993, 5105, 5106, 5120, 5122, 5134, 5171, 5228, 5298, 5370, 5405, 5441)

pFrame <- tibble(handling=factor(handling, levels=c('Blood test', 'Check-out', 'Discuss Results', 'MRI SCAN', 'Registration', 'Triage and Assessment', 'X-Ray')), 
                 patient=patient, 
                 employee=factor(employee, levels=c('r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7')), 
                 handling_id=handling_id, 
                 registration_type=factor(registration_type, levels=c("complete", "start")), 
                 time=as.POSIXct(rTime), 
                 .order=rOrder
                 )

patients <- eventlog(pFrame,
    case_id = "patient",
    activity_id = "handling",
    activity_instance_id = "handling_id",
    lifecycle_id = "registration_type",
    timestamp = "time",
    resource_id = "employee")


# The function slice can be used to take a slice of cases out of the eventdata. slice(1:10) will select the first ten cases in the event log, where first is defined by the current ordering of the data.

# How many patients are there?
n_cases(patients)

# Print the summary of the data
summary(patients)

# Show the journey of the first patient
slice(patients, 1)


# How many distinct activities are there?
n_activities(patients)

# What are the names of the activities?
activity_labels(patients)

# Create a list of activities
activities(patients)


# Have a look at the different traces
traces(patients)

# How many are there?
n_traces(patients)

# Visualize the traces using trace_explorer
trace_explorer(patients, coverage=1)

# Draw process map
process_map(patients)


claims <- tibble(id=c("claim1", "claim1", "claim2", "claim2", "claim2"), 
                 action=c(10002L, 10011L, 10015L, 10024L, 10024L), 
                 action_type=c("Check Contract", "Pay Back Decision", "Check Contract", "Pay Back Decision", "Pay Back Decision"), 
                 date=as.Date(c("2008-01-12", "2008-03-22", "2008-01-13", "2008-03-23", "2008-04-14")), 
                 originator=c("Assistant 1", "Manager 2", "Assistant 6", "Manager 2", "Manager 2"), 
                 status=as.factor(c("start", "start", "start", "start", "complete"))
                 )
claims


#create eventlog claims_log 
claims_log <- eventlog(claims,
    case_id = "id",
    activity_id = "action_type",
    activity_instance_id = "action",
    lifecycle_id = "status",
    timestamp = "date",
    resource_id = "originator")

# Print summary
summary(claims_log)

# Check activity labels
activity_labels(claims_log)

# Once you have an eventlog, you can access its complete metadata using the function mapping or the functions case_id, activity_id etc., to inspect individual identifiers.

```
  
  
  
***
  
Chapter 2 - Analysis Techniques  
  
Organizational analysis:  
  
* Processes are always dependent on resources, even if automated (machines and algorithms can be resources)  
	* Who executes the task, how specialized is the knowledge, etc.  
    * resource_labels(log_hospital)  # will pull out the resources  
    * resources(log_hospital)  # will pull out frequencies by resource  
* Can create a resource-activity matrix  
	* A person who performs only a few activities is considered to be specialized in that activity  
    * If only one person ever performs a specific activity, then there is a high risk of "brain drain"  
    * The plot() function, applied to an event_log, will create the resource-activity matrix  
    * resource_map(log_hospital)  # shows arrows between the work flows  
  
Structuredness:  
  
* Control-flow refers to the succession of activities  
	* Each unique flow is referred to as a trace  
    * Metrics include entry/exit points, length of cases, presence of activities, rework, etc.  
    * log_healthcare %>% start_activities("activity") %>% plot()  
    * log_healthcare %>% end_activities("activity") %>% plot()  
* Rework is when the same activity is done multiple times for the same case  
	* Repetitions are when the activity is repeated after some intervening steps  
    * Sel-loops are when the activity is repeated immediately after itself  
* The precedence matrix shows the relationships between the activities in a more structured manner  
	* eventlog %>% precedence_matrix(type = "absolute") %>% plot  # can be type="relative" also  
  
Performance analysis:  
  
* Visuals can include performance process maps and dotted charts; metrics can include throughput time, processing time, idle time  
	* eventlog %>% process_map(type = frequency())  # normal process map  
    * eventlog %>% process_map(type = performance())  # performance process map  
* The dotted chart shows the freqency of activities over time; basically, a form of scatter plot  
	* throughput_time is total time, processing_time is the sum of activity time, idle_time is the sume of when nothing is happening  
  
Linking perspectives:  
  
* Granularity can help give the statistics at the desired levels  
	* <process_metric>(level = "log", "trace", "case", "activity", "resource", "resource-activity")  
* Categorical data can be leveraged using the group_by() functionality - each group will then be calculated separately  
	* eventlog %>% group_by(priority) %>% number_of_repetitions(level = "resource") %>% plot()  
  
Example code includes:  
```{r}


data(sepsis, package="eventdataR")
str(sepsis)


# Print list of resources
resource_frequency(sepsis, level="resource")

# Number of resources per activity
resource_frequency(sepsis, level = "activity")

# Plot Number of executions per resource-activity
resource_frequency(sepsis, level = "resource-activity") %>% plot()


# Calculate resource involvement
resource_involvement(sepsis, level="resource")

# Show graphically 
sepsis %>% resource_involvement(level = "resource") %>% plot

# Compare with resource frequency
resource_frequency(sepsis, level="resource")


# Min, max and average number of repetitions
sepsis %>% number_of_repetitions(level = "log")

# Plot repetitions per activity
sepsis %>% number_of_repetitions(level = "activity") %>% plot

# Number of repetitions per resources
sepsis %>% number_of_repetitions(level = "resource")


eci <- c('21', '21', '21', '21', '21', '21', '21', '21', '21', '31', '31', '31', '31', '31', '31', '31', '31', '31', '31', '41', '41', '41', '41', '41', '41', '41', '51', '51', '51', '51', '51', '51', '51', '61', '61', '61', '61', '61', '61', '91', '91', '91', '91', '91', '91', '101', '101', '101', '101', '101', '101', '111', '111', '111', '111', '121', '121', '121', '121', '121', '121', '121', '121', '121', '131', '131', '131', '131', '131', '131', '131', '131', '161', '161', '171', '171', '171', '171', '181', '181', '181', '181', '181', '181', '201', '201', '201', '201', '201', '201', '201', '12', '12', '12', '12', '12', '22', '22', '22', '22', '22', '22', '32', '32', '32', '32', '32', '32', '42', '42', '42', '42', '52', '52', '52', '52', '52', '82', '82', '82', '82', '82', '92', '92', '92', '92', '92', '102', '102', '102', '102', '102', '112', '112', '122', '122', '21', '21', '21', '21', '21', '21', '21', '21', '21', '31', '31', '31', '31', '31', '31', '31', '31', '31', '31', '41', '41', '41', '41', '41', '41', '41', '51', '51', '51', '51', '51', '51', '51', '61', '61', '61', '61', '61', '61', '91', '91', '91', '91', '91', '91', '101', '101', '101', '101', '101', '101', '111', '111', '111', '111', '121', '121', '121', '121', '121', '121', '121', '121', '121', '131', '131', '131', '131', '131', '131', '131', '131', '161', '161', '171', '171', '171', '171', '181', '181', '181', '181', '181', '181', '201', '201', '201', '201', '201', '201', '201', '12', '12', '12', '12', '12', '22', '22', '22', '22', '22', '22', '32', '32', '32', '32', '32', '32', '42', '42', '42', '42', '52', '52', '52', '52', '52', '82', '82', '82', '82', '82', '92', '92', '92', '92', '92', '102', '102', '102', '102', '102', '112', '112', '122', '122')
ea1 <- c('prepareBreakfast', 'eatingBreakfast', 'snack', 'prepareLunch', 'eatingLunch', 'snack', 'snack', 'prepareDinner', 'eatingDinner', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'snack', 'prepareLunch', 'eatingLunch', 'snack', 'snack', 'prepareDinner', 'eatingDinner', 'prepareBreakfast', 'eatingBreakfast', 'prepareBreakfast', 'eatingBreakfast', 'prepareDinner', 'eatingDinner', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'prepareLunch', 'eatingLunch', 'prepareDinner', 'eatingDinner', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'prepareLunch', 'eatingLunch', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'prepareDinner', 'eatingDinner', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'snack', 'prepareLunch', 'eatingLunch', 'prepareBreakfast', 'prepareLunch', 'eatingLunch', 'snack', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'snack', 'prepareLunch', 'eatingLunch', 'snack', 'snack', 'snack', 'eatingBreakfast', 'prepareBreakfast', 'snack', 'prepareLunch', 'eatingLunch', 'snack', 'snack', 'eatingBreakfast', 'prepareBreakfast', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'snack', 'snack', 'eatingDinner', 'prepareBreakfast', 'eatingBreakfast', 'prepareLunch', 'eatingLunch', 'snack', 'prepareDinner', 'eatingDinner', 'prepareBreakfast', 'eatingBreakfast', 'prepareLunch', 'eatingLunch', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'prepareLunch', 'eatingLunch', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'prepareLunch', 'eatingLunch', 'snack', 'eatingLunch', 'prepareBreakfast', 'eatingBreakfast', 'prepareLunch', 'prepareBreakfast', 'eatingBreakfast', 'prepareLunch', 'eatingLunch', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'prepareLunch', 'eatingLunch', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'prepareLunch', 'eatingLunch', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'prepareLunch', 'eatingLunch', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'prepareBreakfast')
ea2 <- c('eatingBreakfast', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'prepareLunch', 'eatingLunch', 'snack', 'snack', 'prepareDinner', 'eatingDinner', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'snack', 'prepareLunch', 'eatingLunch', 'snack', 'snack', 'prepareDinner', 'eatingDinner', 'prepareBreakfast', 'eatingBreakfast', 'prepareBreakfast', 'eatingBreakfast', 'prepareDinner', 'eatingDinner', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'prepareLunch', 'eatingLunch', 'prepareDinner', 'eatingDinner', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'prepareLunch', 'eatingLunch', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'prepareDinner', 'eatingDinner', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'snack', 'prepareLunch', 'eatingLunch', 'prepareBreakfast', 'prepareLunch', 'eatingLunch', 'snack', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'snack', 'prepareLunch', 'eatingLunch', 'snack', 'snack', 'snack', 'eatingBreakfast', 'prepareBreakfast', 'snack', 'prepareLunch', 'eatingLunch', 'snack', 'snack', 'eatingBreakfast', 'prepareBreakfast', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'snack', 'snack', 'eatingDinner', 'prepareBreakfast', 'eatingBreakfast', 'prepareLunch', 'eatingLunch', 'snack', 'prepareDinner', 'eatingDinner', 'prepareBreakfast', 'eatingBreakfast', 'prepareLunch', 'eatingLunch', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'prepareLunch', 'eatingLunch', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'snack', 'prepareLunch', 'eatingLunch', 'snack', 'eatingLunch', 'prepareBreakfast', 'eatingBreakfast', 'prepareLunch', 'prepareBreakfast', 'eatingBreakfast', 'prepareLunch', 'eatingLunch', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'prepareLunch', 'eatingLunch', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'prepareLunch', 'eatingLunch', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'prepareLunch', 'eatingLunch', 'snack', 'prepareBreakfast', 'eatingBreakfast', 'prepareBreakfast', 'eatingBreakfast')
eaii <- c('9', '10', '19', '23', '24', '26', '36', '40', '41', '51', '52', '58', '60', '62', '63', '67', '69', '72', '73', '86', '87', '89', '90', '104', '105', '107', '119', '120', '128', '132', '133', '138', '139', '149', '150', '156', '159', '160', '164', '174', '175', '192', '194', '195', '198', '205', '206', '208', '211', '213', '214', '229', '236', '237', '239', '245', '251', '252', '253', '255', '259', '260', '262', '264', '271', '276', '281', '287', '292', '293', '297', '299', '310', '312', '331', '332', '336', '347', '363', '364', '374', '376', '387', '389', '434', '435', '447', '448', '450', '453', '454', '462', '463', '471', '472', '475', '483', '484', '487', '491', '492', '496', '508', '509', '512', '517', '518', '522', '536', '540', '541', '543', '562', '563', '565', '566', '572', '584', '585', '589', '590', '598', '615', '616', '618', '619', '627', '639', '640', '642', '643', '653', '665', '666', '682', '683', '9', '10', '19', '23', '24', '26', '36', '40', '41', '51', '52', '58', '60', '62', '63', '67', '69', '72', '73', '86', '87', '89', '90', '104', '105', '107', '119', '120', '128', '132', '133', '138', '139', '149', '150', '156', '159', '160', '164', '174', '175', '192', '194', '195', '198', '205', '206', '208', '211', '213', '214', '229', '236', '237', '239', '245', '251', '252', '253', '255', '259', '260', '262', '264', '271', '276', '281', '287', '292', '293', '297', '299', '310', '312', '331', '332', '336', '347', '363', '364', '374', '376', '387', '389', '434', '435', '447', '448', '450', '453', '454', '462', '463', '471', '472', '475', '483', '484', '487', '491', '492', '496', '508', '509', '512', '517', '518', '522', '536', '540', '541', '543', '562', '563', '565', '566', '572', '584', '585', '589', '590', '598', '615', '616', '618', '619', '627', '639', '640', '642', '643', '653', '665', '666', '682', '683')
elci <- c('start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'start', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete', 'complete')
ets1 <- c('2012-11-12 09:42:02', '2012-11-12 09:52:33', '2012-11-12 11:05:44', '2012-11-12 13:45:49', '2012-11-12 13:48:49', '2012-11-12 15:23:00', '2012-11-12 18:47:29', '2012-11-12 22:35:21', '2012-11-12 22:35:21', '2012-11-13 08:56:37', '2012-11-13 09:04:54', '2012-11-13 10:14:04', '2012-11-13 13:47:45', '2012-11-13 14:08:24', '2012-11-13 14:19:01', '2012-11-13 17:34:23', '2012-11-13 18:51:51', '2012-11-13 23:05:07', '2012-11-13 23:17:07', '2012-11-14 09:06:08', '2012-11-14 09:17:48', '2012-11-14 10:38:16', '2012-11-14 10:44:16', '2012-11-14 21:30:09', '2012-11-14 21:37:09', '2012-11-14 22:14:23', '2012-11-15 09:37:15', '2012-11-15 09:47:12', '2012-11-15 10:11:08', '2012-11-15 14:35:27', '2012-11-15 14:41:27', '2012-11-15 22:07:26', '2012-11-15 22:26:02', '2012-11-16 10:39:14', '2012-11-16 10:52:56', '2012-11-16 12:09:10', '2012-11-16 14:13:00', '2012-11-16 14:19:00', '2012-11-16 18:11:36', '2012-11-19 10:13:23', '2012-11-19 10:25:00', '2012-11-19 15:55:22', '2012-11-19 21:47:27', '2012-11-19 21:59:27', '2012-11-19 22:31:06', '2012-11-20 10:20:00', '2012-11-20 10:21:02', '2012-11-20 11:00:16', '2012-11-20 13:03:28', '2012-11-20 14:25:11', '2012-11-20 14:41:22', '2012-11-21 10:01:00', '2012-11-21 15:02:08', '2012-11-21 15:15:08', '2012-11-21 17:50:29', '2012-11-22 01:40:42', '2012-11-22 10:19:15', '2012-11-22 10:26:15', '2012-11-22 11:02:27', '2012-11-22 11:56:06', '2012-11-22 15:05:51', '2012-11-22 15:12:55', '2012-11-22 16:43:08', '2012-11-22 18:15:32', '2012-11-23 00:36:00', '2012-11-23 01:03:00', '2012-11-23 09:49:00', '2012-11-23 12:53:06', '2012-11-23 14:01:08', '2012-11-23 14:23:08', '2012-11-23 16:57:24', '2012-11-23 17:58:00', '2012-11-26 09:06:12', '2012-11-26 09:57:12', '2012-11-27 10:20:26', '2012-11-27 10:30:50')
ets2 <- c('2012-11-27 11:54:15', '2012-11-27 19:46:15', '2012-11-28 09:27:15', '2012-11-28 09:34:15', '2012-11-28 12:28:02', '2012-11-28 13:16:33', '2012-11-28 19:30:08', '2012-11-28 22:15:02', '2012-11-30 10:43:19', '2012-11-30 10:46:19', '2012-11-30 14:51:36', '2012-11-30 15:08:36', '2012-11-30 17:30:40', '2012-11-30 22:12:05', '2012-11-30 22:16:07', '2011-11-28 10:38:00', '2011-11-28 10:43:00', '2011-11-28 14:31:06', '2011-11-28 14:42:00', '2011-11-28 20:20:55', '2011-11-29 12:09:09', '2011-11-29 12:11:01', '2011-11-29 13:25:29', '2011-11-29 15:15:14', '2011-11-29 15:23:00', '2011-11-29 16:32:20', '2011-11-30 10:23:46', '2011-11-30 10:28:46', '2011-11-30 13:05:27', '2011-11-30 14:39:42', '2011-11-30 14:56:00', '2011-11-30 16:41:05', '2011-11-30 14:37:00', '2011-12-01 11:17:05', '2011-12-01 11:20:05', '2011-12-01 14:29:37', '2011-12-02 12:29:08', '2011-12-02 12:32:08', '2011-12-02 14:47:18', '2011-12-02 14:51:00', '2011-12-02 19:40:44', '2011-12-05 12:15:45', '2011-12-05 12:18:05', '2011-12-05 15:00:55', '2011-12-05 15:14:00', '2011-12-05 19:24:11', '2011-12-06 11:30:19', '2011-12-06 11:33:02', '2011-12-06 14:41:16', '2011-12-06 14:56:00', '2011-12-06 19:22:50', '2011-12-07 11:12:17', '2011-12-07 11:17:22', '2011-12-07 14:04:32', '2011-12-07 14:14:00', '2011-12-07 19:23:55', '2011-12-08 11:25:12', '2011-12-08 11:29:01', '2011-12-09 11:00:13', '2011-12-09 11:03:33', '2012-11-12 09:50:02', '2012-11-12 09:55:29', '2012-11-12 12:39:42', '2012-11-12 14:48:14', '2012-11-12 14:53:14', '2012-11-12 15:31:53', '2012-11-12 19:00:56', '2012-11-12 22:37:55', '2012-11-12 22:40:55', '2012-11-13 09:00:26', '2012-11-13 09:10:12', '2012-11-13 10:51:55', '2012-11-13 14:03:31', '2012-11-13 14:18:36', '2012-11-13 14:42:36', '2012-11-13 17:36:34', '2012-11-13 19:45:03', '2012-11-13 23:15:33', '2012-11-13 23:37:33', '2012-11-14 09:09:41', '2012-11-14 09:21:43', '2012-11-14 11:43:23', '2012-11-14 11:06:23', '2012-11-14 21:35:17', '2012-11-14 21:47:18', '2012-11-14 22:17:47', '2012-11-15 09:44:06', '2012-11-15 09:48:08', '2012-11-15 10:23:49', '2012-11-15 15:40:32', '2012-11-15 15:46:32', '2012-11-15 22:22:44', '2012-11-15 22:31:00', '2012-11-16 10:42:13') 
ets3 <- c('2012-11-16 10:52:58', '2012-11-16 12:09:57', '2012-11-16 14:58:55', '2012-11-16 14:55:55', '2012-11-16 18:14:49', '2012-11-19 10:17:12', '2012-11-19 10:33:59', '2012-11-19 16:07:49', '2012-11-19 21:59:01', '2012-11-19 22:24:58', '2012-11-19 22:31:59', '2012-11-20 10:21:02', '2012-11-20 10:37:51', '2012-11-20 11:14:44', '2012-11-20 13:28:35', '2012-11-20 14:40:16', '2012-11-20 15:10:16', '2012-11-21 10:06:50', '2012-11-21 15:14:47', '2012-11-21 15:30:55', '2012-11-21 17:55:48', '2012-11-22 01:45:42', '2012-11-22 10:25:45', '2012-11-22 10:59:45', '2012-11-22 11:10:30', '2012-11-22 12:09:07', '2012-11-22 15:12:19', '2012-11-22 15:26:18', '2012-11-22 16:51:54', '2012-11-22 18:17:25', '2012-11-23 00:41:13', '2012-11-23 10:28:57', '2012-11-23 10:01:57', '2012-11-23 12:57:33', '2012-11-23 14:20:47', '2012-11-23 14:38:47', '2012-11-23 16:57:43', '2012-11-23 18:06:38', '2012-11-26 10:37:28', '2012-11-26 10:05:28', '2012-11-27 10:30:43', '2012-11-27 10:44:43', '2012-11-27 11:54:59', '2012-11-27 19:46:56', '2012-11-28 09:33:52', '2012-11-28 09:44:52', '2012-11-28 12:57:42', '2012-11-28 13:38:45', '2012-11-28 19:45:20', '2012-11-28 22:18:43', '2012-11-30 11:45:40', '2012-11-30 11:51:40', '2012-11-30 15:05:54', '2012-11-30 15:20:00', '2012-11-30 17:42:59', '2012-11-30 22:15:48', '2012-11-30 22:39:48', '2011-11-28 10:42:55', '2011-11-28 10:49:00', '2011-11-28 14:41:54', '2011-11-28 15:04:00', '2011-11-28 20:20:59', '2011-11-29 12:10:37', '2011-11-29 12:19:00', '2011-11-29 13:25:32', '2011-11-29 15:22:57', '2011-11-29 15:49:00', '2011-11-29 16:32:23', '2011-11-30 10:27:58', '2011-11-30 10:38:58', '2011-11-30 13:05:31', '2011-11-30 14:55:24', '2011-11-30 15:11:00', '2011-11-30 16:41:09', '2011-11-30 15:08:00', '2011-12-01 11:19:43', '2011-12-01 11:29:43', '2011-12-01 14:36:38', '2011-12-02 12:31:10', '2011-12-02 12:37:10', '2011-12-02 14:50:19', '2011-12-02 15:24:00', '2011-12-02 19:40:50', '2011-12-05 12:17:58', '2011-12-05 12:26:02', '2011-12-05 15:13:55', '2011-12-05 15:42:00', '2011-12-05 19:24:16', '2011-12-06 11:32:49', '2011-12-06 11:38:51', '2011-12-06 14:55:18', '2011-12-06 15:18:18', '2011-12-06 19:22:55', '2011-12-07 11:17:14', '2011-12-07 11:22:35', '2011-12-07 14:13:34', '2011-12-07 14:41:00', '2011-12-07 20:38:18', '2011-12-08 11:28:24', '2011-12-08 11:35:55', '2011-12-09 11:03:09', '2011-12-09 11:09:08')
etsF <- c(ets1, ets2, ets3)

eatData <- tibble(case_id=eci, 
                  activity=factor(c(ea1, ea2)), 
                  activity_instance_id=eaii, 
                  lifecycle_id=factor(elci), 
                  resource=factor("UNDEFINED"), 
                  timestamp=as.POSIXct(etsF)
                  )

eat_patterns <- eventlog(eatData,
    case_id = "case_id",
    activity_id = "activity",
    activity_instance_id = "activity_instance_id",
    lifecycle_id = "lifecycle_id",
    timestamp = "timestamp",
    resource_id = "resource")


# Create performance map
eat_patterns %>% process_map(type = performance(FUN = median, units = "hours"))

# Inspect variation in activity durations graphically
eat_patterns %>% processing_time(level = "activity") %>% plot()

# Draw dotted chart
eat_patterns %>% dotted_chart(x = "relative_day", sort = "start_day", units = "secs")


# Time per activity
# daily_activities %>% processing_time(level = "activity") %>% plot

# Average duration of recordings
# daily_activities %>% throughput_time(level="log", units = "hours")

# Missing activities
# daily_activities %>% idle_time(level="log", units = "hours")


# Distribution throughput time
# vacancies %>% throughput_time(units="days")

# Distribution throughput time per department
# vacancies %>% group_by(vacancy_department) %>% throughput_time(units="days") %>% plot()

# Repetitions of activities
# vacancies %>% number_of_repetitions(level = "activity") %>% arrange(-relative)

```
  
  
  
***
  
Chapter 3 - Event Data Processing  
  
Filtering cases:  
  
* Sometimes there are too many cases, too many activities, missing data, and the like  
	* Can filter by either cases or events (time periods or specific activity types)  
    * Three levels of cases - performance, control-flow, and time frame  
* Look at long cases for what went wrong, and short cases for what to mimic  
	* filter_throughput_time(log, interval = c(5,10))  # absolute case length is 5-10 days  
    * filter_throughput_time(log, percentage = 0.5)  # shortest 50% of the cases  
    * filter_throughput_time(log, interval = c(5,10), units = "days", reverse =TRUE)  # cases that are NOT 5-10 days  
    * filter_throughput_time(log, interval = c(5,NA), units = "days") # cases longer than 5 days  
* Control-flow filters can be based on activity presence/absence, timing, and the like  
  
Filtering events - trim, frequency, label, general attribute:  
  
* Can trim to a time period based on start or end  
	* filter_time_period(log, interval = ymd(c("20180110","20180122")), filter_method = "trim")  # discards everything else  
* Can trim based on a specific start and end activities  
	* filter_trim(start_activities = "blues")  # traces that have no blues will be discarded  
    * filter_trim(start_activities = "blues", end_activities = "greens")  # traces that do not have blues followed by greens will be discarded  
    * Can set reverse=TRUE to get the opposites of these  
* Can filter by frequencies by either activity or resource  
	* filter_activity_frequency(log, interval = c(50,100))  
    * filter_activity_frequency(log, percentage = 0.8)  
    * filter_resource_frequency(log, interval = c(60,900))  
    * filter_resource_frequency(log, percentage = 0.6)  
* Can filter by labels  
	* filter_activity(log, activities = c("reds","oranges","purples")))  
    * dplyr::filter(log, cost > 1000, priority == "High", ...)  
  
Aggregating events - Is-A and Part-of:  
  
* The Is-A is when there are many subtypes of activity that are really all part of a main activity  
	* act_unite(log, "New name" = c("Old Variant 1","Old Variant 2","Old Variant 3"), ...)  # same number of activity instances, just fewer names  
* The Part-of is when there are clearly distinct activities that can also be considered components of a higher-level activity  
	* act_collapse(log, "Sub process" = c("Part 1","Part 2","Part 3"), ...)  # fewer number of activity instances, as they are collapsed to a single activity  
  
Enriching events - mutation (adding calculated variables):  
  
* The dplyr::mutate() can be used to directly add variables such as the cost  
	* log %>% group_by_case() %>% mutate(total_cost = sum(cost, na.rm = TRUE)  # group_by_case() is a function applied to event logs  
    * log %>% group_by_case() %>% mutate(total_cost = sum(cost, na.rm = TRUE) %>% mutate(impact = case_when(cost <= 1000 ~ "Low", cost <= 5000 ~ "Medium", TRUE ~ "High"))  
    * log %>% group_by_case() %>% mutate(refund_made = any(str_detect(activity, "Pay Claim")))  
* Metric functions can be used directly, with apped=TRUE, to both calculate the metric and add to the event log  
	* log %>% througput_time(level = "case", units = "days", append = TRUE) %>% mutate(on_time = processing_time_case <= 7)  
  
Example code includes:  
```{r eval=FALSE}

# Select top 20% of cases according to trace frequency
happy_path <- filter_trace_frequency(vacancies, percentage = 0.2)

# Visualize using process map
happy_path %>% process_map(type=requency(value = "absolute_case"))

# Compute throughput time
happy_path %>% throughput_time(units="days")


# Find no_declines
no_declines <- filter_activity_presence(vacancies, activities = "Decline Candidate", reverse=TRUE)

# What is the average number of  
first_hit <- filter_activity_presence(vacancies, activities = c("Send Offer", "Offer Accepted"), method="all")

# Create a performance map
first_hit %>% process_map(type=performance())

# Compute throughput time
first_hit %>% throughput_time()


# Create not_refused
not_refused <- vacancies %>% filter_precedence(antecedents = "Receive Response", consequents = "Review Non Acceptance", precedence_type = "directly_follows", filter_method = "none") 

# Select longest_cases
worst_cases <- not_refused %>% filter_throughput_time(interval=c(300, NA))

# Show the different traces
worst_cases %>% trace_explorer(coverage=1)


# Select activities
disapprovals <- vacancies %>% filter_activity(activities=c("Construct Offer", "Disapprove Offer", "Revise Offer","Disapprove Revision", "Restart Procedure"))

# Explore traces
disapprovals %>% trace_explorer(coverage=0.8)

# Performance map
disapprovals %>% process_map(type = performance(FUN = sum, units = "weeks"))


# Select cases
high_paid <- vacancies %>% filter(vacancy_department=="R&D", vacancy_salary_range==">100000")

# Most active resources
high_paid %>% resource_frequency(level="resource")

# Create a dotted chart
high_paid %>% dotted_chart(x="absolute", sort="start")

# Filtered dotted chart
library(lubridate)
high_paid %>% filter_time_period(interval = ymd(c("20180321","20180620")), filter_method = "trim") %>% dotted_chart(x="absolute", sort="start")


# Count activities and instances
n_activities(vacancies)
n_activity_instances(vacancies)

# Combine activities
united_vacancies <- vacancies %>% 
    act_unite("Disapprove Contract Offer" = c("Disapprove Offer","Disapprove Revision"),
              "Approve Contract Offer" = c("Approve Offer","Approve Revision"), 
              "Construct Contract Offer" = c("Construct Offer","Revise Offer")
              )
              
# Count activities and instances
n_activities(united_vacancies)
n_activity_instances(united_vacancies)


# Aggregate sub processes
aggregated_vacancies <- act_collapse(united_vacancies, 
                            "Interviews" = c("First Interview","Second Interview","Third Interview"),
                            "Prepare Recruitment" = c("Publish Position","File Applications","Check References"),
                            "Create Offer" = c("Construct Contract Offer", "Disapprove Contract Offer", "Approve Contract Offer")
                            )

# Calculated number of activities and activity instances
n_activities(aggregated_vacancies)
n_activity_instances(aggregated_vacancies)

# Create performance map
aggregated_vacancies %>% process_map(type=performance())


# Add total_cost
vacancies_cost <- vacancies %>% 
    group_by_case() %>% 
    mutate(total_cost = sum(activity_cost, na.rm = TRUE))

# Add cost_impact
vacancies_impact <- vacancies_cost %>%




# Compute throughput time per impact
vacancies_impact %>% group_by(cost_impact) %>% throughput_time(units = "weeks") %>% plot()


# Create cost_profile
vacancies_profile <- vacancies_impact %>%
    mutate(cost_profile = case_when(cost_impact == "High" & urgency < 7 ~ "Disproportionate",
                                    cost_impact == "Medium" & urgency < 5 ~ "Excessive",
                                    cost_impact == "Low" & urgency > 6 ~ "Lacking",
                                    TRUE ~ "Appropriate")) 

# Compare number of cases 
vacancies_profile %>% 
    group_by(cost_profile) %>%
    n_cases()
    
# Explore lacking traces
vacancies_profile %>%
  filter(cost_profile == "Lacking") %>%
  process_map()

```
  
  
  
***
  
Chapter 4 - Case Study  
  
Preparing the event data - example includes data from Sales, Purchasing, Manufacturing, Packaging & Delivery, Accounting:  
  
* While all departments need to work together, it is common for each department to have different data, business rules, relational data, etc.  
* Need to create event data first prior to running anything in the bupar package  
* Various field names (ends in _at or _by) may indicate the timing and resource levels  
* The tidyverse tools are helpful for creating the initial data  
  
Getting to know the process:  
  
* Identify data sources, transform so that each row is an event, harmonize them, create an eventlog  
* Start with high-level understanding of the process - summary(otc)  
	* activity_presence(otc) %>% plot()  
    * trace_length(otc) %>% plot()  
    * start_activities(otc, "activity") %>% plot()  
    * end_activities(otc, "activity") %>% plot()  
  
Roles and rules:  
  
* Parallel activities can be run in any order, which can cause an explosion in the number of traces - collapsing can help with abstraction  
* Research questions may be related to performance, compliance, etc.  
* The "4-eye" pricniple says that certain activities should not be performed by the same person  
  
Fast production, fast delivery:  
  
* Dotted charts can show the progression of the cases - request for quotation may be declined, or the offer may only be sent (no response)  
* May want to look at the performance by stages (sub-groups of activities), for more fair comparisons  
  
Course recap:  
  
* Process maps  
* Process analytics  
* Data preprocessing  
* Analysis and use cases  
  
Example code includes:  
```{r cache=TRUE}

quotations <- readRDS("./RInputFiles/otc_quotations.RDS")

# Inspect quotations
str(quotations)

# Create offer_history
offer_history <- quotations %>%
    gather(key, value, -quotation_id) %>%
    separate(key, into = c("activity", "info"))

# Recode the key variable
offer_history <- offer_history %>%
    mutate(info = fct_recode(info,  "timestamp" = 'at',  "resource" = 'by'))

# Spread the info variable
offer_history <- offer_history %>%
    spread(info, value)


validations <- readRDS("./RInputFiles/otc_validations.RDS")

# Inspect validations
str(validations)

# Create validate_history
validate_history <- validations %>%
    mutate(
        activity = "Validate",
        action = paste(quotation_id, "validate",  sep = "-"))

# Gather the timestamp columns
validate_history <- validate_history  %>%
    gather(lifecycle, timestamp, started, completed)


# Recode the lifecycle column of validate_history
validate_history <- validate_history %>%
    mutate(lifecycle = fct_recode(lifecycle,
                "start" = "started",
                "complete" = "completed"))


# Add lifecycle and action column to offer_history
offer_history <- offer_history %>%
    mutate(
        lifecycle = "complete",
        action = paste(quotation_id, 1:n(), sep = "-"))

# Create sales_history
sales_history <- bind_rows(validate_history, offer_history)


sales_history <- readRDS("./RInputFiles/otc_sales_history.RDS")
order_history <- readRDS("./RInputFiles/otc_order_history.RDS")
# sales_quotations <- readRDS("./RInputFiles/otc_sales_quotation.RDS")

str(sales_history)
str(order_history)
# str(sales_quotations)

order_history <- order_history %>% 
    rename(timestamp=time, lifecycle=status) %>%
    select(-activity_cost) %>%
    mutate(activity=as.character(activity), 
           resource=as.character(activity), 
           lifecycle=as.character(lifecycle)
           )
sales_history <- sales_history %>%
    mutate(timestamp=lubridate::as_datetime(timestamp))

# sales_history <- sales_history %>% left_join(sales_quotations)
otc <- bind_rows(sales_history, order_history)


# Create the eventlog object 
otc <- otc %>%
    mutate(case_id = paste(quotation_id, sales_order_id, sep = "-")) %>%
    eventlog(
        case_id = "case_id",
        activity_id = "activity",
        activity_instance_id = "action",
        timestamp = "timestamp",
        resource_id = "resource",
        lifecycle_id = "lifecycle"
        )

# Create trace coverage graph
trace_coverage(otc, level="trace") %>% plot()

# Explore traces
otc %>%
    trace_explorer(coverage = 0.25)


# Collapse activities
otc_high_level <- act_collapse(otc, "Delivery" = c(
  "Handover To Deliverer",
  "Order Delivered",
  "Present For Collection",
  "Order Fetched")
  )

# Draw a process map
process_map(otc_high_level)

# Redraw the trace coverage graph
otc_high_level %>% trace_coverage(level="trace") %>% plot()

# Compute activity wise processing time
otc_high_level %>% processing_time(level="activity", units="days")

# Plot a resource activity matrix of otc
otc %>% resource_frequency(level = "resource-activity") %>% plot()


# Create otc_selection
otc_selection <- otc %>% filter_activity(activities = c("Send Quotation","Send Invoice"))

# Explore traces
otc %>% trace_explorer(coverage=1)

# Draw a resource map
otc_selection %>% resource_map()


# Create otc_returned
otc_returned <- otc %>% filter_activity_presence("Return Goods")

# Compute percentage of returned orders
n_cases(otc_returned)/n_cases(otc)

# Trim cases and visualize
otc_returned %>% filter_trim(start_activities="Return Goods") %>% process_map()


# Time from order to delivery
# otc %>% filter_trim(start_activities="Receive Sales Order", end_activities="Order Delivered") %>% 
#     processing_time(units="days")


# Plot processing time by type
# otc %>%
#     group_by(type) %>%
#     throughput_time() %>%
#     plot()

```
  
  
  
***
  
###_Network Science in R - A Tidy Approach_  
  
Chapter 1 - Hubs of the Network  
  
Network science - include social networks, neural networks, etc.:  
  
* Nodes and edges (connections between nodes, aka "ties") make up a network  
	* In a directed network, ties have a direction (for example, followers and follwing)  
    * In an undirected network, ties do not have a direction (for example, mutual friendship)  
    * In a weighted network, the ties have an associated weight (such as bandwidth, duration of friendship, etc.)  
* Chapter will focus on the terrorism network associated with the Madrid train bombing of 2004  
	* Ties include friendhsip, training camps, previous attacks, and other terrorists  
* The network is reflected in tidy fashion, using one data frame for nodes and another for ties  
    * g <- igraph::graph_from_data_frame(d = ties, directed = FALSE, vertices = nodes)  
    * V(g); vcount(g)  
    * E(g); ecount(g)  
* And, then working with attributes of the network  
    * g$name <- "Madrid network"; g$name  
    * V(g)$id <- 1:vcount(g)  
    * E(g)$weight  
  
Visualizing networks:  
  
* The ggraph package can help with visualizing networks  
	* ggraph(g, layout = "with_kk") + geom_edge_link(aes(alpha = weight)) + geom_node_point()  
    * Much like the language of ggplot2  
  
Centrality measures:  
  
* Objective is to find the most important nodes - connections among members of the networks  
* Network science is a spinoff of data science, with the goal of measuring networks  
* The agree of "degree" measures the number of ties (edges) that a node has  
	* degree(g) # gives the number of edges per node  
    * strength(g) # sumes the weights of the edges per node  
  
Example code includes:  
```{r eval=FALSE}

# read the nodes file into the variable nodes
nodes <- readr::read_csv("./RInputFiles/nodes.csv")
nodes

# read the ties file into the variable ties
ties <- readr::read_csv("./RInputFiles/ties.csv")
ties


library(igraph)
library(ggraph)


# make the network from the data frame ties and print it
g <- graph_from_data_frame(ties, directed = FALSE, vertices = nodes)
g

# explore the set of nodes
V(g)

# print the number of nodes
vcount(g)

# explore the set of ties
E(g)

# print the number of ties
ecount(g)


# give the name "Madrid network" to the network and print the network `name` attribute
g$name <- "Madrid network"
g$name

# add node attribute id and print the node `id` attribute
V(g)$id <- 1:vcount(g)
V(g)$id

# print the tie `weight` attribute
E(g)$weight

# print the network and spot the attributes
g


# visualize the network with layout Kamada-Kawai
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha = weight)) + 
  geom_node_point()


# add an id label to nodes
ggraph(g, layout = "with_kk") +
  geom_edge_link(aes(alpha = weight)) +
  geom_node_point()  + 
  geom_node_text(aes(label = id), repel=TRUE)


# visualize the network with circular layout. Set tie transparency proportional to its weight
ggraph(g, layout = "in_circle") + 
  geom_edge_link(aes(alpha = weight)) + 
  geom_node_point()


# visualize the network with grid layout. Set tie transparency proportional to its weight
ggraph(g, layout = "grid") + 
  geom_edge_link(aes(alpha = weight)) + 
  geom_node_point()


# compute the degrees of the nodes
dgr <- degree(g)

# add the degrees to the data frame object
nodes <- mutate(nodes, degree = dgr)

# add the degrees to the network object
V(g)$degree <- dgr

# arrange the terrorists in decreasing order of degree
arrange(nodes, -degree)


# compute node strengths
stg <- strength(g)

# add strength to the data frame object using mutate
nodes <- mutate(nodes, strength = stg)

# add the variable stg to the network object as strength
V(g)$strength <- stg

# arrange terrorists in decreasing order of strength and then in decreasing order of degree
arrange(nodes, -degree)
arrange(nodes, -strength)

```
  
  
  
***
  
Chapter 2 - Weakness and strength  
  
Tie betweenness:  
  
* Betweeness is the number of shortest paths that go through a specific tie (edge) - these removals would be the most disruptive  
* In a weighted network, the shortest path is defined as the lowest sum of weights, rather than the fewest edges  
	* Often need to inverse the weights prior to running, since a "high" weight usually means a close connection and thus an easy path  
    * dist_weight = 1 / E(g)$weight  
    * edge_betweenness(g, weights = dist_weight)  
	
Visualizing centrality measures:  
  
* Visualizing betweenness can be done within the igraph package  
    * ggraph(g, layout = "with_kk") + geom_edge_link(aes(alpha = betweenness)) + geom_node_point()  
    * ggraph(g, layout = "with_kk") + geom_edge_link(aes(alpha = weight)) + geom_node_point(aes(size = degree))  
  
The strength of weak ties:  
  
* "The strength of weak ties" is a research paper written about network strengths  
	* Argument is that the "weak ties" in a network are often the most important - relationships between diverse communities, leading to diverse ideas  
    * The "strong ties" are the relationships between people who are frequently together - can lead to group-think and stasis  
    * Noted that the Madrid group (and similar) tended to be highly dispersed and thus having many weak ties  
    * ties %>% group_by(weight) %>% summarise(n = n(), p = n / nrow(ties)) %>% arrange(-n)  
  
Example code includes:  
```{r eval=FALSE}

# save the inverse of tie weights as dist_weight
dist_weight <- 1 / E(g)$weight

# compute weighted tie betweenness
btw <- edge_betweenness(g, weights = dist_weight)

# mutate the data frame ties adding a variable betweenness using btw
ties <- mutate(ties, betweenness=btw)

# add the tie attribute betweenness to the network
E(g)$betweenness <- btw


# join ties with nodes
ties_joined <- ties %>% 
  left_join(nodes, c("from" = "id")) %>% 
  left_join(nodes, c("to" = "id")) 

# select only relevant variables and save to ties
ties_selected <- ties_joined %>% 
  select(from, to, name_from = name.x, name_to = name.y, betweenness)

# arrange named ties in decreasing order of betweenness
arrange(ties_selected, -betweenness)


# set (alpha) proportional to weight and node size proportional to degree
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha=weight)) + 
  geom_node_point(aes(size=degree))

# produce the same visualization but set node size proportional to strength
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha = weight)) + 
  geom_node_point(aes(size = strength))


# visualize the network with tie transparency proportional to betweenness
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha = betweenness)) + 
  geom_node_point()

# add node size proportional to degree
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha = betweenness)) + 
  geom_node_point(aes(size = degree))


# find median betweenness
q = median(E(g)$betweenness)

# filter ties with betweenness larger than the median
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha = betweenness, filter = (betweenness > q))) + 
  geom_node_point() + 
  theme(legend.position="none")


# find number and percentage of weak ties
ties %>%
  group_by(weight) %>%
  summarise(number = n(), percentage=n()/nrow(.)) %>%
  arrange(-number)


# build vector weakness containing TRUE for weak ties
weakness <- ifelse(ties$weight == 1, TRUE, FALSE)

# check that weakness contains the correct number of weak ties
sum(weakness)


# visualize the network by coloring the weak and strong ties
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(color = weakness)) + 
  geom_node_point()


# visualize the network with only weak ties using the filter aesthetic
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(filter=weakness), alpha = 0.5) + 
  geom_node_point()

```
  
  
  
***
  
Chapter 3 - Connection patterns  
  
Connection patterns:  
  
* The adjacency matrix can be calculated using as_adjacency_matrix(g)  
	* For each match of row/column, there will be a 1 for adjacency and a 0 for non-adjacency  
    * Alternately, can have the weight of the tie as the entry for each row/column (with 0 as before meaning non-adjacency)  
    * A = as_adjacency_matrix(g, attr = "weight")  
    * diag(A)  
* Can use the adjacency matrix to assess similarity of nodes in the matrix  
	* The Pearson similarity measures the correlation between the columns in the matrix  
  
Pearson correlation coefficient:  
  
* Can visualize the correlations using scatterplots  
* Can compute the correlations analytically as well  
	* cor(nodes$degree, nodes$strength)  
  
Most similar and most dissimilar terrorists:  
  
* Can use named graphs with weighted ties for a graphical representation of nodes and paths  
* Can use the adjacency matrix to reprsent the ties in a manner simplified for algebra  
* Can use the data frame format (one for nodes, and one for ties) for use with dplur and ggplot2  
	* as_data_frame(g, what = "both")  
* Can easily switch back and forth between the representations of the network  
	* as_adjacency_matrix(g)  
    * graph_from_adjacency_matrix(A)  
    * as_data_frame(g, what = "both")  
    * graph_from_data_frame(df$ties, vertices = df$nodes)  
    * as_data_frame(graph_from_adjacency_matrix(A), what = "both")  
    * as_adjacency_matrix(graph_from_data_frame(df$ties, vertices = df$nodes))  
  
Example code includes:  
```{r eval=FALSE}

# mutate ties data frame by swapping variables from and to 
ties_mutated <- mutate(ties, temp = to, to = from, from = temp) %>% select(-temp)

# append ties_mutated data frame to ties data frame
ties <- rbind(ties, ties_mutated)

# use a scatter plot to visualize node connection patterns in ties setting color aesthetic to weight
ggplot(ties, aes(x = from, y = to, color = factor(weight))) +
  geom_point() +
  labs(color = "weight")


# get the weighted adjacency matrix
A <- as_adjacency_matrix(g, attr = "weight", sparse = FALSE, names = FALSE)

# print the first row and first column of A
A[1, ]
A[, 1]

# print submatrix of the first 6 rows and columns
A[1:6, 1:6]


# obtain a vector of node strengths
rowSums(A)

# build a Boolean (0/1) matrix from the weighted matrix A
B <- ifelse(A > 0, 1, 0)

# obtain a vector of node degrees using the Boolean matrix
rowSums(B)


# compute the Pearson correlation on columns of A
S <- cor(A)

# set the diagonal of S to 0
diag(S) = 0

# print a summary of the similarities in matrix S
summary(c(S))

# plot a histogram of similarities in matrix S
hist(c(S), xlab = "Similarity", main = "Histogram of similarity")


# Scatter plot of degree and strength with regression line
ggplot(nodes, aes(x = degree, y = strength)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)

# Pearson correlation coefficient 
cor(nodes$degree, nodes$strength)


# build weighted similarity network and save to h
h <- graph_from_adjacency_matrix(S, mode = "undirected", weighted = TRUE)

# convert the similarity network h into a similarity data frame sim_df
sim_df <- as_data_frame(h, what = "edges")

# map the similarity data frame to a tibble and save it as sim_tib
sim_tib <- as_tibble(sim_df)

# print sim_tib
sim_tib


# left join similarity and nodes data frames and then select and rename relevant variables
sim2 <- sim_tib %>% 
  left_join(nodes, c("from" = "id")) %>% 
  left_join(nodes, c("to" = "id")) %>%
  select(from, to, name_from = name.x, name_to = name.y, similarity = weight, 
         degree_from = degree.x, degree_to = degree.y, strength_from = strength.x, strength_to = strength.y)
  
# print sim2
sim2


# arrange sim2 in decreasing order of similarity. 
sim2 %>% arrange(-similarity)

# filter sim2, allowing only pairs with a degree of least 10, arrange the result in decreasing order of similarity
sim2 %>%
  filter(degree_from >= 10, degree_to >= 10) %>%
  arrange(-similarity)

# Repeat the previous steps, but in increasing order of similarity
sim2 %>%
  filter(degree_from >= 10, degree_to >= 10) %>%
  arrange(similarity)


# filter the similarity data frame to similarities larger than or equal to 0.60
sim3 <- filter(sim2, similarity >= 0.6)

# build a similarity network called h2 from the filtered similarity data frame
h2 <- graph_from_data_frame(sim3, directed = FALSE)

# visualize the similarity network h2
ggraph(h2, layout = "with_kk") + 
  geom_edge_link(aes(alpha = similarity)) + 
  geom_node_point()

```
  
  
  
***
  
Chapter 4 - Similarity Clusters  
  
Hierarchical clustering - find clusters of similar people:  
  
* Basic idea is to define a measure of similarity, then match the most similar entities to groups, proceeding until there is a single cluster containing everyone  
* The dendrogram (tree diagram) is helpful for viewing this data  
* The similarity measure between individual nodes (person similarity) exists, and needs to be extended to groups  
	* Single-linkage - similarity is the maximum of the similarities of anyone in the groups  
    * Complete-linkage - similarity is the minimum of the similarities of anyone in the groups  
    * Average-linkage - similarity is the average of the simlarities of everyone in the groups  
* The clustering algorithm works as follows  
	* Evaluate simlarity for all node pairs  
    * Assign each node to its own group  
    * Find the pair of groups with the highest simlarity, and join them  
    * Calculate simlarity of this newly formed group to all previously existing entities (groups or individuals)  
    * Repeat until there is just a single cluster remaining  
* The R implementation is hclust()  
    * D <- 1-S  
    * d <- as.dist(D)  
    * cc <- hclust(d, method = "average")  
    * cls <- cutree(cc, k = 4)  
  
Interactive visualizations with visNetwork:  
  
* visNetwork is an interactive package for viewing networks  
	* Many different layouts are available, and you can interact with the nodes and the ties  
    * Can select nodes and see their neighborhoods (nodes within a certain distance)  
    * Can select nodes by name  
    * Can partition nodes in to groups and color, highlight, etc.  
  
Wrap up:  
  
* Analysis of networks with measures of centrality and similarity  
* Visualization of networks, including interactivity  
  
Example code includes:  
```{r eval=FALSE}

# compute a distance matrix
D <- 1 - S

# obtain a distance object 
d <- as.dist(D)

# run average-linkage clustering method and plot the dendrogram 
cc <- hclust(d, method = "average")
plot(cc)

# find the similarity of the first pair of nodes that have been merged 
S[40, 45]


# cut the dendrogram at 4 clusters
cls <- cutree(cc, k = 4)

# add cluster information to the nodes data frame
nodes <- mutate(nodes, cluster = cls)

# print the nodes data frame
nodes


# output the names of terrorists in the first cluster
filter(nodes, cluster == 1) %>% 
    select(name)

# for each cluster select the size of the cluster, the average node degree, and the average node strength and sorts by cluster size
group_by(nodes, cluster) %>%
  summarise(size = n(), 
            avg_degree = mean(degree),
            avg_strength = mean(strength)
            ) %>%
  arrange(-size)


# add cluster information to the network 
V(g)$cluster <- nodes$cluster

# visualize the original network with colored clusters
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha = weight), show.legend=FALSE) + 
  geom_node_point(aes(color = factor(cluster))) +
  labs(color = "cluster")

# facet the network with respect to cluster attribute
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha = weight), show.legend=FALSE) + 
  geom_node_point(aes(color = factor(cluster))) +
  facet_nodes(~cluster, scales="free")  +
  labs(color = "cluster")


# convert igraph to visNetwork
data <- visNetwork::toVisNetworkData(g)

# print head of nodes and ties
head(data$nodes)
head(data$edges)

# visualize the network
visNetwork::visNetwork(nodes = data$nodes, edges = data$edges, width = 300, height = 300)


# use the circle layout
visNetwork::visNetwork(nodes = data$nodes, edges = data$edges, width = 300, height = 300) %>%
  visNetwork::visIgraphLayout(layout = "layout_with_kk")

# use the circle layout
visNetwork::visNetwork(nodes = data$nodes, edges = data$edges, width = 300, height = 300) %>%
  visNetwork::visIgraphLayout(layout = "layout_in_circle")

# use the grid layout
visNetwork::visNetwork(nodes = data$nodes, edges = data$edges, width = 300, height = 300) %>%
  visNetwork::visIgraphLayout(layout = "layout_on_grid")


# highlight nearest nodes and ties of the selected node
visNetwork::visNetwork(nodes = data$nodes, edges = data$edges, width = 300, height = 300) %>%
  visNetwork::visIgraphLayout(layout = "layout_with_kk") %>%
  visNetwork::visOptions(highlightNearest = TRUE) 


# select nodes by id 
visNetwork::visNetwork(nodes = data$nodes, edges = data$edges, width = 300, height = 300) %>%
  visNetwork::visIgraphLayout(layout = "layout_with_kk") %>%
  visNetwork::visOptions(nodesIdSelection = TRUE)

# set color to cluster and generate network data
V(g)$color = V(g)$cluster
data <- visNetwork::toVisNetworkData(g)

# select by group (cluster)
visNetwork::visNetwork(nodes = data$nodes, edges = data$edges, width = 300, height = 300) %>%
  visNetwork::visIgraphLayout(layout = "layout_with_kk") %>%
  visNetwork::visOptions(selectedBy = "group")

```
  
  
  
***
  
###_Data Privacy and Anaonymization in R_  
  
Chapter 1 - Introduction to Data Privacy  
  
Intro to Anonymization - Part I:  
  
* Need to implement better data privacy techniques - e.g., census data, healthcare data, etc.  
* Need to have data such as individualized health, but not in a manner that identifies specific individuals  
* Topics covered in this course will include  
	* Remove identifiers, synthesize data  
    * Laplace mechnaism for removing names  
    * Differential privacy and post-processing  
    * Release of data using the above techniques  
* Data sets will include White House salaries and male infertility data  
	* One basic technique is removing identifiers, such as replacing names with numbers  
    * Another basic technique is to round continuous values (such as to the nearest 1000)  
  
Intro to Anonymization - Part II:  
  
* Additional approaches include generalization and top/bottom coding  
	* Generalization creates larger buckets of data  
    * Top/bottom is about setting outliers back to a pre-defined top and bottom of the range  
* Additional dplyr functions of interest  
	* count() is used to find the number of observations for each distinct group  
    * whitehouse %>% count(Status)  
    * whitehouse %>% count(Status, Title, sort = TRUE)  # sort=TRUE sorts by descending n  
    * summarize_at() lets you get summary statistics for a key variable  
    * whitehouse %>% summarise_at(vars(Salary), sum)  # vars() holds the bare variables, while sum is the requested function  
    * whitehouse %>% summarise_at(vars(Salary), funs(mean, sd))  # funs() holds the list of functions that you want to apply  
  
Data Synthesis:  
  
* Fake datasets created based on sampling from a probability distribution  
* Goal is a fake dataset (by definition anaonymized) that is statistically similar to the real dataset  
	* For 1/0 data, sampling from the binomial distribution can work well  
    * For bell-shaped data, the normal or log-normal can often work well (though there can be issues with bounding)  
    * Hard-bounding is setting values to a proper max/min, while another approach is to discard the record and sample again  
  
Example code includes:  
```{r}

load("./RInputFiles/dataPriv.RData")


# Preview data
whitehouse

# Set seed
set.seed(42)

# Replace names with random numbers from 1 to 1000
whitehouse_no_names <- whitehouse %>%
    mutate(Name = sample(1:1000, nrow(.), replace=FALSE))

whitehouse_no_names


# Rounding Salary to the nearest ten thousand
whitehouse_no_identifiers <- whitehouse_no_names %>%
    mutate(Salary = round(Salary, -4))

whitehouse_no_identifiers


# Convert the salaries into three categories
whitehouse.gen <- whitehouse %>%
    mutate(Salary = ifelse(Salary < 50000, 0, 
                           ifelse(Salary >= 50000 & Salary < 100000, 1, 2)))

whitehouse.gen


# Bottom Coding
whitehouse.bottom <- whitehouse %>%
    mutate(Salary = pmax(Salary, 45000))

# Filter Results
whitehouse.bottom %>%
    filter(Salary <= 45000)


# View fertility data
fertility

# Number of participants with Surgical_Intervention and Diagnosis
fertility %>%
    summarise_at(vars(Surgical_Intervention, Diagnosis), sum)

# Mean and Standard Deviation of Age
fertility %>%
    summarise_at(vars(Age), funs(mean, sd))

# Counts of the Groups in High_Fevers
fertility %>%
    count(High_Fevers)

# Counts of the Groups in Child_Disease
fertility %>%
    count(Child_Disease, Accident_Trauma)

# Find proportions
fertility %>%
    summarise_at(vars(Accident_Trauma, Surgical_Intervention), mean)


# Set seed
set.seed(42)

# Generate Synthetic data
accident <- rbinom(100, 1, prob=0.440)
surgical <- rbinom(100, 1, prob=0.510)


# Square root Transformation of Salary
whitehouse.salary <- whitehouse %>%
    mutate(Salary = sqrt(Salary))

# Calculate the mean and standard deviation
stats <- whitehouse.salary %>%
    summarize(mean(Salary), sd(Salary))

stats


# Generate Synthetic data
set.seed(42)
salary_transformed <- rnorm(nrow(whitehouse), mean=279, sd=71.8)

# Power transformation
salary_original <- salary_transformed ** 2

# Hard bound
salary <- ifelse(salary_original < 0, 0, salary_original)

```
  
  
  
***
  
Chapter 2 - Introduction to Differential Privacy  
  
Differential Privacy - quantification of privacy loss via a privacy budget:  
  
* The worst-case scenario is that no assumptions are made about data intruders  
	* If an individual is from a small group, their data may be 100% available by looking at statistics in aggregate and statistics for the group that excludes them (everyone else)  
* The privacy budget is defined using epsilon - smaller numbers mean that less information will be made available  
* The general concept is to look at a dataset that includes the segment the individual is in, and a dataset that includes all other segments  
	* The answer sent back to the query will have noise added to it depending on the privacy budget  
* Basically, the differential privacy algorithm finds the most "unique" person in the dataset, and then decides how much noise to add based on how identifiable they are by attribute  
  
Global Sensitivity - usual decision-making factor for differential privacy:  
  
* The global sensitivity of a query is the most a variable could change based on removing one individual  
	* By definition, count queries always have a global sensitivity of 1 (exclude 1 individual)  
    * Therefore, proportion queries always have a global sensitity of 1/n  
    * Mean queries always have a global sensitivity of (max - min) / n  
    * Variance queries always have a global sensitivity of (max - min)^2 / n  
* The global sensitivity and the epsilon work together to determine the amount of noise  
	* Measures like median are not very sensitive to outliers, and thus very little noise needs to be added  
    * Measures like maximum are very sensitive to outliers (e.g., Bill Gates income), and thus very little noise needs to be added  
  
Laplace Mechanism - adds noise based on the Laplace distribution with mean 0 and parameters global sensitivity and privacy budget:  
  
* fertility %>% summarise_at(vars(Child_Disease), sum)  
* library(smoothmest)  # has function rdoublex(draws, mean, shaping) - set draws=1, mean=true_mean, shaping=globalSensitivity / epsilon  
  
Example code includes:  
```{r}

# Number of observations
n <- nrow(fertility)

# Global sensitivity of counts
gs.count <- 1

# Global sensitivity of proportions
gs.prop <- 1/n


# Lower bound of Hours_Sitting
a <- 0

# Upper bound of Hours_Sitting
b <- 1

# Global sensitivity of mean for Hours_Sitting
gs.mean <- (b - a) / n

# Global sensitivity of proportions Hours_Sitting
gs.var <- (b - a)**2 / n


# How many participants had a Surgical_Intervention?
fertility %>%
   summarise_at(vars(Surgical_Intervention), sum)

# Set the seed
set.seed(42)

# Apply the Laplace mechanism
eps <- 0.1
smoothmest::rdoublex(1, 51, 1/eps)


# Proportion of Accident_Trauma
stats <- fertility %>%
   summarise_at(vars(Accident_Trauma), mean)

stats

# Set the seed
set.seed(42)

# Apply the Laplace mechanism
eps <- 0.1
smoothmest::rdoublex(1, 0.440, (1/n)/eps)


# Mean and Variance of Hours Sitting
fertility %>%
    summarise_at(vars(Hours_Sitting), funs(mean, var))

# Setup
set.seed(42)
eps <- 0.1

# Laplace mechanism to mean
smoothmest::rdoublex(1, 0.41, gs.mean/eps)

# Laplace mechanism to variance
smoothmest::rdoublex(1, 0.03, gs.var/eps)

```
  
  
  
***
  
Chapter 3 - Differentially Private Properties  
  
Sequential Composition - method to require that someone cannot find the real answer by just sending multiple queries:  
  
* Idea is that the privacy budget is divided by the number of queries you plan to send  
* For example, if a query will be made for mean and another query will be made for maximum, then epsilon needs to be divided by two  
  
Parallel Composition - method to account for queries to different parts of the database (no adjustment to epsilon needed):  
  
* Deciding between sequential and parallel is whether queries could be answered using completely different (MECE) splits of the dataset  
  
Post-processing:  
  
* When new queries can be answered using data that has already been privatized, it can be synthesized to a noisy answer to this new query  
	* The privacy budget need not be adjusted in this case  
    * For example, if there are three groups, can just add noise to two of the groups and let the third group be total minus these two groups  
  
Impossible and inconsistent answers:  
  
* Bounding can be introduced, such as making all negative numbers zero or anything greater than the total to the total  
	* rdoublex(1, 12, gs.count / eps) %>% round() %>% max(0)  # lower bound is zero  
    * normalized <- (smoking/sum(smoking)) * (nrow(fertility))  # upper bound is the size of the dataset  
  
Example code includes:  
```{r}

# Set Value of Epsilon
eps <- 0.1 / 2

# Number of observations
n <- nrow(fertility)

# Lower bound of Age
a <- 0

# Upper bound of Age
b <- 1

# GS of counts for Diagnosis
gs.count <- 1

# GS of mean for Age
gs.mean <- (b-a)/n


# Number of Participants with abnormal diagnosis
stats1 <- fertility %>% 
    summarize_at(vars(Diagnosis), sum)

stats1

# Mean of age
stats2 <- fertility %>%
    summarize_at(vars(Age), mean)

stats2


# Set seed
set.seed(42)

# Laplace mechanism to the count of abnormal diagnosis
smoothmest::rdoublex(1, 12, gs.count/eps)

# Laplace mechanism to the mean of age
smoothmest::rdoublex(1, 0.67, gs.mean/eps)


# Set Value of Epsilon
eps <- 0.1

# Mean of Age per diagnosis level 
fertility %>%
  group_by(Diagnosis) %>%
  summarise_at(vars(Age), mean)


# Set the seed
set.seed(42)

# Laplace mechanism to the mean age of participants with an abnormal diagnoisis
smoothmest::rdoublex(1, 0.71, gs.mean/eps)

# Laplace mechanism to the mean age of participants with a normal diagnoisis
smoothmest::rdoublex(1, 0.66, gs.mean/eps)


# Set Value of Epsilon
eps <- 0.5/3

# GS of Counts
gs.count <- 1

# Number of participants in each of the four seasons
fertility %>%
    group_by(Diagnosis) %>%
    summarise_at(vars(Age), mean)

# Set the seed
set.seed(42)

# Laplace mechanism to the number of participants who were evaluated in the winter, spring, and summer
winter <- smoothmest::rdoublex(1, 28, gs.count / eps) %>%
    round()

spring <- smoothmest::rdoublex(1, 37, gs.count / eps) %>%
    round()

summer <- smoothmest::rdoublex(1, 4, gs.count / eps) %>%
    round()

# Post-process based on previous queries
fall <- nrow(fertility) - winter - spring - summer


# Set Value of Epsilon
eps <- 0.01

# GS of counts
gs.count <- 1

# Number of Participants with Child_Disease
fertility %>%
    summarise_at(vars(Child_Disease), sum)

# Apply the Laplace mechanism
set.seed(42)
lap_childhood <- smoothmest::rdoublex(1, 87, gs.count / eps) %>%
    round()

# Total number of observations in fertility
max_value <- nrow(fertility)

# Bound the value such that the noisy answer does not exceed the total number of observations
ifelse(lap_childhood > max_value, max_value, lap_childhood)


# Set the seed
set.seed(42)

# Apply the Laplace mechanism
fever1 <- smoothmest::rdoublex(1, 9, gs.count/eps) %>%
    max(0)
fever2 <- smoothmest::rdoublex(1, 63, gs.count/eps) %>%
    max(0)
fever3 <- smoothmest::rdoublex(1, 28, gs.count/eps) %>%
    max(0)

fever <- c(fever1, fever2, fever3)

# Normalize noise 
fever_normalized <- (fever/sum(fever)) * (nrow(fertility))

# Round the values
round(fever_normalized)

```
  
  
  
***
  
Chapter 4 - Differentially Private Data Synthesis  
  
Laplace Sanitizer - basic way to generate "noisy" categorical data:  
  
* Takes advantage of parallel - if the data can be binned or placed in a contingency table, assumes no more need to divide the privacy budget  
	* Since the data is queries as a histogram, it can be considered disjoint (non-overlapping) and thus parallel composition  
* Can generate data using rep() for a single vector  
  
Parametric Approaches:  
  
* Sampling from a binomial distribution (where appropriate), with a known proportion that has been modified by Laplace differential privacy guarantee  
* Sampling from a normal or log-normal distribution (where appropriate), with a known mean and variance that has been modified by Laplace differential privacy guarantee  
  
Wrap up:  
  
* Basics of anonymyzing data, such as removing names  
* Basics of modifying data such as generalizing to categorical data  
* Basics of generating synthetic data using rbinom() and rnorm()  
* Basics of privacy budgets, global sensitivities, and the Laplace mechanism  
* Basics of differential privacy, such as sequential (split epsilon) or parallel (including through binning or continegnecy tables)  
* Basics of the Laplace sanitizer for both categorical data (rbinom) and continuous data (rnorm)  
* Next steps include managing data gaps, incorrect statistics distributions with hard bounding, etc.  
	* Local differential privacy (Apple) and probabilistic differential privacy (US census)  
    * Techniques specific to GPS data or PCA  
  
Example code includes:  
```{r}

# Set Value of Epsilon
eps <- 0.1

# GS of Counts
gs.count <- 1

# Number of participants in each season
fertility %>%
    count(Season)


# Set the seed
set.seed(42)

# Apply the Laplace mechanism 
winter <- smoothmest::rdoublex(1, 28, gs.count/eps) %>% max(0)
spring <- smoothmest::rdoublex(1, 37, gs.count/eps) %>% max(0)
summer <- smoothmest::rdoublex(1, 4, gs.count/eps) %>% max(0)
fall <- smoothmest::rdoublex(1, 31, gs.count/eps) %>% max(0)


# Store noisy results
seasons <- c(winter = winter, spring = spring, summer = summer, fall = fall)

# Normalizing seasons
seasons_normalized <- (seasons/sum(seasons)) * nrow(fertility)

# Round the values
round(seasons_normalized)

# Generate synthetic data for winter
rep(-1, 29)

# Generate synthetic data for spring
rep(-0.33, 38)

# Generate synthetic data for summer
rep(0.33, 0)

# Generate synthetic data for fall
rep(1, 33)


# Calculate proportions
fertility %>%
    summarise_at(vars(Accident_Trauma, Surgical_Intervention), mean)

# Number of Observations
n <- nrow(fertility)

# Set Value of Epsilon
eps <- 0.1

# GS of Proportion
gs.prop <- (1/n)


# Apply the Laplace mechanism
set.seed(42)
smoothmest::rdoublex(1, 0.44, gs.prop/eps)
smoothmest::rdoublex(1, 0.51, gs.prop/eps)

# Generate Synthetic data
set.seed(42)
accident <- rbinom(n, 1, 0.46)
surgical <- rbinom(n, 1, 0.54)


# Set Value of Epsilon
eps <- 0.1 / 2

# Number of observations
n <- nrow(fertility)

# Upper and lower bounds of age
a <- 0
b <- 1

# GS of mean and variance for age
gs.mean <- (b-a) / n
gs.var <- (b-a)**2 / n


# Mean and Variance of Age
fertility %>%
    summarise_at(vars(Age), funs(mean, var))

# Apply the Laplace mechanism
set.seed(42)
smoothmest::rdoublex(1, 0.67, gs.mean/eps)
smoothmest::rdoublex(1, 0.01, gs.var/eps)


# Generate Synthetic data
set.seed(42)
age <- rnorm(n, mean=0.71, sd=sqrt(0.07))

# Hard Bounding the data
age[age < 0] <- 0
age[age > 1] <- 1

```
  
  
  
*** 
  
###_Marketing Analytics in R: Statistical Modeling_  
  
Chapter 1 - Modeling Customer Lifetime Value with Linear Regression  
  
Introduction - Verena from INWT Statistics (consultancy in marketing analytics):  
  
* Customer Lifetime Value (CLV) is the expected value of forecasted customer value to the company  
	* CLV is based on margin, and needs to use current information to predict future margins  
    * Customers predicted to have higher CLV can then be targeted  
* Can inspect the data without seeing attributes using str(clvData1, give.attr = FALSE)  
* Can derive correlations using corrplot  
	* library(corrplot)  
    * clvData1 %>% select(nOrders, nItems, ... ,margin, futureMargin) %>% cor() %>% corrplot()  
  
Simple linear regression - one predictor variable to predict one response variable:  
  
* Can run linear regressions using basic stats modules  
	* simpleLM <- lm(futureMargin ~ margin, data = clvData1)  
    * summary(simpleLM)  
* Can plot previous margin vs. current margin, including a linear regression (smooth)  
	* ggplot(clvData1, aes(margin, futureMargin)) + geom_point() + geom_smooth(method = lm, se = FALSE) + xlab("Margin year 1") + ylab("Margin year 2")  
* Several conditions must apply for linear regression to be the best method  
	* Linear relationship between x and y  
    * No measurement error in x (weak exogeneity)  
    * Independence of errors  
    * Expectation of errors is 0  
    * Constant variance of prediction errors (homoscedasticity)  
    * Normality of errors  
  
Multiple linear regression:  
  
* Omitted variable bias is when a variable not in the regression is correlated with both the predictor and the response variables  
	* Simpson's Paradox is an example - upward sloping becomes downward sloping after properly splitting on the extra variable  
* Multicollinearity is a threat to a linear regression - leads to unstable regression coefficients, with associated under-reporting of standard errors  
	* rms::vif(myLMModel)  # above 5 is concerning, above 10 almost always needs to be addressed  
  
Model validation, fit, and prediction:  
  
* The R-squared is the proportion of variance in the depedent variable that is explained by the regression  
* Can look at the p-value of the F-test to assess the overall statistical significance of the model  
* There is a risk of over-fitting, when the model is overly complex and learns artifacts of the training data rather than genuine patterns  
	* Can use stats::AIC() or MASS::stepAIC(), with the goal being to minimize AIC (needs to be models of the same data)  
    * AIC(multipleLM2)  
* Can predict outputs automatically, such as with  
	* predMargin <- predict(multipleLM2, newdata = clvData2)  
  
Example code includes:  
```{r}

salesData <- readr::read_csv("./RInputFiles/salesData.csv")

# Structure of dataset
str(salesData, give.attr = FALSE)

# Visualization of correlations
salesData %>% select_if(is.numeric) %>%
  select(-id) %>%
  cor() %>%
  corrplot::corrplot()

# Frequent stores
ggplot(salesData) +
    geom_boxplot(aes(x = mostFreqStore, y = salesThisMon))

# Preferred brand
ggplot(salesData) +
    geom_boxplot(aes(x = preferredBrand, y = salesThisMon))


# Model specification using lm
salesSimpleModel <- lm(salesThisMon ~ salesLast3Mon, data = salesData)

# Looking at model summary
summary(salesSimpleModel)


# Estimating the full model
salesModel1 <- lm(salesThisMon ~ . -id, data = salesData)

# Checking variance inflation factors
car::vif(salesModel1)

# Estimating new model by removing information on brand
salesModel2 <- lm(salesThisMon ~ . -id -preferredBrand -nBrands, data = salesData)

# Checking variance inflation factors
car::vif(salesModel2)


salesData2_4 <- readr::read_csv("./RInputFiles/salesDataMon2To4.csv")

# getting an overview of new data
summary(salesData2_4)

# predicting sales
predSales5 <- predict(salesModel2, newdata = salesData2_4)

# calculating mean of future sales
mean(predSales5)

```
  
  
  
***
  
Chapter 2 - Logistic Regression for Churn Prevention  
  
Churn prevention in online marketing:  
  
* Objective is to predict the likelihood of a customer repeating their business, assessed using logistic regression  
	* Model the log-odds (defined as log (P(Y=1) / P(Y=0))) as a linear function of the inputs  
    * Convert the log-odds to odds (defined as P(Y=1) / P(Y=0)) by exponentiation  
    * Convert the odds to a probability of churning, using odds / (1 + odds)  
* Can begin with basic data exploration  
	* ggplot(churnData, aes(x = returnCustomer)) + geom_histogram(stat = "count")  
  
Modeling and model selection:  
  
* The logit model can be run using the GLM provided in R  
	* logitModelFull <- glm(returnCustomer ~ title + newsletter + websiteDesign + ..., family = binomial, churnData)  
* Interpreting the coefficients is not easy - they are related to the log-odds  
	* Can exponentiate the coefficients to get their impact on the odds  
    * Can then interpret that greater than 1 means "more likely, all else equal"  
* Can use MASS::stepAIC() to help refine the modeling  
	* library(MASS)  
    * logitModelNew <- stepAIC(logitModelFull, trace = 0)  
    * summary(logitModelNew)  
    * Produces a model with fewer variables and a lower AIC  
  
In-sample model fit and thresholding:  
  
* There are three types of pseudo-R-squared statistics available for the results of logistical regression  
	* McFadden: R-squared = 1 - L(null) / L(full)  
    * Cox-Snell: R-squared = 1 - (L(null) / L(full)) ** (2/n)  
    * Nagelkerke: R-squared = [1 - (L(null) / L(full)) ** (2/n)] / [1 - L(null) ** (2/n)]  
    * Generally, anything above 0.2 is reasonably good  
    * descr::LogRegR2(logitModelNew)  
    * library(SDMTools)  
    * churnData$predNew <- predict(logitModelNew, type = "response", na.action = na.exclude)  # get the prediction probabilities  
    * data %>% select(returnCustomer, predNew) %>% tail()  
    * confMatrixNew <- confusion.matrix(churnData$returnCustomer, churnData$predNew, threshold = 0.5)  # this is the version from SDMTools  
* Can give different weights to the different errors (false negatives, false positives, etc.)  
	* Can instead look at a payoff, defined based on scalars for the various quadrants  
  
Out-of-sample validation and cross validation:  
  
* Begin by randomly splitting data in to training (roughly two-thirds) and holding back the remainder for validation (roughly one-third)  
	* set.seed(534381)  
    * churnData$isTrain <- rbinom(nrow(churnData), 1, 0.66)  
    * train <- subset(churnData, churnData$isTrain == 1)  
    * test <- subset(churnData, churnData$isTrain == 0)  
    * test$predNew <- predict(logitTrainNew, type = "response", newdata = test)  # make predictions only on the test dataset  
* Cross-validation is an even more powerful tool for assessing out-of-sample error  
	* Split the data in to k subsets, and run the model k times with k-1 training data and the last subset used as the validation data  
    * Acc03 <- function(r, pi = 0) {  
    *   cm <- confusion.matrix(r, pi, threshold = 0.3)  
    *   acc <- sum(diag(cm)) / sum(cm) return(acc)  
    * }  
    * set.seed(534381)  
    * boot::cv.glm(churnData, logitModelNew, cost = Acc03, K = 6)$delta  
* Can continually tweak the model to see if transforms, variable additions, etc., might tend to improve the out-of-sample error rate  
  
Example code includes:  
```{r}

defaultData <- readr::read_delim("./RInputFiles/defaultData.csv", delim=";")

# Summary of data
summary(defaultData)

# Look at data structure
str(defaultData, give.attr=FALSE)

# Analyze the balancedness of dependent variable
ggplot(defaultData, aes(x = PaymentDefault)) +
  geom_histogram(stat = "count") 


# Build logistic regression model
logitModelFull <- glm(PaymentDefault ~ limitBal + sex + education + marriage +
                   age + pay1 + pay2 + pay3 + pay4 + pay5 + pay6 + billAmt1 + 
                   billAmt2 + billAmt3 + billAmt4 + billAmt5 + billAmt6 + payAmt1 + 
                   payAmt2 + payAmt3 + payAmt4 + payAmt5 + payAmt6, 
                family = "binomial", data = defaultData)

# Take a look at the model
summary(logitModelFull)

# Take a look at the odds
coefsexp <- coef(logitModelFull) %>% exp() %>% round(2)
coefsexp


# The old (full) model
logitModelFull <- glm(PaymentDefault ~ limitBal + sex + education + marriage +
                   age + pay1 + pay2 + pay3 + pay4 + pay5 + pay6 + billAmt1 + 
                   billAmt2 + billAmt3 + billAmt4 + billAmt5 + billAmt6 + payAmt1 + 
                   payAmt2 + payAmt3 + payAmt4 + payAmt5 + payAmt6, 
                 family = binomial, defaultData)

#Build the new model
logitModelNew <- MASS::stepAIC(logitModelFull, trace=0) 

#Look at the model
summary(logitModelNew) 

# Save the formula of the new model (it will be needed for the out-of-sample part) 
formulaLogit <- as.formula(summary(logitModelNew)$call)
formulaLogit


# Make predictions using the full Model
defaultData$predFull <- predict(logitModelFull, type = "response", na.action = na.exclude)

# Construct the in-sample confusion matrix
confMatrixModelFull <- SDMTools::confusion.matrix(defaultData$PaymentDefault, 
                                                  defaultData$predFull, 
                                                  threshold = 0.5
                                                  )
confMatrixModelFull

# Calculate the accuracy for the full Model
accuracyFull <- sum(diag(confMatrixModelFull)) / sum(confMatrixModelFull)
accuracyFull


# Calculate the accuracy for 'logitModelNew'
# Make prediction
defaultData$predNew <- predict(logitModelNew, type = "response", na.action = na.exclude)

# Construct the in-sample confusion matrix
confMatrixModelNew <- SDMTools::confusion.matrix(defaultData$PaymentDefault, 
                                                 defaultData$predNew, 
                                                 threshold = 0.5
                                                 )
confMatrixModelNew

# Calculate the accuracy...
accuracyNew <- sum(diag(confMatrixModelNew)) / sum(confMatrixModelNew)
accuracyNew

# and compare it to the full model's accuracy
accuracyFull
accuracyNew


# Prepare data frame with threshold values and empty payoff column
payoffMatrix <- data.frame(threshold = seq(from = 0.1, to = 0.5, by = 0.1), payoff = NA) 
payoffMatrix
 
for(i in 1:length(payoffMatrix$threshold)) {
  # Calculate confusion matrix with varying threshold
  confMatrix <- SDMTools::confusion.matrix(defaultData$PaymentDefault, 
                                           defaultData$predNew, 
                                           threshold = payoffMatrix$threshold[i]
                                           )
  # Calculate payoff and save it to the corresponding row
  payoffMatrix$payoff[i] <- confMatrix[1, 1]*250 + confMatrix[1, 2]*(-1000)
}
payoffMatrix


# Split data in train and test set
set.seed(534381) 
defaultData$isTrain <- rbinom(nrow(defaultData), 1, 0.66)
train <- subset(defaultData, isTrain == 1)
test <- subset(defaultData, isTrain  == 0)

logitTrainNew <- glm(formulaLogit, family = binomial, data = train) # Modeling
test$predNew <- predict(logitTrainNew, type = "response", newdata = test) # Predictions

# Out-of-sample confusion matrix and accuracy
confMatrixModelNew <- SDMTools::confusion.matrix(test$PaymentDefault, test$predNew, threshold = 0.3) 
sum(diag(confMatrixModelNew)) / sum(confMatrixModelNew) # Compare this value to the in-sample accuracy


# Accuracy function
costAcc <- function(r, pi = 0) {
  cm <- SDMTools::confusion.matrix(r, pi, threshold = 0.3)
  acc <- sum(diag(cm)) / sum(cm)
  return(acc)
}

# Cross validated accuracy for logitModelNew
set.seed(534381)
boot::cv.glm(defaultData, logitModelNew, cost = costAcc, K = 6)$delta[1]

```
  
  
  
***
  
Chapter 3 - Modeling Time to Reorder with Survival Analysis  
  
Survival Analysis Introduction:  
  
* Often have "censored" data, meaning that the customer journeys are not yet complete  
	* Random Type I Right censoring is the most common - a point can only be observed if it has occurred before time X, and it is otherwise unknowable (but known that they have not yet churned)  
    * Can plot histograms of whether someone has churned depending on the length of time  
    * plotTenure <- dataSurv %>% mutate(churn = churn %>% factor(labels = c("No", "Yes"))) %>%  
    *   ggplot() + geom_histogram(aes(x = tenure, fill = factor(churn))) + facet_grid( ~ churn) +           
    *   theme(legend.position = "none")  
* Survival analysis attempts to estimate when something will happen (churn, second order, renewal, etc.)  
  
Survival curve analysis by Kaplan-Meier:  
  
* Begin by creating a new object containing the survival attribute  
	* cbind(dataSurv %>% select(tenure, churn), surv = Surv(dataSurv$tenure, dataSurv$churn)) %>% head(10)  
* The survival function is the probability of "no event" in cumulative by time t  
	* The hazard function is the cumulative probability of "event" by time t  
    * The "hazard rate" is the probability of the event happening in a small time, provided that it has not yet happened  
* The Kaplan-Meier analysis can be used to estimate survival  
	* fitKM <- survival::survfit(Surv(dataSurv$tenure, dataSurv$churn) ~ 1, type = "kaplan-meier")  
    * print(fitKM)  # gives a few rough summary statistics  
    * plot(fitKM) # survival curve with confidence interval  
    * fitKMstr <- survfit(Surv(tenure, churn) ~ Partner, data = dataSurv)  # add covariates, such as ~ Partner rather than ~1 as in the baseline  
  
Cox PH model with constant covariates:  
  
* Model definition: cannot parse to ISO - see Excel notes  
	* Predictors are lineary and multiplicatively related to the hazard function, lambda  
    * Relative hazard function needs to remain constant over time  
* Fitting a survival model in R  
	* library(rms)  
    * units(dataSurv$tenure) <- "Month"  
    * dd <- datadist(dataSurv)  
    * options(datadist = "dd")  
    * fitCPH1 <- cph(Surv(tenure, churn) ~ gender + SeniorCitizen + Partner + Dependents + StreamMov + PaperlessBilling + PayMeth + MonthlyCharges, data = dataSurv, x = TRUE, y = TRUE, surv = TRUE, time.inc = 1)  
    * Coefficient interpretation is relatively similar to logistic regression - exp(fitCPH1$coefficients) - can simplify the coefficients be making them multiplicative (1.00 is no impact)  
    * survplot(fitCPH1, MonthlyCharges, label.curves = list(keys = 1:5))  # plots the survival probabilities based on varying 1 variable, assuming other variables constant  
    * survplot(fitCPH1, Partner)  # covariate with partner, plotted  
    * plot(summary(fitCPH1), log = TRUE)  # visualizing the hazard ratios  
  
Checking model assumptions and making predictions:  
  
* Can again use the Cox PH function  
	* testCPH1 <- cox.zph(fitCPH1)  
    * print(testCPH1)  # if p < 0.05, can reject the assumption that the predictor meets the proportional hazard assumption  
    * plot(testCPH1, var = "Partner=Yes")  
    * plot(testCPH1, var = "MonthlyCharges")  
    * This test is conservative and sensitive to the number of observations  
* If the PH (proportional hazard) assumptions are violated, can correct for this using  
	* fitCPH2 <- cph(Surv(tenure, churn) ~ MonthlyCharges + SeniorCitizen + Partner + Dependents + StreamMov + Contract, stratum = "gender = Male", data = dataSurv, x = TRUE, y = TRUE, surv = TRUE)  
    * rms::validate(fitCPH1, method = "crossvalidation", B = 10, pr = FALSE)  # pr=FALSE means only print at the end; R2 is the R-squared corrected by cross-validation  
* Can then assess probabilities for the event to occur  
	* oneNewData <- data.frame(gender = "Female", SeniorCitizen = "Yes", Partner = "No", Dependents = "Yes", StreamMov = "Yes", PaperlessBilling = "Yes", PayMeth = "BankTrans(auto)", MonthlyCharges = 37.12)  
    * str(survest(fitCPH1, newdata = oneNewData, times = 3))  
    * plot(survfit(fitCPH1, newdata = oneNewData))  
    * print(survfit(fitCPH1, newdata = oneNewData))  
  
Example code includes:  
```{r}

survData <- readr::read_delim("./RInputFiles/survivalDataExercise.csv", delim=",")


dataNextOrder <- survData %>%
    select(daysSinceFirstPurch, boughtAgain)

# Look at the head of the data
head(dataNextOrder)

# Plot a histogram
ggplot(dataNextOrder) +
  geom_histogram(aes(x = daysSinceFirstPurch, fill = factor(boughtAgain))) +
  facet_grid( ~ boughtAgain) + # Separate plots for boughtAgain = 1 vs. 0
  theme(legend.position = "none") # Don't show legend


# Create survival object
survObj <- survival::Surv(dataNextOrder$daysSinceFirstPurch, dataNextOrder$boughtAgain)

# Look at structure
str(survObj)


# Compute and print fit
fitKMSimple <- survival::survfit(survObj ~ 1)
print(fitKMSimple)

# Plot fit
plot(fitKMSimple, conf.int = FALSE, xlab = "Time since first purchase", 
     ylab = "Survival function", main = "Survival function"
     )


dataNextOrder <- survData %>%
    select(daysSinceFirstPurch, boughtAgain, voucher)

# Compute fit with categorical covariate
fitKMCov <- survival::survfit(survObj ~ voucher, data = dataNextOrder)

# Plot fit with covariate and add labels
plot(fitKMCov, lty = 2:3, xlab = "Time since first purchase", 
     ylab = "Survival function", main = "Survival function"
     )
legend(90, .9, c("No", "Yes"), lty = 2:3)


dataNextOrder <- survData

# Determine distributions of predictor variables
dd <- rms::datadist(dataNextOrder)
options(datadist = "dd")

# Compute Cox PH Model and print results
fitCPH <- rms::cph(survival::Surv(daysSinceFirstPurch, boughtAgain) ~ 
                       shoppingCartValue + voucher + returned + gender, data = dataNextOrder, 
                   x = TRUE, y = TRUE, surv = TRUE
                   )
print(fitCPH)

# Interpret coefficients
exp(fitCPH$coefficients)

# Plot result summary
plot(summary(fitCPH), log = TRUE)


# Check proportional hazard assumption and print result
testCPH <- survival::cox.zph(fitCPH)
print(testCPH)

# Plot time-dependent beta
plot(testCPH, var = "gender=male")

# Validate model
rms::validate(fitCPH, method = "crossvalidation", B = 10, dxy = TRUE, pr = FALSE)


# Create data with new customer
newCustomer <- data.frame(daysSinceFirstPurch = 21, shoppingCartValue = 99.9, gender = "female", 
                          voucher = 1, returned = 0, stringsAsFactors = FALSE
                          )

# Make predictions
pred <- survival::survfit(fitCPH, newdata = newCustomer)
print(pred)
plot(pred)

# Correct the customer's gender
newCustomer2 <- newCustomer
newCustomer2$gender <- "male"

# Redo prediction
pred2 <- survival::survfit(fitCPH, newdata = newCustomer2)
print(pred2)

```
  
  
  
***
  
Chapter 4 - Reducing Dimensionality with Principal Component Analysis  
  
PCA for CRM Data - address mutlicollinearity and data volume issues in the raw CRM data:  
  
* PCA reduces a large number of correlated variables to a smaller number of uncorrelated (orthogonal) variables  
* PCA can also help with creating an index, such as using the first component of the PCA  
* All variables must be either continuous or binary prior to running the PCA analysis  
	* dataCustomers %>% cor() %>% corrplot()  # plot the initial correlations  
  
PCA Computation:  
  
* Need to manage for variance, otherwise high-variance variables will be over-represented in the PCA  
	* lapply(dataCustomers, var)  
    * dataCustomers <- dataCustomers %>% scale() %>% as.data.frame()  
    * pcaCust <- prcomp(dataCustomers)  
    * pcaCust$sdev %>% round(2)  # standard deviations by component  
    * pcaCust$sdev ^ 2 %>% round(2)  # variances, also known as eigenvalues, by component give a good sense for relative importance (relative ratio is percent of variance explained)  
    * round(pcaCust$rotation[, 1:6], 2)  # correlations between original variables and principal components (can use these to give descriptive names to components)  
* Values of the observations are the weightings for the PC to make up the underlying data  
	* sum(dataCustomers[1,] * pcaCust$rotation[,1])  # Value on 1st component for 1st customer  
    * pcaCust$x[1:5, 1:6]  # first 5 customers and first 6 component loadings (weightings)  
  
PCA Model Specification:  
  
* Need to decide on how many components to keep - balance size of data vs. reconstruction of original data  
	* Can set a minimum requirement for percentage of variance explained (such as 70%)  
    * summary(pcaCust)  # will show cumulatives also  
    * Can use the Kaiser-Guttman criteria, which keeps only components with an eigenvalue of 1 (since 1 is the average)  
    * Can also draw a scree plot to see the variances (eigenvalues) in descending order - look for an elbow  
    * screeplot(pcaCust, type = "lines")  
    * Generally, use a few different techniques, and pick a number that is "in the range"  
* The biplot can help to show how the data map on to the principal components  
	* biplot(pcaCust, choices = 1:2, cex = 0.7)  # will show PC1 and PC2, with arrows for the various features and how they map on them  
  
Principal components in a regression analysis:  
  
* PCA can help to solve the multi-collinearity problem in a regression  
	* dataCustComponents <- cbind(dataCustomers[, "customerSatis"], pcaCust$x[, 1:6]) %>% as.data.frame  
    * mod2 <- lm(customerSatis ~ ., dataCustComponents)  
    * vif(mod2)  # by construction, these will all be 1, since the principal components are orthogonal  
* Factor analysis is another dimension-reduction technique, sometimes confused with PCA  
	* Factor analysis theorizes that latent constructs (e.g., intelligence) which cannot be directly measured are influencing the observed variables  
    * Factor analysis is often used in questionnaires - factor analysis can investigate where multiple questions really just measure one thing  
    * In contrast, with PCA, the features are actually being combined to model the data  
  
Wrap up:  
  
* Logistic regression for churn  
* Survival analysis to prevent churn  
* Principal component analysis (PCA) to reduce multicollinearity  
  
Example code includes:  
```{r}

load("./RInputFiles/newsData.RData")

rawData <- newsData
newsData <- newsData[, c('n_tokens_title', 'n_tokens_content', 'n_unique_tokens', 'num_hrefs', 'num_self_hrefs', 'num_imgs', 'num_videos', 'num_keywords', 'is_weekend', 'kw_avg_min', 'kw_avg_avg', 'kw_avg_max', 'average_token_length', 'global_subjectivity', 'global_sentiment_polarity', 'global_rate_positive_words', 'global_rate_negative_words', 'avg_positive_polarity', 'avg_negative_polarity', 'title_subjectivity', 'title_sentiment_polarity')]


# Overview of data structure:
str(newsData, give.attr = FALSE)

# Correlation structure:
newsData %>% cor() %>% corrplot::corrplot()


# Standardize data
newsData <- newsData %>% scale() %>% as.data.frame()

# Compute PCA
pcaNews <- newsData %>% prcomp()

# Eigenvalues
pcaNews$sdev**2


# Screeplot:
screeplot(pcaNews, type = "lines")

# Cumulative explained variance:
summary(pcaNews)

# Kaiser-Guttmann (number of components with eigenvalue larger than 1):
sum(pcaNews$sdev > 1)


# Print loadings of the first six components
pcaNews$rotation[, 1:6] %>% round(2)

pcaNews %>% biplot(choices=1:2, cex = 0.5)


# Predict log shares with all original variables
logShares <- rawData %>%
    select(shares) %>%
    mutate(logShares=log(1+shares)) %>%
    pull(logShares) %>%
    scale()

newsData <- newsData %>%
    cbind(logShares)

mod1 <- lm(logShares ~ ., data = newsData)

# Create dataframe with log shares and first 6 components
dataNewsComponents <- cbind(logShares = newsData[, "logShares"], pcaNews$x[, 1:6]) %>%
  as.data.frame()

# Predict log shares with first six components
mod2 <- lm(logShares ~ ., data = dataNewsComponents)

# Print adjusted R squared for both models
summary(mod1)$adj.r.squared
summary(mod2)$adj.r.squared

```
  
  
  
***
  
###_Interactive Maps with leaflet in R_  
  
Chapter 1 - Setting Up Interactive Web Maps  
  
Introduction to leaflet - open-source JavaScript library that makes interactive, mobile-friendly maps:  
  
* Objective for this course is to build up to an interactive map of 4-year colleges, including incorporation type (public, private, etc.)  
	* Additionally, labels that occur when hovering  
* Leaflet builds maps using tiles, which join many smaller maps together  
	* library(leaflet)  
    * leaflet() %>% addTiles()  # zooming and scrolling lead to new tiles being shown  
* In Chapter 1, will use multiple tile types to create maps of the DataCamp HQ in Belgium and Boston  
	* leaflet() %>% addProviderTiles("CartoDB") %>% addMarkers(lng = dc_hq$lon, lat = dc_hq$lat, popup = dc_hq$hq)  
  
Map tiles - over 100 pre-canned maps that are available as bases:  
  
* Selecting a base map - consider the intended purpose of the map, and ensure that the maps selected meet that purpose  
	* Instructor has a preference for gray-scale maps (for ease of seeing other data)  
* The base maps are stored as "providers" - most are available for immediate use, but a few require registration  
	* names(providers)  # get all the available providers  
    * names(providers)[str_detect(names(providers), "OpenStreetMap")]  # all from OpenStreetMap  
    * leaflet() %>% # addTiles() addProviderTiles("OpenStreetMap.BlackAndWhite")  # replace the default with the BW OpenStreetMap  
  
Setting the default map view:  
  
* Can load the map centered on a specific point and with a requested zoom level - coomon to use ggmap::geocode()  
	* ggmap::geocode("350 5th Ave, New York, NY 10118")   # will return the lat-lon where possible (uses google API unless source="dsk" is chosen)  
* Can use either setView() or fitBounds()  
	* leaflet() %>% addTiles() %>% setView(lng = -73.98575, lat = 40.74856, zoom = 13)  # setView picks a lat/lon and zoom  
    * leaflet() %>% addTiles() %>% fitBounds( lng1 = -73.910, lat1 = 40.773, lng2 = -74.060, lat2 = 40.723)  # fitBounds defines a rectangle  
* Can limit user controls such as panning and zooming  
	* leaflet(options = leafletOptions(dragging = FALSE, minZoom = 14, maxZoom = 18)) %>% addProviderTiles("CartoDB") %>% setView(lng = -73.98575, lat = 40.74856, zoom = 18)  
    * dragging=FALSE removes the ability to pan  
    * maxZoom and minZoom limit the options for zooming  
    * leaflet() %>% addTiles() %>% setView(lng = -73.98575, lat = 40.74856, zoom = 18) %>% setMaxBounds(lng1 = -73.98575, lat1 = 40.74856, lng2 = -73.98575, lat2 = 40.74856)  
    * setMaxBounds() limits the user to the boundaries that you pre-specify  
* For more information, can go to  
	* http://leafletjs.com/reference-1.3.0.html  
    * https://rstudio.github.io/leaflet/  
  
Plotting DataCamp HQ:  
  
* Location markers are a common addition, managed using addMarkers()  
	* leaflet() %>% addTiles() %>% addMarkers(lng = -73.98575, lat = 40.74856)  
    * If single vectors are passed to lng and lat, then a single blue pin will be placed and the map will be centered/zoomed there  
    * dc_hq <- tibble( hq = c("DataCamp - NYC", "DataCamp - Belgium"), lon = c(-73.98575, 4.717863), lat = c(40.74856, 50.881363))  
    * leaflet() %>% addTiles() %>% addMarkers(lng = dc_hq$lon, lat = dc_hq$lat)  
    * When the tibble is passed, then the map will be zoomed/centered such that all the pins can be displayed
dc_hq %>% leaflet() %>% addTiles() %>% addMarkers()   
    * The functions will seek a lat and lon column from the piped in data (dc_hq in this case), and pass along a note that they were used  
* Pop-ups are a common way to provide additional information about a marker  
	* leaflet() %>% addTiles() %>% addMarkers(lng = dc_hq$lon, lat = dc_hq$lat, popup = dc_hq$hq)  # markers, with popup enabled on clicking  
    * leaflet() %>% addTiles() %>% addPopups(lng = dc_hq$lon, lat = dc_hq$lat, popup = dc_hq$hq)  # popups instead of markers  
* Leaflets can be stored as objects (similar to ggplot2), with additions and prints and whatnot called later  
  
Example code includes:  
```{r}

# Load the leaflet library
library(leaflet)

# Create a leaflet map with default map tile using addTiles()
leaflet() %>%
    addTiles()


# Print the providers list included in the leaflet library
providers

# Print only the names of the map tiles in the providers list 
names(providers)

# Use str_detect() to determine if the name of each provider tile contains the string "CartoDB"
str_detect(names(providers), "CartoDB")

# Use str_detect() to print only the provider tile names that include the string "CartoDB"
names(providers)[str_detect(names(providers), "CartoDB")]


# Change addTiles() to addProviderTiles() and set the provider argument to "CartoDB"
leaflet() %>% 
    addProviderTiles("CartoDB")

# Create a leaflet map that uses the Esri provider tile 
leaflet() %>% 
    addProviderTiles("Esri")

# Create a leaflet map that uses the CartoDB.PositronNoLabels provider tile
leaflet() %>% 
    addProviderTiles("CartoDB.PositronNoLabels")


# Map with CartoDB tile centered on DataCamp's NYC office with zoom of 6
leaflet()  %>% 
    addProviderTiles("CartoDB")  %>% 
    setView(lng = -73.98575, lat = 40.74856, zoom = 6)


dc_hq <- tibble::tibble(hq=c("NYC", "Belgium"), lon=c(-73.98575, 4.71786), lat=c(40.7486, 50.8814))
dc_hq

# Map with CartoDB.PositronNoLabels tile centered on DataCamp's Belgium office with zoom of 4
leaflet() %>% 
    addProviderTiles("CartoDB.PositronNoLabels") %>% 
    setView(lng = dc_hq$lon[2], lat = dc_hq$lat[2], zoom = 4)


leaflet(options = leafletOptions(
                    # Set minZoom and dragging 
                    minZoom = 12, dragging = TRUE))  %>% 
  addProviderTiles("CartoDB")  %>% 
  # Set default zoom level 
  setView(lng = dc_hq$lon[2], lat = dc_hq$lat[2], zoom = 14) %>% 
  # Set max bounds of map 
  setMaxBounds(lng1 = dc_hq$lon[2] + 0.05, 
               lat1 = dc_hq$lat[2] + .05, 
               lng2 = dc_hq$lon[2] - 0.05, 
               lat2 = dc_hq$lat[2] - .05) 


# Plot DataCamp's NYC HQ
leaflet() %>% 
    addProviderTiles("CartoDB") %>% 
    addMarkers(lng = dc_hq$lon[1], lat = dc_hq$lat[1])

# Plot DataCamp's NYC HQ with zoom of 12    
leaflet() %>% 
    addProviderTiles("CartoDB") %>% 
    addMarkers(lng = -73.98575, lat = 40.74856)  %>% 
    setView(lng = -73.98575, lat = 40.74856, zoom = 12)    

# Plot both DataCamp's NYC and Belgium locations
leaflet() %>% 
    addProviderTiles("CartoDB") %>% 
    addMarkers(lng = dc_hq$lon, lat = dc_hq$lat)


# Store leaflet hq map in an object called map
map <- leaflet() %>% 
    addProviderTiles("CartoDB") %>% 
    # add hq column of dc_hq as popups
    addMarkers(lng = dc_hq$lon, lat = dc_hq$lat, 
               popup = dc_hq$hq
               )

# Center the view of map on the Belgium HQ with a zoom of 5  
map_zoom <- map %>% 
      setView(lat = 50.881363, lng = 4.717863, zoom = 5)

# Print map_zoom
map_zoom

```
  
  
  
***
  
Chapter 2 - Plotting points  
  
Introduction to IPEDS Data:  
  
* Can clear the boundaries of a map, while keeping everything else (data and the like) constant  
	* m %>% clearBounds()  # kills the bounds layers  
    * m %>% clearBounds() %>% clearMarkers()  # kills the markers layers  
* The IPEDS data is the Integrated Post-Secondary Education dataset - this course uses a subset consisting of 4-year colleges  
	* Goal is to create a subset of the IPEDS data consisting of the ~300 colleges in California  
    * Can then plot and color-code the California colleges  
  
Mapping California colleges:  
  
* Clustered markers are poorly shown by pins due to obscuring  
* A nice alternative is to use circle markers, which have much less tendency for overlaps  
	* maine_colleges_map %>% clearMarkers() %>% addCircleMarkers(data = maine, radius = 3)  
    * maine_colleges_map %>% addCircleMarkers( data = maine_colleges, radius = 4, color = "red", popup = ~name)  # custom color and radius while maintaining popups  
  
Labels and pop-ups:  
  
* Can use piping as well as the tilde, which allows for referring to key variables in the piped in data  
	* ipeds %>% leaflet() %>% addProviderTiles("CartoDB") %>% addCircleMarkers( lng = ~lng, lat = ~lat, popup = ~name, color = "#FF0000")  
    * Colors can be specified using hexadecimal, as shown in the example above - can find these using google and color sliders  
* Can build better popups using pipes and tildes  
	* addCircleMarkers(popup = ~paste0(name, "-", sector_label)  
    * addCircleMarkers(popup = ~paste0("<b>",name,"</b>","<br/>",sector_label))  # enhanced with html tags  
* Labels provide similar information as pop-ups, but require only a hover rather than a click  
	* ipeds %>% leaflet() %>% addProviderTiles("CartoDB") %>% addCircleMarkers(label = ~name, radius = 2)  
  
Color coding colleges:  
  
* Can include differential colors depending on a variables that has been piped in using colorFactor()  
	* OR <- ipeds %>% filter(state == "OR")  
    * pal <- colorFactor(palette = c("red", "blue", "#9b4a11"), levels = c("Public", "Private", "For-Profit"))  # create the color palette for future use  
    * oregon_colleges <- OR %>% leaflet() %>% addProviderTiles("CartoDB") %>% addCircleMarkers(radius = 2, color = ~pal(sector_label), label = ~name)  # apply as pal()  
    * oregon_colleges %>% addLegend(position = "bottomright", pal = pal, values = c("Public", "Private", "For-Profit"))  # add to legend  
* Can instead color based on a numeric value using colorNumeric()  
	* admit <- admit %>% filter(!is.na(rate), rate < 50, rate > 0)  # filer for rates that exist and are between 0 and 50  
    * pal <- colorNumeric(palette = "Reds", domain = c(1:50), reverse = TRUE)  # reverse=TRUE flips the gradient so that lower admit rates are darker red  
    * admit_map <- admit %>% leaflet() %>% addProviderTiles("CartoDB") %>% addCircleMarkers(radius = 4, color = ~pal(rate), label = ~name) %>% addLegend(title = "Admit Rate", pal = pal, values = c(1:50), position = "bottomright")  
* Can use RColorBrewer for default color palettes  
	* library(RColorBrewer)  
    * display.brewer.all()  
  
Example code includes:  
```{r}

# Remove markers, reset bounds, and store the updated map in the m object
map <- map %>%
    clearMarkers() %>% 
    clearBounds()

# Print the cleared map
map


ipedsRaw <- readr::read_csv("./RInputFiles/ipeds.csv")


# Remove colleges with missing sector information
ipeds <- 
    ipedsRaw %>% 
    tidyr::drop_na()

# Count the number of four-year colleges in each state
ipeds %>% 
    group_by(state)  %>% 
    count()

# Create a list of US States in descending order by the number of colleges in each state
ipeds  %>% 
    group_by(state)  %>% 
    count()  %>% 
    arrange(desc(n))

# Create a dataframe called `ca` with data on only colleges in California
ca <- ipeds %>%
    filter(state == "CA")

map <- leaflet() %>% 
    addProviderTiles("CartoDB")

# Use `addMarkers` to plot all of the colleges in `ca` on the `m` leaflet map
map %>%
    addMarkers(lng = ca$lng, lat = ca$lat)


la_coords <- data.frame(lat = 34.05223, lon = -118.2437) 

# Center the map on LA 
map %>% 
    addMarkers(data = ca) %>% 
    setView(lat = la_coords$lat, lng = la_coords$lon, zoom = 12)

# Set the zoom level to 8 and store in the m object
map_zoom <-
    map %>%
    addMarkers(data = ca) %>%
    setView(lat = la_coords$lat, lng = la_coords$lon, zoom = 8)

map_zoom


# Clear the markers from the map 
map2 <- map %>% clearMarkers()

# Use addCircleMarkers() to plot each college as a circle
map2 %>%
    addCircleMarkers(lng = ca$lng, lat = ca$lat)

# Change the radius of each circle to be 2 pixels and the color to red
map2 %>% 
    addCircleMarkers(lng = ca$lng, lat = ca$lat, radius = 2, color = "red")


# Add circle markers with popups for college names
map %>%
    addCircleMarkers(data = ca, radius = 2, popup = ~name)

# Change circle color to #2cb42c and store map in map_color object
map_color <- map %>% 
    addCircleMarkers(data = ca, radius = 2, color = "#2cb42c", popup = ~name)

# Print map_color
map_color


# Clear the bounds and markers on the map object and store in map2
map2 <- map %>% 
    clearBounds() %>% 
    clearMarkers()

# Add circle markers with popups that display both the institution name and sector
map2 %>% 
    addCircleMarkers(data = ca, radius = 2, 
                     popup = ~paste0(name, "<br/>", sector_label)
                     )

# Make the institution name in each popup bold
map2 %>% 
    addCircleMarkers(data = ca, radius = 2, 
                     popup = ~paste0("<b>", name, "</b>", "<br/>", sector_label)
                     )


# Add circle markers with labels identifying the name of each college
map %>% 
    addCircleMarkers(data = ca, radius = 2, label = ~name)

# Use paste0 to add sector information to the label inside parentheses 
map %>% 
    addCircleMarkers(data = ca, radius = 2, label = ~paste0(name, " (", sector_label, ")"))


# Make a color palette called pal for the values of `sector_label` using `colorFactor()`  
# Colors should be: "red", "blue", and "#9b4a11" for "Public", "Private", and "For-Profit" colleges, respectively
pal <- colorFactor(palette = c("red", "blue", "#9b4a11"), 
                   levels = c("Public", "Private", "For-Profit")
                   )

# Add circle markers that color colleges using pal() and the values of sector_label
map2 <- map %>% 
        addCircleMarkers(data = ca, radius = 2, 
                         color = ~pal(sector_label), 
                         label = ~paste0(name, " (", sector_label, ")")
                         )

# Print map2
map2


# Add a legend that displays the colors used in pal
map2 %>% 
    addLegend(pal = pal, values = c("Public", "Private", "For-Profit"))

# Customize the legend
map2 %>% 
    addLegend(pal = pal, 
              values = c("Public", "Private", "For-Profit"),
              # opacity of .5, title of Sector, and position of topright
              opacity = 0.5, title = "Sector", position = "topright"
              )

```
  
  
  
***
  
Chapter 3 - Groups, Layers, Extras  
  
Leaflet Extras Package:  
  
* The leaflet.extras package provides some nice extensibility to the baseline leaflet package  
	* leaflet() %>% addTiles() %>% addSearchOSM()  # searching open-source-maps (magnifying glass icon with search box)  
    * leaflet() %>% addTiles() %>% addSearchOSM() %>% addReverseSearchOSM()  # can also use geocode to find a click, as requested by addReverseSearchOSM()  
    * leaflet() %>% addTiles() %>% addSearchOSM() %>% addReverseSearchOSM() %>% addResetMapButton()  # can click "reset" to return to the default view  
  
Overlay Groups - ability to control the segments that are displayed on the map:  
  
* One option is to segment the data in advance, then to add as layers using addCircleMarkers  
	* ca_public <- ipeds %>% filter(sector == "Public", state == "CA")  
    * m %>% addCircleMarkers( data = ca_public, group = "Public")  
* After creating multiple calls for addCircleMarkers(), each with group=, can then activate the grouping  
	* addLayersControl( overlayGroups = c("Public", "Private", "For-Profit"))  
* Since the layers are stacked, the order in which they are added matters (they layer/stack on top of each other)  
  
Base Groups - can provide multiple options for toggling (only one may be selected at a time):  
  
* Need to call addProviderTiles() once for each layer that is an option, then activate using addLayersControl()  
	* a <- leaflet() %>% addTiles(group = "OSM") %>% addProviderTiles("CartoDB", group = "Carto") %>% addProviderTiles("Esri", group = "Esri")   
    * a %>% addLayersControl(baseGroups = c("OSM", "Carto", "Esri"), position = "topleft")  
* Can be handy to try a few different base groups during exploratory analysis, to find the base that best matches the rest of the analysis  
* Basic four-step process for building up the base groups includes  
	* leaflet() %>% # initialize leaflet map  
    * addTiles(group = "OSM") %>% addProviderTiles("CartoDB", group = "Carto") %>% addProviderTiles("Esri", group = "Esri") %>% # add basemaps with groups  
    * addCircleMarkers(data = public, radius = 2, label = ~htmlEscape(name), color = ~pal(sector_label), group = "Public") %>% addCircleMarkers(data = private, radius = 2, label = ~htmlEscape(name), color = ~pal(sector_label), group = "Private") %>% addCircleMarkers(data = profit, radius = 2, label = ~htmlEscape(name), color = ~pal(sector_label), group = "For-Profit") %>% # add marker layer for each sector with corresponding group name  
    * addLayersControl(baseGroups = c("OSM", "Carto", "Esri"), overlayGroups = c("Public", "Private", "For-Profit")) # add layer controls for base and overlay groups  
  
Pieces of Flair:  
  
* Can customize ths search function using leaflet.extra capability  
	* ca_public <- ipeds %>% filter(sector_label == "Public", state == "CA")  
    * ca_public %>% leaflet() %>% addProviderTiles("Esri") %>% addCircleMarkers(radius = 2, label = ~htmlEscape(name), color = ~pal(sector_label), group = "Public") %>% addSearchFeatures(targetGroups = 'Public', options = searchFeaturesOptions(zoom = 10))  # will filter the search on Public data, with a specified zoom  
* Can cluster the colleges to improve readability of the maps  
	* ipeds %>% leaflet() %>% addTiles() %>% addCircleMarkers(radius = 2, color = ~pal(sector_label), clusterOptions = markerClusterOptions())  # many colleges in one circle  
  
Example code includes:  
```{r}

library(leaflet.extras)
library(htmltools)

leaflet() %>%
  addTiles() %>% 
  addSearchOSM() %>% 
  addReverseSearchOSM() 


m2 <- ipeds %>% 
    leaflet() %>% 
    # use the CartoDB provider tile
    addProviderTiles("CartoDB") %>% 
    # center on the middle of the US with zoom of 3
    setView(lat = 39.8282, lng = -98.5795, zoom=3)

# Map all American colleges 
m2 %>% 
    addCircleMarkers() 


# Create data frame called public with only public colleges
public <- filter(ipeds, sector_label == "Public")  

# Create a leaflet map of public colleges called m3 
m3 <- leaflet() %>% 
    addProviderTiles("CartoDB") %>% 
    addCircleMarkers(data = public, radius = 2, label = ~htmlEscape(name), 
                     color = ~pal(sector_label), group = "Public"
                     )

m3


# Create data frame called private with only private colleges
private <- filter(ipeds, sector_label == "Private")  

# Add private colleges to `m3` as a new layer
m3 <- m3 %>% 
    addCircleMarkers(data = private, radius = 2, label = ~htmlEscape(name), 
                     color = ~pal(sector_label), group = "Private"
                     ) %>% 
    addLayersControl(overlayGroups = c("Public", "Private"))

m3


# Create data frame called profit with only for-profit colleges
profit <- filter(ipeds, sector_label == "For-Profit")  

# Add for-profit colleges to `m3` as a new layer
m3 <- m3 %>% 
    addCircleMarkers(data = profit, radius = 2, label = ~htmlEscape(name), 
                     color = ~pal(sector_label),   group = "For-Profit"
                     )  %>% 
    addLayersControl(overlayGroups = c("Public", "Private", "For-Profit"))  

# Center the map on the middle of the US with a zoom of 4
m4 <- m3 %>%
    setView(lat = 39.8282, lng = -98.5795, zoom = 4) 
        
m4


leaflet() %>% 
  # Add the OSM, CartoDB and Esri tiles
  addTiles(group = "OSM") %>% 
  addProviderTiles("CartoDB", group = "Carto") %>% 
  addProviderTiles("Esri", group = "Esri") %>% 
  # Use addLayersControl to allow users to toggle between basemaps
  addLayersControl(baseGroups = c("OSM", "Carto", "Esri"))


m4 <- leaflet() %>% 
    addTiles(group = "OSM") %>% 
    addProviderTiles("CartoDB", group = "Carto") %>% 
    addProviderTiles("Esri", group = "Esri") %>% 
    addCircleMarkers(data = public, radius = 2, label = ~htmlEscape(name), 
                     color = ~pal(sector_label),  group = "Public"
                     ) %>% 
    addCircleMarkers(data = private, radius = 2, label = ~htmlEscape(name), 
                     color = ~pal(sector_label), group = "Private"
                     )  %>% 
    addCircleMarkers(data = profit, radius = 2, label = ~htmlEscape(name), 
                     color = ~pal(sector_label), group = "For-Profit"
                     )  %>% 
    addLayersControl(baseGroups = c("OSM", "Carto", "Esri"), 
                     overlayGroups = c("Public", "Private", "For-Profit")
                     ) %>% 
    setView(lat = 39.8282, lng = -98.5795, zoom = 4) 

m4


ipeds %>% 
    leaflet() %>% 
    addTiles() %>% 
    # Sanitize any html in our labels
    addCircleMarkers(radius = 2, label = ~htmlEscape(name), 
                     # Color code colleges by sector using the `pal` color palette 
                     color = ~pal(sector_label), 
                     # Cluster all colleges using `clusterOptions` 
                     clusterOptions = markerClusterOptions()
                     ) 

```
  
  
  
***
  
Chapter 4 - Plotting Polygons  
  
Spatial Data - ability to plot polygons rather than points:  
  
* Polygons have many points, and are stored in SPDF (Spatial Polygons Data Frame) with 5 slots  
	* data - one observation per polygon  
    * polygons - coordinates to plot each polygon  
    * plotOrder - order for plotting  
    * bbox - rectangle containing all the polygons  
    * proj4string - coordinate reference system (CRS)  
    * All accessed using the @ symbol  
* Can join from the data component of the SPDF, accessed using @  
	* hp@data <- shp@data %>% left_join(nc_income, by = c("GEOID10" = "zipcode"))  
    * shp@polygons[[1]] %>% leaflet() %>% addPolygons()  # can plot a single polygon  
  
Mapping Polygons - can pipe SPDF in to a series of leaflet calls:  
  
* The basic polygon plotting method using leaflet() may produce shape boundaries that are too thick  
	* shp %>% leaflet() %>% addTiles() %>% addPolygons()  
    * weight - thickness of lines  
    * color - color of lines  
    * label - information shown on hover  
    * highlight - options to highlight polygon on hover  
* The refined plotting approach adds customization for better readability  
	* shp %>% leaflet() %>% addTiles() %>% addPolygons(weight = 1, color = "grey", label = ~paste0("Total Income: " dollar(income)), highlight = highlightOptions(weight = 3, color = "red", bringToFront = TRUE))  
* Can color numeric data when plotting polygons  
	* colorNumeric - maps continuous data to interpolated palettes  
    * colorBin - colors based on cut function  
    * colorQuantile - colors based on quantile  
    * nc_pal <- colorNumeric(palette = "Blues", domain = high_inc@data$mean_income)  
    * nc_pal <- colorBin(palette = "YlGn", bins = 5, domain = high_inc@data$mean_income)  
    * nc_pal <- colorQuantile(palette = "YlGn", n = 4, domain = high_inc@data$mean_income)  
* Example of coloring using colorNumeric()  
	* nc_pal <- colorNumeric("Blues", domain = high_inc@data$mean_income)  
    * previewColors(pal = nc_pal, values = c(seq(100000, 600000, by = 100000)))  # explore sample values  
    * shp %>% leaflet() %>% # addTiles() %>% addPolygons(weight = 1, fillOpacity = 1, color = ~nc_pal(mean_income), label = ~paste0("Mean Income: ", dollar(mean_income)), highlight = highlightOptions(weight = 3, color = "red", bringToFront = TRUE))  
* Sometimes need to log-transform skewed data for better displays  
  
Putting Everything Together:  
  
* Leaflet and htmlwidgets for base maps and coloring  
* Base and overlay groups to enhance interactivity  
* Features available in the leaflet.extras function  
* Can piece together a full map that includes both polygons and circle markers  
	* leaflet() %>% addTiles(group = "OSM") %>% addProviderTiles("CartoDB", group = "Carto") %>%           
	*   addProviderTiles("Esri", group = "Esri") %>%  
    *   addPolygons(data = shp, weight = 1, fillOpacity = .75, color = ~nc_pal(log(mean_income)), label = ~paste0("Mean Income: ", dollar(mean_income)), group = "Mean Income") %>%  
    *   addCircleMarkers(data = nc_public, radius = 2, label = ~htmlEscape(name), color = ~pal(sector_label), group = "Public") %>%  
    *   addCircleMarkers(data = nc_private, radius = 2, label = ~htmlEscape(name), color = ~pal(sector_label), group = "Private") %>%  
    *   addCircleMarkers(data = nc_profit, radius = 2, label = ~htmlEscape(name), color = ~pal(sector_label), group = "For-Profit") %>%  
    * addLayersControl(baseGroups = c("OSM", "Carto", "Esri"), overlayGroups = c("Public", "Private", "For-Profit", "Mean Income"))  
* Can also save a map for future use  
	* m <- leaflet() %>% addTiles() %>% addMarkers( data = ipeds, clusterOptions = markerClusterOptions())%>% addPolygons(data = shp)  
    * library(htmlwidgets)  
    * saveWidget(m, file="myMap.html")  # saves the file as html  
  
Wrap up - additional resources:  
  
* RStudio's leaflet website: https://rstudio.github.io/leaflet/  
* Leaflet extras: https://github.com/bhaskarvk/leaflet.extras  
* JavaScript library: http://leafletjs.com/  
  
Example code includes:  
```{r}


load("./RInputFiles/nc_zips.Rda")
load("./RInputFiles/wealthiest_zips.Rda")
nc_income <- readr::read_csv("./RInputFiles/mean_income_by_zip_nc.csv")
str(nc_income, give.attr = FALSE)


# Print a summary of the `shp` data
summary(shp)

# Print the class of `shp`
class(shp)

# Print the slot names of `shp`
slotNames(shp)


# Glimpse the data slot of shp
glimpse(shp@data)

# Print the class of the data slot of shp
class(shp@data)

# Print GEOID10
shp@data$GEOID10
shp@data$GEOID10 <- as.integer(as.character(shp@data$GEOID10))
str(shp@data$GEOID10)


# Glimpse the nc_income data
glimpse(nc_income)

# Summarise the nc_income data
summary(nc_income)

# Left join nc_income onto shp@data and store in shp_nc_income
shp_nc_income <- shp@data %>% 
                left_join(nc_income, by = c("GEOID10" = "zipcode"))

# Print the number of missing values of each variable in shp_nc_income
shp_nc_income %>%
  summarise_all(funs(sum(is.na(.))))


shp <- merge(shp, shp_nc_income, by=c("GEOID10", "ALAND10"))


# map the polygons in shp
shp %>% 
    leaflet() %>% 
    addTiles() %>% 
    addPolygons()

# which zips were not in the income data?
shp_na <- shp[is.na(shp$mean_income),]

# map the polygons in shp_na
shp_na %>% 
    leaflet() %>% 
    addTiles() %>% 
    addPolygons()


# summarise the mean income variable
summary(shp$mean_income)

# subset shp to include only zip codes in the top quartile of mean income
high_inc <- shp[!is.na(shp$mean_income) & shp$mean_income > 55917,]

# map the boundaries of the zip codes in the top quartile of mean income
high_inc %>%
  leaflet() %>%
  addTiles() %>%
  addPolygons()


dollar <- function (x, negative_parens=TRUE, prefix="$", suffix="") {
    # KLUGE to make this work . . . 
    needs_cents <- function(...) { FALSE }
    if (length(x) == 0) 
        return(character())
    x <- plyr::round_any(x, 0.01)
    if (needs_cents(x, largest_with_cents)) {
        nsmall <- 2L
    }
    else {
        x <- plyr::round_any(x, 1)
        nsmall <- 0L
    }
    negative <- !is.na(x) & x < 0
    if (negative_parens) {
        x <- abs(x)
    }
    amount <- format(abs(x), nsmall = nsmall, trim = TRUE, big.mark = ",", scientific = FALSE, digits = 1L)
    if (negative_parens) {
        paste0(ifelse(negative, "(", ""), prefix, amount, suffix, ifelse(negative, ")", ""))
    }
    else {
        paste0(prefix, ifelse(negative, "-", ""), amount, suffix)
    }
}


# create color palette with colorNumeric()
nc_pal <- colorNumeric("YlGn", domain = high_inc@data$mean_income)

high_inc %>%
  leaflet() %>%
  addTiles() %>%
  # set boundary thickness to 1 and color polygons blue
  addPolygons(weight = 1, color = ~nc_pal(mean_income),
              # add labels that display mean income
              label = ~paste0("Mean Income: ", dollar(mean_income)),
              # highlight polygons on hover
              highlight = highlightOptions(weight = 5, color = "white",
              bringToFront = TRUE))


# Create a logged version of the nc_pal color palette
nc_pal <- colorNumeric("YlGn", domain = log(high_inc@data$mean_income))

# apply the nc_pal
high_inc %>%
  leaflet() %>%
  addProviderTiles("CartoDB") %>%
  addPolygons(weight = 1, color = ~nc_pal(log(mean_income)), fillOpacity = 1,
              label = ~paste0("Mean Income: ", dollar(mean_income)),
              highlightOptions = highlightOptions(weight = 5, color = "white", bringToFront = TRUE))


# Print the slot names of `wealthy_zips`
slotNames(wealthy_zips)

# Print a summary of the `mean_income` variable
summary(wealthy_zips$mean_income)

# plot zip codes with mean incomes >= $200k
wealthy_zips %>% 
  leaflet() %>% 
  addProviderTiles("CartoDB") %>% 
  addPolygons(weight = 1, fillOpacity = .7, color = "Green",  group = "Wealthy Zipcodes", 
              label = ~paste0("Mean Income: ", dollar(mean_income)),
              highlightOptions = highlightOptions(weight = 5, color = "white", bringToFront = TRUE))


# Add polygons using wealthy_zips
final_map <- m4 %>% 
   addPolygons(data = wealthy_zips, weight = 1, fillOpacity = .5, color = "Grey",  group = "Wealthy Zip Codes", 
              label = ~paste0("Mean Income: ", dollar(mean_income)),
              highlight = highlightOptions(weight = 5, color = "white", bringToFront = TRUE)) %>% 
    # Update layer controls including "Wealthy Zip Codes"
    addLayersControl(baseGroups = c("OSM", "Carto", "Esri"), 
                         overlayGroups = c("Public", "Private", "For-Profit", "Wealthy Zip Codes"))

# Print and explore your very last map of the course!
final_map

```
  
  
  
***
  
###_Support Vector Machines in R_  
  
Chapter 1 - Introduction  
  
Sugar content of soft drinks:  
  
* Course covers Support Vector Machines (SVM), including visualization, mechanics, situations where they work best, etc.  
	* Will stick with binary classification for this course  
* For a 1-dimensional dataset, the clusters can be separated by choosing a "separating boundary" (decision boundary)  
* Margins are the distances between the decision boundary and the closest point  
	* The best decision boundary is considered to be the decision boundary that maximizes the margin (more robust to noise)  
    * The SVM tries to find the decision boundary that maximizes the margin in n-dimensions  
  
Generating a linearly separable dataset  
  
* Can use runif to generate random data that is unifotm from 0 to 1  
	* n <- 200  
    * set.seed(42)  
    * df <- data.frame(x1 = runif(n), x2 = runif(n))  
* Can define the points with x1 < x2 as class A and the points with x1 > x2 as class B  
	* Can also create a margin by filtering out points where abs(x1-x2) is below a user-specified threshold  
  
Example code includes:  
```{r}

df <- data.frame(sample=1:25, 
                 sugar_content=c(10.9, 10.9, 10.6, 10, 8, 8.2, 8.6, 10.9, 10.7, 8, 7.7, 7.8, 8.4, 11.5, 11.2, 8.9, 8.7, 7.4, 10.9, 10, 11.4, 10.8, 8.5, 8.2, 10.6)
                 )
str(df)

#print variable names
names(df)

#build plot
plot_ <- ggplot(data = df, aes(x = sugar_content, y = c(0))) + 
    geom_point() + 
    geom_text(label = df$sugar_content, size = 2.5, vjust = 2, hjust = 0.5)

#display plot
plot_


#The maximal margin separator is at the midpoint of the two extreme points in each cluster.
mm_separator <- (8.9 + 10)/2


#create data frame
separator <- data.frame(sep = c(mm_separator))

#add ggplot layer 
plot_ <- plot_ + 
  geom_point(data = separator, x = separator$sep, y = c(0), color = "blue", size = 4)

#display plot
plot_


#set seed
set.seed(42)

#set number of data points. 
n <- 600

#Generate data frame with two uniformly distributed predictors lying between 0 and 1.
df <- data.frame(x1 = runif(n), x2 = runif(n))

#classify data points depending on location
df$y <- factor(ifelse(df$x2 - 1.4*df$x1 < 0, -1, 1), levels = c(-1, 1))


#set margin
delta <- 0.07

# retain only those points that lie outside the margin
df1 <- df[abs(1.4*df$x1 - df$x2) > delta, ]

#build plot
plot_margins <- ggplot(data = df1, aes(x = x1, y = x2, color = y)) + geom_point() + 
    scale_color_manual(values = c("red", "blue")) + 
    geom_abline(slope = 1.4, intercept = 0)+
    geom_abline(slope = 1.4, intercept = delta, linetype = "dashed") +
    geom_abline(slope = 1.4, intercept = -delta, linetype = "dashed")
 
#display plot 
plot_margins

```
  
  
  
***
  
Chapter 2 - Support Vector Classifiers - Linear Kernels  
  
Linear Support Vector Machines:  
  
* Can split the data from the previous chapter (perfectly separable) in to train/test on an 80-20 basis  
	* set.seed() = 1  
    * df[, "train"] <- ifelse(runif(nrow(df))<0.8,1,0)  
    * trainset <- df[df$train==1,]  
    * testset <- df[df$train==0,]  
    * trainColNum <- grep("train", names(trainset))  
    * trainset <- trainset[,-trainColNum]  
    * testset <- testset[,-trainColNum]  
* Decision boundaries have many shapes-types (called kernels) such as lines, polynomials, etc.  
* For this chapter, will use e1071::svm(), a function with many options  
	* formula, data, type ("C-classification" for classification), kernel ("linear" for this chapter), cost/gamma (tuning parameters, which will be left at the defaults for now), scale (boolean telling whether to scale the data in advance - FALSE makes for easier plotting, but typically would be set to TRUE in the real-world)  
* Example of running e1071::svm()  
	* library(e1071)  
    * svm_model<- svm(y ~ ., data = trainset, type = "C-classification", kernel = "linear", scale = FALSE)  
    * svm_model  
    * svm_model$index  # indices of the support vectors  
    * svm_model$SV  # support vector coordinates  
    * svm_model$rho  # negative y-intercept of the decision boundary  
    * svm_model$coefs  # weighting coefficients of support vectors (magnitude is importance, side is which part of boundary)  
    * pred_train <- predict(svm_model,trainset)  
    * pred_test <- predict(svm_model,testset)  
  
Visualizing Linear SVM:  
  
* Can begin by plotting the training data, distinguished by color  
	* p <- ggplot(data = trainset, aes(x = x1, y = x2, color = y)) + geom_point() + scale_color_manual(values = c("red","blue"))  
    * df_sv <- trainset[svm_model$index,]  
    * p <- p + geom_point(data = df_sv, aes(x = x1, y = x2), color = "purple", size = 4, alpha = 0.5)  
    * p  
* The support vectors tend to be close to the decision boundary - in fact, they are defined as points that "support" the boundary  
* Goal is to extract the slope and coefficients from the model (not stored in the model object)  
	* w <- t(svm_model$coefs) %*% svm_model$SV  
    * slope_1 <- -w[1]/w[2]  
    * intercept_1 <- svm_model$rho/w[2]  
    * p <- p + geom_abline(slope = slope_1, intercept = intercept_1)  
    * p <- p + geom_abline(slope = slope_1, intercept = intercept_1-1/w[2], linetype = "dashed") + geom_abline(slope = slope_1, intercept = intercept_1+1/w[2], linetype = "dashed")  
    * p  
* There are several properties observed in the plot  
	* The boundary is supported by the support vectors  
    * The boundary is "soft", which allows for uncertainty in location/shape of the boundary  
    * Can also use e1071::plot(x=myModel, data=myData) to plot the function  
  
Tuning Linear SVM:  
  
* Can tweak the cost parameter to change the size of the soft boundary for the SVM  
	* Higher costs lead to harder (smaller, narrower) decision boundaries, with fewer support vectors  
    * The implication is that raising the cost can be a good idea if the data are known to be linearly separable  
  
Multi-class problems:  
  
* SVM can manage classification problems with 3+ target types also - using the example iris data  
	* p <- ggplot(data = iris, aes(x = Petal.Width, y = Petal.Length, color = Species)) + geom_point()  
    * p  
* The SVM at core is a binary classifier, but can be used in a multi-class setting  
	* Have a model for each of the choose(m, 2) possible combinations, and use majority voting on the outputs (ties broken by random)  
    * This method is called the "one against one" classification, and it is automatically included in e1071  
    * svm_model<- svm(Species ~ ., data = trainset, type = "C-classification", kernel = "linear")  # all run automatically  
  
Example code includes:  
```{r}


dfOld <- df
delta <- 0.07
df <- df[abs(1.4*df$x1 - df$x2) > delta, ]


#split train and test data in an 80/20 proportion
df[, "train"] <- ifelse(runif(nrow(df))<0.8, 1, 0)

#assign training rows to data frame trainset
trainset <- df[df$train == 1, ]
#assign test rows to data frame testset
testset <- df[df$train == 0, ]

#find index of "train" column
trainColNum <- grep("train", names(df))

#remove "train" column from train and test dataset
trainset <- trainset[, -trainColNum]
testset <- testset[, -trainColNum]


library(e1071)

#build svm model, setting required parameters
svm_model<- svm(y ~ ., 
                data = trainset, 
                type = "C-classification", 
                kernel = "linear", 
                scale = FALSE)


#list components of model
names(svm_model)

#list values of the SV, index and rho
svm_model$SV
svm_model$index
svm_model$rho

#compute training accuracy
pred_train <- predict(svm_model, trainset)
mean(pred_train == trainset$y)

#compute test accuracy
pred_test <- predict(svm_model, testset)
mean(pred_test == testset$y)


#build scatter plot of training dataset
scatter_plot <- ggplot(data = trainset, aes(x = x1, y = x2, color = y)) + 
    geom_point() + 
    scale_color_manual(values = c("red", "blue"))
 
#add plot layer marking out the support vectors 
layered_plot <- 
    scatter_plot + geom_point(data = trainset[svm_model$index, ], aes(x = x1, y = x2), color = "purple", size = 4, alpha = 0.5)

#display plot
layered_plot


#calculate slope and intercept of decision boundary from weight vector and svm model
w <- c(x1=6.55241, x2=-4.73278)  # calculated manually outside of this module
slope_1 <- -w[1]/w[2]
intercept_1 <- svm_model$rho/w[2]

#build scatter plot of training dataset
scatter_plot <- ggplot(data = trainset, aes(x = x1, y = x2, color = y)) + 
    geom_point() + scale_color_manual(values = c("red", "blue"))
#add decision boundary
plot_decision <- scatter_plot + geom_abline(slope = slope_1, intercept = intercept_1) 
#add margin boundaries
plot_margins <- plot_decision + 
 geom_abline(slope = slope_1, intercept = intercept_1 - 1/w[2], linetype = "dashed")+
 geom_abline(slope = slope_1, intercept = intercept_1 + 1/w[2], linetype = "dashed")
#display plot
plot_margins


#build svm model
svm_model<- 
    svm(y ~ ., data = trainset, type = "C-classification", 
        kernel = "linear", scale = FALSE)

#plot decision boundaries and support vectors
plot(x = svm_model, data = trainset)


#build svm model, cost = 1
svm_model_1 <- svm(y ~ .,
                   data = trainset,
                   type = "C-classification",
                   cost = 1,
                   kernel = "linear",
                   scale = FALSE)

#print model details
svm_model_1

#build svm model, cost = 100
svm_model_100 <- svm(y ~ .,
                   data = trainset,
                   type = "C-classification",
                   cost = 100,
                   kernel = "linear",
                   scale = FALSE)

#print model details
svm_model_100


# Create the base train_plot
train_plot <- ggplot(data = trainset, aes(x = x1, y = x2, color = y)) + 
    geom_point() + scale_color_manual(values = c("red", "blue"))
w_1 <- c(x1=6.55241, x2=-4.73278)  # calculated manually outside of this module
w_100 <- c(x1=18.3097, x2=-13.09972)  # calculated manually outside of this module
intercept_1 <- -0.005515526  # calculated outside of this module
intercept_100 <- 0.001852543  # calculated outside of this module
slope_1 <- -w_1[1]/w_1[2]
slope_100 <- -w_100[1]/w_100[2]


#add decision boundary and margins for cost = 1 to training data scatter plot
train_plot_with_margins <- train_plot + 
    geom_abline(slope = slope_1, intercept = intercept_1) +
    geom_abline(slope = slope_1, intercept = intercept_1 - 1/w_1[2], linetype = "dashed")+
    geom_abline(slope = slope_1, intercept = intercept_1 + 1/w_1[2], linetype = "dashed")

#display plot
train_plot_with_margins

#add decision boundary and margins for cost = 100 to training data scatter plot
train_plot_with_margins <- train_plot_with_margins + 
    geom_abline(slope = slope_100, intercept = intercept_100, color = "goldenrod") +
    geom_abline(slope = slope_100, intercept = intercept_100 - 1/w_100[2], linetype = "dashed", color = "goldenrod")+
    geom_abline(slope = slope_100, intercept = intercept_100 + 1/w_100[2], linetype = "dashed", color = "goldenrod")

#display plot 
train_plot_with_margins


svm_model<- svm(y ~ ., data = trainset, type = "C-classification", kernel = "linear", scale = FALSE)

#compute training accuracy
pred_train <- predict(svm_model, trainset)
mean(pred_train == trainset$y)

#compute test accuracy
pred_test <- predict(svm_model, testset)
mean(pred_test == testset$y)

#plot
plot(svm_model, trainset)


data(iris)
nTrials <- 100
accuracy <- numeric(nTrials)

#calculate accuracy for n distinct 80/20 train/test partitions
for (i in 1:nTrials){ 
    iris[, "train"] <- ifelse(runif(nrow(iris))<0.8, 1, 0)
    trainColNum <- grep("train", names(iris))
    trainset <- iris[iris$train == 1, -trainColNum]
    testset <- iris[iris$train == 0, -trainColNum]
    svm_model <- svm(Species~ ., data = trainset, 
                     type = "C-classification", kernel = "linear")
    pred_test <- predict(svm_model, testset)
    accuracy[i] <- mean(pred_test == testset$Species)
}

#mean accuracy and standard deviation
mean(accuracy) 
sd(accuracy)

```
  
  
  
***
  
Chapter 3 - Polynomial Kernels  
  
Generating radially separable datasets:  
  
* The goal is to generate 2D points (again uniformly distributed on x1 and x2 using runif)  
* Can then define a value for whether the points are within x of the center  
	* radius <- 0.7  
    * radius_squared <- radius^2  
    * df$y <- factor(ifelse(df$x1^2 + df$x2^2 < radius_squared, -1, 1), levels = c(-1,1))  
    * p <- ggplot(data = df, aes(x = x1, y = x2, color = y)) + geom_point() + scale_color_manual(values = c("-1" = "red","1" = "blue"))   
    * p  
* Can add a circular boundary  
	* circle <- function(x1_center, x2_center, r, npoint = 100){ 
	*   #angular spacing of 2*pi/npoint between points  
	*   theta <- seq(0,2*pi,length.out = npoint)  
	*   x1_circ <- x1_center + r * cos(theta)  
	*   x2_circ <- x2_center + r * sin(theta)  
	*   return(data.frame(x1c = x1_circ, x2c = x2_circ))  
	*   }  
    * boundary <- circle(x1_center = 0, x2_center = 0, r = radius)  
    * p <- p + geom_path(data = boundary, aes(x = x1c, y = x2c), inherit.aes = FALSE)  
  
Linear SVM on radially separable datasets:  
  
* The linear SVM will perform poorly on the radially separable dataset  
	* svm_model<- svm(y ~ ., data=trainset, type="C-classification", kernel="linear")  
    * svm_model  
    * pred_test <- predict(svm_model,testset)  
    * plot(svm_model,trainset)  # all points are classified as 1  
  
Kernel trick - devise a mathematical transformation that makes the data linearly separable:  
  
* For a circles could map X1 = x1**2 and X2 = x2**2, where X1 + X2 = 0.49 (which is linearly separable)  
* The polynomial kernel has a degree (e.g., 1 for linear, 2 for quadratic, etc.) and tuning parameters gamma and coef0  
	* The kernel also uses u dot v where u and v are vectors belonging to the dataset  
    * (gamma * (u dot v) + coef0) ** degree  
* Applying the quadratic kernel to the circular data from above  
	* svm_model<- svm(y ~ ., data = trainset, type = "C-classification", kernel = "polynomial", degree = 2)  
    * plot(svm_model, trainset)  
  
Tuning SVM:  
  
* Set a search range for each parameter, typically as a sequence of variable (e.g., in multiples of 10)  
* For each combination of parameters, build an SVM and assess the out-of-sample accuracy - can become computationally intensive, though  
	* tune_out <- tune.svm(x = trainset[,-3], y = trainset[,3], type = "C-classification", kernel = "polynomial", degree = 2, cost = 10^(-1:2), gamma = c(0.1,1,10), coef0 = c(0.1,1,10))  
    * tune_out$best.parameters$cost  
    * tune_out$best.parameters$gamma  
    * tune_out$best.parameters$coef0  
    * svm_model <- svm(y~ ., data = trainset, type = "C-classification", kernel = "polynomial", degree = 2, cost = tune_out$best.parameters$cost, gamma = tune_out$best.parameters$gamma, coef0 = tune_out$best.parameters$coef0)  
  
Example code includes:  
```{r}

#set number of variables and seed
n <- 400
set.seed(1)

#Generate data frame with two uniformly distributed predictors, x1 and x2
df <- data.frame(x1 = runif(n, min = -1, max = 1), x2 = runif(n, min = -1, max = 1))

#We want a circular boundary. Set boundary radius 
radius <- 0.8
radius_squared <- radius^2

#create dependent categorical variable, y, with value -1 or 1 depending on whether point lies
#within or outside the circle.
df$y <- factor(ifelse(df$x1**2 + df$x2**2 < radius_squared, -1, 1), levels = c(-1, 1))


#build scatter plot, distinguish class by color
scatter_plot <- ggplot(data = df, aes(x = x1, y = x2, color = y)) + 
    geom_point() +
    scale_color_manual(values = c("red", "blue"))

#display plot
scatter_plot


inTrain <- sample(1:nrow(df), round(0.75*nrow(df)), replace=FALSE)
trainset <- df[sort(inTrain), ]
testset <- df[-inTrain, ]


#default cost mode;
svm_model_1 <- svm(y ~ ., data = trainset, type = "C-classification", cost = 1, kernel = "linear")

#training accuracy
pred_train <- predict(svm_model_1, trainset)
mean(pred_train == trainset$y)

#test accuracy
pred_test <- predict(svm_model_1, testset)
mean(pred_test == testset$y)

#cost = 100 model
svm_model_100 <- svm(y ~ ., data = trainset, type = "C-classification", cost = 100, kernel = "linear")

#accuracy
pred_train <- predict(svm_model_100, trainset)
mean(pred_train == trainset$y)
pred_test <- predict(svm_model_100, testset)
mean(pred_test == testset$y)


#print average accuracy and standard deviation
accuracy <- rep(NA, 100)
set.seed(2)

#comment
for (i in 1:100){
    df[, "train"] <- ifelse(runif(nrow(df))<0.8, 1, 0)
    trainset <- df[df$train == 1, ]
    testset <- df[df$train == 0, ]
    trainColNum <- grep("train", names(trainset))
    trainset <- trainset[, -trainColNum]
    testset <- testset[, -trainColNum]
    svm_model<- svm(y ~ ., data = trainset, type = "C-classification", kernel = "linear")
    pred_test <- predict(svm_model, testset)
    accuracy[i] <- mean(pred_test == testset$y)
}

#print average accuracy and standard deviation
mean(accuracy)
sd(accuracy)


#transform data
df1 <- data.frame(x1sq = df$x1^2, x2sq = df$x2^2, y = df$y)

#plot data points in the transformed space
plot_transformed <- ggplot(data = df1, aes(x = x1sq, y = x2sq, color = y)) + 
    geom_point()+ guides(color = FALSE) + 
    scale_color_manual(values = c("red", "blue"))

#add decision boundary and visualize
plot_decision <- plot_transformed + geom_abline(slope = -1, intercept = 0.64)
plot_decision


# Still want to use the old (non-squared) data
inTrain <- sample(1:nrow(df), round(0.75*nrow(df)), replace=FALSE)
df$train <- NULL
trainset <- df[sort(inTrain), ]
testset <- df[-inTrain, ]

svm_model <- svm(y ~ ., data = trainset, type = "C-classification", kernel = "polynomial", degree = 2)

#measure training and test accuracy
pred_train <- predict(svm_model, trainset)
mean(pred_train == trainset$y)
pred_test <- predict(svm_model, testset)
mean(pred_test == testset$y)

#plot
plot(svm_model, trainset)


#tune model
tune_out <- 
    tune.svm(x = trainset[, -3], y = trainset[, 3], 
             type = "C-classification", 
             kernel = "polynomial", degree = 2, cost = 10^(-1:2), 
             gamma = c(0.1, 1, 10), coef0 = c(0.1, 1, 10))

#list optimal values
tune_out$best.parameters$cost
tune_out$best.parameters$gamma
tune_out$best.parameters$coef0


#Build tuned model
svm_model <- svm(y ~ ., data = trainset, type = "C-classification", 
                 kernel = "polynomial", degree = 2, 
                 cost = tune_out$best.parameters$cost, 
                 gamma = tune_out$best.parameters$gamma, 
                 coef0 = tune_out$best.parameters$coef0)

#Calculate training and test accuracies
pred_train <- predict(svm_model, trainset)
mean(pred_train == trainset$y)
pred_test <- predict(svm_model, testset)
mean(pred_test == testset$y)

#plot model
plot(svm_model, trainset)

```
  
  
  
***
  
Chapter 4 - Radial Basis Kernel Functions  
  
Generating complex datasets:  
  
* The RBF kernel is highly flexible, can fit complex boundaries, and is common in the real-world  
* Can generate complex data by using different distributions for x and y  
	* n <- 600  
    * set.seed(42)  
    * df <- data.frame(x1 = rnorm(n, mean = -0.5, sd = 1), x2 = runif(n, min = -1, max = 1))  
* The decision boundary can then be two circles that just barely touch at the origin  
	* radius <- 0.7  
    * radius_squared <- radius^2  
    * center_1 <- c(-0.7,0)  
    * center_2 <- c(0.7,0)  
    * df$y <- factor(ifelse( (df$x1-center_1[1])^2 + (df$x2-center_1[2])^2 < radius_squared| (df$x1-center_2[1])^2 + (df$x2-center_2[2])^2 < radius_squared, -1,1), levels = c(-1,1))  
    * p <- ggplot(data = df, aes(x = x1, y = x2, color = y)) + geom_point() + guides(color = FALSE) + scale_color_manual(values = c("red","blue"))  
    * p  
* Can then build linear, polynomial, and RBF kernels to model the data  
  
Motivating the RBF kernel:  
  
* Neither the linear kernel nor the polynomial kernel will work well for the dataset as described  
* Can use the heuristic that points near each other probably belong to the same class (similar to kNN)  
	* The kernel should have a maximum at (a, b), and should decay as you move away from (a, b)  
    * The rate of decay, all else equal should be the same in all directions, with a tunable gamma  
    * As good fortune has it, the exponential exp(-gamma * r) has all of these properties  
    * rbf <- function(r, gamma) exp(-gamma*r)  
    * ggplot(data.frame(r = c(-0, 10)), aes(r)) +  
    *   stat_function(fun = rbf, args = list(gamma = 0.2), aes(color = "0.2")) +  
    *   stat_function(fun = rbf, args = list(gamma = 0.4), aes(color = "0.4")) +  
    *   stat_function(fun = rbf, args = list(gamma = 0.6), aes(color = "0.6")) +  
    *   stat_function(fun = rbf, args = list(gamma = 0.8), aes(color = "0.8")) +  
    *   stat_function(fun = rbf, args = list(gamma = 1), aes(color = "1")) +  
    *   stat_function(fun = rbf, args = list(gamma = 2), aes(color = "2")) +  
    *   scale_color_manual("gamma", values = c("red","orange","yellow", "green","blue","violet")) +  
    *   ggtitle("Radial basis function (gamma=0.2 to 2)")  
  
The RBF kernel simulates some of the principles of kNN using exponential decay:  
  
* The RBF kernel can be built using pre-set R commands  
	* svm_model<- svm(y ~ ., data = trainset, type = "C-classification", kernel = "radial")  
* The predicted decision boundary will no longer be linear, and can be refined through tuning  
	* tune_out <- tune.svm(x = trainset[,-3], y = trainset[,3], gamma = 5*10^(-2:2), cost = c(0.01,0.1,1,10,100), type = "C-classification", kernel = "radial")  
    * tune_out$best.parameters$cost  
    * tune_out$best.parameters$gamma  
    * svm_model <- svm(y~ ., data=trainset, type="C-classification", kernel="radial", cost=tune_out$best.parameters$cost, gamma=tune_out$best.parameters$gamma)  
  
Example code includes:  
```{r}

#number of data points
n <- 1000

#set seed
set.seed(1)

#create dataframe
df <- data.frame(x1 = rnorm(n, mean = -0.5, sd = 1), x2 = runif(n, min = -1, max = 1))


#set radius and centers
radius <- 0.8
center_1 <- c(-0.8, 0)
center_2 <- c(0.8, 0)
radius_squared <- radius^2

#create binary classification variable
df$y <- factor(ifelse((df$x1-center_1[1])^2 + (df$x2-center_1[2])^2 < radius_squared |
                      (df$x1-center_2[1])^2 + (df$x2-center_2[2])^2 < radius_squared, -1, 1),
                      levels = c(-1, 1))


#create scatter plot
scatter_plot<- ggplot(data = df, aes(x = x1, y = x2, color = y)) + 
    geom_point() + 
    scale_color_manual(values = c("red", "blue"))
 
scatter_plot 


# Create 75/25 split for train/test
inTrain <- sample(1:nrow(df), round(0.75*nrow(df)), replace=FALSE)
trainset <- df[sort(inTrain), ]
testset <- df[-inTrain, ]


#build model
svm_model <- svm(y ~ ., data = trainset, type = "C-classification", kernel = "linear")

#accuracy
pred_train <- predict(svm_model, trainset)
mean(pred_train == trainset$y)
pred_test <- predict(svm_model, testset)
mean(pred_test == testset$y)

#plot model against testset
plot(svm_model, testset)


#build model
svm_model <- svm(y ~ ., data = trainset, type = "C-classification", kernel = "polynomial", degree = 2)

#accuracy
pred_train <- predict(svm_model, trainset)
mean(pred_train == trainset$y)
pred_test <- predict(svm_model, testset)
mean(pred_test == testset$y)

#plot model
plot(svm_model, trainset)


#create vector to store accuracies and set random number seed
accuracy <- rep(NA, 100)
set.seed(2)


# Create a dummy frame dfDum for use in the for loop
dfDum <- df

#calculate accuracies for 100 training/test partitions
for (i in 1:100){
    dfDum[, "train"] <- ifelse(runif(nrow(dfDum))<0.8, 1, 0)
    trainset <- dfDum[dfDum$train == 1, ]
    testset <- dfDum[dfDum$train == 0, ]
    trainColNum <- grep("train", names(trainset))
    trainset <- trainset[, -trainColNum]
    testset <- testset[, -trainColNum]
    svm_model<- svm(y ~ ., data = trainset, type = "C-classification", kernel = "polynomial", degree = 2)
    pred_test <- predict(svm_model, testset)
    accuracy[i] <- mean(pred_test == testset$y)
}

#print average accuracy and standard deviation
mean(accuracy)
sd(accuracy)


#create vector to store accuracies and set random number seed
accuracy <- rep(NA, 100)
set.seed(2)

#calculate accuracies for 100 training/test partitions
for (i in 1:100){
    dfDum[, "train"] <- ifelse(runif(nrow(dfDum))<0.8, 1, 0)
    trainset <- dfDum[dfDum$train == 1, ]
    testset <- dfDum[dfDum$train == 0, ]
    trainColNum <- grep("train", names(trainset))
    trainset <- trainset[, -trainColNum]
    testset <- testset[, -trainColNum]
    svm_model<- svm(y ~ ., data = trainset, type = "C-classification", kernel = "radial")
    pred_test <- predict(svm_model, testset)
    accuracy[i] <- mean(pred_test == testset$y)
}

#print average accuracy and standard deviation
mean(accuracy)
sd(accuracy)


# Re-create original 75/25 split for train/test
inTrain <- sample(1:nrow(df), round(0.75*nrow(df)), replace=FALSE)
trainset <- df[sort(inTrain), ]
testset <- df[-inTrain, ]

#tune model
tune_out <- tune.svm(x = trainset[, -3], y = trainset[, 3], 
                     gamma = 5*10^(-2:2), 
                     cost = c(0.01, 0.1, 1, 10, 100), 
                     type = "C-classification", kernel = "radial")
tune_out

#build tuned model
svm_model <- svm(y~ ., data = trainset, type = "C-classification", kernel = "radial", 
                 cost = tune_out$best.parameters$cost, 
                 gamma = tune_out$best.parameters$gamma)

#calculate test accuracy
pred_test <- predict(svm_model, testset)
mean(pred_test == testset$y)

#Plot decision boundary against test data
plot(svm_model, testset)

```
  
  
  
***
  
###_Experimental Design in R_  
  
Chapter 1 - Introduction to Experimental Design  
  
Introduction to experimental design:  
  
* Experiments start with a question in mind, then finding and analyzing data  
* This course will use open data, meaning that we do not know the original experimental design  
* Key conditions of an experiment include randomization, replication, and blocking  
  
Hypothesis testing:  
  
* The null hypothesis changes depending on the question of interest - "no effect" (two-sided) or "no positive effect" (one-sided) or etc.  
* Power is the probability that the test correctly reject the null hypothesis when the alternative hypothesis is true (target >= 80%)  
* The effect size is the standardized measure of the difference that you are trying to detect  
* Sample size is generally chosen so that the effect size can be measured at the required power  
* Example of using the power package for calculating the metrics  
	* library(pwr)  
    * pwr.anova.test(k = 3, n = 20, f = 0.2, sig.level = 0.05, power = NULL)  # one must be entered as NULL (this will be calculated) ; k groups with n per group and f effect size  
  
Example code includes:  
```{r}

# load the ToothGrowth dataset
data("ToothGrowth")

#perform a two-sided t-test
t.test(x = ToothGrowth$len, alternative = "two.sided", mu = 18)

#perform a t-test
ToothGrowth_ttest <- t.test(len ~ supp, data = ToothGrowth)

#tidy the t-test model object
broom::tidy(ToothGrowth_ttest)


#group by supp, dose, then examine how many observations in ToothGrowth there are by those groups
ToothGrowth %>% 
    group_by(supp, dose) %>% 
    summarize(n=n())

#create a boxplot with geom_boxplot()
ggplot(ToothGrowth, aes(x=as.factor(dose), y=len)) + 
    geom_boxplot()

#create the ToothGrowth_aov model object
ToothGrowth_aov <- aov(len ~ dose + supp, data = ToothGrowth)

#examine the model object with summary()
summary(ToothGrowth_aov)


#less than
t.test(x = ToothGrowth$len, alternative = "less", mu = 18)

#greater than
t.test(x = ToothGrowth$len, alternative = "greater", mu = 18)


#calculate power
pwr::pwr.t.test(n = 100, d = 0.35, sig.level = 0.10, type = "two.sample", 
                alternative = "two.sided", power = NULL
                )

#calculate sample size
pwr::pwr.t.test(n = NULL, d = 0.25, sig.level = 0.05, 
                type = "one.sample", alternative = "greater", power = 0.8
                )

```
  
  
  
***
  
Chapter 2 - Basic Experiments  
  
Single and Multiple Factor Experiments:  
  
* The ANOVA (Analysis of Variance) test allows for comparing means across 3-groups; is at least one mean different  
	* model_1 <- lm(y ~ x, data = dataset)  # first option is lm followed by aov  
    * anova(model_1)  # first option is lm followed by anova  
    * aov(y ~ x, data = dataset)  # second option is a straight call to aov  
* The multiple factor experiment includes additional potential explanatory variables  
	* model2 <- lm(y ~ x + r + s + t)  
    * anova(model2)  
* The Lending Club data is 890k x 75, and contains data from a lending company  
  
Model Validation:  
  
* EDA is an important step prior to modeling the data  
* Boxplots can be a helpful way to explore the data  
	* ggplot(data = lendingclub, aes(x = verification_status, y = funded_amnt)) + geom_boxplot()  
* ANOVA and other linear models generally assume that the residuals are normally distributed  
  
A/B Testing:  
  
* A/B tests are a type of controlled experiment with only two variants of something  
* Power and sample size are crucial to A/B testing, allowing for an understanding of the required size for a desired power and expected effect size  
  
Example code includes:  
```{r}

lendingclub <- readr::read_csv("./RInputFiles/lendclub.csv")


#examine the variables with glimpse()
glimpse(lendingclub)

#find median loan_amt, mean int_rate, and mean annual_inc with summarise()
lendingclub %>% summarise(median(loan_amnt), mean(int_rate), mean(annual_inc))

# use ggplot2 to build a bar chart of purpose
ggplot(data=lendingclub, aes(x = purpose)) + geom_bar()

#use recode() to create the new purpose_recode variable.
lendingclub$purpose_recode <- lendingclub$purpose %>% recode( 
        "credit_card" = "debt_related",
        "debt_consolidation" = "debt_related", 
        "medical" = "debt_related",
        "car" = "big_purchase", 
        "major_purchase" = "big_purchase", 
        "vacation" = "big_purchase",
        "moving" = "life_change", 
        "small_business" = "life_change", 
        "wedding" = "life_change",
        "house" = "home_related", 
        "home_improvement" = "home_related"
        )


#build a linear regression model, stored as purpose_recode_model
purpose_recode_model <- lm(funded_amnt ~ purpose_recode, data = lendingclub)

#look at results of purpose_recode_model
summary(purpose_recode_model)

#get anova results and save as purpose_recode_anova
purpose_recode_anova <- anova(purpose_recode_model)

# look at the class of purpose_recode_anova
class(purpose_recode_anova)


#Use aov() to build purpose_recode_aov
purpose_recode_aov <- aov(funded_amnt ~ purpose_recode, data = lendingclub)

#Conduct Tukey's HSD test to create tukey_output
tukey_output <- TukeyHSD(purpose_recode_aov)

#tidy tukey_output to make sense of the results
broom::tidy(tukey_output)


#Use aov() to build purpose_emp_aov
purpose_emp_aov <- aov(funded_amnt ~ purpose_recode + emp_length, data=lendingclub)

#print purpose_emp_aov to the console
purpose_emp_aov

#call summary() to see the p-values
summary(purpose_emp_aov)


#examine the summary of int_rate
summary(lendingclub$int_rate)

#examine int_rate by grade
lendingclub %>% 
    group_by(grade) %>% 
    summarise(mean = mean(int_rate), var = var(int_rate), median = median(int_rate))

#make a boxplot of int_rate by grade
ggplot(lendingclub, aes(x = grade, y = int_rate)) + geom_boxplot()

#use aov() to create grade_aov plus call summary() to print results
grade_aov <- aov(int_rate ~ grade, data = lendingclub)
summary(grade_aov)


#for a 2x2 grid of plots:
par(mfrow=c(2, 2))

#plot grade_aov
plot(grade_aov)

#back to defaults
par(mfrow=c(1, 1))

#Bartlett's test for homogeneity of variance
bartlett.test(int_rate ~ grade, data=lendingclub)


#use the correct function from pwr to find the sample size
pwr::pwr.t.test(n=NULL, d=0.2, sig.level=0.05, 
                type="two.sample", alternative="two.sided", power=0.8
                )


lc_A <- c(11976148, 1203719, 54998739, 5801830, 31587242, 7711391, 54494666, 57663583, 8967787, 21760921, 44765721, 8596988, 5794746, 59501253, 10578432, 36058744, 11727607, 357888, 51936863, 1178593, 57315811, 5705168, 46024211, 12947039, 57345207, 55299831, 28763037, 49763149, 20077511, 60216198, 12295190, 1570287, 61408414, 59121340, 32349527, 5773180, 26899704, 55412161, 2217935, 16462713, 9196065, 27802028, 40949245, 56007625, 56935379, 62187473, 20178048, 604912, 58533358, 652594, 44066849, 38942161, 6414816, 65617953, 51816492, 43489983, 6794967, 42345315, 59532019, 13107597, 63249029, 7371829, 12335467, 8560739, 7337238, 887484, 23493355, 41031080, 60537197, 12816159, 38446687, 51026618, 6374688, 18685270, 296645, 44439325, 4915968, 63449566, 25256236, 63407874, 36753301, 20728660, 7937228, 13058684, 636359, 50527238, 40450502, 1018943, 12438198, 3065732, 1510626, 5764344, 37840363, 27460227, 39751366, 5028066, 43956700, 56109033, 1412622, 44289534, 41770436, 49956562, 44409121, 47168726, 60953428, 52189251, 64281487, 51928150, 1002880, 4537354, 12605849, 477843, 6808167, 38629237, 33311208, 36109419, 58593881, 40362979, 440300, 9848361, 30656060, 15691500, 4375269, 15360849, 7077904, 66076532, 33350264, 4175651, 44006939, 21130605, 54098234, 53192890, 7371114, 12967808, 58061230, 34803392, 5544911, 28843825, 63244663, 38504887, 68565204, 1211255, 63427670, 56472411, 10548622, 43957279, 59313014, 5768723, 66210490, 25507112, 55472659, 61339767, 65684813, 45544639, 43710238, 46833245, 13028661, 13167268, 3064642, 62072249, 27631726, 65825964, 15540990, 64320858, 8605358, 17795606, 9894584, 543619, 2380700, 20959552, 57743104, 63917130, 38480348, 61393540, 19916851)
lc_A <- c(lc_A, 12528162, 7264617, 61480809, 36411752, 20139228, 21290880, 390228, 45584424, 17755019, 23413261, 15490914, 1254285, 875004, 24274579, 51006600, 11458143, 5125832, 37802077, 57327243, 41059894, 64978360, 58683523, 4290736, 40919379, 65029207, 7096004, 42285591, 7388784, 65914238, 46833088, 21221678, 62855006, 10557733, 44915714, 23083224, 67289213, 9746670, 349608, 66610322, 1595886, 3635144, 38419356, 9715410, 9726377, 621152, 23213635, 18685424, 65782663, 57304429, 20770003, 8865120, 58664359, 1454540, 42404539, 60952405, 61339308, 7367648, 11215938, 41207320, 23553299, 1681376, 7617266, 30485630, 10604792, 46044414, 63094909, 59189668, 10106916, 52058386, 17763104, 6396213, 8981232, 48070364, 10615808, 11956507, 38444903, 60216940, 58310439, 10099562, 7504691, 17533228, 62236540, 38626163, 55657128, 7728107, 42415348, 42454693, 4777573, 23834164, 25157042, 1339435, 50587486, 55998961, 32950014, 28422748, 492346, 50607472, 11335041, 4254623, 65058537, 5375256, 5646680, 44430975, 4054992, 55253292, 68375791, 16822421, 64978226, 59859214, 65424555, 10112206, 6908772, 67879649, 4794842, 31227479, 17423361, 64049774, 58624386, 14829134, 50233873, 44389635, 29684724, 452267, 43044890, 55942742, 19516366, 34443897, 57135665, 34392172, 17352839, 12896521, 40451807, 43255228, 40372428, 8568706, 68364520, 3486848, 40991148, 19196658, 8658538, 65885614, 38352455, 65674149, 1029473, 39290483, 47420355, 65364529, 32318884, 13115811, 48484348, 65975356, 56129109, 3378980, 31026386, 55231010, 41113253, 1480114, 51406116, 2445051, 8627441, 60942818, 55453270, 58573102, 25767158, 9655554, 49783137, 42273770, 32038806, 681948, 65059359, 48546050, 20169281, 68546780, 7065575, 46387142, 66180493, 58430918, 1390497, 41950574, 39888056, 11774847, 55308824, 51969105, 7936525, 5960208, 7700566, 14529825, 14688918, 43024566, 21110140, 55797803, 31236439, 6817136, 1467168, 36028128, 60781310, 66595886, 57548184, 3194733, 8589175, 1546517, 17654773, 40572454, 63284984, 5780985, 39660177, 64050493, 55081623, 51346675, 1235123, 65633931, 66390924, 17413278, 57950994, 55911330, 11814853, 31357211, 56038385, 40038565, 64400706, 35034758, 60296238, 6527713, 5685238, 1062701, 63406447, 64008930, 63476297, 5114652, 20060374, 10085133, 61328568, 9435001, 56057656, 49934674, 39661404, 19616499, 34342717, 46653815, 45614269, 59290211, 31296803, 50605437, 46928301, 58562582, 63879452, 65733359, 51086476, 40601201, 9845217, 29213549, 41227222, 7337659, 46517072, 38610653, 9694813, 21350102, 46716202, 50535150, 39729407, 22263578, 25987787, 64913590, 19636684, 59311687, 4295372, 571012, 20588847, 63424767, 1099384, 3810242, 5604591, 39760687, 43739869, 56019939, 51526987, 45494853, 4302122, 21009984, 66210827, 67255219, 46613149, 63345017, 43570211, 62002161, 2214708, 4234697, 51055338, 19647002, 28593783, 6804647, 40542044, 42263319, 4784593, 19636686, 44015285, 55697847, 5814660, 15409525, 2307393, 54404433, 15490230, 62245810, 64969544, 48120716, 41040511, 51176224, 6376426, 60386775, 826517, 27601385, 8185587, 28564285, 68613325, 58623041, 60941473, 1635691, 7729270, 46417835, 57285778, 55960993, 66510262, 60285691, 61902329, 68565071)


lc_B <- c(62012715, 49974687, 27570947, 63417796, 61449107, 12906517, 57074291, 21021086, 404854, 15139172, 46774978, 50486061, 4305577, 65783354, 48544529, 31667129, 36980133, 19117791, 3845908, 846821, 40381968, 64018601, 57184860, 49963980, 44142706, 6327771, 20811335, 67336862, 3628833, 31247310, 4764984, 1619549, 56492219, 67959628, 61672211, 1472227, 55268407, 13497237, 57538143, 43096178, 35723158, 226780, 2307012, 1210773, 50273799, 28903599, 50839792, 44916418, 9714937, 51876659, 3919804, 12968154, 54978278, 6938022, 53854432, 63350177, 39692948, 67216234, 22253060, 59099446, 46135199, 11717805, 48596572, 8475061, 61462130, 21480483, 2014943, 41430440, 43196143, 243173, 61543762, 66562164, 67878273, 41100627, 11915326, 28753020, 12617369, 59090559, 55583726, 31256585, 544537, 61430245, 1681767, 7670078, 38506546, 36500594, 31367711, 46694948, 2080069, 38457330, 54524836, 27651989, 63358477, 62002922, 8995111, 45694307, 61470409, 17933815, 27370082, 66612753, 1536521, 54948920, 57548472, 876991, 40127147, 57365210, 1904740, 3195692, 743529, 67408356, 8766184, 23643466, 51336378, 13397002, 3700020, 49935259, 38455198, 63506356, 11386690, 32479126, 6300017, 67427011, 63344398, 51366616, 727247, 59291548, 21551336, 8776003, 16111335, 1051513, 61973285, 60764833, 59190150, 25406927, 10138072, 61361677, 32279884, 63337618, 49933340, 30565592, 3217416, 61883095, 63436296, 58290318, 29884855, 50353289, 14699170, 67625637, 6815821, 2286867, 6274586, 17853756, 55948157, 6995898, 44126015, 66643915, 41338910, 8626219, 67858810, 38597465, 45884338, 565018, 46436141, 15259622, 6594706, 39479497, 5535388, 5855546, 48734782, 2896555, 67296211, 713979, 33110251, 8987918, 1224687, 5637315, 484473, 9814600, 29694710, 60902260, 25897153, 40705483, 1439301, 3055155, 26319992, 6245002, 66441896, 46427698, 36330836, 8915199, 46205024, 62459417, 3497439, 54888931, 30475522, 38998249, 12636103, 60536957)
lc_B <- c(lc_B, 27521279, 2365984, 361549, 43430210, 35843833, 9768308, 12705933, 59179388, 60830121, 67929084, 36138408, 854552, 8865548, 13096420, 23836169, 61502149, 1621627, 11426617, 48274995, 41123011, 7296181, 29635336, 30565882, 8145149, 46116481, 21119590, 43894290, 65866235, 44143687, 873468, 12419378, 26378681, 55140334, 56964922, 61682200, 14338072, 65047247, 57267246, 59581503, 41093708, 48524124, 513842, 1685090, 42723216, 60647576, 55341080, 9735578, 41110083, 30255415, 56010965, 63214550, 67828966, 671468, 38540004, 65107371, 18645038, 26017706, 660734, 573283, 9454644, 64017354, 617449, 7645594, 43286428, 55941273, 8636865, 31226902, 46194753, 6160505, 1412225, 65741544, 24084859, 58532795, 41880754, 45515321, 60585561, 65272380, 7937327, 1489732, 17553239, 7638498, 1473206, 38162164, 3355990, 15610681, 57025137, 6254978, 38162571, 52768311, 5938741, 58101279, 18895673, 30175739, 38222417, 55909312, 65663878, 6607837, 24725076, 61722475, 11895058, 28182084, 185962, 55259655, 16241080, 66602227, 5781939, 60801476, 6996130, 12346893, 65672013, 19076244, 1475379, 9056893, 59492895, 56864322, 60942704, 44015940, 62225220, 39739191, 66435524, 44199929, 59471139, 38547168, 6205030, 38615829, 6698930, 66514563, 1623685, 60545969, 46703319, 39739315, 12636426, 65364691, 16403147, 9204637, 19306532, 66270322, 65653692, 22313524, 59082682, 19796545, 10766253, 50436003, 49363132, 27600713, 44865530, 57763719, 47857115, 48535477, 65986020, 58603818, 42934257, 1167844, 66390187, 58281312, 63888770, 48596526, 67385135, 24775459, 55090096, 12347068, 37317537, 64007908, 1683908, 11976597, 41019342, 6855113, 7964638, 65701227, 44037648, 23133074, 9787718, 61389384, 38418035, 33130454, 13038119, 14639242, 38505864, 65725266, 62904623, 68513661, 36039498, 6538734, 51857455, 59139740, 64341225, 21430833, 55455899, 17795459, 65128493, 46428798, 43216120, 59199242, 50364311, 41079485, 27711293, 63218354, 65492649, 50819365, 40737432, 377507, 65736437, 61488876, 44886450, 31467727, 46651816, 11914779, 65352381, 24726593, 52989922, 43105128, 34322310, 8669148, 12795739, 38485516, 39559934, 4280915, 63437401, 7103037, 44946049, 15400322, 28583975, 59592185, 877645, 56019484, 3372858, 60556772, 19846532, 11658194, 6894823, 61414862, 52708301, 48806212, 12204849, 60863986, 3919883, 37661631, 47210580, 14689912, 23393084, 60961679, 6170889, 55191727, 14690280, 42415518, 65855022, 62156039, 38536464, 44603544, 63527328, 48182146, 25867085, 61952845, 4744682, 20110370, 65854766, 57722242, 11438361, 34111919, 53262232, 12247443, 64210396, 37630339, 41237564, 46722148, 65791211, 16882760, 7719304, 37622016, 3220774, 51906280, 12446784, 50064210, 57733299, 63437152, 38445791, 3730324, 56052115, 57354312, 58010576, 626701, 7224706, 64079786, 62167132, 8396526, 7625377, 12707224, 35084508, 56022111, 52027979, 43215589, 50425264, 59253209, 28312549, 67376619, 30795837, 43869662, 20849433, 55351366, 39549686, 22972745, 1025579)


# The specific member IDs in lc_A and lc_B are not in dataset lendingclub
lendingclub_ab <- lendingclub %>%
    mutate(Group=ifelse(member_id %in% lc_A, "A", ifelse(member_id %in% lc_B, "B", "C")))


# ggplot(lendingclub_ab, aes(x=Group, y=loan_amnt)) + geom_boxplot()

#conduct a two-sided t-test
# t.test(loan_amnt ~ Group, data=lendingclub_ab)


#build lendingclub_multi
# lendingclub_multi <-lm(loan_amnt ~ Group + grade + verification_status, data=lendingclub_ab)

#examine lendingclub_multi results
# broom::tidy(lendingclub_multi)

```
  
  
  
***
  
Chapter 3 - Randomized Complete (and Balanced Incomplete) Block Designs  
  
Intro to NHANES Dataset and Sampling:  
  
* NHANES is the National Health and Nutrition Examination Study, run once every 2 years in the US since the late 1990s (was run on different frequency since the 1960s)  
* NHANES individuals are sampled from a scheme to match the US demographics - upsampling of elderly and minorities for sufficient sample size for statistical conclusions  
* Two key types of sampling  
	* Probability sampling - probability is used to select the sample (will be covered in this course)  
    * Non-probability sampling - voluntary (whoever responds), convenience (whoever the researcher can find)  
* Many types of random sampling can be run in R  
	* Simple Random Sampling - sample()  
    * Stratified Sampling - dataset %>% group_by(strata_variable) %>% sample_n()  # sample a specified number of people inside each segment  
    * Cluster Sampling - cluster(dataset, cluster_var_name, number_to_select, method = "option")  # select everyone in each randomly select cluster  
    * Systematic Sampling - every 5th or 10th or etc. person (implemented by custom functions)  
    * Multi-Stage Sampling - combinations of 2+ of the above approaches in a sensible and structured manner  
  
Randomized Complete Block Designs (RCBD):  
  
* RCBD is run when there is a potential nuisance factor in the data that might otherwise impact the results and conclusions  
	* Randomized - treatment is assigned randomly inside each block  
    * Complete - each treatment is used the same number of times inside each block  
    * Block - experimental groups are blocked to be similar (differences within the group are expected to be lesser than differences across the groups)  
    * Design - the experiment  
    * "Block what you can, randomize what you cannot"  
* The library(agricolae) allows for drawing some of the experimental designs such as an RCBD  
	* library(agricolae)  
    * trt <- letters[1:4]  
    * rep <- 4  
    * design.rcbd <- design.rcbd(trt, r = rep, seed = 42, serie = 0)  # serie has to do with tagging of number blocks  
    * design.rcbd$sketch  
  
Balanced Incomplete Block Designs (BIBD):  
  
* Incomplete blocaks are when you cannot fully fit a treatment inside a block  
	* Balanced - each pair of treatments occur together in a block an equal number of times  
    * Incomplete - not every treatment will appear in every block  
    * Block - experimental groups are blocked to be similar (differences within the group are expected to be lesser than differences across the groups  
    * Design - the experiment  
* Suppose that t is the number of treatments, k is the number of treatments per block, and r is the number of replications  
	* lambda = r * (k - 1) / (t - 1)  
    * If lambda is a whole number, then a BIBD is possible; otherwise, it is not  
  
Example code includes:  
```{r}

nhanes_demo <- readr::read_csv("./RInputFiles/nhanes_demo.csv")
nhanes_medical <- readr::read_csv("./RInputFiles/nhanes_medicalconditions.csv")
nhanes_bodymeasures <- readr::read_csv("./RInputFiles/nhanes_bodymeasures.csv")
dummy_nhanes_final <- readr::read_csv("./RInputFiles/nhanes_final.csv")

#merge the 3 datasets you just created to create nhanes_combined
nhanes_combined <- list(nhanes_demo, nhanes_medical, nhanes_bodymeasures) %>%
  Reduce(function(df1, df2) inner_join(df1, df2, by="seqn"), .)


#fill in the dplyr code
nhanes_combined %>% group_by(mcq365d) %>% summarise(mean = mean(bmxwt, na.rm = TRUE))

#fill in the ggplot2 code
nhanes_combined %>% filter(ridageyr > 16) %>% 
  ggplot(aes(x=as.factor(mcq365d), y=bmxwt)) +
  geom_boxplot()


#filter out anyone less than 16
nhanes_filter <- nhanes_combined %>% filter(ridageyr > 16)

#use simputation & impute bmxwt to fill in missing values
nhanes_final <- simputation::impute_median(nhanes_filter, bmxwt ~ riagendr)

#recode mcq365d with ifelse() & examine with table()
nhanes_final$mcq365d <- ifelse(nhanes_final$mcq365d==9, 2, nhanes_final$mcq365d)
table(nhanes_final$mcq365d)


#use sample() to create nhanes_srs
nhanes_srs <- nhanes_final[sample(nrow(nhanes_final), 2500), ]

#create nhanes_stratified with group_by() and sample_n()
nhanes_stratified <- nhanes_final %>%
  group_by(riagendr) %>%
  sample_n(2000)
table(nhanes_stratified$riagendr)

#load sampling package and create nhanes_cluster with cluster()
nhanes_cluster <- sampling::cluster(nhanes_final, "indhhin2", 6, method = "srswor")


#use str() to view design.rcbd's criteria
str(agricolae::design.rcbd)

#build trt and rep
trt <- LETTERS[1:5]
rep <- 4

#Use trt and rep to build my.design.rcbd and view the sketch part of the object
my_design_rcbd <- agricolae::design.rcbd(trt, r=rep, seed = 42, serie=0)
my_design_rcbd$sketch


#make nhanes_final$riagendr a factor variable
nhanes_final$riagendr <- factor(nhanes_final$riagendr)

#use aov() to create nhanes_rcbd
nhanes_rcbd <- aov(bmxwt ~ mcq365d + riagendr, data=nhanes_final)

#check the results of nhanes_rcbd with summary()
summary(nhanes_rcbd)

#print the difference in weights by mcq365d and riagendr
nhanes_final %>% group_by(mcq365d, riagendr) %>% summarise(mean_wt = mean(bmxwt))


#set up the 2x2 plotting grid and then plot nhanes_rcbd
par(mfrow=c(2, 2))
plot(nhanes_rcbd)
par(mfrow=c(1, 1))

#run the code to view the interaction plots
with(nhanes_final, interaction.plot(mcq365d, riagendr, bmxwt))

#run the code to view the interaction plots
with(nhanes_final, interaction.plot(riagendr, mcq365d, bmxwt))


#create my_design_bibd_1
# my_design_bibd_1 <- design.bib(LETTERS[1:3], k = 4, r = 16, serie = 0, seed = 42)  # will throw an error

#create my_design_bibd_2
# my_design_bibd_2 <- design.bib(letters[1:2], k = 3, r = 5, serie = 0, seed = 42)  # will throw warning

#create my_design_bibd_3
my_design_bibd_3 <- agricolae::design.bib(letters[1:4], k = 4, r = 6, serie = 0, seed = 42)
my_design_bibd_3$sketch


lambda <- function(t, k, r){
  return((r*(k-1)) / (t-1))
}

#calculate lambda
lambda(4, 3, 3)


#build the data.frame
creatinine <- c(1.98, 1.97, 2.35, 2.09, 1.87, 1.95, 2.08, 2.01, 1.84, 2.06, 1.97, 2.22)
food <- as.factor(c("A", "C", "D", "A", "B", "C", "B", "C", "D", "A", "B", "D"))
color <- as.factor(rep(c("Black", "White", "Orange", "Spotted"), each = 3))
cat_experiment <- as.data.frame(cbind(creatinine, food, color))

#create cat_model & then wrong_cat_model and examine them with summary()
cat_model <- aov(creatinine ~ food + color, data=cat_experiment)
summary(cat_model)


#calculate lambda
lambda(3, 3, 2)

#create weightlift_model & examine results (variable does not exist in dataset)
# weightlift_model <- aov(bmxarmc ~ weightlift_treat + ridreth1, data=nhanes_final)
# summary(weightlift_model)

```
  
  
  
***
  
Chapter 4 - Latin Squares, Graeco-Latin Squares, Factorial Experiments  
  
Latin Squares have two blocking factors, assumed not to interact with each other or the treatment, and each with the same number of levels:  
  
* Latin squares can be analyzed just like an RCBD  
* In a Latin square, both the rows and the columns are the blocking factors  
* Can use nyc_scores dataset containing reading, writing, and math scores from all accredited high schools  
	* Goal is to assess the impact of a (fabricated) tutoring program on the scores by school  
  
Graeco-Latin Squares builds on Latin squares by adding an additional blocking factor:  
  
* Three blocking factors, all with the same number of levels, and assumed not to interact with each other or the treatment  
	* Greek letters added next to the Latin letters indicate the third blocking factors (can use Latin and numbers instead)  
    * All of the combinations occur only once (each letter once per row/column, and each number once per letter)  
  
Factorial Experiments - designs in which 2+ variables are crossed in an experiment, with each combination considered a factor:  
  
* Example of testing all combinations of high/low water and high/low light - each combination is tested, with TukeyHSD() applied after  
* This course will focus on 2^k factor experiments, meaning that each level has only a High/Low (or similar) possibility  
  
Next steps:  
  
* Many other types of factorial designs - do not all need to be 2**k, with many factor levels  
	* Might consider a fractional factorial design to minimize the analytical burden  
* Design should be a valued and integrated part of the process  
* There will always be some unmeasured confounders, but good design can help to reduce that noise  
  
Example code includes:  
```{r}

nyc_scores <- readr::read_csv("./RInputFiles/nyc_scores.csv")
glimpse(nyc_scores)


tEL <- c('PhD', 'BA', 'BA', 'MA', 'MA', 'PhD', 'MA', 'MA', 'BA', 'PhD', 'College Student', 'College Student', 'Grad Student', 'MA', 'MA', 'MA', 'BA', 'MA', 'BA', 'MA', 'College Student', 'PhD', 'MA', 'MA', 'BA', 'MA', 'College Student', 'BA', 'PhD', 'Grad Student', 'MA', 'Grad Student', 'MA', 'College Student', 'Grad Student', 'MA', 'Grad Student', 'BA', 'BA', 'College Student', 'Grad Student', 'College Student', 'BA', 'BA', 'PhD', 'BA', 'Grad Student', 'Grad Student', 'College Student', 'College Student', 'BA', 'PhD', 'College Student', 'PhD', 'PhD', 'PhD', 'College Student', 'Grad Student', 'MA', 'MA', 'BA', 'PhD', 'College Student', 'MA', 'MA', 'College Student', 'Grad Student', 'MA', 'PhD', 'MA', 'College Student', 'MA', 'PhD', 'MA', 'College Student', 'College Student', 'Grad Student', 'PhD', 'MA', 'MA', 'Grad Student', 'MA', 'MA', 'Grad Student', 'PhD', 'Grad Student', 'Grad Student', 'Grad Student', 'MA', 'PhD', 'BA', 'MA', 'Grad Student', 'BA', 'College Student', 'MA', 'College Student', 'Grad Student', 'Grad Student', 'College Student', 'MA', 'BA', 'BA', 'MA', 'MA', 'Grad Student', 'MA', 'Grad Student', 'MA', 'Grad Student', 'College Student', 'College Student', 'College Student', 'MA', 'BA', 'Grad Student', 'Grad Student', 'MA', 'College Student', 'BA', 'Grad Student', 'MA', 'Grad Student', 'PhD', 'MA', 'MA', 'College Student', 'MA', 'College Student', 'PhD', 'College Student', 'MA', 'MA', 'MA', 'MA', 'College Student', 'MA', 'BA', 'MA', 'Grad Student', 'BA', 'MA', 'MA', 'Grad Student', 'MA', 'MA', 'College Student', 'MA', 'MA', 'BA', 'MA', 'College Student', 'Grad Student', 'College Student', 'MA', 'BA', 'MA', 'BA', 'College Student', 'Grad Student', 'Grad Student', 'Grad Student', 'Grad Student', 'Grad Student', 'MA', 'BA', 'MA', 'BA', 'College Student', 'MA', 'BA', 'MA', 'Grad Student', 'MA', 'PhD', 'MA', 'BA', 'Grad Student', 'MA', 'BA', 'BA', 'MA', 'BA', 'College Student', 'BA', 'MA', 'MA', 'BA', 'MA', 'College Student', 'BA', 'Grad Student', 'MA', 'BA', 'MA', 'MA', 'MA', 'BA', 'College Student', 'College Student')
tEL <- c(tEL, 'BA', 'Grad Student', 'BA', 'BA', 'MA', 'Grad Student', 'BA', 'MA', 'BA', 'PhD', 'MA', 'MA', 'MA', 'BA', 'College Student', 'PhD', 'BA', 'Grad Student', 'BA', 'College Student', 'BA', 'MA', 'College Student', 'MA', 'College Student', 'Grad Student', 'College Student', 'MA', 'PhD', 'BA', 'PhD', 'Grad Student', 'BA', 'BA', 'MA', 'MA', 'BA', 'PhD', 'College Student', 'MA', 'BA', 'College Student', 'BA', 'MA', 'College Student', 'MA', 'College Student', 'BA', 'MA', 'BA', 'BA', 'MA', 'PhD', 'BA', 'MA', 'Grad Student', 'College Student', 'MA', 'College Student', 'MA', 'MA', 'PhD', 'College Student', 'College Student', 'Grad Student', 'Grad Student', 'MA', 'College Student', 'Grad Student', 'Grad Student', 'Grad Student', 'MA', 'Grad Student', 'MA', 'BA', 'College Student', 'MA', 'Grad Student', 'College Student', 'MA', 'BA', 'BA', 'College Student', 'College Student', 'College Student', 'College Student', 'College Student', 'PhD', 'MA', 'College Student', 'MA', 'MA', 'MA', 'PhD', 'College Student', 'College Student', 'MA', 'MA', 'MA', 'PhD', 'MA', 'MA', 'PhD', 'MA', 'Grad Student', 'MA', 'Grad Student', 'MA', 'Grad Student', 'MA', 'MA', 'PhD', 'BA', 'BA', 'Grad Student', 'Grad Student', 'PhD', 'BA', 'BA', 'Grad Student', 'College Student', 'BA', 'College Student', 'MA', 'MA', 'MA', 'Grad Student', 'BA', 'BA', 'MA', 'Grad Student', 'PhD', 'BA', 'Grad Student', 'Grad Student', 'Grad Student', 'BA', 'MA', 'BA', 'College Student', 'College Student', 'Grad Student', 'MA', 'Grad Student', 'Grad Student', 'BA', 'BA', 'MA', 'College Student', 'BA', 'Grad Student', 'Grad Student', 'College Student', 'Grad Student', 'College Student', 'PhD', 'BA', 'MA', 'MA', 'BA', 'College Student', 'College Student', 'PhD', 'MA', 'BA', 'MA', 'MA', 'Grad Student', 'MA', 'PhD', 'MA', 'MA', 'Grad Student', 'College Student', 'MA', 'BA', 'BA', 'College Student', 'Grad Student', 'BA', 'MA', 'MA', 'Grad Student', 'BA', 'Grad Student', 'Grad Student', 'MA', 'PhD', 'Grad Student', 'Grad Student', 'MA', 'MA', 'PhD', 'College Student', 'College Student', 'MA', 'BA', 'MA', 'College Student', 'MA', 'PhD', 'BA', 'MA', 'College Student', 'PhD', 'PhD', 'College Student', 'MA', 'MA', 'MA', 'PhD', 'MA', 'BA', 'College Student', 'BA', 'BA', 'MA', 'MA', 'College Student', 'College Student', 'Grad Student', 'College Student', 'MA', 'MA', 'MA', 'Grad Student', 'MA', 'College Student', 'Grad Student', 'BA', 'Grad Student', 'BA', 'MA', 'College Student', 'MA')


nyc_scores <- nyc_scores %>%
    mutate(Teacher_Education_Level=tEL)
glimpse(nyc_scores)


#mean, var, and median of Math score
nyc_scores %>%
    group_by(Borough) %>% 
    summarise(mean = mean(Average_Score_SAT_Math, na.rm=TRUE),
              var = var(Average_Score_SAT_Math, na.rm=TRUE),
              median = median(Average_Score_SAT_Math, na.rm=TRUE))

#mean, var, and median of Math score
nyc_scores %>%
    group_by(Teacher_Education_Level) %>% 
    summarise(mean = mean(Average_Score_SAT_Math, na.rm=TRUE),
              var = var(Average_Score_SAT_Math, na.rm=TRUE),
              median = median(Average_Score_SAT_Math, na.rm=TRUE))

#mean, var, and median of Math score
nyc_scores %>%
    group_by(Borough, Teacher_Education_Level) %>% 
    summarise(mean = mean(Average_Score_SAT_Math, na.rm=TRUE),
              var = var(Average_Score_SAT_Math, na.rm=TRUE),
              median = median(Average_Score_SAT_Math, na.rm=TRUE))


# If we want to use SAT scores as our outcome, we need to examine their missingness
# First, look at the pattern of missingness using md.pattern() from the mice package
# There are 60 scores missing in each of the scores
# There are many R packages which help with more advanced forms of imputation, such as MICE, Amelia, mi, and more
# We will use the simputation andimpute_median() as we did previously

#examine missingness with md.pattern()
mice::md.pattern(nyc_scores)

#impute the Math, Writing, and Reading scores by Borough
nyc_scores_2 <- simputation::impute_median(nyc_scores, Average_Score_SAT_Math ~ Borough)

#convert Math score to numeric
nyc_scores_2$Average_Score_SAT_Math <- as.numeric(nyc_scores_2$Average_Score_SAT_Math)

#examine scores by Borough in both datasets, before and after imputation
nyc_scores %>% 
  group_by(Borough) %>% 
  summarise(median = median(Average_Score_SAT_Math, na.rm = TRUE), mean = mean(Average_Score_SAT_Math, na.rm = TRUE))
nyc_scores_2 %>% 
  group_by(Borough) %>% 
  summarise(median = median(Average_Score_SAT_Math, na.rm = TRUE), mean = mean(Average_Score_SAT_Math, na.rm = TRUE))


#design a LS with 5 treatments A:E then look at the sketch
my_design_lsd <- agricolae::design.lsd(LETTERS[1:5], serie=0, seed=42)
my_design_lsd$sketch


# To execute a Latin Square design on this data, suppose we want to know the effect of of our tutoring program, which includes one-on-one tutoring, two small groups, and an in and after school SAT prep class
# A new dataset nyc_scores_ls is available that represents this experiment. Feel free to explore the dataset in the console.

# We'll block by Borough and Teacher_Education_Level to reduce their known variance on the score outcome
# Borough is a good blocking factor because schools in America are funded partly based on taxes paid in each city, so it will likely make a difference on quality of education

lsID <- c('11X290', '10X342', '09X260', '09X412', '12X479', '14K478', '32K554', '14K685', '22K405', '17K382', '05M692', '02M427', '02M308', '03M402', '02M282', '30Q501', '26Q495', '24Q455', '29Q326', '25Q670', '31R450', '31R445', '31R080', '31R460', '31R455')
lsTP <- c('One-on-One', 'Small Groups (2-3)', 'Small Groups (4-6)', 'SAT Prep Class (school hours)', 'SAT Prep Class (after school)', 'Small Groups (2-3)', 'Small Groups (4-6)', 'SAT Prep Class (school hours)', 'SAT Prep Class (after school)', 'One-on-One', 'Small Groups (4-6)', 'SAT Prep Class (school hours)', 'SAT Prep Class (after school)', 'One-on-One', 'Small Groups (2-3)', 'SAT Prep Class (school hours)', 'SAT Prep Class (after school)', 'One-on-One', 'Small Groups (2-3)', 'Small Groups (4-6)', 'SAT Prep Class (after school)', 'One-on-One', 'Small Groups (2-3)', 'Small Groups (4-6)', 'SAT Prep Class (school hours)')

nyc_scores_ls <- nyc_scores_2 %>%
    filter(School_ID %in% lsID) %>%
    mutate(Tutoring_Program=lsTP)


#build nyc_scores_ls_lm
nyc_scores_ls_lm <- lm(Average_Score_SAT_Math ~ Tutoring_Program + Borough + Teacher_Education_Level,
                       data=nyc_scores_ls
                       )

#tidy the results with broom
nyc_scores_ls_lm %>% broom::tidy()

#examine the results with anova
nyc_scores_ls_lm %>% anova()


#create a boxplot of Math scores by Borough, with a title and x/y axis labels
ggplot(nyc_scores, aes(x=Borough, y=Average_Score_SAT_Math)) + 
  geom_boxplot() + 
  ggtitle("Average SAT Math Scores by Borough, NYC") + 
  xlab("Borough (NYC)") + 
  ylab("Average SAT Math Scores (2014-15)")


#create trt1 and trt2
trt1 <- LETTERS[1:5]
trt2 <- 1:5

#create my_graeco_design
my_graeco_design <- agricolae::design.graeco(trt1, trt2, serie=0, seed=42)

#examine the parameters and sketch
my_graeco_design$parameters
my_graeco_design$sketch


glsID <- c('09X241', '10X565', '09X260', '07X259', '11X455', '18K563', '23K697', '32K403', '22K425', '16K688', '02M135', '06M348', '02M419', '02M489', '04M495', '30Q502', '24Q530', '30Q555', '24Q560', '27Q650', '31R440', '31R064', '31R450', '31R445', '31R460')
glsTP <- c('SAT Prep Class (school hours)', 'SAT Prep Class (after school)', 'One-on-One', 'Small Groups (4-6)', 'Small Groups (2-3)', 'SAT Prep Class (after school)', 'One-on-One', 'Small Groups (4-6)', 'Small Groups (2-3)', 'SAT Prep Class (school hours)', 'One-on-One', 'Small Groups (4-6)', 'Small Groups (2-3)', 'SAT Prep Class (school hours)', 'SAT Prep Class (after school)', 'Small Groups (4-6)', 'Small Groups (2-3)', 'SAT Prep Class (school hours)', 'SAT Prep Class (after school)', 'One-on-One', 'Small Groups (2-3)', 'SAT Prep Class (school hours)', 'SAT Prep Class (after school)', 'One-on-One', 'Small Groups (4-6)')
glsHT <- c('Small Group', 'Large Group', 'Individual', 'Mix of Large Group/Individual', 'Mix of Small Group/Individual', 'Individual', 'Mix of Large Group/Individual', 'Mix of Small Group/Individual', 'Small Group', 'Large Group', 'Mix of Small Group/Individual', 'Small Group', 'Large Group', 'Individual', 'Mix of Large Group/Individual', 'Large Group', 'Individual', 'Mix of Large Group/Individual', 'Mix of Small Group/Individual', 'Small Group', 'Mix of Large Group/Individual', 'Mix of Small Group/Individual', 'Small Group', 'Large Group', 'Individual')


nyc_scores_gls <- nyc_scores_2 %>%
    filter(School_ID %in% glsID) %>%
    mutate(Tutoring_Program=glsTP, Homework_Type=glsHT)


#build nyc_scores_gls_lm
nyc_scores_gls_lm <- lm(Average_Score_SAT_Math ~ Tutoring_Program + Borough + Teacher_Education_Level + Homework_Type, data=nyc_scores_gls)

#tidy the results with broom
nyc_scores_gls_lm %>% broom::tidy()

#examine the results with anova
nyc_scores_gls_lm %>% anova()


pctTHL <- c(1, 1, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 1, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 1, 2, 1, 1, 2, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 2, 1, 2, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 1, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 2, 1, 2, 2, 2, 1, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 1, 2, 1, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 2, 1, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 2, 1, 2, 1, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1, 2)
pctBHL <- c(2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 2, 1, 2, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 2, 2, 1, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 1, 2, 2, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 2, 2, 2, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 1, 2, 1, 2, 2, 1, 1, 2, 1, 1, 1, 2, 1, 2, 1, 1, 2, 2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 2, 2, 2, 2, 1, 2, 1, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1)
tP <- c('Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'Yes', 'No', 'No')

nyc_scores <- nyc_scores %>%
    select(-Teacher_Education_Level) %>%
    mutate(Percent_Tested_HL=factor(pctTHL), Percent_Black_HL=factor(pctBHL), Tutoring_Program=factor(tP))


#build the boxplots for all 3 factor variables: tutoring program, pct black, pct tested
ggplot(nyc_scores, aes(x=Tutoring_Program, y=Average_Score_SAT_Math)) + 
    geom_boxplot()

ggplot(nyc_scores, aes(x=Percent_Black_HL, y=Average_Score_SAT_Math)) + 
    geom_boxplot()

ggplot(nyc_scores, aes(x=Percent_Tested_HL, y=Average_Score_SAT_Math)) + 
    geom_boxplot()


#create nyc_scores_factorial and examine the results
nyc_scores_factorial <- aov(Average_Score_SAT_Math ~ Percent_Tested_HL * Percent_Black_HL * Tutoring_Program, data=nyc_scores)
broom::tidy(nyc_scores_factorial)


#use shapiro.test() to test the outcome
shapiro.test(nyc_scores$Average_Score_SAT_Math)

#plot nyc_scores_factorial to examine residuals
par(mfrow = c(2, 2))
plot(nyc_scores_factorial)
par(mfrow = c(1, 1))

```
  
  
  
***
  
###_Structural Equation Modeling with lavaan in R_  
  
Chapter 1 - One-Factor Models  
  
Model Specification - Structural Equation Models (SEM) - explore relationships between variables:  
  
* Can confirm the structure of a developed model also  
* Two variable types - manifest (directly measured) which are represented by squares, and latent (abstract underlying phenomenon) represented as circles  
	* The manifest variables are assumed to be driven by the latent variables (such as intelligence)  
* Can set up an analysis in R using lavaan based on 1939 intelligence data  
	* library(lavaan)  
    * data(HolzingerSwineford1939)  
    * example model <- 'latent_variable =~ manifest_variable1 + manifest_variable2 + ...'  # latent_variable can have any name not in dataset, =~ is direction of prediction  
    * visual.model <- 'visual =~ x1 + x2 + x3 + x7 + x8 + x9'  # x1, x2, x3, x7, x8, x9 are visual components inside the 1939 dataset  
  
Model Analysis:  
  
* Degrees of freedom are based on df = Possible Values - Estimated Values  
	* Possible Values = Manifest Variables * (Manifest Variables + 1) / 2  
    * Models need to have at least 3 manifest variables and df > 0  
    * Can use scaling and constraints to control degrees of freedom - managed inside lavaan but can modify defaults  
* Can run the models using lavaan in R  
	* visual.model <- 'visual =~ x1 + x2 + x3 + x7 + x8 + x9'  
    * visual.fit <- cfa(model = visual.model, data = HolzingerSwineford1939)  # include the previously defined model and the data frame  
    * summary(visual.fit)  # basic information about the model  
    * The loadings (weightings) for each of the manifest variables will be shown, typically with the first coefficient set to 1 as per the scaling  
    * The variance estimates are also provided for each of the variables - should be positive, but can be negative (needs to be troubleshot)  
  
Model Assessment:  
  
* Standardized loadings measure the strength of the relationships between the manifest variables and the latent variables  
	* Can be measured based on the estimates, relative to the variable that was set as 1.00  
    * Can instead use the standardized solution based on the z-scores  
    * summary(visual.fit, standardized = TRUE)  # to get the standardized solution (Std.all column, with close to 1 being best; Std.lv being scaled like the loading variable)  
* The model fit measures how well the data fit the specified model  
	* Goodness of fit indices like the Comparative Fit Index or the Tucker Lewis Index - goal is closer to 1 and 0.9+  
    * Badness of fit indices like RMSE Approximation or Standardized Root Mean Square Residual (SRMR) - goal is lower and 0.1-  
    * summary(visual.fit, standardized = TRUE, fit.measures = TRUE)  # will show most common fit meaasures  
  
Example code includes:  
```{r}

#Load the lavaan library
library(lavaan)

#Look at the dataset
data(HolzingerSwineford1939, package="lavaan")
head(HolzingerSwineford1939[ , 7:15])

#Define your model specification
text.model <- "textspeed =~ x4 + x5 + x6 + x7 + x8 + x9"

#Analyze the model with cfa()
text.fit <- lavaan::cfa(model=text.model, data=HolzingerSwineford1939)

#Summarize the model
summary(text.fit)
summary(text.fit, standardized=TRUE)
summary(text.fit, fit.measures=TRUE)


#Look at the dataset
data(PoliticalDemocracy, package="lavaan")
head(PoliticalDemocracy)

#Define your model specification
politics.model <- "poldemo60 =~ y1 + y2 + y3 + y4"

#Analyze the model with cfa()
politics.fit <- lavaan::cfa(model = politics.model, data = PoliticalDemocracy)

#Summarize the model
summary(politics.fit, standardized=TRUE, fit.measures=TRUE)

```
  
  
  
***
  
Chapter 2 - Multi-Factor Models  
  
Multifactor Specification - exploring multiple latent relationships, and their relationships to each other:  
  
* Combining manifest variables that represent different latent variables often results in a model with poor fit  
* Can instead convert each of the manifest variables to the appropriate latent variable, for example  
	* visual.model <- 'visual =~ x1 + x2 + x3'  
    * visual.fit <- cfa(model = visual.model, data = HolzingerSwineford1939)   
    * speed.model <- 'speed =~ x7 + x8 + x9'  
    * speed.fit <- cfa(model = speed.model, data = HolzingerSwineford1939)  
* However, having too many models can lead to having zero degrees of freedom; constraints (such as same loading for x2/x3) are used to address this  
	* visual.model <- 'visual =~ x1 + a*x2 + a*x3'  # The a means that x2 and x3 will be set equal to each other, while a number rather than a would use that exact number  
* One larger model can sometimes better capture all the relationships  
	* twofactor.model <- 'visual =~ x1 + x2 + x3 \n speed =~ x7 + x8 + x9'  # adding them all at the same time (must have new line for new model)  
    * twofactor.fit <- cfa(model = twofactor.model, data = HolzingerSwineford1939)  
    * summary(twofactor.fit, standardized = TRUE, fit.measures = TRUE)  
  
Model Structure:  
  
* The two-factor model assumes there is a covariant relationship between the latent variables - basically, one latent variable can predict another  
* Can see the correlation between the standardized variables using the summary() function - technically shows R-squared  
	* =~ creates latent variables  
    * ~~ creates covariances between variables  
    * ~ creates direct prediction between variables  
    * if there is a newline followed by 'speed ~~ 0*visual' then speed will be assumed NOT to vary at all with visual  
    * if there is a newline followed by 'speed ~ visual' then there is assumed to be a direct relationship between these variables  
  
Modification Indices:  
  
* If a model has a poor fit, can examine the standardized solutions - desire is to see loading greater than 0.3  
* Model problems can often be identified by variances that are very high relative to the raw data  
* Modification indices can help show the improvement in the model when an additional index is added  
	* modificationindices(twofactor.fit, sort = TRUE)  
    * Output will be lhs op rhs (left-hand side, operator, right-hand-side) followed by mi (modification index, a form of chi-squared)  
    * Parameters should be added one at a time, and only if they "make theoretical sense"  
    * Take the desired path(s) and add them as new lines in the model  
  
Model Comparison:  
  
* Can create and save two models, then analyze both using the same cfa(), then use anova() to compare the models  
	* anova(twofactor.fit, twofactor.fit1)  
    * This is only useful for nested models that otherwise share the same variables  
* Can also compare the fit indices using more detailed criteria  
	* fitmeasures(twofactor.fit)  
    * AIC (lower is better, including more negative better than less negative)  
    * ECVI is the likelihood of replicating the model with the same sample size and population (lower is better)  
    * fitmeasures(twofactor.fit1, c("aic", "ecvi"))  
  
Example code includes:  
```{r}

#Create your text model specification
text.model <- 'text =~ x4 + x5 + x6'

#Analyze the model
text.fit <- cfa(model=text.model, data=HolzingerSwineford1939)

#Summarize the model
summary(text.fit, standardized = TRUE, fit.measures = TRUE)


#Update the model specification by setting two paths to the label a
text.model <- 'text =~ x4 + a*x5 + a*x6'

#Analyze the model
text.fit <- cfa(model = text.model, data = HolzingerSwineford1939)

#Summarize the model
summary(text.fit, standardized = TRUE, fit.measures = TRUE)


#Create a two-factor model of text and speed variables
twofactor.model <- 'text =~ x4 + x5 + x6
speed =~ x7 + x8 + x9'

#Previous one-factor model output
summary(text.fit, standardized = TRUE, fit.measures = TRUE)

#Two-factor model specification
twofactor.model <- 'text =~ x4 + x5 + x6
speed =~ x7 + x8 + x9'

#Use cfa() to analyze the model
twofactor.fit <- cfa(model=twofactor.model, data=HolzingerSwineford1939)

#Use summary() to view the fitted model
summary(twofactor.fit, standardized = TRUE, fit.measures = TRUE)


#Load the library and data
data(epi, package="psych")

#Specify a three-factor model with one correlation set to zero
epi.model <- 'extraversion =~ V1 + V3 + V5 + V8
neuroticism =~ V2 + V4 + V7 + V9
lying =~ V6 + V12 + V18 + V24
extraversion ~~ 0*neuroticism'

#Run the model
epi.fit <- cfa(model = epi.model, data = epi)

#Examine the output 
summary(epi.fit, standardized = TRUE, fit.measures = TRUE)


#Specify a three-factor model where lying is predicted by neuroticism
epi.model <- 'extraversion =~ V1 + V3 + V5 + V8
neuroticism =~ V2 + V4 + V7 + V9
lying =~ V6 + V12 + V18 + V24
lying ~ neuroticism'


#Run the model
epi.fit <- cfa(model = epi.model, data = epi)

#Examine the output 
summary(epi.fit, standardized = TRUE, fit.measures = TRUE)

#Calculate the variance of V1
var(epi$V1, na.rm=TRUE)

#Examine the modification indices
modificationindices(epi.fit, sort=TRUE)


#Edit the model specification
epi.model1 <- 'extraversion =~ V1 + V3 + V5 + V8
neuroticism =~ V2 + V4 + V7 + V9
lying =~ V6 + V12 + V18 + V24
neuroticism =~ V3'

#Reanalyze the model
epi.fit1 <- cfa(model = epi.model1, data = epi)

#Summarize the updated model
summary(epi.fit1, standardized = TRUE, fit.measures = TRUE)


#Analyze the original model
epi.fit <- cfa(model = epi.model, data = epi)

#Analyze the updated model
epi.fit1 <- cfa(model = epi.model1, data = epi)

#Compare those models
anova(epi.fit, epi.fit1)


#Analyze the original model
epi.fit <- cfa(model = epi.model, data = epi)

#Find the fit indices for the original model
fitmeasures(epi.fit)[c("aic", "ecvi")]

#Analyze the updated model
epi.fit1 <- cfa(model = epi.model1, data = epi)

#Find the fit indices for the updated model
fitmeasures(epi.fit1)[c("aic", "ecvi")]

```
  
  
  
***
  
Chapter 3 - Troubleshooting Model Errors and Diagrams  
  
Heywood Cases on the Latent Variable:  
  
* Heywood cases (defined by Heywood in 1931) are cases where correlations (greater than 1) or variances (negative) are out of bounds  
* The lavaan package will throw a warning that the matrix of latent variables is "not positive definite"  
	* Usually occurs because one of the latent variables is really a combination of the others  
    * Can then identify the highly correlated variables, and collapse them in to a single equation (fewer factors or the like)  
  
Heywood Cases on the Manifest Variable (negative error variances):  
  
* Generally occur dur to a mis-specified (under-specified) model, small sample sizes, manifest variables on vastly different scales, etc.  
* The lavaan package will throw a warning that "model has not converged"  
	* summary(negative.fit, standardized = TRUE, fit.measures = TRUE, rsquare = TRUE)  # rsquare can help to identify the issue; variance in each manifest variable should be (0, 1)  
* Can just freeze the variance of one of the wonky variables to its variance in the raw data  
	* negative.model <- 'latent1 =~ V1 + V2 + V3\nlatent2 =~ V4 + V5 + V6\nV2 ~~ 18.83833*V2'   # 18.84 is var(V2)  
  
Create Diagrams with semPaths():  
  
* The semPlot library allows for diagramming the fit models  
	* library(semPlot)  
    * twofactor.model <- 'text =~ x4 + x5 + x6\nspeed =~ x7 + x8 + x9'  
    * twofactor.fit <- cfa(model = twofactor.model, data = HolzingerSwineford1939)  
    * semPaths(object = twofactor.fit)  
* The double-headed arrows on the manifest variables are variances, and the double-headed arrows on the latent variables are covariances  
* There are many options for semPaths, and allow a few will be covered here  
	* semPaths(object = twofactor.fit, whatLabels = "std", edge.label.cex = 1)  # std is standardized while par is parameters; edge.label.cex is the font size for the edges  
    * semPaths(object = twofactor.fit, whatLabels = "std", edge.label.cex = 1, layout = "circle")  # "tree" is the default for layouts  
    * semPaths(object = twofactor.fit, whatLabels = "std", edge.label.cex = 1, layout = "tree", rotation = 2)  # rotation can only be used for trees; 2 means left/right  
    * semPaths(object = twofactor.fit, whatLabels = "std", edge.label.cex = 1, layout = "tree", rotation = 2, what = "std", edge.color = "purple")  # what colors arrows by strength  
  
Example code includes:  
```{r}

badlatentdata <- readr::read_csv("./RInputFiles/badlatentdata.csv")
badvardata <- readr::read_csv("./RInputFiles/badvardata.csv")

adoptsurvey <- badlatentdata %>%
    select(-X1) %>%
    rename(pictures=V1, background=V2, loveskids=V3, energy=V4, wagstail=V5, playful=V6)

#Look at the data
str(adoptsurvey, give.attr=FALSE)
head(adoptsurvey)

#Build the model
adopt.model <- 'goodstory =~ pictures + background + loveskids
inperson =~ energy + wagstail + playful'

#Analyze the model
adopt.fit <- cfa(model = adopt.model, data = adoptsurvey)
lavInspect(adopt.fit, "cov.lv")
summary(adopt.fit, standardized=TRUE, fit.measures=TRUE)


#Edit the original model 
adopt.model <- 'goodstory =~ pictures + background + loveskids + energy + wagstail + playful'

#Analyze the model
adopt.fit <- cfa(model = adopt.model, data = adoptsurvey)

#Look for Heywood cases
summary(adopt.fit, standardized = TRUE, fit.measures = TRUE)



adoptsurvey <- badvardata %>%
    select(-X1) %>%
    rename(pictures=V1, background=V2, loveskids=V3, energy=V4, wagstail=V5, playful=V6)
str(adoptsurvey, give.attr=FALSE)
summary(adoptsurvey)


#Build the model
adopt.model <- 'goodstory =~ pictures + background + loveskids
inperson =~ energy + wagstail + playful'

#Analyze the model
adopt.fit <- cfa(model=adopt.model, data=adoptsurvey)

#Summarize the model to view the negative variances
summary(adopt.fit, standardized=TRUE, fit.measures=TRUE, rsquare=TRUE)

#View the variance of the problem manifest variable
var(adoptsurvey$wagstail)


#Update the model using 5 decimal places
adopt.model2 <- 'goodstory =~ pictures + background + loveskids
inperson =~ energy + wagstail + playful
wagstail~~23.07446*wagstail'

#Analyze and summarize the updated model
adopt.fit2 <- cfa(model = adopt.model2, data = adoptsurvey)
summary(adopt.fit2, standardized=TRUE, fit.measures=TRUE, rsquare=TRUE)


#Create a default picture
semPlot::semPaths(adopt.fit)

#Update the default picture
semPlot::semPaths(object = adopt.fit, layout="tree", rotation=2)

#Update the default picture
semPlot::semPaths(object = adopt.fit, layout = "tree", rotation = 2, whatLabels = "std", 
                  edge.label.cex = 1, what = "std", edge.color = "blue"
                  )

```
  
  
  
***
  
Chapter 4 - Full Example and Extension  
  
Model WAIS-III IQ Scale:  
  
* WAIS-III is a four-factor model of intelligence, including verbal, working memory, perceptual organization, and processing speed  
	* Idea is that Verbal IQ drives verbal and working memory, Performance IQ drives perceptual and processing, and Verbal/Performance drive each other  
    * 4 latent variables, measured by 12 manifest variables, with 2 additional latent variables at a higher layer that drive the initial 4 latent variables  
  
Update WAIS-III Model:  
  
* Once the model is stable, can look for additional areas to further improve the model  
* Variables that are poor on loadings and are also high in variance should be further explored  
* Can also use modification indices to better understand and model the data  
	* modificationindices(wais.fit, sort = TRUE)  
  
Hierarchical Model of IQ:  
  
* One overall IQ that is the latent variable for all of the other latent variable  
	* wais.model3 <- 'verbalcomp =~ vocab + simil + inform + compreh  
    * workingmemory =~ arith + digspan + lnseq  
    * perceptorg =~ piccomp + block + matrixreason + digsym + symbolsearch  
    * simil ~~ inform  
    * general =~ verbalcomp + workingmemory + perceptorg'  # the general is a new latent variable, built from other latent variables  
* The updated model will often have the same fit indices (simply shifting parameters from covariances to loadings)  
  
Wrap Up:  
  
* Learned model syntax for lavaan (=~ for latent, ~~ for covariance/correlation, and ~ for prediction)  
* Learned to add constraints and troubleshoot Heywood cases  
* Learned one-factor, multi-factor, and hierarchical models  
  
Example code includes:  
```{r}

IQdata <- readr::read_csv("./RInputFiles/IQdata.csv")
glimpse(IQdata)
IQdata <- IQdata %>%
    select(-X1)
glimpse(IQdata)


#Build a four-factor model
wais.model <- 'verbalcomp =~ vocab + simil + inform + compreh 
workingmemory =~ arith + digspan + lnseq
perceptorg =~ piccomp + block + matrixreason
processing =~ digsym + symbolsearch'

#Analyze the model
wais.fit <- cfa(model=wais.model, data=IQdata)

#Summarize the model
summary(wais.fit, standardized=TRUE, fit.measures=TRUE, rsquare=TRUE)


#Edit the original model
wais.model <- 'verbalcomp =~ vocab + simil + inform + compreh 
workingmemory =~ arith + digspan + lnseq
perceptorg =~ piccomp + block + matrixreason + digsym + symbolsearch'

#Analyze the model
wais.fit <- cfa(model=wais.model, data=IQdata)

#Summarize the model
summary(wais.fit, standardized=TRUE, fit.measures=TRUE, rsquare=TRUE)

#Update the default picture
semPlot::semPaths(object = wais.fit, layout = "tree", rotation = 1, whatLabels = "std", 
                  edge.label.cex = 1, what = "std", edge.color = "black"
                  )

#Examine modification indices 
modificationindices(wais.fit, sort = TRUE)


#Update the three-factor model
wais.model2 <- 'verbalcomp =~ vocab + simil + inform + compreh 
workingmemory =~ arith + digspan + lnseq
perceptorg =~ piccomp + block + matrixreason + digsym + symbolsearch
simil ~~ inform'

#Analyze the three-factor model where data is IQdata
wais.fit2 <- cfa(model=wais.model2, data=IQdata)

#Summarize the three-factor model 
summary(wais.fit2, standardized=TRUE, fit.measures=TRUE, rsquare=TRUE)

#Compare the models
anova(wais.fit, wais.fit2)


#View the fit indices for the original model
fitmeasures(wais.fit, c("aic", "ecvi"))

#View the fit indices for the updated model
fitmeasures(wais.fit2, c("aic", "ecvi"))


#Update the three-factor model to a hierarchical model
wais.model3 <- 'verbalcomp =~ vocab + simil + inform + compreh 
workingmemory =~ arith + digspan + lnseq
perceptorg =~ piccomp + block + matrixreason + digsym + symbolsearch
simil ~~ inform
general =~ verbalcomp + workingmemory + perceptorg'

#Analyze the hierarchical model where data is IQdata
wais.fit3 <- cfa(model = wais.model3, data = IQdata)

#Examine the fit indices for the old model
fitmeasures(wais.fit2, c("rmsea", "srmr"))

#Examine the fit indices for the new model
fitmeasures(wais.fit3, c("rmsea", "srmr"))


#Update the default picture
semPlot::semPaths(object = wais.fit3, layout = "tree", rotation = 1, whatLabels = "std", 
                  edge.label.cex = 1, what = "std", edge.color = "navy"
                  )

```
  
  
  
***
  
###_Working with Data in the Tidyverse_  
  
Chapter 1 - Explore Data  
  
Import data:  
  
* Begging steps of the pipeline include importing, tidying, and transforming (wrangling)  
* Focus of this course will be recatngular data including both columns (variables) and rows (observations)  
	* bakers  # 10x6 tibble  
    * tibbles are a special type of data frame - both store rectangular data in R  
* Can read the data using readr::read_csv()  
	* ?read_csv  
    * bakers <- read_csv("bakers.csv")  
    * bakers  # same 10x6 tibble  
  
Know data:  
  
* The bakeoff data includes three types of challenges - Signature, Technical, Showstopper  
* Tibble printing by default will cut off columns and just show the variables - glimpse from dplyr can help with visualizing  
	* glimpse(bakers_mini)  
    * library(skimr)  
    * skim(bakers_mini)  # skim provides statistics for every column depending on the variable types  
  
Count data - broken video that provides some code snippets:  
  
* bakers %>% distinct(series)  
* bakers %>% count(series)  
* bakers %>% group_by(series) %>% summarize(n = n())  
* bakers %>% count(aired_us, series)  
* bakers %>% count(aired_us, series) %>% mutate(prop_bakers = n/sum(n))  
* bakers %>% group_by(aired_us, series) %>% summarize(n = n()) %>% mutate(prop_bakers = n/sum(n))  
* bakers %>% count(aired_us, series) %>% count(aired_us)  
  
Example code includes:  
```{r}

# Read in "bakeoff.csv" as bakeoff
bakeoff <- readr::read_csv("./RInputFiles/bakeoff.csv")

# Print bakeoff
bakeoff


# Data set above is already OK - UNKNOWN are NA in CSV
# Filter rows where showstopper is UNKNOWN 
bakeoff %>% 
    filter(showstopper == "UNKNOWN")

# Edit to add list of missing values
bakeoff <- read_csv("./RInputFiles/bakeoff.csv", na = c("", "NA", "UNKNOWN"))

# Filter rows where showstopper is NA 
bakeoff %>% 
    filter(is.na(showstopper))


# Edit to filter, group by, and skim
bakeoff %>% 
  filter(!is.na(us_season)) %>% 
  group_by(us_season) %>%
  skimr::skim()
  

bakeoff %>% 
  distinct(result)

# Count rows by distinct results
bakeoff %>% 
  count(result)

# Count whether or not star baker
bakeoff %>% 
  count(result=="SB")


# Count the number of rows by series and episode
bakeoff %>%
  count(series, episode)

# Add second count by series
bakeoff %>% 
  count(series, episode) %>%
  count(series)


# Count the number of rows by series and baker
bakers_by_series <- 
  bakeoff %>%
  count(series, baker)

# Print to view
bakers_by_series

# Count again by series
bakers_by_series %>%
  count(series)

# Count again by baker
bakers_by_series %>%
  count(baker, sort=TRUE)


ggplot(bakeoff, aes(x=episode)) + 
    geom_bar() + 
    facet_wrap(~series)

```
  
  
  
***
  
Chapter 2 - Tame Data  
  
Cast column types:  
  
* Type-casting can be an important step in taming data  
* The readr package has options for col_type within the read_csv() function  
	* By default, all of the column types are guessed from the first 1,000 rows  
    * bakers_raw %>% dplyr::slice(1:4)  # look at the first 4 rows  
* Can convert a character to a number using parse_number()  
	* parse_number("36 years")  # will become 36  
    * bakers_tame <- read_csv(file = "bakers.csv", col_types = cols(age = col_number()) )  # col_number() will wrangle the age column to a numeric  
* Can also use the parse_date capability to manage datetime inputs  
	* parse_date("14 August 2012", format = "%d %B %Y")  
    * bakers <- read_csv("bakers.csv", col_types = cols( last_date_uk = col_date(format = "%d %B %Y") ))  # col_date() will wrangle last_date_uk to a datetime  
* There is always both a parse_* and a col_* for any given data type; can practive with parse_* then use col_* in the read-in  
  
Recode values:  
  
* The recode() function in dplyr can be used to recode values in the data  
	* young_bakers %>% mutate(stu_label = recode(student, `0` = "other", .default = "student"))  # 0 will become other, anything else will become student  
    * young_bakers %>% mutate(stu_label = recode(student, `0` = NA_character_, .default = "student"))  # create NA for a specific string  
    * young_bakers %>% mutate(student = na_if(student, 0))  # na_if will convert to NA if the condition(s) is met  
  
Select variables:  
  
* Can select just a subset of the variables using select  
* The select() function is powerful when you only need to work with a subset of the data  
	* young_bakers2 %>% select(baker, series_winner)  # keep these variables  
    * young_bakers2 %>% select(-technical_winner)  # drop these variables (signalled by the minus sign)  
* Can use helper functions inside the select() call  
	* young_bakers2 %>% select(baker, starts_with("series"))  
    * young_bakers2 %>% select(ends_with("winner"), baker)  
    * young_bakers2 %>% select(contains("bake"))  
* The filter() function works on rows rather than columns  
	* young_bakers2 %>% filter(series_winner == 1 | series_runner_up == 1)  
  
Tame variable names:  
  
* Can rename variables while selecting  
	* young_bakers3 %>% select(baker, tech_1 = tre1)  
    * young_bakers3 %>% select(baker, tech_ = tre1:tre3)  
    * young_bakers3 %>% select(baker, tech_ = starts_with("tr"), result_ = starts_with("rs"))  
* Within the rename call, it is not possible to use the helper functions  
	* young_bakers3 %>% rename(tech_1 = t_first, result_1 = r_first)  # new = old  
    * young_bakers3 %>% select(everything(), tech_ = starts_with("tr"), result_ = starts_with("rs"))  # everything first keeps all the column orders the same  
* Can also use the janitor package to help with cleaning variables  
	* young_bakers3 %>% janitor::clean_names()  
    * Converts to snake case (lower case with underscores)  
  
Example code includes:  
```{r}

# NOTE THAT THIS WILL THROW WARNINGS
# Try to cast technical as a number
desserts <- readr::read_csv("./RInputFiles/desserts.csv",
                      col_types = cols(
                        technical = col_number())
                     )

# View parsing problems
readr::problems(desserts)

# NOTE THAT THIS WILL FIX THE ERRORS
# Edit code to fix the parsing error 
desserts <- readr::read_csv("./RInputFiles/desserts.csv",
                      col_types = cols(
                        technical = col_number()),
                      na = c("", "NA", "N/A") 
                     )

# View parsing problems
readr::problems(desserts)


# Find format to parse uk_airdate 
readr::parse_date("17 August 2010", format = "%d %B %Y")

# Edit to cast uk_airdate
desserts <- readr::read_csv("./RInputFiles/desserts.csv", 
                     na = c("", "NA", "N/A"),
                     col_types = cols(
                       technical = col_number(),
                       uk_airdate = col_date("%d %B %Y")
                     ))

# Print by descending uk_airdate
desserts %>%
  arrange(desc(uk_airdate))


# Cast result a factor
desserts <- readr::read_csv("./RInputFiles/desserts.csv", 
                     na = c("", "NA", "N/A"),
                     col_types = cols(
                       technical = col_number(),
                       uk_airdate = col_date(format = "%d %B %Y"),
                       result = col_factor(levels=NULL)
                     ))
                    
# Glimpse to view
glimpse(desserts)


oldDesserts <- desserts
tempDesserts <- desserts %>%
    gather(key="type_ing", value="status", starts_with(c("showstopper")), starts_with(c("signature"))) %>%
    separate(type_ing, into=c("challenge", "ingredient"), sep="_") %>%
    spread(ingredient, status)
glimpse(tempDesserts)
desserts <- tempDesserts


# Count rows grouping by nut variable
desserts %>%
  count(nut, sort=TRUE)

# Recode filberts as hazelnuts
desserts <- desserts %>% 
  mutate(nut = recode(nut, "filbert" = "hazelnut"))

# Count rows again 
desserts %>% 
    count(nut, sort = TRUE)

# Edit code to recode "no nut" as missing
desserts <- desserts %>% 
  mutate(nut = recode(nut, "filbert" = "hazelnut", 
                           "no nut" = NA_character_))

# Count rows again 
desserts %>% 
    count(nut, sort = TRUE)


# Edit to recode tech_win as factor
desserts <- desserts %>% 
  mutate(tech_win = recode_factor(technical, `1` = 1,
                           .default = 0))

# Count to compare values                      
desserts %>% 
  count(technical == 1, tech_win)


ratings0 <- readr::read_csv("./RInputFiles/02.03_messy_ratings.csv")
str(ratings0, give.attr=FALSE)

ratings <- ratings0 %>%
    filter(series >= 3) %>%
    rename(day=day_of_week) %>%
    mutate(series=factor(series), 
           season_premiere=lubridate::mdy(season_premiere), 
           season_finale=lubridate::mdy(season_finale), 
           viewer_growth = (e10_viewers_7day - e1_viewers_7day)
           ) %>%
    select(-contains("uk_airdate"))


# Recode channel as dummy: bbc (1) or not (0)
ratings <- ratings %>% 
  mutate(bbc = recode_factor(channel, "Channel 4"=0, .default=1))

# Look at the variables to plot next
ratings %>% select(series, channel, bbc, viewer_growth)

# Make a filled bar chart
ggplot(ratings, aes(x = series, y = viewer_growth, fill = bbc)) +
  geom_col()


# Move channel to first column
ratings %>% 
  select(channel, everything())

# Edit to drop 7- and 28-day episode viewer data
ratings %>% 
  select(-ends_with("day"))

# Edit to move channel to first and drop episode viewer data
ratings %>% 
  select(-ends_with("day")) %>%
  select(channel, everything())


# Glimpse messy names
# glimpse(messy_ratings)

# Reformat to lower camelcase
# ratings <- messy_ratings %>%
#   clean_names(case="lower_camel")
    
# Glimpse cleaned names
# glimpse(ratings)

# Reformat to snake case
# ratings <- messy_ratings %>% 
#     clean_names("snake")

# Glimpse cleaned names
# glimpse(ratings)


# Select 7-day viewer data by series
viewers_7day <- ratings %>%
  select(series, contains("7day"))

# Glimpse
glimpse(viewers_7day)

# Adapt code to also rename 7-day viewer data
viewers_7day <- ratings %>% 
    select(series, viewers_7day_ = ends_with("7day"))

# Glimpse
glimpse(viewers_7day)


# Adapt code to drop 28-day columns; move 7-day to front
viewers_7day <- ratings %>% 
    select(viewers_7day_ = ends_with("7day"), everything(), -contains("28day"))

# Glimpse
glimpse(viewers_7day)


# Adapt code to keep original order
viewers_7day <- ratings %>% 
    select(everything(), -ends_with("28day"), viewers_7day_ = ends_with("7day"))

# Glimpse
glimpse(viewers_7day)

```
  
  
  
***
  
Chapter 3 - Tidy Your Data  
  
Introduction to Tidy Data:  
  
* Tidy data helps with producing good plots - allows for faceting and the like  
* Data can be tidy but not tame, and can be tame but not tidy  
	* In general, tidy data is long rather than wide  
    * As a result, tidy data tends to take up more space, but with the advantage of being easier to plot or analyze  
* Can automatically get counts summed to a specific level  
	* juniors_tidy %>% count(baker, wt = correct)  # variable wt will be the sum of correct  
    * ggplot(juniors_tidy, aes(baker, correct)) + geom_col()  # roughly the equivalent if plotting the data  
  
Gather:  
  
* Gathering is the process of converting data from wide to long  
	* gather(data, key, value, .)  
    * key is the new column containing the variable  
    * value is the new column contining the value  
    * The . are the columns to be gathered, with column name going to the key column and associated values going to the value column  
    * The key and value need to be quoted while the . can be passed bare (unquoted)  
  
Separate:  
  
* Sometimes, a column really contains two variable, for example when there is spice_trail or the like  
* The separate function requires at least three arguments  
	* data - the data frame  
    * col - the column that you want to separate (can be a bare variable name since it already exists in the data frame)  
    * into - quoted variables to be created, inside the c() function  
    * By default, the existing column col is replaced  
    * There is also an option for convert=TRUE where it will try to pick the best variable type (especially helpful when creating numbers)  
    * There is also the option for sep, where the defaults for separators can be over-ridden to better match the data  
  
Spread:  
  
* The spread function is designed to convert long data to wide data  
	* Spread can be considered a tool to tidy messy rows, where gather is a tool to tidy messy columns  
    * data - the data frame  
    * key - the key is the column that currently contains what should become the new columns  
    * value - value is the column that currently contains what should become the values in the new columns  
    * convert=TRUE will help with re-casting variable types (particularly helpful when numbers are being pulled out of a mixed character-number column (likely what drove the need to spread)  
  
Tidy multiple sets of data:  
  
* Sometimes, there are multiple data components to tidy, where the columns need to be fixed in several ways  
	* For example, score_1, guess_1, score_2, guess_2  
    * Ideal target would be to have trials (1, 2, 3) in one column, and with columns score and guess containing the variables  
* Example code for converting multiple columns simultaneously  
	* juniors_multi %>% gather(key = "key", value = "value", score_1:guess_3) %>% separate(key, into = c("var", "order"), convert = TRUE)  
    * juniors_multi %>% gather(key = "key", value = "value", score_1:guess_3) %>% separate(key, into = c("var", "order"), convert = TRUE) %>% spread(var, value)  
  
Example code includes:  
```{r}

ratings1 <- readr::read_csv("./RInputFiles/messy_ratings.csv")
oldRatings <- ratings
ratings <- ratings1
ratings1

# Plot of episode 1 viewers by series
ratings %>%
  ggplot(aes(x=series, y=e1)) + 
  geom_bar(stat="identity")
  
# Adapt code to plot episode 2 viewers by series
ggplot(ratings, aes(x = series, y = e2)) +
    geom_col() 


# Gather and count episodes
tidy_ratings <- ratings %>%
    gather(key = "episode", value = "viewers_7day", -series, 
           factor_key = TRUE, na.rm = TRUE) %>% 
    arrange(series, episode) %>% 
    mutate(episode_count = row_number())

# Plot viewers by episode and series
ggplot(tidy_ratings, aes(x = episode_count, y = viewers_7day, fill = as.factor(series))) +
    geom_col()


ratings2 <- readr::read_csv("./RInputFiles/messy_ratings2.csv")
ratings2$series <- as.factor(ratings2$series)
ratings2

# Gather 7-day viewers by episode (ratings2 already loaded)
week_ratings <- ratings2  %>% 
    select(series, ends_with("7day")) %>% 
    gather(episode, viewers_7day, ends_with("7day"), na.rm = TRUE, factor_key = TRUE)
    
# Plot 7-day viewers by episode and series
ggplot(week_ratings, aes(x = episode, y = viewers_7day, group = series)) +
    geom_line() +
    facet_wrap(~series)


# Edit to parse episode number
week_ratings <- ratings2 %>% 
    select(series, ends_with("7day")) %>% 
    gather(episode, viewers_7day, ends_with("7day"), na.rm = TRUE) %>% 
    separate(episode, into = "episode", extra = "drop") %>% 
    mutate(episode = parse_number(episode))
    
# Edit your code to color by series and add a theme
ggplot(week_ratings, aes(x = episode, y = viewers_7day, 
                         group = series, color = series)) +
    geom_line() +
    facet_wrap(~series) +
    guides(color = FALSE) +
    theme_minimal() 


week_ratings_dec <- week_ratings %>%
    mutate(viewers_7day=as.character(viewers_7day)) %>%
    separate(viewers_7day, into=c("viewers_millions", "viewers_decimal"), sep="\\.") %>%
    mutate(viewers_decimal=ifelse(is.na(viewers_decimal), ".", paste0(".", viewers_decimal))) %>%
    dplyr::arrange(series, episode)

# Unite series and episode
ratings3 <- week_ratings_dec %>% 
    unite("viewers_7day", viewers_millions, viewers_decimal)

# Print to view
ratings3


# Adapt to change the separator
ratings3 <- week_ratings_dec  %>% 
    unite(viewers_7day, viewers_millions, viewers_decimal, sep="")

# Print to view
ratings3


# Adapt to cast viewers as a number
ratings3 <- week_ratings_dec  %>% 
    unite(viewers_7day, viewers_millions, viewers_decimal, sep="") %>%
    mutate(viewers_7day = parse_number(viewers_7day))

# Print to view
ratings3


# Create tidy data with 7- and 28-day viewers
tidy_ratings_all <- ratings2 %>%
    gather(episode, viewers, ends_with("day"), na.rm = TRUE) %>% 
    separate(episode, into = c("episode", "days")) %>%  
    mutate(episode = parse_number(episode),
           days = parse_number(days)) 

# Adapt to spread counted values
tidy_ratings_all %>% 
    count(series, days, wt = viewers) %>%
    spread(key=days, value=n, sep="_")

# Fill in blanks to get premiere/finale data
tidy_ratings <- ratings %>%
    gather(episode, viewers, -series, na.rm = TRUE) %>%
    mutate(episode = parse_number(episode)) %>% 
    group_by(series) %>% 
    filter(episode == 1 | episode == max(episode)) %>% 
    ungroup()


# Recode first/last episodes
first_last <- tidy_ratings %>% 
  mutate(episode = recode(episode, `1` = "first", .default = "last")) 

# Fill in to make slope chart
ggplot(first_last, aes(x = episode, y = viewers, color = as.factor(series))) +
  geom_point() +
  geom_line(aes(group = series))

# Switch the variables mapping x-axis and color
ggplot(first_last, aes(x = series, y = viewers, color = episode)) +
  geom_point() + # keep
  geom_line(aes(group = series)) + # keep
  coord_flip() # keep

# Calculate relative increase in viewers
bump_by_series <- first_last %>% 
  spread(episode, viewers) %>%   
  mutate(bump = (last - first) / first)
  
# Fill in to make bar chart of bumps by series
ggplot(bump_by_series, aes(x = series, y = bump)) +
  geom_col() +
  scale_y_continuous(labels = scales::percent) # converts to %

```
  
  
  
***
  
Chapter 4 - Transform Your Data  
  
Complex recoding with case_when:  
  
* The case_when function allow for vectoizing multiple if-else-then statements  
	* The LHS must give (or be) a boolean  
    * The default value for else is NA  
* Example using ages of the baker data  
	* bakers %>% mutate(gen = if_else(between(birth_year, 1981, 1996), "millenial", "not millenial"))  # simple if statement (boundaries of between are inclusive)  
    * bakers %>% mutate(gen = case_when( between(birth_year, 1965, 1980) ~ "gen_x", between(birth_year, 1981, 1996) ~ "millenial" ))  # logical ~ result  
    * bakers %>% mutate(gen = case_when( between(birth_year, 1928, 1945) ~ "silent", between(birth_year, 1946, 1964) ~ "boomer", between(birth_year, 1965, 1980) ~ "gen_x", between(birth_year, 1981, 1996) ~ "millenial", TRUE ~ "gen_z" ))  
    * bakers %>% count(gen, sort = TRUE) %>% mutate(prop = n / sum(n))  
  
Factors:  
  
* The forcats package is made specifically for working with factors - all functions start with fct_  
* Converting to factors helps ensure the proper ordering of the data  
	* ggplot(bakers, aes(x = fct_rev(fct_infreq(gen)))) + geom_bar()  # reverse by infrequency (build from small to large)  # on-the-fly conversions inside ggplot  
    * bakers <- bakers %>% mutate(gen = fct_relevel(gen, "silent", "boomer", "gen_x", "millenial", "gen_z"))  # conversions of the raw dataset  
    * bakers %>% dplyr::pull(gen) %>% levels()  # check that this worked  
    * ggplot(bakers, aes(x = gen)) + geom_bar()  # will now be plotted in the desired order  
* Need to be careful of the proper treatment of factors  
	* ggplot(bakers, aes(x = gen, fill = series_winner)) + geom_bar()  # FAIL  
    * bakers <- bakers %>% mutate(series_winner = as.factor(series_winner))  
    * ggplot(bakers, aes(x = gen, fill = series_winner)) + geom_bar()  # WORKS  
    * ggplot(bakers, aes(x = gen, fill = as.factor(series_winner))) + geom_bar()  # ALSO WORKS  
  
Dates:  
  
* Can use lubridate for convenience functions such as ymd() or dmy(), with the output being ISO (YYYY-MM-DD)  
	* Can also include a vector of suspected dates  
    * dmy("17 August 2010")  # will work  
    * hosts <- tibble::tribble( ~host, ~bday, ~premiere, "Mary", "24 March 1935", "August 17th, 2010", "Paul", "1 March 1966", "August 17th, 2010")  
    * hosts <- hosts %>% mutate(bday = dmy(bday), premiere = mdy(premiere))  
* There are three aspects of timespans  
	* interval - time span bound by two real dates  
    * duration - exact number of seconds in an interval  
    * period - change in clock time of an interval  
    * hosts <- hosts %>% mutate(age_int = interval(bday, premiere))  # new variable age_int will be of type interval  
    * hosts %>% mutate(years_decimal = age_int / years(1), years_whole = age_int %/% years(1))  # years(1) is one year, so this is fractional and whole (floored) years  
  
Strings:  
  
* The separate function splits one column in to 2+ columns (for example "age, job" could become "age" and "job")  
	* series5 <- series5 %>% separate(about, into = c("age", "occupation"), sep = ", ")  
    * series5 <- series5 %>% separate(about, into = c("age", "occupation"), sep = ", ") %>% mutate(age = parse_number(age))  # numeric age. Dropping years  
* The stringr package makes working with strings in R easier (typically used within a mutate) - all functions start with str_  
	* series5 <- series5 %>% mutate(baker = str_to_upper(baker), showstopper = str_to_lower(showstopper))  
    * series5 %>% mutate(pie = str_detect(showstopper, "pie"))  # returns a boolean  
    * series5 %>% mutate(showstopper = str_replace(showstopper, "pie", "tart"))  # find and replace for strings  
    * series5 %>% mutate(showstopper = str_remove(showstopper, "pie"))  # remove "pie", though there may be trailing whitespace  
    * series5 %>% mutate(showstopper = str_remove(showstopper, "pie"), showstopper = str_trim(showstopper))  # trim whitespace at the beginning or end  
  
Final thoughts:  
  
* R using the tidyverse for analysis and presentation  
* Reading data using readr and analyzing using dplyr and ggplot2  
* Taming variable types, names, and values  
* Transforming data using stringr and lubridate  
* The "here" package can make working with file paths much easier  
  
Example code includes:  
```{r}

baker_results <- readr::read_csv("./RInputFiles/baker_results.csv")
messy_baker_results <- readr::read_csv("./RInputFiles/messy_baker_results.csv")
bakers <- baker_results
glimpse(bakers)


# Create skill variable with 3 levels
bakers <- bakers %>% 
  mutate(skill = case_when(
    star_baker > technical_winner ~ "super_star",
    star_baker < technical_winner ~ "high_tech",
    TRUE ~ "well_rounded"
  ))
  
# Filter zeroes to examine skill variable
bakers %>% 
  filter(star_baker==0 & technical_winner==0) %>% 
  count(skill)


# Add pipe to drop skill = NA
bakers_skill <- bakers %>% 
  mutate(skill = case_when(
    star_baker > technical_winner ~ "super_star",
    star_baker < technical_winner ~ "high_tech",
    star_baker == 0 & technical_winner == 0 ~ NA_character_,
    star_baker == technical_winner  ~ "well_rounded"
  )) %>% 
  drop_na(skill)
  
# Count bakers by skill
bakers_skill %>%
  count(skill)


# Cast skill as a factor
bakers <- bakers %>% 
  mutate(skill = as.factor(skill))

# Examine levels
bakers %>%
  pull(skill) %>%
  levels()


baker_dates <- bakers %>%
    select(series, baker, contains("date")) %>%
    mutate(last_date_appeared_us=as.character(last_date_us), 
           first_date_appeared_us=as.character(first_date_us)
           ) %>%
    rename(first_date_appeared_uk=first_date_appeared, last_date_appeared_uk=last_date_appeared) %>%
    select(-last_date_us, -first_date_us)
glimpse(baker_dates)


# Add a line to extract labeled month
baker_dates <- baker_dates %>% 
  mutate(last_date_appeared_us=lubridate::ymd(last_date_appeared_us), 
         last_month_us=lubridate::month(last_date_appeared_us, label=TRUE)
         )
         
ggplot(baker_dates, aes(x=last_month_us)) + geom_bar()


baker_time <- baker_dates %>%
    mutate(first_date_appeared_us=lubridate::ymd(first_date_appeared_us)) %>%
    select(-last_month_us)
glimpse(baker_time)

           
# Add a line to create whole months on air variable
baker_time <- baker_time  %>% 
  mutate(time_on_air = lubridate::interval(first_date_appeared_uk, last_date_appeared_uk),
         weeks_on_air = time_on_air / lubridate::weeks(1), 
         months_on_air = time_on_air %/% months(1)
         )

# Count rows
messy_baker_results %>% 
  count(position_reached)


# Add another mutate to replace "THIRD PLACE" with "RUNNER UP"and count
messy_baker_results <- messy_baker_results %>% 
  mutate(position_reached = str_to_upper(position_reached),
         position_reached = str_replace(position_reached, "-", " "), 
         position_reached = str_replace(position_reached, "THIRD PLACE", "RUNNER UP"))

# Count rows
messy_baker_results %>% 
  count(position_reached)


# Add a line to create new variable called student
bakers <- bakers %>% 
    mutate(occupation = str_to_lower(occupation), 
           student=str_detect(occupation, "student")
           )

# Find all students and examine occupations
bakers %>% 
  filter(student) %>%
  select(baker, occupation, student)

```
  
  
  
***
  
###_Modeling Data in the Tidyverse_  
  
Chapter 1 - Introduction to Modeling  
  
Background on modeling for explanation:  
  
* Generally, the model has y as a function of x plus epsilon, where y is the outcome of interest and x is a set of explanatory variables and epsilon is irreducible error  
	* The x can be either explanatory or predictive - depends on the purpose of the analysis  
* Example of explanation - can differences in teacher evaluation scores be explained by teacher attributes  
	* library(dplyr)  
    * library(moderndive)  
    * glimpse(evals)  # evals data is available in the moderndivw package (From the moderndive package for ModernDive.com:)  
    * ggplot(evals, aes(x = score)) + geom_histogram(binwidth = 0.25) + labs(x = "teaching score", y = "count")  # EDA on scores using histogram  
    * evals %>% summarize(mean_score = mean(score), median_score = median(score), sd_score = sd(score))  # summary statistics using dplyr::summarize  
  
Background on modeling for prediction:  
  
* House sales in King County USA in 2014-2015 (from Kaggle) based on features such as size, bedrooms, etc.  
	* glimpse(house_prices)  
    * ggplot(house_prices, aes(x = price)) + geom_histogram() + labs(x = "house price", y = "count")  
    * house_prices <- house_prices %>% mutate(log10_price = log10(price))  
    * house_prices %>% select(price, log10_price)  
    * ggplot(house_prices, aes(x = log10_price)) + geom_histogram() + labs(x = "log10 house price", y = "count")  # after transformation  
  
Modeling problem for explanation:  
  
* Typically, both the function that relates x and y and the function that generates the errors is unknwon  
	* Goal is to create a model that can generate y-hat by separating signal from noise  
* Can start by considering linear models, assessed as a starting point by examining a scatter plot  
	* ggplot(evals, aes(x = age, y = score)) + geom_point() + labs(x = "age", y = "score", title = "Teaching score over age")  
    * ggplot(evals, aes(x = age, y = score)) + geom_jitter() + labs(x = "age", y = "score", title = "Teaching score over age (jittered)")  
* Can further explore the data by looking at correlations among some or all of the potential explanatory variables  
	* evals %>% summarize(correlation = cor(score, age))  
  
Modeling problem for prediction:  
  
* For explanation, we care about the form of the function  
* For prediction, we care mainly that the function makes good predictions (even if it may not be easy to explain)  
	* house_prices %>% select(log10_price, condition) %>% glimpse()  # condition is a categorical variable saved as a factor  
    * ggplot(house_prices, aes(x = condition, y = log10_price)) + geom_boxplot() + labs(x = "house condition", y = "log10 price", title = "log10 house price over condition")  
* Means tend to be at the center of the linear modeling process  
	* house_prices %>% group_by(condition) %>% summarize(mean = mean(log10_price), sd = sd(log10_price), n = n())  
  
Example code includes:  
```{r}

data(evals, package="moderndive")
glimpse(evals)


# Plot the histogram
ggplot(evals, aes(x = age)) +
  geom_histogram(binwidth = 5) +
  labs(x = "age", y = "count")

# Compute summary stats
evals %>%
  summarize(mean_age = mean(age),
            median_age = median(age),
            sd_age = sd(age))


data(house_prices, package="moderndive")
glimpse(house_prices)


# Plot the histogram
ggplot(house_prices, aes(x = sqft_living)) +
  geom_histogram() +
  labs(x="Size (sq.feet)", y="count")

# Add log10_sqft_living
house_prices_2 <- house_prices %>%
  mutate(log10_sqft_living = log10(sqft_living))

# Plot the histogram  
ggplot(house_prices_2, aes(x = log10_sqft_living)) +
  geom_histogram() +
  labs(x = "log10 size", y = "count")


# Plot the histogram
ggplot(evals, aes(x=bty_avg)) +
  geom_histogram(binwidth=0.5) +
  labs(x = "Beauty score", y = "count")

# Scatterplot
ggplot(evals, aes(x = bty_avg, y = score)) +
  geom_point() +
  labs(x = "beauty score", y = "teaching score")

# Jitter plot
ggplot(evals, aes(x = bty_avg, y = score)) +
  geom_jitter() +
  labs(x = "beauty score", y = "teaching score")


# Compute correlation
evals %>%
  summarize(correlation = cor(score, bty_avg))


house_prices <- house_prices %>%
    mutate(log10_price=log10(price))

# View the structure of log10_price and waterfront
house_prices %>%
  select(log10_price, waterfront) %>%
  glimpse()

# Plot 
ggplot(house_prices, aes(x = waterfront, y = log10_price)) +
  geom_boxplot() +
  labs(x = "waterfront", y = "log10 price")


# Calculate stats
house_prices %>%
  group_by(waterfront) %>%
  summarize(mean_log10_price = mean(log10_price), n = n())
  
# Prediction of price for houses with view
10^(6.12)

# Prediction of price for houses without view
10^(5.66)

```
  
  
  
***
  
Chapter 2 - Modeling with Regression  
  
Explaining teaching score with age:  
  
* Can overlay a regression line to the scatter plot for a bivariate relationship  
	* ggplot(evals, aes(x = age, y = score)) + geom_point() + labs(x = "age", y = "score", title = "Teaching score over age") + geom_smooth(method = "lm", se = FALSE)  
* In simple linear regression, the assumption is that f(x) is B0 + B1*x  
    * The fitted model f-hat does not have an error term, since it is just the model prediction for a given value of x  
    * model_score_1 <- lm(score ~ age, data = evals)  
    * moderndive::get_regression_table(model_score_1)  
  
Predicting teaching score using age:  
  
* Can make predictions based on the existing regression line - f-hat can be used for both explanatory and predictive purposes  
* The residuals are the errors (predictive vs. actual values), and correspond to the epsilon of the general modeling framework  
    * On average, for linear regression, the residuals should average out to zero  
    * get_regression_points(model_score_1)  # gives y, x, y-hat, and residuals  
  
Explaining teaching score with gender:  
  
* Can extend the models to include categorical data, such as gender  
	* ggplot(evals, aes(x = score)) + geom_histogram(binwidth = 0.25) + facet_wrap(~gender) + labs(x = "score", y = "count")  
    * model_score_3 <- lm(score ~ gender, data = evals)  # will just give an overall mean and a change in mean vs. the first-level factor  
* Can also look at multi-level factors, such as rank (teacher type)  
	* evals %>% group_by(rank) %>% summarize(n = n())  
  
Predicting teaching score with gender:  
  
* Can use group means as part of the predictive approach - if only factor are used in the regression, there will be the same prediction for everyone who is in the same class(es)  
	* model_score_3_points <- get_regression_points(model_score_3)  
  
Example code includes:  
```{r}

# Plot 
ggplot(evals, aes(x = bty_avg, y = score)) +
  geom_point() +
  labs(x = "beauty score", y = "score") +
  geom_smooth(method = "lm", se = FALSE)

# Fit model
model_score_2 <- lm(score ~ bty_avg, data = evals)

# Output content
model_score_2

# Output regression table
moderndive::get_regression_table(model_score_2)

# Use fitted intercept and slope to get a prediction
y_hat <- 3.88 + 0.067 * 5
y_hat

# Compute residual y - y_hat
4.7 - y_hat


# Get regression table
moderndive::get_regression_table(model_score_2, digits = 5)

# Get all fitted/predicted values and residuals
moderndive::get_regression_points(model_score_2)

# Get all fitted/predicted values and residuals
moderndive::get_regression_points(model_score_2) %>% 
  mutate(score_hat_2 = 3.88 + 0.0666 * bty_avg)

# Get all fitted/predicted values and residuals
moderndive::get_regression_points(model_score_2) %>% 
  mutate(residual_2 = score - score_hat)


ggplot(evals, aes(x=rank, y=score)) +
  geom_boxplot() +
  labs(x = "rank", y = "score")

evals %>%
  group_by(rank) %>%
  summarize(n = n(), mean_score = mean(score), sd_score = sd(score))


# Fit regression model
model_score_4 <- lm(score ~ rank, data = evals)

# Get regression table
moderndive::get_regression_table(model_score_4, digits = 5)

# teaching mean
teaching_mean <- 4.28

# tenure track mean
tenure_track_mean <- 4.28-0.13 

# tenure mean
tenure_mean <- 4.28-0.145


# Calculate predictions and residuals
model_score_4_points <- moderndive::get_regression_points(model_score_4)
model_score_4_points

# Plot residuals
ggplot(model_score_4_points, aes(x=residual)) +
  geom_histogram() +
  labs(x = "residuals", title = "Residuals from score ~ rank model")

```
  
  
  
***
  
Chapter 3 - Modeling with Multiple Regression  
  
Explaining house price with year and size:  
  
* Can incorporate 2+ explanatory / predictive variable using multiple regression  
	* house_prices %>% select(price, sqft_living, condition, waterfront) %>% glimpse()  
    * The log-10 transformation is helpful for this specific dataset (assume the code below for future examples in this course)  
    * house_prices <- house_prices %>% mutate( log10_price = log10(price), log10_sqft_living = log10(sqft_living) )  
* Exploring the relationship between mutliple variables - EDA and regression  
	* Can create a 3D plot with associated regression plane using plotly  
    * model_price_1 <- lm(log10_price ~ log10_sqft_living + yr_built, data = house_prices)  
    * get_regression_table(model_price_1, digits = 5))  
  
Predicting house price using year and size:  
  
* Can get the fitted values and exponentiate as needed, assessing the overall fit or lack thereof (sum-squared residuals) of the model  
	* get_regression_points(model_price_1, digits = 5)  
    * get_regression_points(model_price_1) %>% mutate(sq_residuals = residual^2) %>% summarize(sum_sq_residuals = sum(squared_residuals))  # SSR  
  
Explaining house price with size and condition:  
  
* The EDA from previous chapters is repeated  
	* house_prices <- house_prices %>% mutate( log10_price = log10(price), log10_sqft_living = log10(sqft_living) )  
    * house_prices %>% group_by(condition) %>% summarize(mean = mean(log10_price), sd = sd(log10_price), n = n())  
* The parallel slopes model is lines where the slopes are the same but they have a different intercept (likely, coefficients of a categorical variable)  
	* model_price_3 <- lm(log10_price ~ log10_sqft_living + condition, data = house_prices)  
    * get_regression_table(model_price_3, digits = 5)  
  
Predicting house price using size and condition:  
  
* Objective is to predict on new data (as opposed to checking our predictions on data where we already had the answer)  
	* model_price_3 <- lm(log10_price ~ log10_sqft_living + condition, data = house_prices)  
    * get_regression_table(model_price_3)  
* Automating the housing price prediction process  
	* new_houses <- read_csv("new_houses.csv")  
    * new_houses  
    * get_regression_points(model_price_3, newdata = new_houses)  # moderndata form of predict() function  
    * get_regression_points(model_price_3, newdata = new_houses) %>% mutate(price_hat = 10^log10_price_hat)  
  
Example code includes:  
```{r}

# Create scatterplot with regression line
ggplot(house_prices, aes(x=bedrooms, y = log10_price)) +
  geom_point() +
  labs(x = "Number of bedrooms", y = "log10 price") +
  geom_smooth(method = "lm", se = FALSE)

# Remove outlier
house_prices_transform <- house_prices %>%
    filter(bedrooms < 33) %>%
    mutate(log10_sqft_living=log10(sqft_living))

# Create scatterplot with regression line
ggplot(house_prices_transform, aes(x = bedrooms, y = log10_price)) +
  geom_point() +
  labs(x = "Number of bedrooms", y = "log10 price") +
  geom_smooth(method = "lm", se = FALSE)


# Fit model
model_price_2 <- lm(log10_price ~ log10_sqft_living + bedrooms, data = house_prices_transform)

# Get regression table
moderndive::get_regression_table(model_price_2)

# Make prediction in log10 dollars
2.69 + 0.941 * log10(1000) - 0.033 * 3

# Make prediction dollars
10**(2.69 + 0.941 * log10(1000) - 0.033 * 3)

# Automate prediction and residual computation
moderndive::get_regression_points(model_price_2) %>%
    mutate(squared_residuals = residual**2) %>%
    summarize(sum_squared_residuals = sum(squared_residuals))


# Fit model
model_price_4 <- lm(log10_price ~ log10_sqft_living + waterfront, data = house_prices_transform)

# Get regression table
moderndive::get_regression_table(model_price_4)

# Prediction for House A
10**(2.96 + 0.825*2.9 + 0.322)

# Prediction for House B
10**(2.96 + 0.825*3.1 + 0)


# View the "new" houses
new_houses_2 <- tibble(log10_sqft_living=c(2.9, 3.1), waterfront=c(TRUE, FALSE))
new_houses_2

# Get predictions price_hat in dollars on "new" houses
moderndive::get_regression_points(model_price_4, newdata = new_houses_2) %>% 
  mutate(price_hat = 10**log10_price_hat)

```
  
  
  
***
  
Chapter 4 - Model Selection and Assessment  
  
Model selection and assessment:  
  
* Can use multiple models for the same data and compare  
	* model_price_1 <- lm(log10_price ~ log10_sqft_living + yr_built, data = house_prices)  
    * model_price_3 <- lm(log10_price ~ log10_sqft_living + condition, data = house_prices)  
    * get_regression_points(model_price_1) %>% mutate(sq_residuals = residual^2) %>% summarize(sum_sq_residuals = sum(sq_residuals))  
    * get_regression_points(model_price_3) %>% mutate(sq_residuals = residual^2) %>% summarize(sum_sq_residuals = sum(sq_residuals))  
  
Assessing model fit with R-squared:  
  
* The R-squared is a reasonable measure of model fit - R-squared = 1 - Var(Residuals) / Var(Y)  
	* Larger R-squared is suggestive of better fit, with values (typically) constrained between 0 and 1  
    * R-squared is the proportion of variation in the outcome model that can be explained using the model  
    * model_price_1 <- lm(log10_price ~ log10_sqft_living + yr_built, data = house_prices)  
    * get_regression_points(model_price_1) %>% summarize(r_squared = 1 - var(residual) / var(log10_price))  
    * model_price_3 <- lm(log10_price ~ log10_sqft_living + condition, data = house_prices)  
    * get_regression_points(model_price_3) %>% summarize(r_squared = 1 - var(residual) / var(log10_price))  
  
Assessing predictions with RMSE:  
  
* RMSE (Root Mean Squared Error) is a slight variation on RSS  
	* Where RSS is the sum-squared of the residuals, RMSE is the square root of the average of the residuals-squared  
    * model_price_1 <- lm(log10_price ~ log10_sqft_living + yr_built, data = house_prices)   
    * get_regression_points(model_price_1) %>% mutate(sq_residuals = residual^2) %>% summarize(sum_sq_residuals = sum(sq_residuals))  
    * get_regression_points(model_price_1) %>% mutate(sq_residuals = residual^2) %>% summarize(mse = mean(sq_residuals))  
    * get_regression_points(model_price_1) %>% mutate(sq_residuals = residual^2) %>% summarize(mse = mean(sq_residuals)) %>% mutate(rmse = sqrt(mse))  
* Cannot calculate RMSE on new data - predictions means that we do not know the actual values  
	* get_regression_points(model_price_3, newdata = new_houses) %>% mutate(sq_residuals = residual^2) %>% summarize(mse = mean(sq_residuals)) %>% mutate(rmse = sqrt(mse))  
    * The above code will crash out, since the residuals do not exist  
  
Validation set prediction framework:  
  
* Use two different datasets for modeling; a training set used for modeling, and a test set used for assessing likely out-of-sample errors  
	* house_prices_shuffled <- house_prices %>% sample_frac(size = 1, replace = FALSE)  # Randomly shuffle order of rows  
    * train <- house_prices_shuffled %>% slice(1:10000)  
    * test <- house_prices_shuffled %>% slice(10001:21613)  
    * train_model_price_1 <- lm(log10_price ~ log10_sqft_living + yr_built, data = train)  
* After having trained the model on the train data, can assess the fit using the test data  
	* get_regression_points(train_model_price_1, newdata = test)  
    * get_regression_points(train_model_price_1, newdata = test) %>% mutate(sq_residuals = residual^2) %>% summarize(rmse = sqrt(mean(sq_residuals)))  
  
Next steps:  
  
* Tidyverse ties together many of the packages that help with data wrangling and analysis  
* Can extend regressions to areas like polynomials and trees  
* "ModernDive" is a textbook on the tidyverse tools  
  
Example code includes:  
```{r}

# Model 2
model_price_2 <- lm(log10_price ~ log10_sqft_living + bedrooms, data = house_prices_transform)

# Calculate squared residuals
moderndive::get_regression_points(model_price_2) %>% 
    mutate(sq_residuals=residual**2) %>% 
    summarize(sum_sq_residuals=sum(sq_residuals))

# Model 4
model_price_4 <- lm(log10_price ~ log10_sqft_living + waterfront, data = house_prices_transform)

# Calculate squared residuals
moderndive::get_regression_points(model_price_4) %>% 
    mutate(sq_residuals = residual**2) %>% 
    summarize(sum_sq_residuals=sum(sq_residuals))


# Get fitted/values & residuals, compute R^2 using residuals
moderndive::get_regression_points(model_price_2) %>% 
    summarize(r_squared = 1 - var(residual) / var(log10_price))

# Get fitted/values & residuals, compute R^2 using residuals
moderndive::get_regression_points(model_price_4) %>% 
    summarize(r_squared = 1 - var(residual) / var(log10_price))


# Get all residuals, square them, take the mean and square root
moderndive::get_regression_points(model_price_2) %>% 
    mutate(sq_residuals = residual^2) %>% 
    summarize(mse = mean(sq_residuals)) %>% 
    mutate(rmse = sqrt(mse))

# MSE and RMSE for model_price_2
moderndive::get_regression_points(model_price_2) %>% 
    mutate(sq_residuals = residual^2) %>% 
    summarize(mse = mean(sq_residuals), rmse = sqrt(mean(sq_residuals)))

# MSE and RMSE for model_price_4
moderndive::get_regression_points(model_price_4) %>% 
    mutate(sq_residuals = residual^2) %>% 
    summarize(mse = mean(sq_residuals), rmse = sqrt(mean(sq_residuals)))


# Set random number generator seed value for reproducibility
set.seed(76)

# Randomly reorder the rows
house_prices_shuffled <- house_prices_transform %>% 
    sample_frac(size = 1, replace = FALSE)

# Train/test split
train <- house_prices_shuffled %>% 
    slice(1:10000)
test <- house_prices_shuffled %>% 
    slice(10001:nrow(.))

# Fit model to training set
train_model_2 <- lm(log10_price ~ log10_sqft_living + bedrooms, data=train)


# Compute RMSE (train)
moderndive::get_regression_points(train_model_2) %>% 
    mutate(sq_residuals = residual**2) %>% 
    summarize(rmse = sqrt(mean(sq_residuals)))

# Compute RMSE (test)
moderndive::get_regression_points(train_model_2, newdata = test) %>% 
    mutate(sq_residuals = residual**2) %>% 
    summarize(rmse = sqrt(mean(sq_residuals)))

```
  
  
  
***
  
###_Analyzing Survey Data in R_  
  
Chapter 1 - Introduction to Survey Data  

What are survey weights?  
  
* Survey weights sometimes appear inside a dataset, to reflect potential over/under sampling  
	* Survey weights result from a complex survey design - number of points in the population represented by each entry in the sampling frame  
    * For example, average income would be the sum-product of weights and incomes divided by the sum of weights  
  
Specifying elements of the design in R:  
  
* Simple random sampling is when every member of the population is known and had an equal chance of being selected  
	* library(survey)  
    * srs_design <- svydesign(data = paSample, weights = ~wts, fpc=~N, id=~1)  # the ~ means that these are column names  
* Stratified sampling is when a simple random sample is taken from each of the strata (sub-units)  
	* For example, taking 100 people from every county in a state, so that county-level averages can be gathered  
    * stratified_design <- svydesign(data = paSample, id = ~1, weights = ~wts, strata = ~county, fpc = ~N)  
* Cluster sampling is when the population are grouped in to clusters, with a simple random sample of clusters selected, and with simple random samples taken within each selected cluster  
	* cluster_design <- svydesign(data = paSample, id = ~county + personid, fpc = ~N1 + N2, weights = ~wts) 
  
Visualizing impact of survey weights:  
  
* NHANES data - assessment of health of persons in the US, derived by a health check in a mobile doctor's office  
	* Stage 0 - stratified by geography and proportion minority  
    * Stage 1 - within strata, counties randomly selected (selection likelihood proportional to population)  
    * Stage 2 - within counties, city blocks randomly selected (selection likelihood proportional to population)  
    * Stage 3 - within city blocks, households randomly selected (based on demographics)  
    * Stage 4 - within households, people randomly selected  
* NHANES data are availabl through a package in R  
	* library(NHANES)  
    * dim(NHANESraw)  
    * summarize(NHANESraw, N_hat = sum(WTMEC2YR))  # sums to double the US population, due to having 4 years of data when desiring only 2 years of data  
    * NHANESraw <- mutate(NHANESraw, WTMEC4YR = WTMEC2YR/2)  # fix the double population issue  
    * NHANES_design <- svydesign(data = NHANESraw, strata = ~SDMVSTRA, id = ~SDMVPSU, nest = TRUE, weights = ~WTMEC4YR)  # id is the cluster (first-level), nest=TRUE is due to id being nested within strata (???)  
    * distinct(NHANESraw, SDMVPSU)  # only takes 3 values, since only 1-3 counties are selected  
  
Example code includes:  
```{r}

colTypes <- "FINLWT21 numeric _ FINCBTAX integer _ BLS_URBN integer _ POPSIZE integer _ EDUC_REF character _ EDUCA2 character _ AGE_REF integer _ AGE2 character _ SEX_REF integer _ SEX2 integer _ REF_RACE integer _ RACE2 integer _ HISP_REF integer _ HISP2 integer _ FAM_TYPE integer _ MARITAL1 integer _ REGION integer _ SMSASTAT integer _ HIGH_EDU character _ EHOUSNGC numeric _ TOTEXPCQ numeric _ FOODCQ numeric _ TRANSCQ numeric _ HEALTHCQ numeric _ ENTERTCQ numeric _ EDUCACQ integer _ TOBACCCQ numeric _ STUDFINX character _ IRAX character _ CUTENURE integer _ FAM_SIZE integer _ VEHQ integer _ ROOMSQ character _ INC_HRS1 character _ INC_HRS2 character _ EARNCOMP integer _ NO_EARNR integer _ OCCUCOD1 character _ OCCUCOD2 character _ STATE character _ DIVISION integer _ TOTXEST integer _ CREDFINX character _ CREDITB integer _ CREDITX character _ BUILDING character _ ST_HOUS integer _ INT_PHON character _ INT_HOME character _ "

ce <- readr::read_csv("./RInputFiles/ce.csv")
glimpse(ce)
ceColTypes <- ""
for (x in names(ce)) { ceColTypes <- paste0(ceColTypes, x, " ", class(ce[, x, drop=TRUE]), " _ ") }
all.equal(colTypes, ceColTypes)

# Construct a histogram of the weights
ggplot(data = ce, mapping = aes(x = FINLWT21)) +
    geom_histogram()

# In the next few exercises we will practice specifying sampling designs using different samples from the api dataset, located in the survey package
# The api dataset contains the Academic Performance Index and demographic information for schools in California
# The apisrs dataset is a simple random sample of schools from the api dataset
# Notice that pw contains the survey weights and fpc contains the total number of schools in the population

data(api, package="survey")
library(survey)

# Look at the apisrs dataset
glimpse(apisrs)

# Specify a simple random sampling for apisrs
apisrs_design <- svydesign(data = apisrs, weights = ~pw, fpc = ~fpc, id = ~1)

# Print a summary of the design
summary(apisrs_design)


# Now let's practice specifying a stratified sampling design, using the dataset apistrat
# The schools are stratified based on the school type stype where E = Elementary, M = Middle, and H = High School
# For each school type, a simple random sample of schools was taken

# Glimpse the data
glimpse(apistrat)

# Summarize strata sample sizes
apistrat %>%
  count(stype)

# Specify the design
strat_design <- svydesign(data = apistrat, weights = ~pw, fpc = ~fpc, id = ~1, strata = ~stype)

# Look at the summary information for the stratified design
summary(strat_design)


# Now let's practice specifying a cluster sampling design, using the dataset apiclus2
# The schools were clustered based on school districts, dnum
# Within a sampled school district, 5 schools were randomly selected for the sample
# The schools are denoted by snum
# The number of districts is given by fpc1 and the number of schools in the sampled districts is given by fpc2

# Glimpse the data
glimpse(apiclus2)

# Specify the design
apiclus_design <- svydesign(id = ~dnum + snum, data = apiclus2, weights = ~pw, fpc = ~fpc1 + fpc2)

#Look at the summary information stored for both designs
summary(apiclus_design)


# Construct histogram of pw
ggplot(data = apisrs, mapping = aes(x = pw)) + 
    geom_histogram()

# Construct histogram of pw
ggplot(data = apistrat, mapping = aes(x = pw)) + 
    geom_histogram()

# Construct histogram of pw
ggplot(data = apiclus2, mapping = aes(x = pw)) + 
    geom_histogram()



NHANESraw <- read.csv("./RInputFiles/NHANESraw.txt")
NHANESraw <- NHANESraw %>%
    mutate(WTMEC4YR=WTMEC2YR / 2)
names(NHANESraw)[1] <- "SurveyYr"
glimpse(NHANESraw)

#Create table of average survey weights by race
tab_weights <- NHANESraw %>%
  group_by(Race1) %>%
  summarize(avg_wt = mean(WTMEC4YR))

#Print the table
tab_weights


# The two important design variables in NHANESraw are SDMVSTRA, which contains the strata assignment for each unit, and SDMVPSU, which contains the cluster id within a given stratum
# Specify the NHANES design
NHANES_design <- svydesign(data = NHANESraw, strata = ~SDMVSTRA, id = ~SDMVPSU, 
                           nest = TRUE, weights = ~WTMEC4YR
                           )

# Print summary of design
summary(NHANES_design)

# Number of clusters
NHANESraw %>%
  summarize(n_clusters = n_distinct(SDMVSTRA, SDMVPSU))

# Sample sizes in clusters
NHANESraw %>%
  count(SDMVSTRA, SDMVPSU) 

```
  
  
  
***
  
Chapter 2 - Exploring categorical data  
  
Visualizing categorical variables:  
  
* Can estimate distributions of race, including both the weighted and unweighted distributions  
	* tab_unw <- NHANESraw %>% group_by(Race1) %>% summarize(Freq = n()) %>% mutate(Prop = Freq/sum(Freq)) %>% arrange(desc(Prop))  
    * ggplot(data = tab_unw, mapping = aes(x = Race1, y = Prop)) + geom_col() + coord_flip() + scale_x_discrete(limits = tab_unw$Race1) # Labels layer omitted  
* Can convert back to the weighted frequencies  
	* tab_w <- svytable(~Race1, design = NHANES_design) %>% as.data.frame() %>% mutate(Prop = Freq/sum(Freq)) %>% arrange(desc(Prop))  
    * ggplot(data = tab_w, mapping = aes(x = Race1, y = Prop)) + geom_col() + coord_flip() + scale_x_discrete(limits = tab_w$Race1) # Labels layer omitted  
  
Exploring two categorical variables:  
  
* Can look at diabetes withing the NHANES data, using the syvtable() function  
	* svytable(~Diabetes, design = NHANES_design)  
    * tab_w <- svytable(~Race1 + Diabetes, design = NHANES_design)  # Race and Diabetes  
    * tab_w <- as.data.frame(tab_w)  # converts contingency table to frame  
    * ggplot(data = tab_w, mapping = aes(x = Race1, fill = Diabetes, y = Freq)) + geom_col() + coord_flip()  
    * ggplot(data = tab_w, mapping = aes(x = Race1, y = Freq, fill = Diabetes)) + geom_col(position = "fill") + coord_flip()  # stacked bars to 100%  
  
Inference for categorical variables:  
  
* Formal statistical tests for associations among categorical variables using chi-squared tests for association  
	* svychisq(~Race1 + Diabetes, design = NHANES_design, statistic = "Chisq")  
  
Example code includes:  
```{r}

# Specify the survey design
NHANESraw <- mutate(NHANESraw, WTMEC4YR = .5 * WTMEC2YR)
NHANES_design <- svydesign(data = NHANESraw, strata = ~SDMVSTRA, id = ~SDMVPSU, nest = TRUE, weights = ~WTMEC4YR)

# Determine the levels of Depressed
levels(NHANESraw$Depressed)

# Construct a frequency table of Depressed
tab_w <- svytable(~Depressed, design = NHANES_design)

# Determine class of tab_w
class(tab_w)

# Display tab_w
tab_w


# Add proportions to table
tab_w <- tab_w %>%
  as.data.frame() %>%
  mutate(Prop = Freq/sum(Freq))

# Create a barplot
ggplot(data = tab_w, mapping = aes(x = Depressed, y = Prop)) + 
  geom_col()


# Construct and print a frequency table
tab_D <- svytable(~Depressed, design = NHANES_design)
tab_D

# Construct and print a frequency table
tab_H <- svytable(~HealthGen, design = NHANES_design)
tab_H

# Construct and print a frequency table
tab_DH <- svytable(~Depressed + HealthGen, design = NHANES_design)
tab_DH


# Add conditional proportions to tab_DH
tab_DH_cond <- tab_DH %>%
    as.data.frame() %>%
    group_by(HealthGen) %>%
    mutate(n_HealthGen = sum(Freq), Prop_Depressed = Freq/n_HealthGen) %>%
    ungroup()

# Print tab_DH_cond
tab_DH_cond

# Create a segmented bar graph of the conditional proportions in tab_DH_cond
ggplot(data = tab_DH_cond, mapping = aes(x = HealthGen, y = Prop_Depressed, fill = Depressed)) + 
  geom_col() + 
  coord_flip() 


# We can also estimate counts with svytotal(). The syntax is given by:
# svytotal(x = ~interaction(Var1, Var2), design = design, na.rm = TRUE)
# For each combination of the two variables, we get an estimate of the total and the standard error


# Estimate the totals for combos of Depressed and HealthGen
tab_totals <- svytotal(x = ~interaction(Depressed, HealthGen), design = NHANES_design, na.rm = TRUE)

# Print table of totals
tab_totals

# Estimate the means for combos of Depressed and HealthGen
tab_means <- svymean(x = ~interaction(Depressed, HealthGen), design = NHANES_design, na.rm = TRUE)

# Print table of means
tab_means


# Run a chi square test between Depressed and HealthGen
svychisq(~Depressed + HealthGen, design = NHANES_design, statistic = "Chisq")

# Construct a contingency table
tab <- svytable(~Education + HomeOwn, design=NHANES_design)

# Add conditional proportion of levels of HomeOwn for each educational level
tab_df <- as.data.frame(tab) %>%
  group_by(Education) %>%
  mutate(n_Education = sum(Freq), Prop_HomeOwn = Freq/n_Education) %>%
  ungroup()

# Create a segmented bar graph
ggplot(data = tab_df, mapping = aes(x=Education, y=Prop_HomeOwn, fill=HomeOwn)) + 
  geom_col() + 
  coord_flip()

# Run a chi square test
svychisq(~Education + HomeOwn, 
    design = NHANES_design, 
    statistic = "Chisq")

```
  
  
  
***
  
Chapter 3 - Exploring quantitative data  
  
Summarizing quantitative data:  
  
* Can look at the physician health bad variable and summarize  
	* NHANESraw %>% filter(Age >= 12) %>% select(DaysPhysHlthBad)  # just the data  
    * svymean(x = ~DaysPhysHlthBad, design = NHANES_design, na.rm = TRUE)  # means of number of days feeling in bad heatlh  
    * svyquantile(x = ~DaysPhysHlthBad, design = NHANES_design, na.rm = TRUE, quantiles = 0.5)  # get the median (quantile 0.5) of the data  
* Can grab summaries by group using svyby with a function FUN provided  
	* svyby(formula = ~DaysPhysHlthBad, by = ~SmokeNow, design = NHANES_design, FUN = svymean, na.rm = TRUE, row.names = FALSE)  
    * svyby(formula = ~Age, by = ~SmokeNow, design = NHANES_design, FUN = svymean, na.rm = TRUE, keep.names = FALSE)  
  
Visualizing quantitative data:  
  
* Can create bar graphs of the means  
	* out <- svyby(formula = ~DaysPhysHlthBad, by = ~SmokeNow, design = NHANES_design, FUN = svymean, na.rm = TRUE, keep.names = FALSE)  
    * ggplot(data = out, mapping = aes(x = SmokeNow, y = DaysPhysHlthBad)) + geom_col() + labs(y = "Monthly Average Number\n of Bad Health Days", x = "Smoker?")  
    * out <- mutate(out, lower = DaysPhysHlthBad - se, upper = DaysPhysHlthBad + se)  
* Create histograms of the data  
	* ggplot(data = out, mapping = aes(x = SmokeNow, y = DaysPhysHlthBad, ymin = lower, ymax = upper)) + geom_col(fill = "lightblue") + geom_errorbar(width = .5) + labs(y = "Monthly Average Number\n of Bad Health Days", x = "Smoker?")  
    * ggplot(data = NHANESraw, mapping = aes(x = DaysPhysHlthBad, weight = WTMEC4YR)) + geom_histogram(binwidth = 1, color = "white") + labs(x = "Number of Bad Health Days in a Month")  
* Create density plots of the data  
	* NHANESraw %>% filter(!is.na(DaysPhysHlthBad)) %>% mutate(WTMEC4YR_std = WTMEC4YR/sum(WTMEC4YR)) %>%  
    *     ggplot(mapping = aes(x = DaysPhysHlthBad, weight = WTMEC4YR_std)) + geom_density(bw = .6, fill = "lightblue") + labs(x = "Number of Bad Health Days in a Month")  
  
Inference for quantitative data:  
  
* May want to compare means across two groups in the data using a weighted 2-sample t-test  
	* The test statistic is the difference in means divided by the SE (standard error)  
    * svyttest(formula = DaysPhysHlthBad ~ SmokeNow, design = NHANES_design)  
  
Example code includes:  
```{r}

# Compute the survey-weighted mean
svymean(x = ~SleepHrsNight, design = NHANES_design, na.rm = TRUE)

# Compute the survey-weighted mean by Gender
svyby(formula = ~SleepHrsNight, by = ~Gender, design = NHANES_design, 
      FUN = svymean, na.rm = TRUE, keep.names = FALSE
      )

# Compute the survey-weighted quantiles
svyquantile(x = ~SleepHrsNight, design = NHANES_design, na.rm = TRUE, 
            quantiles = c(0.01, 0.25, 0.5, 0.75, .99)
            )

# Compute the survey-weighted quantiles by Gender
svyby(formula = ~SleepHrsNight, by = ~Gender, design = NHANES_design, FUN = svyquantile, 
      na.rm = TRUE, quantiles = c(0.5), keep.rows = FALSE, keep.var = FALSE
      )

# Compute the survey-weighted mean by Gender
out <- svyby(formula = ~SleepHrsNight, by = ~Gender, design = NHANES_design, 
             FUN = svymean, na.rm = TRUE, keep.names = FALSE
             )
             
# Construct a bar plot of average sleep by gender
ggplot(data = out, mapping = aes(x=as.factor(Gender), y=SleepHrsNight)) + 
    geom_col() + 
    labs(y="Average Nightly Sleep")

# Add lower and upper columns to out
out_col <- mutate(out, lower = SleepHrsNight - 2*se, upper = SleepHrsNight + 2*se)

# Construct a bar plot of average sleep by gender with error bars
ggplot(data = out_col, mapping = aes(x = Gender, y = SleepHrsNight, ymin = lower, ymax = upper)) + 
    geom_col(fill = "gold") + 
    labs(y = "Average Nightly Sleep") + 
    geom_errorbar(width = 0.7)  


# Create a histogram with a set binwidth
ggplot(data = NHANESraw, mapping = aes(x=SleepHrsNight, weight=WTMEC4YR)) + 
    geom_histogram(binwidth = 1, color = "white") + 
    labs(x = "Hours of Sleep")

# Create a histogram with a set binwidth
ggplot(data = NHANESraw, mapping = aes(x=SleepHrsNight, weight=WTMEC4YR)) + 
    geom_histogram(binwidth = 0.5, color = "white") + 
    labs(x = "Hours of Sleep")

# Create a histogram with a set binwidth
ggplot(data = NHANESraw, mapping = aes(x=SleepHrsNight, weight=WTMEC4YR)) + 
    geom_histogram(binwidth = 2, color = "white") + 
    labs(x = "Hours of Sleep")


# Density plot of sleep faceted by gender
NHANESraw %>% 
    filter(!is.na(SleepHrsNight), !is.na(Gender)) %>%
    group_by(Gender) %>%
    mutate(WTMEC4YR_std = WTMEC4YR/sum(WTMEC4YR)) %>%
    ggplot(mapping = aes(x = SleepHrsNight, weight = WTMEC4YR_std)) + 
        geom_density(bw = 0.6,  fill = "gold") +
        labs(x = "Hours of Sleep") + 
        facet_wrap(~Gender, labeller = "label_both")


# Run a survey-weighted t-test
svyttest(formula = SleepHrsNight ~ Gender, design = NHANES_design)

# Find means of total cholesterol by whether or not active 
out <- svyby(formula = ~TotChol, by = ~PhysActive, design = NHANES_design, 
             FUN = svymean, na.rm = TRUE, keep.names = FALSE
             )

# Construct a bar plot of means of total cholesterol by whether or not active 
ggplot(data = out, mapping = aes(x=PhysActive, y=TotChol)) + 
    geom_col()

# Run t test for difference in means of total cholesterol by whether or not active
svyttest(formula = TotChol ~ PhysActive, design = NHANES_design)

```
  
  
  
***
  
Chapter 4 - Modeling quantitative data  
  
Visualization with scatter plots:  
  
* Can look at head circumference compared to age (only captured for babies) using a scatterplot  
	* babies <- filter(NHANESraw, AgeMonths <= 6) %>% select(AgeMonths, HeadCirc)  
    * ggplot(data = babies, mapping = aes(x = AgeMonths, y = HeadCirc)) + geom_point()  
    * ggplot(data = babies, mapping = aes(x = AgeMonths, y = HeadCirc)) + geom_jitter(width = 0.3, height = 0)  # width jitter but no height jitter  
* Can use weighting to extrapolate the scatter plot to the entire population  
	* ggplot(data = babies, mapping = aes(x = AgeMonths, y = HeadCirc, size = WTMEC4YR)) + geom_jitter(width = 0.3, height = 0) + guides(size = FALSE)  
    * ggplot(data = babies, mapping = aes(x = AgeMonths, y = HeadCirc, size = WTMEC4YR)) + geom_jitter(width = 0.3, height = 0, alpha = 0.3) + guides(size = FALSE)  
    * ggplot(data = babies, mapping = aes(x = AgeMonths, y = HeadCirc, color = WTMEC4YR)) + geom_jitter(width = 0.3, height = 0) + guides(color = FALSE)  
    * ggplot(data = babies, mapping = aes(x = AgeMonths, y = HeadCirc, alpha = WTMEC4YR)) + geom_jitter(width = 0.3, height = 0) + guides(alpha = FALSE)  
  
Visualizing trends:  
  
* Survey-weighted lines of best fit can be added using the geom_smooth() in ggplot2, with the weight= provided as an aestehtic to the geom_smooth()  
	* ggplot(data = babies, mapping = aes(x = AgeMonths, y = HeadCirc, alpha = WTMEC4YR)) + geom_jitter(width = 0.3, height = 0) + guides(alpha = FALSE) + geom_smooth(method = "lm", se = FALSE, mapping = aes(weight = WTMEC4YR))  
* Can also graph the best fit trendlines split by a categorical variable  
	* babies <- filter(NHANESraw, AgeMonths <= 6) %>% select(AgeMonths, HeadCirc, WTMEC4YR, Gender)  
    * ggplot(data = babies, mapping = aes(x = AgeMonths, y = HeadCirc, alpha = WTMEC4YR, color = Gender)) + geom_jitter(width = 0.3, height = 0) + guides(alpha = FALSE) + geom_smooth(method = "lm", se = FALSE, mapping = aes(weight = WTMEC4YR))  
  
Modeling survey data:  
  
* Can use the regression equations directly to predict values for a new data point  
	* mod <- svyglm(HeadCirc ~ AgeMonths, design = NHANES_design)  
    * summary(mod)  
* The standard errors are an assessment of the likely errors between the estimated regression line and the true regression line  
  
More complex modeling:  
  
* Can extend the simple regression to a multiple regression in a parallel slopes model  
	* mod <- svyglm(HeadCirc ~ AgeMonths + Gender, design = NHANES_design)  
* Can also extend the simple regression to a multiple regression with different slopes  
  
Wrap up:  
  
* Packages survey, dplyr, and ggplot2  
* Survey fundamentals - clusters, strata, weights, svydesign(), etc.  
* Categorical data, svytable(), svychisq()  
* Quantiative data, svymean(), svytotal(), svyby(), svyquantile(), svyttest()  
* Modeling trends, svyglm()  
  
Example code includes:  
```{r}

# Create dataset with only 20 year olds
NHANES20 <- filter(NHANESraw, Age == 20)

# Construct scatter plot
ggplot(data = NHANES20, mapping = aes(x=Height, y=Weight)) + 
    geom_point(alpha = 0.3) + 
    guides(size = FALSE)

# Construct bubble plot
ggplot(data = NHANES20, mapping = aes(x=Height, y=Weight, size=WTMEC4YR)) + 
    geom_point(alpha = 0.3) + 
    guides(size = FALSE)

# Construct a scatter plot
ggplot(data = NHANES20, mapping = aes(x=Height, y=Weight, color=WTMEC4YR)) + 
    geom_point() + 
    guides(color = FALSE)

# Construct a scatter plot
ggplot(data = NHANES20, mapping = aes(x=Height, y=Weight, alpha=WTMEC4YR)) + 
    geom_point() + 
    guides(alpha = FALSE)


# Add gender to plot
ggplot(data = NHANES20, mapping = aes(x=Height, y=Weight, size=WTMEC4YR, color=Gender)) + 
    geom_point(alpha=0.3) + 
    guides(size = FALSE)

# Add gender to plot
ggplot(data = NHANES20, mapping = aes(x=Height, y=Weight, alpha=WTMEC4YR, color=Gender)) + 
    geom_point() + 
    guides(alpha = FALSE)


# Bubble plot with linear of best fit
ggplot(data = NHANESraw, mapping = aes(x = Height, y = Weight, size=WTMEC4YR)) + 
  geom_point(alpha = 0.1) + 
  guides(size = FALSE) + 
  geom_smooth(method = "lm", se = FALSE, mapping = aes(weight=WTMEC4YR))

# Add quadratic curve and cubic curve
ggplot(data = NHANESraw, mapping = aes(x = Height, y = Weight, size = WTMEC4YR)) + 
  geom_point(alpha = 0.1) + 
  guides(size = FALSE) + 
  geom_smooth(method = "lm", se = FALSE, mapping = aes(weight = WTMEC4YR)) +
  geom_smooth(method = "lm", se = FALSE, mapping = aes(weight = WTMEC4YR), formula = y ~ poly(x, 2), color = "orange") +
  geom_smooth(method = "lm", se = FALSE, mapping = aes(weight = WTMEC4YR), formula = y ~ poly(x, 3), color = "red")


# Add survey-weighted trend lines to bubble plot
ggplot(data = NHANES20, mapping = aes(x = Height, y = Weight, size = WTMEC4YR, color = Gender)) + 
  geom_point(alpha = 0.1) + 
  guides(size = FALSE) + 
  geom_smooth(method = "lm", se = FALSE, linetype = 2)

# Add non-survey-weighted trend lines
ggplot(data = NHANES20, mapping = aes(x = Height, y = Weight, size = WTMEC4YR, color = Gender)) + 
  geom_point(alpha = 0.1) + 
  guides(size = FALSE) + 
  geom_smooth(method = "lm", se = FALSE, linetype = 2) + 
  geom_smooth(method = "lm", se = FALSE, mapping = aes(weight=WTMEC4YR))


# Subset survey design object to only include 20 year olds
NHANES20_design <- subset(NHANES_design, Age == 20)

# Build a linear regression model
mod <- svyglm(Weight ~ Height, design = NHANES20_design)

# Print summary of the model
summary(mod)


# Build a linear regression model same slope
mod1 <- svyglm(Weight ~ Height + Gender, design = NHANES20_design)

# Print summary of the same slope model
summary(mod1)

# Build a linear regression model different slopes
mod2 <- svyglm(Weight ~ Height*Gender, design = NHANES20_design)

# Print summary of the different slopes model
summary(mod2)


# Plot BPDiaAve and BPSysAve by Diabetes and include trend lines
drop_na(NHANESraw, Diabetes) %>% 
    ggplot(mapping = aes(x=BPDiaAve, y=BPSysAve, size=WTMEC4YR, color=Diabetes)) + 
    geom_point(alpha = 0.2) +  
    guides(size = FALSE) + 
    geom_smooth(method="lm", se = FALSE, mapping = aes(weight=WTMEC4YR))

# Build simple linear regression model
mod1 <- svyglm(BPSysAve ~ BPDiaAve, design = NHANES_design)

# Build model with different slopes
mod2 <- svyglm(BPSysAve ~ BPDiaAve*Diabetes, design = NHANES_design)

# Summarize models
summary(mod1)
summary(mod2)

```
  
  
  
***
  
###_Inference for Catgeorical Data_  
  
Chapter 1 - Inference for a Single Parameter  
  
General Social Survey:  
  
* Categorical data are where the data are categories rather than numbers, which is prevalent in the General Social Survey (GSS)  
	* Several thousand people are surveyed, with a goal of drawing inferences about the population from the sample  
    * Can grab the "gss" dataframe from the tidyverse package  
* Can generate an approximate error by using mean +/- 2*SE  
* The bootstrap can be a valuable way to assess the standard errors - calculate the sample statistic within each replicate, and calculate its distribution  
	* library(infer)  
    * boot <- gss2016 %>% specify(response=happy, success="HAPPY") %>% generate(reps=500, type="bootstrap") %>% calculate(stat="prop")  
  
CI interpretations:  
  
* In classicial statistical inference, there is assumed to be a fix but unknown population parameter that is being estimated by way of sampling  
* A 95% CI means that 95% of the intervals formed from random samples would include the true population parameter  
  
Approximation shortcut:  
  
* Standard errors tend to increase when the sample size is small or the probability is close to 50%  
* The normal distribution (bell curve) can be a useful approximation for a large sample size - the normal becomes the sampling distribution  
	* SE = sqrt( p * (1-p) / n )  
    * n * p and n * (1-p) should both be greater than or equal to 10  
  
Example code includes:  
```{r}

load("./RInputFiles/gss.RData")
glimpse(gss)


# Subset data from 2016
gss2016 <- gss %>%
  filter(year == 2016)

gss2016 %>% count(consci)
gss2016 <- gss2016 %>%
    mutate(old_consci=consci, 
           consci=fct_other(fct_recode(old_consci, "High"="A GREAT DEAL"), keep="High", other_level="Low")
           )
gss2016 %>% count(consci)

# Plot distribution of consci
ggplot(gss2016, aes(x = consci)) +
  geom_bar()

# Compute proportion of high conf
p_hat <- gss2016 %>%
  summarize(p = mean(consci == "High", na.rm = TRUE)) %>%
  pull()


# Load the infer package
library(infer)

# Create single bootstrap data set
b1 <- gss2016 %>%
    specify(response = consci, success = "High") %>%
    generate(reps = 1, type = "bootstrap")

# Plot distribution of consci
ggplot(b1, aes(x = consci)) +
  geom_bar()

# Compute proportion with high conf
b1 %>%
  summarize(p = mean(consci == "High")) %>%
  pull()


# Create bootstrap distribution for proportion that favor
boot_dist <- gss2016 %>%
  specify(response = consci, success = "High") %>%
  generate(reps = 500) %>%
  calculate(stat = "prop", success = "High", na.rm = TRUE)

# Plot distribution
ggplot(boot_dist, aes(x=stat)) +
  geom_density()

# Compute estimate of SE
SE <- boot_dist %>%
  summarize(se = sd(stat)) %>%
  pull()

# Create CI
c(p_hat - 2*SE, p_hat + 2*SE)


# Two new smaller data sets have been created for you from gss2016: gss2016_small, which contains 50 observations, and gss2016_smaller which contains just 10 observations

id50 <- c(6, 98, 2673, 1435, 1535, 525, 2784, 1765, 163, 1859, 2497, 1780, 184, 575, 2781, 2310, 1677, 2478, 1226, 2350, 1139, 1635, 1350, 1809, 1842, 1501, 1502, 2610, 2456, 49, 56, 2167, 2401, 2002, 2343, 2012, 860, 2557, 1147, 1119, 2449, 695, 1511, 666, 1595, 1094, 2643, 769, 1263, 2426)
id10 <- c(1609, 1342, 2066, 2710, 1809, 503, 1889, 486, 1469, 6)

gss2016_small <- gss2016 %>%
    filter(id %in% id50)
gss2016_smaller <- gss2016 %>%
    filter(id %in% id10)

# Create bootstrap distribution for proportion
boot_dist_small <- gss2016_small %>%
  specify(response = consci, success = "High") %>%
  generate(reps = 500, type = "bootstrap") %>%
  calculate(stat = "prop")

# Compute estimate of SE
SE_small_n <- boot_dist_small %>%
  summarize(se = sd(stat)) %>%
  pull()

# Create bootstrap distribution for proportion
boot_dist_smaller <- gss2016_smaller %>%
  specify(response = consci, success = "High") %>%
  generate(reps = 500, type = "bootstrap") %>%
  calculate(stat = "prop")

# Compute estimate of SE
SE_smaller_n <- boot_dist_smaller %>%
  summarize(se = sd(stat)) %>%
  pull()

c(SE_small_n, SE_smaller_n)


# Create bootstrap distribution for proportion that have hardy any
boot_dist <- gss2016 %>%
  specify(response=consci,  success = "Low") %>%
  generate(reps=500, type="bootstrap") %>%
  calculate(stat = "prop", na.rm = TRUE)

# Compute estimate of SE
SE_low_p <- boot_dist %>%
    summarize(se = sd(stat)) %>%
    pull()


# Compute p-hat and n
p_hat <- gss2016_small %>% 
    summarize(p = mean(consci == "High", na.rm=TRUE)) %>%
    pull()
n <- nrow(gss2016_small)

# Check conditions
p_hat * n >= 10
(1 - p_hat) * n >= 10

# Calculate SE
SE_approx <- sqrt(p_hat * (1 - p_hat) / n)

# Form 95% CI
c(p_hat - 2 * SE_approx, p_hat + 2 * SE_approx)

```
  
  
  
***
  
Chapter 2 - Proportions (Testing and Power)  
  
Hypothesis test for a proportion:  
  
* The hypothesis test for a proportion looks at what sort of p-hat would be observed if p held a specific value  
	* The hypothesize() function prior to generate() sets out the hypothesis in question  
* Suppose that analysis is being run on whether people favor capital punishment  
	* null <- gss2016 %>% specify(response=cappun, success="FAVOR") %>% hypothesize(null="point", p=0.5) %>% generate(reps=500, type="simulate") %>% calculate(stat="prop")  
    * null %>% summarize(mean(stat > p_hat)) %>% pull() * 2  # The times 2 is for a two-sided test  
  
Intervals for differences:  
  
* Can also look at differences in proportions, for example men vs. women belief in afterlife  
* Can generate null data by rewording the null hypothesis to "there is no association between belief in the afterlife and gender" - enables test by permutation  
	* gss2016 %>% specify(response=postlife, explanatory=sex, success="YES") %>% hypothesize(null="independence") %>% generate(reps=1, type="permute")  
    * gss2016 %>% specify(postlife ~ sex, success="YES") %>% hypothesize(null="independence") %>% generate(reps=1, type="permute")  # can use formula notation; same command as above, but simplified  
    * null <- gss2016 %>% specify(postlife ~ sex, success="YES") %>% hypothesize(null="independence") %>% generate(reps=500, type="permute")  %>% calculate(stat="diff in props", order=c("FEMALE", "MALE")) # Full command  
    * null %>% summarize(mean(stat > d_hat)) %>% pull() * 2  
  
Statistical errors:  
  
* Type I errors - probability of rejecting a true null hypothesis - will happen with probability alpha  
* Type II errors - probability of not rejecting a false null hypothesis  - will happen with probability beta, meaning the test has power 1-beta  
  
Example code includes:  
```{r}

# Construct plot
ggplot(gss2016, aes(x = postlife)) + 
    geom_bar()

# Compute and save proportion that believe
p_hat <- gss2016 %>%
    summarize(mean(postlife == "YES", na.rm = TRUE)) %>%
    pull()

# Generate one data set under H0
sim1 <- gss2016 %>%
    specify(response = postlife, success = "YES") %>%
    hypothesize(null = "point", p = 0.75) %>%
    generate(reps = 1, type = "simulate")

# Construct plot
ggplot(sim1, aes(x=postlife)) +
    geom_bar()

# Compute proportion that believe
sim1 %>%
    summarize(mean(postlife == "YES")) %>%
    pull()


# Generate null distribution
null <- gss2016 %>%
    specify(response = postlife, success = "YES") %>%
    hypothesize(null = "point", p = .75) %>%
    generate(reps = 100, type = "simulate") %>%
    calculate(stat = "prop")

# Visualize null distribution
ggplot(null, aes(x = stat)) +
    geom_density() +
    geom_vline(xintercept = p_hat, color = "red")

# Compute the two-tailed p-value
null %>%
    summarize(mean(stat > p_hat)) %>%
    pull() * 2


# Plot distribution
ggplot(gss2016, aes(x = sex, fill = cappun)) +
    geom_bar(position = "fill")
  
# Compute two proportions
p_hats <- gss2016 %>%
    group_by(sex) %>%
    summarize(mean(cappun == "FAVOR", na.rm = TRUE)) %>%
    pull()

# Compute difference in proportions
d_hat <- diff(p_hats)


# Create null distribution
null <- gss2016 %>%
    specify(cappun ~ sex, success = "FAVOR") %>%
    hypothesize(null = "independence") %>%
    generate(reps = 500, type = "permute") %>%
    calculate(stat = "diff in props", order = c("FEMALE", "MALE"))
  
# Visualize null
ggplot(null, aes(x = stat)) +
    geom_density() +
    geom_vline(xintercept = d_hat, col = "red")
  
# Compute two-tailed p-value
null %>%
    summarize(mean(stat < d_hat)) %>%
    pull() * 2


# Create the bootstrap distribution
boot <- gss2016 %>%
    specify(cappun ~ sex, success="FAVOR") %>%
    generate(reps=500, type="bootstrap") %>%
    calculate(stat = "diff in props", order = c("FEMALE", "MALE"))
  
# Compute the standard error
SE <- boot %>%
    summarize(sd(stat)) %>%
    pull()
  
# Form the CI (lower, upper)
c( d_hat - 2*SE, d_hat + 2*SE )


gssmod <- gss2016 %>%
    mutate(coinflip=sample(c("heads", "tails"), size=nrow(.), replace=TRUE))
table(gssmod$coinflip)

# Find difference in props
p_hats <- gssmod %>%
    group_by(coinflip) %>%
    summarize(mean(cappun == "FAVOR", na.rm = TRUE)) %>%
    pull()

# Compute difference in proportions
d_hat <- diff(p_hats)

# Form null distribution
null <- gssmod %>%
    specify(cappun ~ coinflip, success = "FAVOR") %>%
    hypothesize(null = "independence") %>%
    generate(reps = 500, type = "permute") %>%
    calculate(stat = "diff in props", order = c("heads", "tails"))

ggplot(null, aes(x = stat)) +
    geom_density() +
    geom_vline(xintercept = d_hat, color = "red")


# Set alpha
alpha <- 0.05

# Find cutoffs
upper <- null %>%
    summarize(quantile(stat, probs = c(1-alpha/2))) %>%
    pull()
lower <- null %>%
    summarize(quantile(stat, probs = alpha/2)) %>%
    pull()
  
# Visualize cutoffs
ggplot(null, aes(x = stat)) +
    geom_density() +
    geom_vline(xintercept = d_hat, color = "red") +
    geom_vline(xintercept = lower, color = "blue") +
    geom_vline(xintercept = upper, color = "blue")

# check if inside cutoffs
d_hat %>%
    between(lower, upper)

```
  
  
  
***
  
Chapter 3 - Comparing Many Parameters (Independence)  
  
Contingency tables:  
  
* Can look at bivariate relationships, such as political party affiliation vs. opinions on military spending  
	* The broom package can help in movements to/from contingency tables, by keeping things cleaner  
    * tab <- gss2016 %>% select(natarms, party) %>% table()  
    * tab %>% broom::tidy() %>% uncount(Freq)  
  
Chi-squared test statistic:  
  
* Can use Chi-squared to look at dependence of variables  
* Can create a contingency table O of the observations and a contingency table E of the expected distribution if there is pure independence  
	* Can then look at (O-E)**2 / E, and sum up to get the overall Chi-squared distribution  
    * Hypothesis tests can then assess how extreme a given Chi-squared may be  
  
Alternative method - chi-squared test statistic:  
  
* The Chi-squared statistic is derived from the Chi-squared distribution, which is specified solely by the number of degrees of freedom  
	* The degrees of freedom are (nRows - 1) * (nCols - 1)  
    * pchisq(chi_obs_spac, df=4)  # gives the likelihood of actual being less than, can use 1-pchisq() for the amount that is greater (the p-value of interest  
* Generally, need to have 5+ counts per cell, and to only use chi-squared for df=2+ (for df=1, can just compare proportions using the normal distribution)  
  
Intervals for chi-squared:  
  
* Can remove the hypothesize() call and use bootstrap() instead, but there is no real meaning to a Chi-squared in the absence of a null hypothesis  
* It is very unlikely that you would ever see a confidence interval attached to a Chi-squared interval  
  
Example code includes:  
```{r}

# Exclude "other" party
gss_party <- gss2016 %>%
    mutate(party=fct_collapse(partyid, 
                              "D"=c("STRONG DEMOCRAT", "NOT STR DEMOCRAT"), 
                              "R"=c("NOT STR REPUBLICAN", "STRONG REPUBLICAN"),
                              "I"=c("IND,NEAR DEM", "INDEPENDENT", "IND,NEAR REP"),
                              "O"="OTHER PARTY"
                              )
           ) %>%
    filter(!is.na(party), party != "O") %>%
    droplevels()

# Bar plot of proportions
gss_party %>%
    ggplot(aes(x = party, fill = natspac)) +
    geom_bar(position = "fill")
  
# Bar plot of counts
gss_party %>%
    ggplot(aes(x=party, fill = natspac)) +
    geom_bar()


# Create table of natspac and party
O <- gss_party %>%
    select(natspac, party) %>%
    table()

# Convert table back to tidy df
O %>%
    broom::tidy() %>%
    uncount(n)


# Create one permuted data set
perm_1 <- gss_party %>%
    specify(natarms ~ party) %>%
    hypothesize(null = "independence") %>%
    generate(reps = 1, type = "permute")
  
# Visualize permuted data
ggplot(perm_1, aes(x = party, fill = natarms)) +
    geom_bar()

# Make contingency table
tab <- perm_1 %>%
    ungroup() %>%
    select(natarms, party) %>%
    table()
  
# Compute chi-squared stat
(chi_obs_arms <- chisq.test(tab)$statistic)

(chi_obs_spac <- chisq.test(gss_party$natspac, gss_party$party)$statistic)

# Create null
null <- gss_party %>%
    specify(natspac ~ party) %>%
    hypothesize(null = "independence") %>%
    generate(reps = 100, type = "permute") %>%
    calculate(stat = "Chisq")

# Visualize H_0 and obs
ggplot(null, aes(x = stat)) +
    geom_density() +
    geom_vline(xintercept = chi_obs_spac, color = "red")

# Create null
null <- gss_party %>%
    specify(natarms ~ party) %>%
    hypothesize(null = "independence") %>%
    generate(reps = 100, type = "permute") %>%
    calculate(stat = "Chisq")

# Visualize H_0 and obs
ggplot(null, aes(x = stat)) +
    geom_density() +
    geom_vline(xintercept = chi_obs_arms, color = "red")


# create bar plot
gss2016 %>%
    ggplot(aes(x = region, fill = happy)) +
    geom_bar(position = "fill") +
    coord_flip()

# create table
tab <- gss2016 %>%
    select(happy, region) %>%
    table()
  
# compute observed statistic
(chi_obs_stat <- chisq.test(tab)$statistic)


# generate null distribution
null <- gss2016 %>%
    mutate(happy=fct_other(happy, keep=c("VERY HAPPY"))) %>%
    specify(happy ~ region, success = "VERY HAPPY") %>%
    hypothesize(null = "independence") %>%
    generate(reps = 500, type = "permute") %>%
    calculate(stat = "Chisq")

# plot null(s)
ggplot(null, aes(x = stat)) +
    geom_density() +
    geom_vline(xintercept = chi_obs_stat) +
    stat_function(fun = dchisq, args = list(df = (9-1)*(2-1)), color = "blue")

# permutation p-value
null %>% 
    summarize(mean(stat > chi_obs_stat)) %>% 
    pull()

# approximation p-value
1 - pchisq(chi_obs_stat, df = (9-1)*(2-1))

```
  
  
  
***
  
Chapter 4 - Comparing Many Parameters (Goodness of Fit)  
  
Case Study: Election Fraud:  
  
* Election fraud has many meanings; this course will focus on altering vote totals  
* Benford's Law applies when looking at broad collections of data, and considering only the first digit  
	* The law proposed that 30.1% of the first digits should be 1, with decreases as the numbers increase  
    * The basic idea is that the 1's always happen first (get to the 100s before any other x00s)  
* Can look at the 2009 Iranian election, and assess in comparison to Benford's Law  
  
Goodness of Fit:  
  
* Desire to assess whether the voter data is well aligned with Benford's law - Chi-squared is a good statistic for this  
	* chisq.test(myTab, p=myProbNull)  
* Can simulate the null hypothesis, for example by using  
	* gss2016 %>% specify(response=party) %>% hypothesize(null="point", p=p_uniform) %>% generate(reps=1, type="simulate")  
  
Now to the US:  
  
* Comparison to the US election in Iowa in 2016  
* Can look at county-level data  
  
Wrap-Up:  
  
* Could have rejected the null hypothesis even when it is true - typically 5%  
* More fundamental errors could be at play, such as assuming the first digit should follow Benford's Law  
	* Population of world cities tend to fit Benford's Law criteria (uniform distribution, consistency of logs, etc.)  
* Techniques for carrying out inference on categorical data - confidence intervals, hypothesis tests, Chi-squared tests for independence, goodness of fit of distributions  
* All tests follow specify-hypohteize-generate-calculate  
  
Example code includes:  
```{r}

iran <- readr::read_csv("./RInputFiles/iran.csv")
glimpse(iran)


# Compute candidate totals
totals <- iran %>%
  summarize(ahmadinejad = sum(ahmadinejad),
            rezai = sum(rezai),
            karrubi = sum(karrubi),
            mousavi = sum(mousavi))

# Plot totals
totals %>%
  gather(key = "candidate", value = "votes") %>%
  ggplot(aes(x = candidate, y = votes)) +
  geom_bar(stat = "identity")
  
# Cities won by #2
iran %>%
  group_by(province) %>%
  summarize(ahmadinejad = sum(ahmadinejad),
            mousavi = sum(mousavi)) %>%
  mutate(mousavi_win = mousavi > ahmadinejad) %>%
  filter(mousavi_win)


# Print get_first
get_first <- function(x) {
    substr(as.character(x), 1, 1) %>%
      as.numeric() %>%
      as.factor()
}

# Create first_digit
iran2 <- iran %>%
  mutate(first_digit = get_first(total_votes_cast))
  
# Construct barchart
iran2 %>%
  ggplot(aes(x=first_digit)) +
  geom_bar()


# Tabulate the counts of each digit
tab <- iran2 %>%
  select(first_digit) %>%
  table()

# Compute observed stat
p_benford <- c(0.301029995663981, 0.176091259055681, 0.1249387366083, 0.0969100130080564, 0.0791812460476248, 0.0669467896306132, 0.0579919469776867, 0.0511525224473813, 0.0457574905606751)
names(p_benford) <- 1:9
p_benford[9] <- 1 - sum(p_benford[-9])
sum(p_benford)
chi_obs_stat <- chisq.test(tab, p = p_benford)$stat

# Form null distribution
null <- iran2 %>%
  specify(response=first_digit) %>%
  hypothesize(null = "point", p = p_benford) %>%
  generate(reps=500, type = "simulate") %>%
  calculate(stat = "Chisq")


# plot both nulls
ggplot(null, aes(x = stat)) +
  geom_density() +
  geom_vline(xintercept = chi_obs_stat) + 
  stat_function(fun = dchisq, args = list(df = 9-1), color = "blue")

# permutation p-value
null %>%
  summarize(mean(stat > chi_obs_stat)) %>%
  pull()

# approximation p-value
pchisq(chi_obs_stat, df=9-1, lower.tail=FALSE)


iowa <- readr::read_csv("./RInputFiles/iowa.csv")
glimpse(iowa)

# Get R+D county totals
iowa2 <- iowa %>%
  filter(candidate == "Hillary Clinton / Tim Kaine" | candidate == "Donald Trump / Mike Pence") %>%
  group_by(county) %>%
  summarize(dem_rep_votes = sum(votes, na.rm = TRUE)) 

# Add first_digit
iowa3 <- iowa2 %>%
  mutate(first_digit = get_first(dem_rep_votes))

# Construct bar plot
iowa3 %>%
  ggplot(aes(x=first_digit)) + 
  geom_bar()


# Tabulate the counts of each digit
tab <- iowa3 %>%
  select(first_digit) %>%
  table()

# Compute observed stat
chi_obs_stat <- chisq.test(tab, p = p_benford)$stat

# Form null distribution
null <- iowa3 %>%
  specify(response = first_digit) %>%
  hypothesize(null = "point", p = p_benford) %>%
  generate(reps = 500, type = "simulate") %>%
  calculate(stat = "Chisq")
  
# Visualize null
ggplot(null, aes(x = stat)) +
  geom_density() +
  geom_vline(xintercept = chi_obs_stat)

```
  
  
  
***
  
###_Building Dashboards with flexdashboard_  
  
Chapter 1 - Dashboard Layouts  
  
Introduction:  
  
* Dashboards are a collection of components in a single display - graphs, text, tables, widgets, etc.  
* The flexdashboard is an R package that allows for using R Markdown to create a dashboard  
	* Can include all the power of R  
    * Can combine with Shiny for reactive elements  
* Course will include capabilities of flexdashboard, decision as to whether to incorporate Shiny, and potential extensions  
  
Anatomy of flexdashboard:  
  
* Within R Markdown, the header controls the type of document created during knitting  
	* output: flexdashboard::flex_dashboard (will create the flesdashboard output)  
* The flexdashboard is made up of charts, with each chart denoted by ### ChartName  
	* The succeeding lines can then be R code, similar to other R Markdown processes  
* By default, all of the charts will stack in a single column, though multiple columns can also be declared  
	* Columns are created using 14+ dashes, with everything underneath contained in that column  
    * Can give a specific name and specify options for each of the columns  
* Can start in Rstudio using File - New File - R Markdown - From Template - flexdashboard  
* Course data will include bicycle sharing data from San Francisco  
  
Layout basics:  
  
* Columns can be of variable width by using data-width= such that they add up to 1000  
* Can create by rows rather than columns using orientation:rows underneath flexdashboard::flex_dashboard:  
	* Can use data-height to vary the row heights  
    * Can use certical_layout: scroll as an option to allow for scrolling rather than forcing everything on to one page (this is considered poor dashboard design, though)  
  
Advanced layouts:  
  
* Options for extending the dashboard include tabsets  
	* Column {.tabset} - will apply the tabset to every chart in that column  
* Can also extend by using pages, where columns and rows are children of their respective pages  
	* Sixteen (16) or more equal signs under a Page title specify a call to the page  
    * Can add Page xxx {data-navmenu=yyy} to specify that the page xxx should belong to the navmenu yyy  
  
Example code includes (not added due to need for separate dashboard file):  
```{r}


```
  
  
  
***
  
Chapter 2 - Data Visualization for Dashboards  
  


	















