---
title: 'Additional Coding: Update #5'
author: "davegoblue"
date: "October 18, 2016"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Overview  
This document explores video poker hands, using <http://wizardofodds.com/games/video-poker/methodology/> as a template, and applying DataCamp_Insights_v001 materials where applicable.  This document builds on the more salient components of the analysis in AdditionalCoding_v004.Rmd.  

## Analysis Approach  
The Wizard of Odds suggests an 11-step approach to calculating the returns for a video poker pay table:  
  
1.  Initialize arrays for discarding 0-5 cards  
2.  Loop through all 52c5 hands, score them based on their poker value, then place them in the appropriate arrays (each of discard 0 through discard 5)  
3.  Create the 134,459 non-duplicate starting hands possible (e.g., Ad Kh Tc 9c 3d is the same as As Kh Td 9d 3s), and assign it a weighting based on how much duplication it covers  
4.  Lookup each of the 134,459 hands and score the discard 0 (hold 5) option  
5.  Lookup every possible discard 1 (hold 4) option, find the EV in the discard 1 array and then subtract the outcome in the discard 0 array (cannot get back the same hand)  
6.  Lookup every possible discard 2 (hold 3) option, find the EV in the discard 2 array and then subtract the outcomes in the discard 1 array and then add back the outcome in the discard 0 array (double-subtracted)  
7.  Lookup every possible discard 3 (hold 2) option, find the EV in the discard 3 array and then subtract the outcomes in the discard 2 array and then add back the outcomes in the discard 1 array and then subtract out the outcome in the discard 0 array (typical set theory add/subtract)  
8.  Lookup every possible discard 4 (hold 1) option, find the EV in the discard 4 array and then subtract the outcomes in the discard 3 array and then add back the outcomes in the discard 2 array and then subtract out the outcome in the discard 1 array and then add back the outcome in the discard 0 array (typical set theory add/subtract)  
9.  Lookup every possible discard 5 (hold 0) option, find the EV in the discard 5 array and then subtract the outcomes in the discard 4 array and then add back the outcomes in the discard 3 array and then subtract out the outcome in the discard 2 array and then add back the outcome in the discard 1 array and then subtract out the outcome of the discard 0 array (typical set theory add/subtract)  
10.  Calculate the EV of every possible decision, and assign the appropriate weightings  
11.  Determine overall return, or other statistics of interest about the game  
  
Steps 2 and 3 are surprisingly time-consuming, and this analysis will look to cache a number of key outcomes for application of a scoring vector at a later stage.  
  
### Step 1:  Initialize Arrays  
First, the relevant arrays for discard 0 (array0) through discard 5 (array5) are created.  A baseline assumption is made that while there are up to 50 types of interesting hands, there are only 16 possible scores driven by these hands.  Arrays for storing these are declared for the game of interest:  
```{r}


library(tidyr)
library(dplyr)
library(ggplot2)


startTime <- proc.time()


# Declare overall game variables
nHandTypes <- 50  # Number of hand types supported
nScores <- 16  # Number of final scores supported - many hand types may map to the same score


# Create the relevant arrays
array0 <- matrix(data=0L, nrow=choose(52, 5), ncol=nScores)
array1 <- matrix(data=0L, nrow=choose(52, 4), ncol=nScores)
array2 <- matrix(data=0L, nrow=choose(52, 3), ncol=nScores)
array3 <- matrix(data=0L, nrow=choose(52, 2), ncol=nScores)
array4 <- matrix(data=0L, nrow=choose(52, 1), ncol=nScores)
array5 <- matrix(data=0L, nrow=choose(52, 0), ncol=nScores)


proc.time() - startTime

```
  
### Step 2:  Create/Score Hands, Create Indexing, and Place Scores in Appropriate Arrays  
#### Step 2a:  Create/Score Hands  
First, the 52c5 possible hands are created, with hand types declared.  Of particular interest will be tracking the following:  
  
* Nothing (0)  
* Royal Flush (1)   
* Straight Flush (2)  
* Full House (3)  
* Flush (4)  
* Straight (5)  
* Trips (6)  
* Two Pair (7)  
* Pair AA (8)  
* Pair KK (9)  
* Pair QQ (10)  
* Pair JJ (11)  
* Pair TT (12)  
* Pair 22-99 (13)  
* AAAA with 2-4 (14)  
* AAAA with J-K (15)  
* AAAA with 5-T (16)  
* 2222/3333/4444 with A (17)  
* 2222/3333/4444 with 2-4 (18)  
* 2222/3333/4444 with J-K (19)  
* 2222/3333/4444 with 5-T (20)  
* JJJJ/QQQQ/KKKK with A (21)  
* JJJJ/QQQQ/KKKK with 2-4 (22)  
* JJJJ/QQQQ/KKKK with J-K (23)  
* JJJJ/QQQQ/KKKK with 5-T (24)  
* 5555-TTTT (25)  
  
```{r}

startTime <- proc.time()


# Create the 52c5 hands
aHands <- t(combn(1:52, 5))
str(aHands)


proc.time() - startTime


# Find the ranks and suits
aRanks <- 1 + (aHands-1) %% 13
aSuits <- (aHands-1) %/% 13
    

# Find the flushes
aFlush <- aSuits[, 1] == aSuits[, 5]


# Find the straights
strMatrix <- matrix(data=0L, nrow=13, ncol=10)
strMatrix[c(1, 10, 11, 12, 13), 1] <- 1L
for (intCtr in 1:9) { strMatrix[intCtr:(intCtr+4), intCtr+1] <- 1L }

aRankCount <- matrix(data=-1L, nrow=choose(52, 5), ncol=13)
for (intCtr in 1:13) { aRankCount[, intCtr] <- rowSums(aRanks == intCtr) }


# Find max and count of ranks (sufficient to determine quads, full houses, trips, two pair, and pair)
aQuads <- rowSums(aRankCount == 4)
aTrips <- rowSums(aRankCount == 3)
aPairs <- rowSums(aRankCount == 2)
aStraight <- rowSums( ((aRankCount == 1) %*% strMatrix) == 5)


# Default is that a hand has nothing
aType <- rep(0L, choose(52, 5))


# Declare types for mainline (RF, SF, FH, FL, ST, 3K, 2P)
aType[aFlush == 1 & aStraight == 1 & aRankCount[, 1] == 1 & 
          aRankCount[, 13] == 1] <- 1  # Royal Flush
aType[aFlush == 1 & aStraight == 1 & 
          (aRankCount[, 1] == 0 | aRankCount[, 13] == 0)] <- 2  # Straight Flush
aType[aTrips == 1 & aPairs == 1] <- 3  # Full House
aType[aFlush == 1 & aStraight == 0] <- 4  # Flush
aType[aFlush == 0 & aStraight == 1] <- 5  # Straight
aType[aTrips == 1 & aPairs == 0] <- 6  # Trips
aType[aPairs == 2] <- 7  # Two Pair


# Declare types for pairs
aType[aTrips == 0 & aPairs == 1 & aRankCount[, 1] == 2] <- 8  # Pair Aces
aType[aTrips == 0 & aPairs == 1 & aRankCount[, 13] == 2] <- 9  # Pair Kings
aType[aTrips == 0 & aPairs == 1 & aRankCount[, 12] == 2] <- 10  # Pair Queens
aType[aTrips == 0 & aPairs == 1 & aRankCount[, 11] == 2] <- 11  # Pair Jacks
aType[aTrips == 0 & aPairs == 1 & aRankCount[, 10] == 2] <- 12  # Pair Tens
aType[aTrips == 0 & aPairs == 1 & !(aType %in% c(8, 9, 10, 11, 12))] <- 13  # Pair 22-99


# Declare types for quads
quadSubset <- aRankCount[aQuads == 1, ]
quadType <- apply(quadSubset, 1, FUN=function(x) { c(which(x == 4), which(x == 1)) } )
quadScore <- rep(-1L, ncol(quadType))

quadScore[quadType[1, ] == 1 & quadType[2, ] %in% c(2, 3, 4)] <- 14  ## AAAA with 2-4
quadScore[quadType[1, ] == 1 & quadType[2, ] %in% c(11, 12, 13)] <- 15  ## AAAA with J-K
quadScore[quadType[1, ] == 1 & quadType[2, ] %in% c(5, 6, 7, 8, 9, 10)] <- 16  ## AAAA with 5-T

quadScore[quadType[1, ] %in% c(2, 3, 4) & 
              quadType[2, ] %in% c(1)] <- 17  ## 2222/3333/4444 with A
quadScore[quadType[1, ] %in% c(2, 3, 4) & 
              quadType[2, ] %in% c(2, 3, 4)] <- 18  ## 2222/3333/4444 with 2-4
quadScore[quadType[1, ] %in% c(2, 3, 4) & 
              quadType[2, ] %in% c(11, 12, 13)] <- 19  ## 2222/3333/4444 with J-K
quadScore[quadType[1, ] %in% c(2, 3, 4) & 
              quadType[2, ] %in% c(5, 6, 7, 8, 9, 10)] <- 20  ## 2222/3333/4444 with 5-T

quadScore[quadType[1, ] %in% c(11, 12, 13) & 
              quadType[2, ] %in% c(1)] <- 21  ## JJJJ/QQQQ/KKKK with A
quadScore[quadType[1, ] %in% c(11, 12, 13) & 
              quadType[2, ] %in% c(2, 3, 4)] <- 22  ## JJJJ/QQQQ/KKKK with 2-4
quadScore[quadType[1, ] %in% c(11, 12, 13) & 
              quadType[2, ] %in% c(11, 12, 13)] <- 23  ## JJJJ/QQQQ/KKKK with J-K
quadScore[quadType[1, ] %in% c(11, 12, 13) & 
              quadType[2, ] %in% c(5, 6, 7, 8, 9, 10)] <- 24  ## JJJJ/QQQQ/KKKK with 5-T

quadScore[quadType[1, ] %in% c(5, 6, 7, 8, 9, 10)] <- 25  ## 5555/6666/7777/8888/9999/TTTT with any


# Populate quad results in to aType
aType[aQuads == 1] <- quadScore
data.frame(type=aType) %>% group_by(type) %>% summarize(ct=n()) %>% print.data.frame()


proc.time() - startTime
```
  
The process takes ~10 seconds, but with the many interim files, it also consumes ~1.0 GB.  
  
#### Step 2b:  Create Indexing  
Next, a methodology is created to index any combination of held cards:  
```{r}

startTime <- proc.time()


# Create a matrix to hold results for choose(n, k)
mtxCombin <- matrix(data=0L, nrow=52, ncol=5)
for (intCtr in 1:52) {
    for (intCtr2 in 1:5) {
        # Note that choose() is a guarded function where choose(n, k) returns 0 for k > n
        mtxCombin[intCtr, intCtr2] <- as.integer(choose(intCtr, intCtr2))
    }
}


idxCard1 <- function(c1) {
    # Just return yourself
    c1
}

idxCard2 <- function(c1, c2) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    as.integer(  1 + mtxCombin[52, 2] - mtxCombin[53-c1, 2] + 
                     mtxCombin[52-c1, 1] - mtxCombin[53-c2, 1]
              ) 
}

idxCard3 <- function(c1, c2, c3) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    as.integer(
        1 + mtxCombin[52, 3] - mtxCombin[53-c1, 3] +
            mtxCombin[52-c1, 2] - mtxCombin[53-c2, 2] +
            mtxCombin[52-c2, 1] - mtxCombin[53-c3, 1]
              )
}

idxCard4 <- function(c1, c2, c3, c4) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    as.integer(
        1 + mtxCombin[52, 4] - mtxCombin[53-c1, 4] +
            mtxCombin[52-c1, 3] - mtxCombin[53-c2, 3] +
            mtxCombin[52-c2, 2] - mtxCombin[53-c3, 2] + 
            mtxCombin[52-c3, 1] - mtxCombin[53-c4, 1]
              )
}

idxCard5 <- function(c1, c2, c3, c4, c5) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    as.integer(
        1 + mtxCombin[52, 5] - mtxCombin[53-c1, 5] +
            mtxCombin[52-c1, 4] - mtxCombin[53-c2, 4] +
            mtxCombin[52-c2, 3] - mtxCombin[53-c3, 3] + 
            mtxCombin[52-c3, 2] - mtxCombin[53-c4, 2] +
            mtxCombin[52-c4, 1] - mtxCombin[53-c5, 1]
             )
}

proc.time() - startTime
```
  
This allows any combination of 1-5 cards to be converted to a relevant index.  This will be useful for several further components of the program.  
    
#### Step 2c:  Place Scores in Appropriate Arrays  
Next, each starting hand is assigned indices for keep0/discard5 (which will fill array5) down to keep5/discard0 (which will fill array0).  Note that hand types have not yet been converted to scores; this is simply the step for finding the relevant indices:  
```{r}

startTime <- proc.time()


getIndices <- function(nKeep, keyFun) {

    mtxKeep <- combn(1:5, nKeep)
    retResults <- matrix(data=-1L, nrow=nrow(aHands), ncol=ncol(mtxKeep))

    for (intCtr in 1:ncol(mtxKeep)) {
        thisKey <- mtxKeep[, intCtr, drop=TRUE]
        thisList <- lapply(seq_along(thisKey), FUN=function(x) { aHands[, thisKey[x]] } )
        if (length(thisList) == 5) {
            retResults[, intCtr] <- keyFun(thisList[[1]], thisList[[2]], thisList[[3]], 
                                           thisList[[4]], thisList[[5]]
                                           )
        } else if (length(thisList) == 4) {
            retResults[, intCtr] <- keyFun(thisList[[1]], thisList[[2]], 
                                           thisList[[3]], thisList[[4]]
                                           )
        } else if (length(thisList) == 3) {
            retResults[, intCtr] <- keyFun(thisList[[1]], thisList[[2]], thisList[[3]])
        } else if (length(thisList) == 2) {
            retResults[, intCtr] <- keyFun(thisList[[1]], thisList[[2]])
        } else if (length(thisList) == 1) {
            retResults[, intCtr] <- keyFun(thisList[[1]])
        } else { stop(paste0("Incorrect list length: ", length(thisList))) }
    }

    # Pass back the outcome
    retResults
    
}


mtxIndices <- matrix(data=-1L, nrow=nrow(aHands), ncol=32)

# Populate the keep-all
mtxIndices[, 1] <- getIndices(nKeep=5, keyFun=idxCard5)
proc.time() - startTime

# Populate the keep-four
mtxIndices[, 2:6] <- getIndices(nKeep=4, keyFun=idxCard4)
proc.time() - startTime

# Populate the keep-three
mtxIndices[, 7:16] <- getIndices(nKeep=3, keyFun=idxCard3)
proc.time() - startTime

# Populate the keep-two
mtxIndices[, 17:26] <- getIndices(nKeep=2, keyFun=idxCard2)
proc.time() - startTime

# Populate the keep-one
mtxIndices[, 27:31] <- getIndices(nKeep=1, keyFun=idxCard1)
proc.time() - startTime

# Populate the keep-zero
mtxIndices[, 32] <- 0L
proc.time() - startTime

```

The hands to scores vectors is created and applied to aHands:  
```{r}
gameIndex <- 0:25

# Jacks or Better Vector
hnd2Score <- data.frame(idx=gameIndex, val=c(-1, 
                                            799, 49,  8,  5,  3, 
                                              2,  1,  0,  0,  0, 
                                              0, -1, -1, 24, 24, 
                                             24, 24, 24, 24, 24, 
                                             24, 24, 24, 24, 24
                                            )
                        )

aScores <- hnd2Score$val[match(aType, gameIndex)]

summary(aScores)

data.frame(aScores=aScores) %>% group_by(aScores) %>% summarize(ct=n())

```
  
As expected, keeping all the cards dealt has an EV of -66.3% (using Jacks or Better scoring).  
  
Next, a function is written to calculate each of the following, assuming that you can get back the original card(s) on the re-draw:  
  
* Keep 4  
* Keep 3  
* Keep 2  
* Keep 1  
  
There is no need to calculate Keep 5 (it is already aScores) or Keep 0 (it defaults to mean(aScores) everywhere):  
```{r}

startTime <- proc.time()


findEV_YesRedraw <- function(useIdx) {
    # Assuming re-draw of thrown cards
    tmpScores <- data.frame(idx=as.vector(mtxIndices[, useIdx]), 
                            val=rep(aScores, times=length(useIdx))
                            )
    
    # This is what will be returned - mean by Index
    tmpScores %>% group_by(idx) %>% summarize(ev=mean(val))
}


tmpEVkeep4 <- findEV_YesRedraw(useIdx=2:6)
tmpEVkeep3 <- findEV_YesRedraw(useIdx=7:16)
tmpEVkeep2 <- findEV_YesRedraw(useIdx=17:26)
tmpEVkeep1 <- findEV_YesRedraw(useIdx=27:31)

summary(tmpEVkeep4$ev)
summary(tmpEVkeep3$ev)
summary(tmpEVkeep2$ev)
summary(tmpEVkeep1$ev)

sum(tmpEVkeep4$idx != 1:choose(52,4))
sum(tmpEVkeep3$idx != 1:choose(52,3))
sum(tmpEVkeep2$idx != 1:choose(52,2))
sum(tmpEVkeep1$idx != 1:choose(52,1))


proc.time() - startTime

```
  
The summary statistics and control totals are "as expected", and the process takes ~8 seconds.  This could be reduced to ~0.5 seconds by using a weighting that avoids redundancy.  However, further effort is needed to make sure that 1) discards are never returned, and 2) optimal holds for each starting hand can be calculated.  
  
