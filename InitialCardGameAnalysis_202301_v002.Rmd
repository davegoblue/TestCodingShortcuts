---
title: "Wild Card Game Analysis"
author: "davegoblue"
date: "2023-05-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
This file builds on _v001 and explores card games that use a standard 52-card deck, optionally modified so that one or more cards are wild, as follows:  
  
* One or more jokers may be added (the card has no natural rank or suit but may take on the most favorable)  
* One or more natural cards may also be used as a wild (in deuces wild, the deuce has a natural suit and rank and can also take on the suit and rank of a more favorable card)  
  
The analysis treats cards 1-52 as being the standard deck, with suits being 1-13, 14-26, 27-39, and 40-52. Counting the first card of each suit as 1, ranks are 1=Ace, 2-10=same card as value, 11=Jack, 12=Queen, 13=King. The Ace almost always plays as the highest rank, but can be treated as low for making a 5432A straight
  
The core functions and setup steps are captured at the top of the file

## Methodology
### Basic Parameters and Core Functions
Several basic parameters of the game are established:  
```{r}

library(tidyverse) # tidyverse functionality is included throughout

source("./Generic_Added_Utility_Functions_202105_v001.R") # Basic functions

nCards <- 53 # This is a standard 52-card deck with a joker
nRanks <- 13 # There are 13 ranks A, 2-10, J, Q, K
nSuits <- 4 # There are four suits, each of 13 cards
perHand <- 5 # Number of cards drawn per hand
idxWild <- c(2, 15, 28, 41, 53) # The indices of the cards that can be considered wild (deuces and the joker)

# Check alignment of basic parameters
if(nSuits*nRanks > nCards) stop("\nerror, misaligned parameters for number of ranks, suits, and cards\n")
if(!isTRUE(setdiff(1:nCards, 1:(nRanks*nSuits)) %in% idxWild %>% reduce(.f=`&`)))
    stop("\nError, any cards outside the standard nRanks*nSuits must be included in idxWild\n")

# Announce the number of wild cards
cat("\nThe game will be played with a", nCards, "card deck with", length(idxWild), "cards considered wild")
cat("\nWild cards are of indices", paste0(idxWild, collapse=", "))

# Announce any cards of no suit or rank
if(!isTRUE(idxWild %in% 1:(nRanks*nSuits) %>% reduce(.f=`&`))) { 
    cat("\nWilds with no natural rank or suit at indices:", 
        paste0(idxWild[!(idxWild %in% 1:(nRanks*nSuits))], collapse=",")
        )
} else cat("\nAll wilds have a natural suit and rank")

# Announce wilds with natural ranks and suits
if(isTRUE(idxWild %in% 1:(nRanks*nSuits) %>% reduce(.f=`|`))) { 
    tmpIdxWild <- idxWild[idxWild %in% 1:(nRanks*nSuits)]
    cat("\nWilds with natural rank and suit at indices:", paste0(tmpIdxWild, collapse=", "))
    cat("\nThese are of suit-independent rank", paste0((tmpIdxWild-1)%%nRanks+1, collapse=", "), "\n")
} else cat("\nNo wilds have a natural suit and rank\n")

# Declaration of hand values
handValues <- tibble::tibble(handRank=c(1:11, 99), 
                             handDesc=c("5W", "RF", "5K", "SF", "4K", "FH", "FL", "ST", "3K", "2P", "1P", "HC"),
                             handLabel=paste0(handRank, " (", handDesc, ")"),
                             blindPay=c(2000, 100, 40, 25, 5, 4, 3, 2, 0, 0, 0, 0),
                             wildPay=c(2000, 90, 70, 25, 6, 5, 4, 3, 1, -1, -1, -1), 
                             naturalPay=c(NA, 1000, NA, 200, 60, 30, 25, 20, 6, -1, -1, -1)
                             )
handValues

# Blind payouts
blindPay <- handValues$blindPay %>% 
    purrr::set_names(paste0("b_", handValues$handRank))

# Create a mapping vector for type to description
vecMapHands <- handValues$handLabel %>% purrr::set_names(handValues$handRank)

```

The main functions are also captured:
```{r}

# Determine if a hand is a flush
isFlush <- function(suits, useWild=4) {
    apply(suits, 1, FUN=function(x) ifelse(min(x)==max(x), TRUE, (max(x[x!=useWild])==min(x[x!=useWild]))))
}

# Determine if a hand is a straight (hard-coded for 5-card hands in a 13-card deck, Ace high or low)
isStraight <- function(rankCounts, isEligible=TRUE) {
    # Exclusion matrix for straights, currently designed only for 13-card decks and A high or low
    strMatrix <- matrix(data=0L, nrow=13, ncol=10)
    strMatrix[c(1, 10, 11, 12, 13), 1] <- 1L
    for (intCtr in 1:9) { strMatrix[intCtr:(intCtr+4), intCtr+1] <- 1L }
    apply(rankCounts, 1, max)<=1 & rowSums(rankCounts%*%(strMatrix-1)==0)>=1 & isEligible
}

# Hard-coded for 52-card deck with 1 joker
findHandTypes <- function (aHands, retAll=FALSE) {
    
    # Track hands that contain the joker and total number of wilds
    aJoker <- rowSums(aHands==53)>0
    nWild <- aJoker + rowSums(aHands%%13==2)
    
    # 1. Calculate natural values
    # 1a. Calculate ranks and suits, counting the joker as having no "rank" and being of a fifth "suit"
    aRanks <- ifelse(aHands==53, 0, 1 + (aHands-1) %% 13)
    aSuits <- ifelse(aHands==53, 0, 1 + (aHands-1) %/% 13)

    # 1b. Find the counts by rank in each hand
    aRankCount <- matrix(data=-1L, nrow=nrow(aHands), ncol=13)
    for (intCtr in 1:13) { aRankCount[, intCtr] <- rowSums(aRanks == intCtr) }
        
    # 1c. Find the natural flushes and straights
    nFlush <- isFlush(aSuits, useWild=-1)
    nStraight <- isStraight(aRankCount, isEligible=!aJoker)

    # 1d. Find max and count of ranks
    nQuads <- rowSums(aRankCount == 4)
    nTrips <- rowSums(aRankCount == 3)
    nPairs <- rowSums(aRankCount == 2)

    # 1e. Score the natural hand values (default is that a hand has nothing of value)
    nType <- rep(0L, nrow(aHands))
    # Five wilds (cannot exist) <- 1
    nType[nFlush==1 & nStraight==1 & aRankCount[, 1]==1 & aRankCount[, 13]==1] <- 2 # Royal
    # Five of a kind (cannot exist as natural) <- 3
    nType[nFlush==1 & nStraight==1 & (aRankCount[, 1]!=1 | aRankCount[, 13]!=1)] <- 4 # Straight flush
    nType[nQuads==1] <- 5 # Four of a kind
    nType[nTrips==1 & nPairs==1] <- 6 # Full House
    nType[nFlush==1 & nStraight==0] <- 7 # Flush
    nType[nFlush==0 & nStraight==1] <- 8 # Straight
    nType[nTrips==1 & nPairs==0] <- 9 # Three of a Kind
    nType[nPairs==2] <- 10 # Two Pair
    nType[nTrips==0 & nPairs==1] <- 11 # Pair

    
    # 2. Calculate wild values
    # 2a. Calculate ranks and suits, counting the joker and 2's as having no "rank" and being of a fifth "suit"
    wRanks <- ifelse(aHands==53|(aHands%%13==2), 0, 1 + (aHands-1) %% 13)
    wSuits <- ifelse(aHands==53|(aHands%%13==2), 0, 1 + (aHands-1) %/% 13)

    # 2b. Find the counts by rank in each hand
    wRankCount <- matrix(data=-1L, nrow=nrow(aHands), ncol=13)
    for (intCtr in 1:13) { wRankCount[, intCtr] <- rowSums(wRanks == intCtr) }
        
    # 2c. Find the wild flushes and straights
    wFlush <- isFlush(wSuits, useWild=0)
    wStraight <- isStraight(wRankCount, isEligible=TRUE)
    
    # 2d. Find max and count of ranks
    wQuads <- rowSums(wRankCount == 4)
    wTrips <- rowSums(wRankCount == 3)
    wPairs <- rowSums(wRankCount == 2)

    # 2e. Score the wild hand values (default is that a hand has nothing of value)
    wType <- rep(0L, nrow(aHands))
    
    # 2e1. Calculate number of royal cards in hand
    nRoyal <- rowSums(wRankCount[, c(1, 10, 11, 12, 13)])
    
    # 2e2. Five wilds (always five wilds)
    wType[nWild==5] <- 1 # Five wild
    
    # 2e3. Four wilds (always either royal flush or five of a kind)
    wType[nWild==4 & nRoyal==1] <- 2 # Royal
    wType[nWild==4 & nRoyal==0] <- 3 # Five of a kind
    
    # 2e4. Three wilds (always either royal flush or five of a kind or straight flush or four of a kind)
    wType[nWild==3 & wFlush==1 & wStraight==1 & nRoyal==2] <- 2 # Royal
    wType[nWild==3 & wPairs==1] <- 3 # Five of a kind
    wType[nWild==3 & wFlush==1 & wStraight==1 & nRoyal<2] <- 4 # Straight Flush
    wType[nWild==3 & !(wFlush==1 & wStraight==1) & wPairs==0] <- 5 # Four of a kind
    
    # 2e5. Two wilds (always either royal, five of a kind, straight flush, four of a kind, flush, straight, trips)
    # Cannot be a full house as any 3-2 using two wilds could instead be 5-0 or 1-4 and thus a better hand
    wType[nWild==2 & wFlush==1 & wStraight==1 & nRoyal==3] <- 2 # Royal
    wType[nWild==2 & wTrips==1] <- 3 # Five of a kind
    wType[nWild==2 & wFlush==1 & wStraight==1 & nRoyal<3] <- 4 # Straight Flush
    wType[nWild==2 & wPairs==1] <- 5 # Four of a kind
    wType[nWild==2 & wFlush==1 & wStraight==0] <- 7 # Flush
    wType[nWild==2 & wFlush==0 & wStraight==1] <- 8 # Straight
    wType[nWild==2 & !(wFlush==1 | wStraight==1) & wPairs==0 & wTrips==0] <- 9 # Three of a kind
    
    # 2e6. One wild (can be anything from pair to royal, with the exception of never two pair)
    wType[nWild==1 & wFlush==1 & wStraight==1 & nRoyal==4] <- 2 # Royal
    wType[nWild==1 & wQuads==1] <- 3 # Five of a kind
    wType[nWild==1 & wFlush==1 & wStraight==1 & nRoyal<4] <- 4 # Straight Flush
    wType[nWild==1 & wTrips==1] <- 5 # Four of a kind
    wType[nWild==1 & wPairs==2] <- 6 # Full House
    wType[nWild==1 & wFlush==1 & wStraight==0] <- 7 # Flush
    wType[nWild==1 & wFlush==0 & wStraight==1] <- 8 # Straight
    wType[nWild==1 & wPairs==1] <- 9 # Three of a kind
    wType[nWild==1 & !(wFlush==1 | wStraight==1) & wPairs==0 & wTrips==0 & wQuads==0] <- 11 # Pair
    
    # 2e7. No wild (is identical to natural)
    wType[nWild==0] <- nType[nWild==0]
    
    # Return the requested data
    if (isTRUE(retAll)) {
        list(nType=nType, 
             wType=wType, 
             nWild=nWild,
             wRankCount=wRankCount,
             aRankCount=aRankCount
             )
    } else {
        list(nType=nType, wType=wType, nWild=nWild)
    }
    
}

# Function to get the cards in a straight
getStraightType <- function(x) {
    if(min(x[x>0]) >= 10) c(10, 11, 12, 13, 14)
    else if(min(x[x>0]) <= 5 & max(x)==14) c(2, 3, 4, 5, 14) # this treats Ace as the last card to resolve (Ace low)
    else seq(min(x[x>0]), min(x[x>0])+4)
}

# Function to get the cards in a flush
getFlushType <- function(x) {
    # Wild cards should be added as highest rank not already in hand (try A then K then Q then J then T)
    numAdd <- sum(x==0)
    if(numAdd > 0) {
        notThere <- (14:10)[!((14:10) %in% x)][1:numAdd]
        x <- c(x[x!=0], notThere)
    }
    sort(x, decreasing=TRUE)
}

# Function to get the cards in a four of a kind, full house, three of a kind, two pair, pair, or high card
getHighTypes <- function(rks, idx=1:14, outNum=c(1, 1, 1, 1, 1)) {
    vecOut <- rep(0L, length(outNum))
    for(x in seq_along(outNum)) {
        vecOut[x]<-max((rks==max(rks)) * idx)
        rks[match(vecOut[x], idx)] <- 0
    }
    rep(vecOut, times=outNum)
}

# Function to get probabilities
findHandProbs <- function(exRank, idxExclude=NULL, df=sortedHandRanks) {
    rkData <- if(is.null(idxExclude)) df$rank else df$rank[-idxExclude]
    qualData <- if(is.null(idxExclude)) df$qual else df$qual[-idxExclude]
    pLN <- mean(rkData < exRank & qualData=="N")
    pLQ <- mean(rkData < exRank & qualData=="Q")
    pTN <- mean(rkData == exRank & qualData=="N")
    pTQ <- mean(rkData == exRank & qualData=="Q")
    pWN <- mean(rkData > exRank & qualData=="N")
    pWQ <- mean(rkData > exRank & qualData=="Q")
    pWNoTie <- (pWN+pWQ)/(1-pTN-pTQ)
    c(pLN=pLN, pLQ=pLQ, pTN=pTN, pTQ=pTQ, pWN=pWN, pWQ=pWQ, pWNoTie=pWNoTie)
}

# Function to get key values
getKeyValues <- function(keyRank, exclCards=c(), lstExclude=cardInHand, dfSort=sortedHandRanks) {

    # Get the union of exclusions
    if(length(exclCards)==0) exclHands<-c()
    else exclHands <- purrr::reduce(.x=lstExclude[c(exclCards)], .f=union)

    dfSort %>%
        filter(!(handNum %in% exclHands)) %>%
        summarize(pLQ=mean(qual=="Q" & rank<keyRank),
                  pLN=mean(qual=="N" & rank<keyRank), 
                  pTQ=mean(qual=="Q" & rank==keyRank),
                  pTN=mean(qual=="N" & rank==keyRank), 
                  pWQ=mean(qual=="Q" & rank>keyRank),
                  pWN=mean(qual=="N" & rank>keyRank), 
                  n=n()
                  ) %>%
        mutate(pWNoTie=(pWQ+pWN)/(1-pTQ-pTN), rank=keyRank)
        
}

calculateResults <- function(useHandNums, dfRanks=sortedHandRanks, hands=mtxHands, bPay=blindPay) {

    map_dfr(useHandNums, 
            .f=function(x) {
                getKeyValues(keyRank=dfRanks$rank[x], exclCards=as.vector(hands[x,])) %>%
                    mutate(type=dfRanks$wType[x], 
                           handNum=x, 
                           betPlay=ifelse((4*pWQ+3*pWN+2*pTQ+2*pTN)<(pLQ+pLN), 0, ifelse(pWNoTie<0.5, 1, 2)), 
                           evAnte=ifelse(betPlay==0, -1, pWQ-pLQ-pLN), 
                           evPlay=betPlay*(pWQ+pWN-pLQ-pLN),
                           evBlind=ifelse(betPlay==0, -1, bPay[paste0("b_", type)]*(pWQ+pWN)-pLQ-pLN), 
                           evAll=evAnte+evPlay+evBlind
                           )
                }
            )
}

getHandOutcome <- function(pWQ, pWN, tie, lose, betPlay, blindPay) {
    if(betPlay==0) return(tibble::tibble(result="fold", ante=-1, blind=-1, play=0))
    result <- sample(c("win/qualify", "win/no qualify", "tie", "lose"), 
                     size=1, 
                     replace=TRUE, 
                     prob=c(pWQ, pWN, tie, lose)
                     )
    return(tibble::tibble(result=result, 
                          ante=case_when(result=="win/qualify" ~ 1, 
                                         result %in% c("win/no qualify", "tie") ~ 0, 
                                         result=="lose" ~ -1, 
                                         TRUE ~ -99
                                         ),
                          blind=case_when(result %in% c("win/qualify", "win/no qualify") ~ blindPay, 
                                          result=="tie" ~ 0, 
                                          result=="lose" ~ -1, 
                                          TRUE ~ -99
                                          ), 
                          play=case_when(result %in% c("win/qualify", "win/no qualify") ~ betPlay, 
                                         result=="tie" ~ 0, 
                                         result=="lose" ~ -betPlay, 
                                         TRUE ~ -99
                                         )
                          )
           )
    
}

# Function to check if file exists and run if so
runHandSequence <- function(handNums, 
                            rdsName, 
                            skipIfExists=TRUE, 
                            saveFile=TRUE, 
                            ovrWrite=FALSE, 
                            returnFile=!isTRUE(saveFile) | (!isTRUE(skipIfExists) & !isTRUE(ovrWrite))
                            ) {
    
    # FUNCTION ARGUMENTS:
    # handNums: sequence of hand numbers to evaluate
    # rdsName: name of the RDS file (if exists or to be saved - no directory, no .RDS extension)
    # skipIfExists: boolean, if TRUE, check whether the file is already saved, and skip running if so
    # saveFile: boolean, should the file be saved after running
    # ovrWrite: boolean, should the previous file be overwritten?
    # returnFile: boolean, should the file be returned after creation?
    
    # Manage the file existence and decision to run or not run
    keyLoc <- paste0(formals(readFromRDS)$dir, rdsName, formals(readFromRDS)$addSuffix)
    fileExists <- file.exists(keyLoc)
    if(isTRUE(skipIfExists) & isTRUE(fileExists)) {
        cat("\nFile", keyLoc, "already exists, exiting without running or overwriting\n")
        return(NULL)
    }
    
    # Run the process and report on the time
    t1 <- proc.time()
    df <- calculateResults(useHandNums=handNums)
    print(proc.time()-t1)
    
    # Save the file if requested (overwriting the existing file)
    if(isTRUE(saveFile)) {
        # If file is to be overwritten, delete it
        if(isTRUE(ovrWrite) & isTRUE(fileExists)) {
            cat("\nRemoving existing file", keyLoc, "so new file can be written\n")
            Sys.chmod(keyLoc, mode="0777", use_umask=FALSE)
            file.remove(keyLoc)
        }
        # Write the file
        saveToRDS(obj=df, file=paste0(rdsName, ".RDS"), ovrWriteError=FALSE)
    }
    
    # Return the file if requested
    if(isTRUE(returnFile)) return(df)
    
}

# Convert 14, 13, 12, 11, 10 to A, K, Q, J, T
numberToCard <- function(x) 
    case_when(x==14 ~ "A", x==13 ~ "K", x==12 ~ "Q", x==11 ~ "J", x==10 ~ "T", TRUE ~ as.character(x))

# Hand types possible given excluded cards
handTypesByExclusion <- function(exclCards=c(), 
                                 df=sortedHandRanks, 
                                 pivotWider=FALSE, 
                                 checkRank=NULL,
                                 keyVars="wType"
                                 ) {
    
    # Function arguments
    # exclCards: cards to be excluded
    # df: file containing hand ranks and types
    # pivotWider: boolean, whould outputs be pivoted wider (unique by keyVars)?
    # checkRank: rank for win/lose/tie (NULL means do not compare ranks)
    # keyVars: key variables to be included in the final output
    
    # Add rankResult as a variable if checkRank is not NULL
    if(!is.null(checkRank)) {
        if(!("rankResult" %in% keyVars)) keyVars <- c(keyVars, "rankResult")
    }
    
    # Create the excluded hand numbers
    exclHands <- purrr::reduce(.x=cardInHand[exclCards], .f=union, .init=c())
                               
    # Create the list of hand types
    df <- df %>% 
        mutate(isOut=ifelse(handNum %in% exclHands, "excl", "avail")) 
    if(!is.null(checkRank))  {
        df <- df %>% 
            mutate(rankResult=case_when(rank<checkRank~"lose", rank==checkRank~"tie", rank>checkRank~"win"))
    }
    df <- df %>% 
        group_by(across(.cols=c(keyVars, "isOut"))) %>%
        summarize(n=n(), .groups="drop")
    
    # Pivot wider if requested, otherwise return as-is
    if(isTRUE(pivotWider)) 
        df %>% pivot_wider(id_cols=all_of(keyVars), names_from="isOut", values_from="n", values_fill=0)
    else df
    
}

# Automates calls to handTypeExclusion()
compareHandExclusion <- function(c1, 
                                 c2, 
                                 keyVars=c("wType", "nWild"), 
                                 checkRank=NULL,
                                 labs=NULL
                                 ) {
    
    # FUNCTION ARGUMENTS
    # c1: card set number 1
    # c2: card set number 2
    # keyVars: variables passed to handTypesByExclusion
    # checkRank: the rank for the relevant hands - can be passed as length 1 or length 2
    #            (NULL means do not check win/lose/tie)
    # labs: labels for the relevant columns (must be length-2)
    
    # Get the relevant checkRank parameters
    if(is.null(checkRank)) {
        cr1 <- NULL
        cr2 <- NULL
    } else if(length(checkRank)==1) {
        cr1 <- checkRank
        cr2 <- checkRank
    } else if(length(checkRank)==2) {
        cr1 <- checkRank[1]
        cr2 <- checkRank[2]
    } else stop("\nParameter checkRank must be NULL or length-1 or length-2\n")
    
    # Check that labels is of appropriate length
    if(is.null(labs)) {
        lab1 <- "Cards 1"
        lab2 <- "Cards 2"
    } else if(length(labs)==2) {
        lab1 <- labs[1]
        lab2 <- labs[2]
    } else stop("\nlabs must be NULL or length-2\n")
    
    # Get the appropriate grouping variables
    groupVars <- c("src", setdiff(keyVars, "nWild"), "hasWild", "isOut")
    if(!is.null(checkRank)) groupVars <- c(groupVars, "rankResult")
    
    handTypesByExclusion(exclCards=c1, keyVars=keyVars, checkRank=cr1) %>%
        bind_rows(handTypesByExclusion(exclCards=c2, keyVars=keyVars, checkRank=cr2), .id="src") %>%
        mutate(src=c("1"=lab1, "2"=lab2)[src]) %>%
        filter(isOut=="avail") %>%
        mutate(hasWild=(nWild>0)) %>%
        group_by(across(all_of(groupVars))) %>%
        summarize(n=sum(n), .groups="drop") %>%
        pivot_wider(id_cols=setdiff(groupVars, "src"), 
                    names_from="src", 
                    values_from="n", 
                    values_fill=0
                    ) %>%
        mutate(delta=get(lab2)-get(lab1)) %>%
        select(setdiff(groupVars, "src"), all_of(lab1), all_of(lab2), "delta", everything()) %>%
        arrange(desc(hasWild), across(setdiff(keyVars, "nWild")))

}

```
  
Several key objects are also created:  
```{r, cache=TRUE}

# 1. Create the matrix of all possible hand types
startTime <- proc.time()

# Create a matrix of all possible hand indices
mtxHands <- t(combn(1:nCards, perHand))
str(mtxHands)

proc.time() - startTime


# 2. Calculate all hand types
tmpTime <- proc.time(); tmpHandTypes<-findHandTypes(mtxHands, retAll=TRUE); proc.time()-tmpTime


# 3. Create tibble of all possible hand types and numbers of wilds
tblAllTypes <- tibble::tibble(wType=tmpHandTypes$wType, 
                              nType=tmpHandTypes$nType, 
                              nWild=tmpHandTypes$nWild
                              ) %>%
    mutate(wType=ifelse(wType==0, 99, wType), 
           nType=ifelse(nType==0, 99, nType)
           )
tblAllTypes


# 4. Payout grid for all possible values
allValueGrid <- expand.grid(wildType=c(1:11, 99), naturalType=c(1:11, 99)) %>%
    tibble::tibble() %>%
    full_join(count(tblAllTypes, wType, nType), by=c("wildType"="wType", "naturalType"="nType")) %>%
    mutate(bestType=pmin(wildType, naturalType)) %>%
    left_join(select(handValues, handRank, wildPay), by=c("wildType"="handRank")) %>%
    left_join(select(handValues, handRank, naturalPay), by=c("naturalType"="handRank")) %>%
    left_join(select(handValues, handRank, blindPay), by=c("bestType"="handRank")) %>%
    mutate(bonusPay=pmax(wildPay, naturalPay, na.rm=TRUE))
allValueGrid


# 5. Numbers of wilds and ranks by hand
perHandNWild <- (rowSums(mtxHands==53)>0) + rowSums(mtxHands%%13==2)
perHandRanks <- ifelse(mtxHands==53, 0, 1 + (mtxHands-1) %% 13) # track joker as wild
perHandRanks[perHandRanks==2] <- 0 # track deuces as wild, ignore rank (place as best later)
perHandRanks[perHandRanks==1] <- 14 # count Aces as high
perHandRankCount <- matrix(data=-1L, nrow=nrow(mtxHands), ncol=14)
for (intCtr in 1:14) { perHandRankCount[, intCtr] <- rowSums(perHandRanks == intCtr) }

```
  
Hand ranks are also calculated:  
```{r cache=TRUE}

mtxTieBreak <- matrix(data=0L, nrow=nrow(mtxHands), ncol=13)

startTime <- proc.time()

# 1. Five wild (nothing to do)
# 2. Royal flush (make the ranks 1 in the last 5 columns)
perHandRanks[tmpHandTypes$wType==2, ] <- t(apply(perHandRanks[tmpHandTypes$wType==2, ], 1, FUN=getStraightType))
# 3. Five of a kind (make the ranks all the same as the only rank)
perHandRanks[tmpHandTypes$wType==3, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==3, ], 
                                           1, 
                                           FUN=getHighTypes, 
                                           outNum=c(5)
                                           )
                                     )
# 4. Straight flush (make the ranks all the best straight possible)
perHandRanks[tmpHandTypes$wType==4, ] <- t(apply(perHandRanks[tmpHandTypes$wType==4, ], 1, FUN=getStraightType))
# 5. Four of a kind (make the ranks four of the most frequent card or the highest card, one of the other)
perHandRanks[tmpHandTypes$wType==5, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==5, ], 
                                           1, 
                                           FUN=getHighTypes, 
                                           outNum=c(4, 1)
                                           )
                                     )
# 6. Full house (make the ranks three of the most frequent card, two of the other)
perHandRanks[tmpHandTypes$wType==6, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==6, ], 
                                           1, 
                                           FUN=getHighTypes, 
                                           outNum=c(3, 2)
                                           )
                                     )
# 7. Flush (need to implement)
perHandRanks[tmpHandTypes$wType==7, ] <- t(apply(perHandRanks[tmpHandTypes$wType==7, ], 1, FUN=getFlushType))
# 8. Straight (make the ranks all the best straight possible)
perHandRanks[tmpHandTypes$wType==8, ] <- t(apply(perHandRanks[tmpHandTypes$wType==8, ], 1, FUN=getStraightType))
# 9. Three of a kind (make the ranks three of the most frequent or highest card, one each of the other)
perHandRanks[tmpHandTypes$wType==9, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==9, ], 
                                           1, 
                                           FUN=getHighTypes, 
                                           outNum=c(3, 1, 1)
                                           )
                                     )
# 10. Two pair (make the ranks two of the highest pair, two of the lowest pair, one of the remainder)
perHandRanks[tmpHandTypes$wType==10, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==10, ], 
                                            1, 
                                            FUN=getHighTypes, 
                                            outNum=c(2, 2, 1)
                                            )
                                      )
# 11. One pair (make the ranks two of the pair or highest card, one each of the remainder)
perHandRanks[tmpHandTypes$wType==11, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==11, ], 
                                            1, 
                                            FUN=getHighTypes, 
                                            outNum=c(2, 1, 1, 1)
                                            )
                                      )
# 0. High card (make the ranks in order of the highest cards)
perHandRanks[tmpHandTypes$wType==0, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==0, ], 
                                            1, 
                                            FUN=getHighTypes, 
                                            outNum=c(1, 1, 1, 1, 1)
                                            )
                                      )

proc.time() - startTime

# Create the hand ranking table
allHandRanks <- tibble::tibble(handNum=1:nrow(mtxHands), wType=tmpHandTypes$wType) %>% 
    bind_cols(perHandRanks) %>% 
    set_names(c("handNum", "wType", "tb1", "tb2", "tb3", "tb4", "tb5")) %>% 
    mutate(wType=ifelse(wType==0, 99, wType)) %>% 
    arrange(wType, desc(tb1), desc(tb2), desc(tb3), desc(tb4), desc(tb5)) %>% 
    mutate(chgRank=ifelse(row_number()==1 | wType!=lag(wType) | tb1 != lag(tb1) | tb2 != lag(tb2) | tb3 != lag(tb3) | tb4 != lag(tb4) | tb5 != lag(tb5), 1, 0), 
           rank=cumsum(chgRank)
           )

# Summary of hand ranks
allHandRanks %>%
    count(wType, rank, tb1, tb2, tb3, tb4, tb5) %>%
    arrange(-n, rank) %>%
    mutate(nvr=row_number()) %>%
    group_by(wType) %>%
    mutate(nty=row_number()) %>%
    ungroup() %>%
    filter(nvr<=10 | nty==1)

# Sort allHandRanks and ensure handNum and row_number() match
sortedHandRanks <- allHandRanks %>%
    mutate(qual=ifelse(wType<=11, "Q", "N")) %>%
    arrange(handNum) %>%
    mutate(nWild=perHandNWild)
if (sum((sortedHandRanks$handNum) != (1:nrow(sortedHandRanks)))>0) 
    stop("\nError in handNum order in sortedHandRanks\n")

# Get all exclusion indices once
startTime <- proc.time()
cardInHand <- lapply(1:53, FUN=function(x) which(rowSums(mtxHands==x)>0))
proc.time() - startTime

```

Simulations are run for the value of the bonus bet:  
```{r, fig.height=9, fig.width=9}

# Expected value of bonus
tblBonusPayCount <- allValueGrid %>%
    group_by(bonusPay) %>%
    summarize(n=sum(n, na.rm=TRUE))
tblBonusPayCount
tblBonusPayCount %>% summarize(evBonus=sum(bonusPay*n)/sum(n))

# Simulations over 100 hands
set.seed(2023051313)

# Function for running simulation
simulateBonus <- function(tbl=tblBonusPayCount, nHandsPerSim, nSims, groupBySim=TRUE) {
    # Sample requested number of hands
    tbl <- tbl %>% 
        sample_n(size=nHandsPerSim*nSims, replace=TRUE, weight=n)
    # If grouping requested, group the hands by simulation
    if(isTRUE(groupBySim)) {
        tbl <- tbl %>%
            mutate(rn=row_number(), simNumber=1 + (rn-1) %/% nHandsPerSim) %>%
            group_by(simNumber) %>%
            summarize(outcome=sum(bonusPay), nHands=n(), .groups="drop")
    }
    # Return the file
    tbl
}

# Simulate 100 hands 100,000 times
sim100k100 <- simulateBonus(nHandsPerSim=100, nSims=100000)

# 1. Overall summary statistics
summary(sim100k100)
# 2. Summary of percentiles
quantile(sim100k100$outcome, c(0, 0.005, 0.01, 0.025, 0.05, 0.25, 0.5, 0.75, 0.95, 0.975, 0.99, 0.995, 1))
# 3. Likelihood of win, lose, tie
sim100k100 %>%
    mutate(resultType=case_when(outcome>0 ~ "win", outcome<0~"lose", TRUE~"tie")) %>%
    group_by(resultType) %>%
    summarize(n=n(), evOutcome=mean(outcome), .groups="drop") %>%
    mutate(pctSims=n/sum(n))

```
  
For purposes of assessing playing strength, Every hand can be converted to a "suit and wild equivalent" hand as follows:  
  
* Wilds are treated as being in order of 2 (one wild), 15 (two wild), 28 (three wild), 41 (four wild), 53  
* Spades is the strongest playing suit, then hearts, then diamonds, then clubs  
* Strength of a suit is defined by the non-wild cards of that suit, ranked first by number of cards, then second by ranks of cards  
  
Tie-breaking is necessary only for suit lengths of two or one, as a suit length of three will always be first:  
```{r, fig.height=9, fig.width=9}

# Ranking method will count any length-5 as 1, any length-4 as 2, any length-3 as 3, 
# then length-2 by high then low as 4-69, then length-1 by high as 70-81
suitTwoRanks <- expand.grid(c1=3:14, c2=3:14) %>%
    tibble::as_tibble() %>%
    arrange(desc(c1), desc(c2)) %>%
    filter(c2<c1) %>%
    mutate(rank=row_number()+3)
suitTwoRanks
tmp <- suitTwoRanks %>%
    mutate(cards=paste(c1, c2, sep="-"))
suitTwoMapper <- tmp$rank
names(suitTwoMapper) <- tmp$cards
suitTwoMapper

suitOneRank <- expand.grid(c1=3:14) %>%
    tibble::as_tibble() %>%
    arrange(desc(c1)) %>%
    mutate(rank=row_number()+max(suitTwoRanks$rank))
suitOneRank
suitOneMapper <- suitOneRank$rank
names(suitOneMapper) <- as.character(suitOneRank$c1)
suitOneMapper

suitZeroRank <- 1+max(suitOneRank$rank)
suitZeroRank

```
  
Cards per hand are converted to tibble, and ranks are assigned to each suit:  
```{r}

# Create tibble of hand types
tblHands <- mtxHands %>%
    as.data.frame()
names(tblHands) <- paste0("V", 1:5)
tblHands <- tblHands %>%
    tibble::as_tibble() %>%
    mutate(handNum=row_number(), across(where(is.numeric), as.integer))
tblHands

# Create tibble containing suits and ranks for each hand, ordered by hand, then suit, then descending rank
tblSuitRank <- tblHands %>%
    pivot_longer(cols=-c(handNum)) %>%
    mutate(suit=case_when(value %in% c(2, 15, 28, 41, 53)~0L, 
                          value %in% c(1:52) ~ 1+(value-1)%/%13, 
                          TRUE~-99L
                          ), 
           rank=ifelse(suit==0, 0L, 1+(value-1)%%13), 
           rank=ifelse(rank==1, 14L, rank), 
           suit=as.integer(suit), 
           rank=as.integer(rank)
           ) %>%
    arrange(handNum, suit, desc(rank))
tblSuitRank

# mutate(score=case_when(n==5~1, 
#                            n==4~2, 
#                            n==3~3, 
#                            n==2~suitTwoMapper[cards], 
#                            n==1~suitOneMapper[cards], 
#                            TRUE~-99
#                            )
#            )

```
  
Hands are separated for cards by suit:  
```{r cache=TRUE}

# Calculate relevant suits by hand
tblSuitCore <- tblSuitRank %>%
    group_by(handNum, suit) %>%
    summarize(n=n(), cards=paste0(rank, collapse="-"), .groups="drop")
tblSuitCore

```
  
Hands are then converted back to an equivalent hand:  
```{r cache=TRUE}

tblNotWild <- tblSuitCore %>%
    filter(suit!=0) %>%
    left_join(tibble::tibble(cards=names(c(suitOneMapper, suitTwoMapper)), rank=c(suitOneMapper, suitTwoMapper)), 
              by="cards"
              ) %>% 
    mutate(rank=case_when(suit==0~0, n==5~1, n==4~2, n==3~3, TRUE~rank)) %>% 
    arrange(handNum, rank) %>%
    group_by(handNum) %>%
    mutate(newSuit=row_number()) %>%
    ungroup() %>%
    tidyr::separate_longer_delim(cols="cards", delim="-")
tblNotWild

tblWild <- tblSuitCore %>%
    filter(suit==0)
tblWild <- tibble::tibble(handNum=rep(tblWild$handNum, tblWild$n)) %>%
    left_join(tblWild, by="handNum") %>%
    group_by(handNum) %>%
    mutate(cards=c(2, 15, 28, 41, 53)[row_number()]) %>%
    ungroup()
tblWild

tblAll <- tblNotWild %>%
    mutate(cards=as.integer(cards), 
           cards=ifelse(cards==14, 1, cards) + 13*(newSuit-1)
           ) %>%
    bind_rows(mutate(tblWild, cards=as.numeric(cards))) %>%
    arrange(handNum, cards)
tblAll

# Number of unique pairings
tblUnique <- tblAll %>%
    select(handNum, cards) %>%
    group_by(handNum) %>%
    mutate(name=paste0("V", row_number())) %>%
    ungroup() %>%
    pivot_wider(id_cols="handNum", names_from="name", values_from="cards")

tblSuitCount <- tblSuitCore %>% 
    filter(suit!=0) %>% 
    arrange(handNum, desc(n)) %>% 
    group_by(handNum) %>% 
    summarize(suits=paste0(n, collapse="-"))
tblSuitCount %>% count(suits)

tmpCounts <- tblUnique %>%
    left_join(select(sortedHandRanks, handNum, nWild), by=c("handNum")) %>%
    left_join(tblSuitCount, by="handNum") %>%
    count(nWild, suits, V1, V2, V3, V4, V5, name="numDup") %>%
    count(nWild, suits, numDup) %>%
    arrange(desc(nWild), desc(suits))
tmpCounts %>% print(n=40)
tmpCounts %>% group_by(nWild) %>% summarize(n=sum(n))
tmpCounts %>% pull(n) %>% sum()

```
  
The game can be simulated using 102,360 hands, since all other hands are symmetric as to ranks by suit and number of wilds. For example, AsKsTh8dJoker is symmetric to AcKcTd8h2s

A tibble of unique hands is kept, along with the counts and matching hand number:  
```{r cache=TRUE}

keyHands <- tblUnique %>%
    left_join(select(sortedHandRanks, handNum, nWild), by=c("handNum")) %>%
    left_join(tblSuitCount, by="handNum") %>%
    count(nWild, suits, V1, V2, V3, V4, V5, name="numDup") %>%
    left_join(tblHands, by=c("V1", "V2", "V3", "V4", "V5"))
keyHands

# Checks for NA (should be a single record, the suits for 5-wild)
sum(is.na(keyHands))

# Checks for number of wilds and suits
tmpUse <- keyHands %>%
    bind_rows(mutate(., suits="All", nWild=NA)) 
tmpUse %>%
    group_by(nWild, suits) %>%
    summarize(nRun=n(), nTotal=sum(numDup), ratRun=nRun/nTotal, ratSave=1/ratRun,.groups="drop") %>%
    arrange(desc(nWild), desc(suits))
tmpUse %>%
    group_by(nWild) %>%
    summarize(nRun=n(), nTotal=sum(numDup), ratRun=nRun/nTotal, ratSave=1/ratRun,.groups="drop") %>%
    arrange(desc(nWild))

```
  
Hands with 1-5 wilds are assessed:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Run for all hands with 1-5 wilds
t <- proc.time()
runHandSequence(handNums=keyHands %>% filter(nWild>=1) %>% pull(handNum), 
                rdsName="ICGA_v002_seq1PlusWild", 
                skipIfExists=TRUE, 
                saveFile=TRUE
                )
proc.time() - t

```
  
Remaining hands are divided in to roughly equal groups:  
```{r}

hands_5_41_32 <- keyHands %>%
    filter(nWild==0, suits %in% c("5", "4-1", "3-2"))

hands_311 <- keyHands %>%
    filter(nWild==0, suits %in% c("3-1-1"))

hands_221 <- keyHands %>%
    filter(nWild==0, suits %in% c("2-2-1"))

hands_2111 <- keyHands %>%
    filter(nWild==0, suits %in% c("2-1-1-1"))

# Confirm that all hands have been created
tibble::tibble(handNum=c(readFromRDS("ICGA_v002_seq1PlusWild")$handNum, 
                         hands_5_41_32$handNum, 
                         hands_311$handNum, 
                         hands_221$handNum, 
                         hands_2111$handNum
                         )
               ) %>%
    arrange(handNum) %>%
    identical(keyHands %>% arrange(handNum) %>% select(handNum))

# Lengths of hands
nrow(hands_5_41_32)
nrow(hands_311)
nrow(hands_221)
nrow(hands_2111)

```
  
Hands of type 2-2-1 are assessed:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Run for all hands of type 2-2-1 (0 wild)
t <- proc.time()
runHandSequence(handNums=hands_221 %>% pull(handNum), 
                rdsName="ICGA_v002_seq221", 
                skipIfExists=TRUE, 
                saveFile=TRUE
                )
proc.time() - t

```
  
Hands of type 2-1-1-1 are assessed:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Run for all hands of type 2-1-1-1 (0 wild)
t <- proc.time()
runHandSequence(handNums=hands_2111 %>% pull(handNum), 
                rdsName="ICGA_v002_seq2111", 
                skipIfExists=TRUE, 
                saveFile=TRUE
                )
proc.time() - t

```
  
Hands of type 5, 4-1, and 3-2 are assessed:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Run for all hands of type 5, 4-1, and 3-2 (0 wild)
t <- proc.time()
runHandSequence(handNums=hands_5_41_32 %>% pull(handNum), 
                rdsName="ICGA_v002_seq5_41_32", 
                skipIfExists=TRUE, 
                saveFile=TRUE
                )
proc.time() - t

```
  
Hands of type 3-1-1 are assessed:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Run for all hands of type 3-1-1 (0 wild)
t <- proc.time()
runHandSequence(handNums=hands_311 %>% pull(handNum), 
                rdsName="ICGA_v002_seq311", 
                skipIfExists=TRUE, 
                saveFile=TRUE
                )
proc.time() - t

```
  
A full database of results is created, along with a mapping from handNum to equivalent symmetric hand in the full database:  
```{r}

# Full database of results
tblFullResults <- readFromRDS("ICGA_v002_seq221") %>% 
    bind_rows(readFromRDS("ICGA_v002_seq1PlusWild"), 
              readFromRDS("ICGA_v002_seq2111"), 
              readFromRDS("ICGA_v002_seq5_41_32"), 
              readFromRDS("ICGA_v002_seq311")
              ) %>% 
    left_join(select(keyHands, handNum, nWild, numDup, suits), by="handNum") %>% 
    arrange(rank, nWild)
tblFullResults
tblFullResults %>% pull(numDup) %>% sum()
tblFullResults %>% count(nWild, suits, wt=numDup) %>% arrange(desc(nWild), desc(suits))

# Mapping of hands to symmetric hand in tblFullResults
mapHands <- tblUnique %>%
    left_join(select(sortedHandRanks, handNum, nWild), by=c("handNum")) %>%
    left_join(tblSuitCount, by="handNum") %>% 
    left_join(select(keyHands, keyHand=handNum, nWild, suits, V1, V2, V3, V4, V5), 
              by=c("nWild", "suits", "V1", "V2", "V3", "V4", "V5")
              ) %>%
    rename(origHand=handNum, mapHand=keyHand)
mapHands

# Confirmation that mapping lines up
mapHands %>%
    select(origHand, mapHand) %>%
    left_join(tblFullResults, by=c("mapHand"="handNum")) %>%
    select(origHand, mapHand, numDup) %>%
    group_by(mapHand, numDup) %>%
    summarize(n=n(), .groups="drop") %>%
    arrange(desc(abs(numDup-n)), mapHand)

```
  
A sample of hands is tested to check that the mapped hands and original hands give the same output:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

set.seed(2023052513)

# Pick a sample of 1000 hands and get their associated values
tmpExample <- mapHands %>% 
    select(origHand, mapHand) %>% 
    filter(origHand!=mapHand) %>% 
    sample_n(1000, replace=FALSE) %>% 
    pull(origHand) %>% 
    runHandSequence(handNums=., rdsName="", saveFile=FALSE) %>% 
    left_join(select(mapHands, handNum=origHand, mapHand), by="handNum") %>% 
    arrange(handNum)

# Confirm that results are identical
tmpExample %>% 
    select(-handNum) %>% 
    rename(handNum=mapHand) %>% 
    arrange(handNum) %>% 
    select(handNum, everything()) %>% 
    identical(tmpExample %>% 
                  select(mapHand) %>% 
                  left_join(tblFullResults, by=c("mapHand"="handNum")) %>% 
                  select(-numDup, -suits, -nWild) %>% 
                  arrange(mapHand) %>% 
                  select(handNum=mapHand, everything())
              )

```
  
The playing strategy is added to a subset of the full results:  
```{r}

# Strategy for playing:
# Double if probability of winning exceeds probability of losing
# Single if 4*pWQ+3*pWN+2*pTQ+2*pTN > plQ+pLN
# Fold otherwise
# Results outcome
# if betPlay is 0, evAnte is -1, evBlind is -1, and evPlay is 0; otherwise,
# evAnte: win 1 on pWQ, push on pWN+pTQ+pTN, lose on pLQ and pLN
# evBlind: win or push based on blind table for pWQ and pWN, push on pTQ and pTN, lose on pLQ and pLN
# evPlay: win betPlay on pWQ and pWN, push on pTQ and pTN, lose on pLQ and pLN
tblPlayStrategy <- tblFullResults %>%
    select(handNum, type, numDup, pWQ, pWN, pTQ, pTN, pLQ, pLN) %>%
    mutate(betPlay=case_when(pWQ+pWN > pLQ+pLN ~ 2, 
                             4*pWQ+3*pWN+2*pTQ+2*pTN > pLQ+pLN ~ 1, 
                             TRUE ~ 0
                             )
           ) %>%
    pivot_longer(cols=-c(handNum, type, numDup, betPlay)) %>%
    mutate(resBlind=case_when(betPlay==0 ~ -1, 
                              name %in% c("pLQ", "pLN") ~ -1, 
                              name %in% c("pTQ", "pTN") ~ 0, 
                              name %in% c("pWQ", "pWN") ~ blindPay[paste0("b_", type)], 
                              TRUE ~ NA
                              ), 
           resAnte=case_when(betPlay==0 ~ -1, 
                             name %in% c("pLQ", "pLN") ~ -1, 
                             name %in% c("pTQ", "pTN", "pWN") ~ 0, 
                             name %in% c("pWQ") ~ 1, 
                             TRUE ~ NA
                             ), 
           resPlay=case_when(betPlay==0 ~ 0, 
                             name %in% c("pLQ", "pLN") ~ -betPlay, 
                             name %in% c("pTQ", "pTN") ~ 0, 
                             name %in% c("pWQ", "pWN") ~ betPlay, 
                             TRUE ~ NA
                             ), 
           resAll=resBlind+resAnte+resPlay
           )
tblPlayStrategy

# Check for NA and basic summary
tblPlayStrategy %>% summary
tblPlayStrategy %>% is.na %>% colSums

# Check for hand-weighted EV
tblPlayStrategy %>%
    summarize(across(starts_with("res"), .fns=function(x) sum(x*numDup*value)/sum(numDup*value)))
tblPlayStrategy %>%
    group_by(betPlay) %>%
    summarize(across(starts_with("res"), .fns=function(x) sum(x*numDup*value)/sum(numDup*value)), 
              nHands=sum(ifelse(name=="pWQ", numDup, 0))
              )
tblPlayStrategy %>%
    group_by(type) %>%
    summarize(across(starts_with("res"), .fns=function(x) sum(x*numDup*value)/sum(numDup*value)), 
              nHands=sum(ifelse(name=="pWQ", numDup, 0))
              )

```
  
The EV for each bet and each hand type is also calculated:  
```{r}

# Get the EV per hand
tblPerHandEV <- tblPlayStrategy %>%
    group_by(handNum, type, numDup, betPlay) %>%
    summarize(across(starts_with("res"), .fns=function(x) sum(x*value)), .groups="drop")
tblPerHandEV

# Summarize by overall
tblPerHandEV %>% 
    pivot_longer(-c(handNum, type, numDup, betPlay)) %>% 
    group_by(name) %>% 
    summarize(nUq=n(), 
              nTot=sum(numDup), 
              wtd_mean=sum(value*numDup)/sum(numDup), 
              across(value, 
                     .fns=list(mean=mean, median=median, max=max, min=min), 
                     .names="ev_{.fn}"
                     )
              )

# Summarize by betplay
tblPerHandEV %>% 
    pivot_longer(-c(handNum, type, numDup, betPlay)) %>% 
    group_by(betPlay, name) %>% 
    summarize(nUq=n(), 
              nTot=sum(numDup), 
              wtd_mean=sum(value*numDup)/sum(numDup), 
              across(value, 
                     .fns=list(mean=mean, median=median, max=max, min=min), 
                     .names="ev_{.fn}"
                     ), 
              .groups="drop"
              )

```
  
As expected, the lowest overall EV for single-betting is -2, since folding can guarantee a result of -2. All of the play bet EV for single-betting are negative and all of the play bet EV for double-betting are positive, in line with the bet-sizing criteria

Main bet results are simulated:  
```{r, fig.height=9, fig.width=9}

# Simulations over 100 hands
set.seed(2023052812)

# Function for running simulation
simulateMainBet <- function(tbl=tblPlayStrategy, nHandsPerSim, nSims, groupBySim=TRUE) {
    # Sample requested number of hands
    tbl <- tbl %>% 
        sample_n(size=nHandsPerSim*nSims, replace=TRUE, weight=numDup*value)
    # If grouping requested, group the hands by simulation
    if(isTRUE(groupBySim)) {
        # Add the simulation number
        tbl <- tbl %>%
            mutate(rn=row_number(), simNumber=1 + (rn-1) %/% nHandsPerSim) 
        # Create the result types
        tblCounts <- tbl %>%
            mutate(name=ifelse(betPlay==0, "pFold", name)) %>%
            count(simNumber, name) %>%
            pivot_wider(id_cols="simNumber", names_from="name", values_from="n", values_fill=0)
        tbl <- tbl %>%
            group_by(simNumber) %>%
            summarize(across(starts_with("res"), .fns=sum), nHands=n(), .groups="drop") %>%
            full_join(tblCounts, by="simNumber")
    }
    # Return the file
    tbl
}

# Simulate 100 hands 100,000 times
simMain100k100 <- simulateMainBet(nHandsPerSim=100, nSims=100000)

# 1. Overall summary statistics
summary(simMain100k100)
# 2. Summary of percentiles for overall results
quantile(simMain100k100$resAll, c(0, 0.005, 0.01, 0.025, 0.05, 0.25, 0.5, 0.75, 0.95, 0.975, 0.99, 0.995, 1))
# 3. Likelihood of win, lose, tie
simMain100k100 %>%
    mutate(resultType=case_when(resAll>0 ~ "win", resAll<0~"lose", TRUE~"tie")) %>%
    group_by(resultType) %>%
    summarize(n=n(), evResAll=mean(resAll), .groups="drop") %>%
    mutate(pctSims=n/sum(n))

```
  
Data containing bonus values by hand number are created:  
```{r, fig.height=9, fig.width=9}

# Create bonus payouts
tblBonusByHand <- tblAllTypes %>%
    mutate(handNum=row_number()) %>%
    left_join(select(handValues, handRank, wildPay), by=c("wType"="handRank")) %>%
    left_join(select(handValues, handRank, naturalPay), by=c("nType"="handRank")) %>%
    left_join(select(mapHands, origHand, mapHand), by=c("handNum"="origHand")) %>%
    mutate(bonusPay=pmax(wildPay, naturalPay)) %>%
    select(handNum, mapHand, everything())
tblBonusByHand

# Create counts by mapped hand and bonus payout
tblBonusMapHand <- tblBonusByHand %>%
    count(mapHand, bonusPay)
tblBonusMapHand
tblBonusMapHand %>% 
    group_by(bonusPay) %>% 
    summarize(nHands=sum(n)) %>% 
    mutate(pct=nHands/sum(nHands), ev=pct*bonusPay) %>%
    arrange(desc(bonusPay)) %>%
    bind_rows(colSums(.)) %>%
    mutate(bonusPay=ifelse(row_number()==n(), NA, bonusPay))

```
  
A function is written to simulate all bets simultaneously:  
```{r, fig.height=9, fig.width=9}

# Simulations over 100 hands
set.seed(2023053014)

# Create the percentages for the mapping
tblBonusMapPct <- tblBonusMapHand %>%
    group_by(mapHand) %>%
    mutate(pct=n/sum(n)) %>%
    ungroup()
tblBonusMapPct

# Confirm that the maximum mapping is two
tblBonusMapPct %>%
    filter(pct != 1) %>%
    count(mapHand, sort=TRUE)

# Function for running simulation
simulateAllBets <- function(tbl=tblPlayStrategy, 
                            tblBonus=tblBonusMapPct,
                            nHandsPerSim, 
                            nSims, 
                            groupBySim=TRUE
                            ) {
    # Pull the requested number of hands and attach the row number
    tbl <- tbl %>% 
        sample_n(size=nHandsPerSim*nSims, replace=TRUE, weight=numDup*value) %>%
        mutate(rn=row_number())
    # For each hand pulled, select associated bonus values
    tbl <- tbl %>% 
        left_join(tblBonusMapPct, by=c("handNum"="mapHand"), multiple="all")
    # Pull all unique values
    tblUq <- tbl %>% filter(pct==1)
    # Pull all non-unique values and select 1
    tblDup <- tbl %>% filter(pct!=1) %>% group_by(rn) %>% sample_n(1, replace=FALSE, weight=pct) %>% ungroup()
    # Put back together in proper order
    tbl <- bind_rows(tblUq, tblDup) %>% 
        arrange(rn) %>%
        rename(resBonus=bonusPay)
    # If grouping requested, group the hands by simulation
    if(isTRUE(groupBySim)) {
        # Add the simulation number
        tbl <- tbl %>%
            mutate(rn=row_number(), simNumber=1 + (rn-1) %/% nHandsPerSim) 
        # Create the result types
        tblCounts <- tbl %>%
            mutate(name=ifelse(betPlay==0, "pFold", name)) %>%
            count(simNumber, name) %>%
            pivot_wider(id_cols="simNumber", names_from="name", values_from="n", values_fill=0)
        tbl <- tbl %>%
            group_by(simNumber) %>%
            summarize(across(starts_with("res"), .fns=sum), nHands=n(), .groups="drop") %>%
            full_join(tblCounts, by="simNumber")
    }
    # Return the file
    tbl
}

# Simulate 100 hands 100,000 times
simAll100k100 <- simulateAllBets(nHandsPerSim=100, nSims=100000)

# 1. Overall summary statistics
summary(simAll100k100)
# 2. Summary of percentiles for main bet and bonus bet
quantile(simAll100k100$resAll, c(0, 0.005, 0.01, 0.025, 0.05, 0.25, 0.5, 0.75, 0.95, 0.975, 0.99, 0.995, 1))
quantile(simAll100k100$resBonus, c(0, 0.005, 0.01, 0.025, 0.05, 0.25, 0.5, 0.75, 0.95, 0.975, 0.99, 0.995, 1))
# 3. Likelihood of win, lose, tie given 1:1 ratio of main to bonus
simAll100k100 %>%
    mutate(resultType=case_when(1*resAll+resBonus>0 ~ "win", 1*resAll+resBonus<0~"lose", TRUE~"tie")) %>%
    group_by(resultType) %>%
    summarize(n=n(), evResAll=mean(resAll), evResBonus=mean(resBonus), .groups="drop") %>%
    mutate(pctSims=n/sum(n))
# 4. Correlation of bonus and main bet outcomes
cor(simAll100k100$resAll, simAll100k100$resBonus)
cor(simAll100k100$resAll, simAll100k100$resBonus, method="kendall")
simAll100k100 %>%
    filter(resBonus <= 250) %>%
    mutate(resAllRound=round(resAll, -1), resBonusRound=round(resBonus, -1)) %>%
    count(resAllRound, resBonusRound) %>%
    ggplot(aes(x=resBonusRound, y=resAllRound)) + 
    geom_point(aes(size=n)) + 
    geom_smooth(method="lm", aes(weight=n)) +
    labs(title="Results of 100,000 simulation of 100 hands", 
         subtitle="(excludes simulations with bonus outcome > 250)", 
         x="Result of 100 bonus (rounded to nearest 10)", 
         y="Result of 100 main (rounded to nearest 10)"
         ) + 
    scale_size_continuous("Number\nof sims")

```
  
An additional simulation is run with data returned:  
```{r, fig.height=9, fig.width=9}

# Simulations over 100 hands
set.seed(2023053115)

# Simulate 100 hands 10,000 times
simAll10k100 <- simulateAllBets(nHandsPerSim=100, nSims=10000, groupBySim = FALSE)

# Simulate betting progression
simAll10kRes <- simAll10k100 %>%
    mutate(sim=1 + (row_number()-1) %/% 100, 
           hn=row_number()-100*(sim-1), 
           resMain=case_when(resAll>0~"win", resAll==0~"tie", resAll<0~"loss", TRUE~"error"), 
           txtBonus=case_when(resBonus>0~"win", resBonus==0~"tie", resBonus<0~"loss", TRUE~"error")
           ) %>%
    group_by(sim) %>%
    mutate(betMain=ifelse(row_number()<=2 | lag(resMain)=="loss" | lag(resMain, 2)=="loss", 10, 20), 
           betBonus=ifelse(row_number()<=2 | lag(txtBonus)=="loss" | lag(txtBonus, 2)=="loss", 5, 10), 
           wlMain=betMain*resAll, 
           wlBonus=betBonus*resBonus
           ) %>%
    select(sim, resBlind, resAnte, resPlay, resAll, resBonus, wlMain, wlBonus, betMain, betBonus) %>%
    summarize(across(where(is.numeric), sum))
    
# 1. Overall summary statistics
summary(simAll10kRes)
# 2. Summary of percentiles for main bet and bonus bet
quantile(simAll10kRes$wlMain, c(0, 0.005, 0.01, 0.025, 0.05, 0.25, 0.5, 0.75, 0.95, 0.975, 0.99, 0.995, 1))
quantile(simAll10kRes$wlBonus, c(0, 0.005, 0.01, 0.025, 0.05, 0.25, 0.5, 0.75, 0.95, 0.975, 0.99, 0.995, 1))
quantile(simAll10kRes$wlMain+simAll10kRes$wlBonus, 
         c(0, 0.005, 0.01, 0.025, 0.05, 0.25, 0.5, 0.75, 0.95, 0.975, 0.99, 0.995, 1)
         )
# 3. Likelihood of win, lose, tie
simAll10kRes %>%
    mutate(resultType=case_when(wlMain+wlBonus>0 ~ "win", wlMain+wlBonus<0~"lose", TRUE~"tie")) %>%
    group_by(resultType) %>%
    summarize(n=n(), evMain=mean(wlMain), evBonus=mean(wlBonus), .groups="drop") %>%
    mutate(pctSims=n/sum(n))
# 4. Correlation of bonus and main bet outcomes
cor(simAll10kRes$wlMain, simAll10kRes$wlBonus)
cor(simAll10kRes$wlMain, simAll10kRes$wlBonus, method="kendall")
simAll10kRes %>%
    filter(wlBonus <= 2500) %>%
    mutate(resAllRound=round(wlMain, -2), resBonusRound=round(wlBonus, -2)) %>%
    count(resAllRound, resBonusRound) %>%
    ggplot(aes(x=resBonusRound, y=resAllRound)) + 
    geom_point(aes(size=n)) + 
    geom_smooth(method="lm", aes(weight=n)) +
    labs(title="Results of 10,000 simulation of 100 hands", 
         subtitle="(excludes simulations with bonus outcome > 2500)", 
         x="Result of 100 bonus (rounded to nearest 100)", 
         y="Result of 100 main (rounded to nearest 100)"
         ) + 
    scale_size_continuous("Number\nof sims")

```
  
The average bet sizes by simulation are also explored:  
```{r, fig.height=9, fig.width=9}

# EV by simulation and bet type
simAll10KSummary <- simAll10kRes %>%
    mutate(bonusPct=wlBonus/betBonus, mainPct=wlMain/betMain)
simAll10KSummary %>%
    select(-sim) %>%
    summarize(across(where(is.numeric), mean)) %>%
    mutate(bonusPct2=wlBonus/betBonus, mainPct2=wlMain/betMain)
simAll10KSummary %>%
    select(sim, bonusPct, mainPct) %>%
    pivot_longer(cols=-c(sim)) %>%
    ggplot(aes(x=value)) + 
    geom_histogram(data=~filter(., value<5), bins=100, fill="lightblue") + 
    geom_text(data=~filter(., value>=5) %>% group_by(name) %>% summarize(nSims=n()), 
              aes(x=1, y=500, label=paste0("Excludes simulations\nwith EV>500% (", nSims, ")")), 
              hjust=0, 
              size=2.5
              ) +
    facet_wrap(~c("bonusPct"="EV of bonus bets", "mainPct"="EV of main bets")[name]) + 
    geom_vline(xintercept=0, lty=2, color="red") + 
    labs(title="Percent EV of bets over 10,000 simulations, each of 100 hands", 
         x="Percent EV", 
         y="# Simulations"
         )

# EV by simulation (excludes EV > 5x)
simAll10kRes %>%
    mutate(bonusPct=round(2*wlBonus/betBonus, 1)/2, mainPct=round(2*wlMain/betMain, 1)/2) %>%
    count(bonusPct, mainPct) %>%
    filter(bonusPct<5) %>%
    ggplot(aes(x=bonusPct, y=mainPct)) + 
    geom_point(aes(size=n)) + 
    geom_smooth(method="lm", aes(weight=n)) + 
    labs(title="EV by bet type",
         subtitle="Excludes simulations with bonus EV over 500%",
         x="EV of bonus bets (rounded to nearest 5%)",
         y="EV of main bets (rounded to nearest 5%)"
         ) + 
    scale_size_continuous("# Sims")

```
  
The minimum and maximum per session are also explored:  
```{r, fig.height=9, fig.width=9}

simAll10kCumulative <- simAll10k100 %>%
    mutate(sim=1 + (row_number()-1) %/% 100, 
           hn=row_number()-100*(sim-1)
           ) %>%
    group_by(sim) %>%
    mutate(cumAll=cumsum(resAll), cumBonus=cumsum(resBonus), cumTotal=15*cumAll+5*cumBonus) %>%
    ungroup()
simAll10kCumulative

# Calculate highs and lows by simulation
simAll10kCumulative %>%
    select(sim, cumAll, cumBonus, cumTotal) %>%
    group_by(sim) %>%
    summarize(across(starts_with("cum"), .fns=list(min=min, max=max))) %>%
    pivot_longer(cols=-sim) %>%
    mutate(betType=str_split_i(name, pattern="_", i=1), 
           betMetric=str_split_i(name, pattern="_", i=2)
           ) %>%
    filter(betType=="cumTotal") %>%
    arrange(value) %>%
    group_by(betMetric) %>%
    mutate(idx=row_number()) %>%
    ungroup() %>%
    ggplot(aes(x=idx, y=value)) + 
    geom_point() + 
    facet_wrap(~betMetric, scales="free_y") + 
    labs(y="Cumulative extreme", 
         x="Simulation (sorted from low to high)", 
         title="Extreme by simulation (cumulative max and cumulative min)", 
         subtitle="Assumes 15*resAll + 5*resBonus"
         )

```
  
The minimum vs. final result is also plotted:
```{r, fig.height=9, fig.width=9}

# Minimum vs. final result
simAll10kCumulative %>%
    select(sim, cumAll, cumBonus, cumTotal) %>%
    group_by(sim) %>%
    summarize(across(starts_with("cum"), .fns=list(min=min, last=last))) %>%
    pivot_longer(cols=-sim) %>%
    mutate(betType=str_split_i(name, pattern="_", i=1), 
           betMetric=str_split_i(name, pattern="_", i=2)
           ) %>%
    pivot_wider(id_cols=c("sim", "betType"), names_from="betMetric", values_from="value") %>%
    filter((betType %in% c("cumAll", "cumBonus") & last < 1000) | (betType=="cumTotal" & last < 10000)) %>%
    mutate(betType=ifelse(betType=="cumAll", "cumMain", betType)) %>%
    ggplot(aes(x=min, y=last)) + 
    geom_point() + 
    geom_smooth(method="lm") +
    facet_wrap(~stringr::str_replace(betType, "cum", ""), scales="free") + 
    labs(y="Final after 100 hands", 
         x="Cumulative minimum during 100 hands", 
         title="Extreme by simulation (cumulative max and cumulative min)", 
         subtitle="Total calculated as 15*Main + 5*Bonus", 
         caption="Extreme positive outlier simulations removed"
         )

```
  
