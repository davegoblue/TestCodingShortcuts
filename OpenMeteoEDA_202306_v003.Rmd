---
title: "Open Meteo Weather Exploration"
author: "davegoblue"
date: "2023-09-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache.lazy=FALSE)
```

## Background
Open-Meteo maintains an [API for historical weather](https://open-meteo.com/en/docs/historical-weather-api) that allows for non-commercial usage of historical weather data maintained by the website.

This file builds on _v001 and _v002 to run exploratory analysis on some historical weather data.

## Functions and Libraries
The exploration process uses tidyverse, ranger, several generic custom functions, and several functions specific to Open Meteo processing. First, tidyverse, ranger, and the generic functions are loaded:  
```{r}

library(tidyverse) # tidyverse functionality is included throughout
library(ranger) # predict() does not work on ranger objects unless ranger has been called

source("./Generic_Added_Utility_Functions_202105_v001.R") # Basic functions

```
  
Next, specific functions written in _v001 are copied:  
```{r}

# Helper function for reading a partial CSV file
partialCSVRead <- function(loc, firstRow=1L, lastRow=+Inf, col_names=TRUE, ...) {
    
    # FUNCTION arguments
    # loc: file location
    # firstRow: first row that is relevant to the partial file read (whether header line or data line)
    # last Row: last row that is relevant to the partial file read (+Inf means read until last line of file)
    # col_names: the col_names parameter passed to readr::read_csv
    #            TRUE means header=TRUE (get column names from file, read data starting on next line)
    #            FALSE means header=FALSE (auto-generate column names, read data starting on first line)
    #            character vector means use these as column names (read data starting on first line)
    # ...: additional arguments passed to read_csv

    # Read the file and return
    # skip: rows to be skipped are all those prior to firstRow
    # n_max: maximum rows read are lastRow-firstRow, with an additional data row when col_names is not TRUE
    readr::read_csv(loc, 
                    col_names=col_names,
                    skip=firstRow-1, 
                    n_max=lastRow-firstRow+ifelse(isTRUE(col_names), 0, 1), 
                    ...
                    )
    
}


# Get the break points for gaps in a vector (e.g., 0, 3, 5:8, 20 has break points 0, 3, 5, 20 and 0, 3, 8, 30)
vecGaps <- function(x, addElements=c(), sortUnique=TRUE) {
    
    if(length(addElements)>0) x <- c(addElements, x)
    if(isTRUE(sortUnique)) x <- unique(sort(x))
    list("starts"=c(x[is.na(lag(x)) | x-lag(x)>1], +Inf), 
         "ends"=x[is.na(lead(x)) | lead(x)-x>1]
         )
    
}


# Find the break points in a single file
flatFileGaps <- function(loc) {

    which(stringr::str_length(readLines(loc))==0) %>% vecGaps(addElements=0)
    
}


# Read all relevant data as CSV with header
readMultiCSV <- function(loc, col_names=TRUE, ...) {

    gaps <- flatFileGaps(loc)
    
    lapply(seq_along(gaps$ends), 
           FUN=function(x) partialCSVRead(loc, 
                                          firstRow=gaps$ends[x]+1, 
                                          lastRow=gaps$starts[x+1]-1, 
                                          col_names=col_names, 
                                          ...
                                          )
           )
    
}


# Create URL with specified parameters for downloading data from Open Meteo
openMeteoURLCreate <- function(mainURL="https://archive-api.open-meteo.com/v1/archive", 
                               lat=45, 
                               lon=-90, 
                               startDate=paste(year(Sys.Date())-1, "01", "01", sep="-"), 
                               endDate=paste(year(Sys.Date())-1, "12", "31", sep="-"), 
                               hourlyMetrics=NULL, 
                               dailyMetrics=NULL,
                               tz="GMT", 
                               ...
                               ) {
    
    # Create formatted string
    fString <- paste0(mainURL, 
                      "?latitude=", 
                      lat, 
                      "&longitude=", 
                      lon, 
                      "&start_date=", 
                      startDate, 
                      "&end_date=", 
                      endDate
                      )
    if(!is.null(hourlyMetrics)) fString <- paste0(fString, "&hourly=", hourlyMetrics)
    if(!is.null(dailyMetrics)) fString <- paste0(fString, "&daily=", dailyMetrics)
    
    # Return the formatted string
    paste0(fString, "&timezone=", stringr::str_replace(tz, "/", "%2F"), ...)
    
}


# Helper function to simplify entry of parameters for Open Meteo download requests
helperOpenMeteoURL <- function(cityName=NULL,
                               lat=NULL,
                               lon=NULL,
                               hourlyMetrics=NULL,
                               hourlyIndices=NULL,
                               hourlyDesc=tblMetricsHourly,
                               dailyMetrics=NULL,
                               dailyIndices=NULL,
                               dailyDesc=tblMetricsDaily,
                               startDate=NULL, 
                               endDate=NULL, 
                               tz=NULL,
                               ...
                               ) {
    
    # Convert city to lat/lon if lat/lon are NULL
    if(is.null(lat) | is.null(lon)) {
        if(is.null(cityName)) stop("\nMust provide lat/lon or city name available in maps::us.cities\n")
        cityData <- maps::us.cities %>% tibble::as_tibble() %>% filter(name==cityName)
        if(nrow(cityData)!=1) stop("\nMust provide city name that maps uniquely to maps::us.cities$name\n")
        lat <- cityData$lat[1]
        lon <- cityData$long[1]
    }
    
    # Get hourly metrics by index if relevant
    if(is.null(hourlyMetrics) & !is.null(hourlyIndices)) {
        hourlyMetrics <- hourlyDesc %>% slice(hourlyIndices) %>% pull(metric)
        hourlyMetrics <- paste0(hourlyMetrics, collapse=",")
        cat("\nHourly metrics created from indices:", hourlyMetrics, "\n\n")
    }
    
    # Get daily metrics by index if relevant
    if(is.null(dailyMetrics) & !is.null(dailyIndices)) {
        dailyMetrics <- dailyDesc %>% slice(dailyIndices) %>% pull(metric)
        dailyMetrics <- paste0(dailyMetrics, collapse=",")
        cat("\nDaily metrics created from indices:", dailyMetrics, "\n\n")
    }
    
    # Use default values from OpenMeteoURLCreate() for startDate, endDate, and tz if passed as NULL
    if(is.null(startDate)) startDate <- eval(formals(openMeteoURLCreate)$startDate)
    if(is.null(endDate)) endDate <- eval(formals(openMeteoURLCreate)$endDate)
    if(is.null(tz)) tz <- eval(formals(openMeteoURLCreate)$tz)
    
    # Create and return URL
    openMeteoURLCreate(lat=lat,
                       lon=lon, 
                       startDate=startDate, 
                       endDate=endDate, 
                       hourlyMetrics=hourlyMetrics, 
                       dailyMetrics=dailyMetrics, 
                       tz=tz,
                       ...
                       )
    
}


# Read JSON data returned from Open Meteo
readOpenMeteoJSON <- function(js, mapDaily=tblMetricsDaily, mapHourly=tblMetricsHourly) {
    
    # FUNCTION arguments: 
    # js: JSON list returned by download from Open-Meteo
    # mapDaily: mapping file for daily metrics
    # mapHourly: mapping file for hourly metrics
    
    # Get the object and names
    jsObj <- jsonlite::read_json(js, simplifyVector = TRUE)
    nms <- jsObj %>% names()
    cat("\nObjects in JSON include:", paste(nms, collapse=", "), "\n\n")
    
    # Set default objects as NULL
    tblDaily <- NULL
    tblHourly <- NULL
    tblUnitsDaily <- NULL
    tblUnitsHourly <- NULL
    
    # Get daily and hourly as tibble if relevant
    if("daily" %in% nms) tblDaily <- jsObj$daily %>% tibble::as_tibble() %>% omProcessDaily()
    if("hourly" %in% nms) tblHourly <- jsObj$hourly %>% tibble::as_tibble() %>% omProcessHourly()
    
    # Helper function for unit conversions
    helperMetricUnit <- function(x, mapper, desc=NULL) {
        if(is.null(desc)) 
            desc <- as.list(match.call())$x %>% 
                deparse() %>% 
                stringr::str_replace_all(pattern=".*\\$", replacement="")
        x %>% 
            tibble::as_tibble() %>% 
            pivot_longer(cols=everything()) %>% 
            left_join(mapper, by=c("name"="metric")) %>% 
            mutate(value=stringr::str_replace(value, "\u00b0", "deg ")) %>% 
            mutate(metricType=desc) %>% 
            select(metricType, everything())
    }
    
    # Get the unit descriptions
    if("daily_units" %in% nms) tblUnitsDaily <- helperMetricUnit(jsObj$daily_units, mapDaily)
    if("hourly_units" %in% nms) tblUnitsHourly <- helperMetricUnit(jsObj$hourly_units, mapHourly)
    if(is.null(tblUnitsDaily) & !is.null(tblUnitsHourly)) tblUnits <- tblUnitsHourly
    else if(!is.null(tblUnitsDaily) & is.null(tblUnitsHourly)) tblUnits <- tblUnitsDaily
    else if(!is.null(tblUnitsDaily) & !is.null(tblUnitsHourly)) 
        tblUnits <- bind_rows(tblUnitsHourly, tblUnitsDaily)
    else tblUnits <- NULL
    
    # Put everything else together
    tblDescription <- jsObj[setdiff(nms, c("hourly", "hourly_units", "daily", "daily_units"))] %>%
        tibble::as_tibble()
    
    # Return the list objects
    list(tblDaily=tblDaily, tblHourly=tblHourly, tblUnits=tblUnits, tblDescription=tblDescription)
    
}


# Return Open meteo metadata in prettified format
prettyOpenMeteoMeta <- function(df, extr="tblDescription") {
    if("list" %in% class(df)) df <- df[[extr]]
    for(name in names(df)) {
        cat("\n", name, ": ", df %>% pull(name), sep="")
    }
    cat("\n\n")
}


# Process Open Meteo daily data
omProcessDaily <- function(tbl, extr="tblDaily") {
    if("list" %in% class(tbl)) tbl <- tbl[[extr]]
    tbl %>% mutate(date=lubridate::ymd(time)) %>% select(date, everything())
}


# Process Open meteo hourly data
omProcessHourly <- function(tbl, extr="tblHourly") {
    if("list" %in% class(tbl)) tbl <- tbl[[extr]]
    tbl %>% 
        mutate(origTime=time, 
               time=lubridate::ymd_hm(time), 
               date=lubridate::date(time), 
               hour=lubridate::hour(time)
               ) %>% 
        select(time, date, hour, everything())
}


# Simple predictive model for categorical variable
simpleOneVarPredict <- function(df, 
                                tgt, 
                                prd, 
                                dfTest=NULL,
                                nPrint=30, 
                                showPlot=TRUE, 
                                returnData=TRUE
                                ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame or tibble with key elements (training data set)
    # tgt: target variable
    # prd: predictor variable
    # dfTest: test dataset for applying predictions
    # nPrint: maximum number of lines of confusion matrix to print
    #         0 means do not print any summary statistics
    # showPlot: boolean, should overlap plot be created and shown?
    
    # Counts of predictor to target variable
    dfPred <- df %>%
        group_by(across(all_of(c(prd, tgt)))) %>%
        summarize(n=n(), .groups="drop") %>%
        arrange(across(all_of(prd)), desc(n)) %>%
        group_by(across(all_of(prd))) %>%
        mutate(correct=row_number()==1, predicted=first(get(tgt))) %>%
        ungroup()

    # Confusion matrix and accuracy
    dfConf <- dfPred %>%
        group_by(across(all_of(c(tgt, "correct")))) %>%
        summarize(n=sum(n), .groups="drop") %>%
        pivot_wider(id_cols=tgt, names_from=correct, values_from=n, values_fill=0) %>%
        mutate(n=`TRUE`+`FALSE`, 
               pctCorrect=`TRUE`/n, 
               pctNaive=1/(nrow(.)), 
               lift=pctCorrect/pctNaive-1
               )
    
    # Overall confusion matrix
    dfConfAll <- dfConf %>%
        summarize(nMax=max(n), across(c(`FALSE`, `TRUE`, "n"), sum)) %>%
        mutate(pctCorrect=`TRUE`/n, 
               pctNaive=nMax/n, 
               lift=pctCorrect/pctNaive-1, 
               nBucket=length(unique(dfPred[[prd]]))
               )
    
    # Print confusion matrices
    if(nPrint > 0) {
        cat("\nAccuracy by target subgroup (training data):\n")
        dfConf %>% print(n=nPrint)
        cat("\nOverall Accuracy (training data):\n")
        dfConfAll %>% print(n=nPrint)
    }
    
    # Plot of overlaps
    if(isTRUE(showPlot)) {
        p1 <- dfPred %>%
            group_by(across(c(all_of(tgt), "predicted", "correct"))) %>%
            summarize(n=sum(n), .groups="drop") %>%
            ggplot(aes(x=get(tgt), y=predicted)) + 
            labs(x="Actual", 
                 y="Predicted", 
                 title=paste0("Training data - Actual vs. predicted ", tgt), 
                 subtitle=paste0("(using ", prd, ")")
                 ) + 
            geom_text(aes(label=n)) + 
            geom_tile(aes(fill=correct), alpha=0.25)
        print(p1)
    }
    
    # Create metrics for test dataset if requested
    if(!is.null(dfTest)) {
        # Get maximum category from training data
        mostPredicted <- count(dfPred, predicted, wt=n) %>% slice(1) %>% pull(predicted)
        # Get mapping of metric to prediction
        dfPredict <- dfPred %>% 
            group_by(across(all_of(c(prd, "predicted")))) %>% 
            summarize(n=sum(n), .groups="drop")
        # Create predictions for test data
        dfPredTest <- dfTest %>%
            select(all_of(c(prd, tgt))) %>%
            left_join(select(dfPredict, -n)) %>%
            replace_na(list(predicted=mostPredicted)) %>%
            group_by(across(all_of(c(prd, tgt, "predicted")))) %>%
            summarize(n=n(), .groups="drop") %>%
            mutate(correct=(get(tgt)==predicted))
        # Create confusion statistics for test data
        dfConfTest <- dfPredTest %>%
            group_by(across(all_of(c(tgt, "correct")))) %>%
            summarize(n=sum(n), .groups="drop") %>%
            pivot_wider(id_cols=tgt, names_from=correct, values_from=n, values_fill=0) %>%
            mutate(n=`TRUE`+`FALSE`, 
                   pctCorrect=`TRUE`/n, 
                   pctNaive=1/(nrow(.)), 
                   lift=pctCorrect/pctNaive-1
                   )
        # Overall confusion matrix for test data
        dfConfAllTest <- dfConfTest %>%
            summarize(nMax=max(n), across(c(`FALSE`, `TRUE`, "n"), sum)) %>%
            mutate(pctCorrect=`TRUE`/n, 
                   pctNaive=nMax/n, 
                   lift=pctCorrect/pctNaive-1, 
                   nBucket=length(unique(dfConfTest[[prd]]))
               )
        # Print confusion matrices
        if(nPrint > 0) {
            cat("\nAccuracy by target subgroup (testing data):\n")
            dfConfTest %>% print(n=nPrint)
            cat("\nOverall Accuracy (testing data):\n")
            dfConfAllTest %>% print(n=nPrint)
            }
    } else {
        dfPredTest <- NULL
        dfConfTest <- NULL
        dfConfAllTest <- NULL
        
    }
    
    # Return data if requested
    if(isTRUE(returnData)) list(dfPred=dfPred, 
                                dfConf=dfConf, 
                                dfConfAll=dfConfAll, 
                                dfPredTest=dfPredTest, 
                                dfConfTest=dfConfTest, 
                                dfConfAllTest=dfConfAllTest
                                )
    
}


# Fit a single predictor to a single categorical variable
simpleOneVarFit <- function(df, 
                            tgt, 
                            prd, 
                            rankType="last", 
                            naMethod=TRUE
                            ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame or tibble with key elements (training data set)
    # tgt: target variable
    # prd: predictor variable
    # rankType: method for breaking ties of same n, passed to base::rank as ties.method=
    # naMethod: method for handling NA in ranks, passed to base::rank as na.last=
    
    # Counts of predictor to target variable, and associated predictions
    df %>%
        group_by(across(all_of(c(prd, tgt)))) %>%
        summarize(n=n(), .groups="drop") %>%
        arrange(across(all_of(prd)), desc(n), across(all_of(tgt))) %>%
        group_by(across(all_of(prd))) %>%
        mutate(rankN=n()+1-rank(n, ties.method=rankType, na.last=naMethod)) %>%
        arrange(across(all_of(prd)), rankN) %>%
        ungroup()

}


# Create categorical predictions mapper
simpleOneVarMapper <- function(df, tgt, prd) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame or tibble from SimpleOneVarFit()
    # tgt: target variable
    # prd: predictor variable
    
    # Get the most common actual results
    dfCommon <- df %>% count(across(all_of(tgt)), wt=n, sort=TRUE)
    
    # Get the predictions
    dfPredictor <- df %>%
        group_by(across(all_of(prd))) %>%
        filter(row_number()==1) %>%
        select(all_of(c(prd, tgt))) %>%
        ungroup()
    
    list(dfPredictor=dfPredictor, dfCommon=dfCommon)
    
}


# Map the categorical predictions to unseen data
simpleOneVarApplyMapper <- function(df, 
                                    tgt,
                                    prd, 
                                    mapper, 
                                    mapperDF="dfPredictor", 
                                    mapperDefault="dfCommon",
                                    prdName="predicted"
                                    ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame containing prd for predicting tgt
    # tgt: target variable in df
    # prd: predictor variable in df
    # mapper: mapping list from sinpleOneVarMapper()
    # mapperDF: element that can be used to merge mappings
    # mapperDefault: element that can be used for NA resulting from merging mapperDF
    # prdName: name for the prediction variable
    
    # Extract the mapper and default value
    vecRename <- c(prdName) %>% purrr::set_names(tgt)
    dfMap <- mapper[[mapperDF]] %>% select(all_of(c(prd, tgt))) %>% colRenamer(vecRename=vecRename)
    chrDefault <- mapper[[mapperDefault]] %>% slice(1) %>% pull(tgt)
    
    # Merge mappings to df
    df %>%
        left_join(dfMap, by=prd) %>%
        replace_na(list("predicted"=chrDefault))
    
}


# Create confusion matrix data for categorical predictions
simpleOneVarConfusionData <- function(df, 
                                      tgtOrig,
                                      tgtPred, 
                                      otherVars=c(),
                                      weightBy="n"
                                      ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame from simpleOneVarApplyMapper()
    # tgtOrig: original target variable name in df
    # tgtPred: predicted target variable name in df
    # otherVars: other variables to be kept (will be grouping variables)
    # weightBy: weighting variable for counts in df (NULL means count each row of df as 1)
    
    # Confusion matrix data creation
    df %>%
        group_by(across(all_of(c(tgtOrig, tgtPred, otherVars)))) %>%
        summarize(n=if(!is.null(weightBy)) sum(get(weightBy)) else n(), .groups="drop") %>%
        mutate(correct=get(tgtOrig)==get(tgtPred))
    
}


# Print and plot confusion matrix for categorical predictions
simpleOneVarConfusionReport <- function(df, 
                                        tgtOrig,
                                        tgtPred, 
                                        otherVars=c(), 
                                        printConf=TRUE,
                                        printConfOrig=printConf, 
                                        printConfPred=printConf,
                                        printConfOverall=printConf, 
                                        plotConf=TRUE, 
                                        plotDesc="",
                                        nBucket=NA, 
                                        predictorVarName="", 
                                        returnData=FALSE
                                        ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame from simpleOneVarConfusionData()
    # tgtOrig: original target variable name in df
    # tgtPred: predicted target variable name in df
    # otherVars: other variables to be kept (will be grouping variables) - NOT IMPLEMENTED
    # printConf: boolean, should confusion matrix data be printed? Applies to all three
    # printConfOrig: boolean, should confusion data be printed based on original target variable?
    # printConfPred: boolean, should confusion data be printed based on predicted target variable?
    # printConfOverall: boolean, should overall confusion data be printed?
    # plotConf: boolean, should confusion overlap data be plotted?
    # plotDesc: descriptive label to be included in front of plot title
    # nBucket: number of buckets used for prediction (pass from previous data)
    # predictorVarName: variable name to be included in chart description
    # returnData: boolean, should the confusion matrices be returned?
    
    # Confusion data based on original target variable
    if(isTRUE(printConfOrig) | isTRUE(returnData)) {
        dfConfOrig <- df %>%
            group_by(across(all_of(c(tgtOrig)))) %>%
            summarize(right=sum(n*correct), wrong=sum(n)-right, n=sum(n), .groups="drop") %>%
            mutate(pctRight=right/n, pctNaive=n/(sum(n)), lift=pctRight/pctNaive-1)
    }

    # Confusion data based on predicted target variable
    if(isTRUE(printConfPred) | isTRUE(returnData)) {
        dfConfPred <- df %>%
            group_by(across(all_of(c(tgtPred)))) %>%
            summarize(right=sum(n*correct), wrong=sum(n)-right, n=sum(n), .groups="drop") %>%
            mutate(pctRight=right/n)
    }

    # Overall confusion data
    if(isTRUE(printConfOverall) | isTRUE(returnData)) {
        maxNaive <- df %>%
            group_by(across(all_of(tgtOrig))) %>%
            summarize(n=sum(n), .groups="drop") %>%
            arrange(desc(n)) %>%
            slice(1) %>%
            pull(n)
        dfConfOverall <- df %>%
            summarize(right=sum(n*correct), wrong=sum(n)-right, n=sum(n), .groups="drop") %>%
            mutate(maxN=maxNaive, pctRight=right/n, pctNaive=maxN/n, lift=pctRight/pctNaive-1, nBucket=nBucket)
    }
    
    # Confusion report based on original target variable
    if(isTRUE(printConfOrig)) {
        cat("\nConfusion data based on original target variable:", tgtOrig, "\n")
        dfConfOrig %>%
            print(n=50)
    }

    # Confusion report based on predicted target variable
    if(isTRUE(printConfPred)) {
        cat("\nConfusion data based on predicted target variable:", tgtPred, "\n")
        dfConfPred %>%
            print(n=50)
    }
    
    # Overall confusion matrix
    if(isTRUE(printConfOverall)) {
        cat("\nOverall confusion matrix\n")
        dfConfOverall %>%
            print(n=50)
    }
    
    # Plot of overlaps
    if(isTRUE(plotConf)) {
        p1 <- df %>%
            group_by(across(all_of(c(tgtOrig, tgtPred, "correct")))) %>%
            summarize(n=sum(n), .groups="drop") %>%
            ggplot(aes(x=get(tgtOrig), y=get(tgtPred))) + 
            labs(x="Actual", 
                 y="Predicted", 
                 title=paste0(plotDesc, "Actual vs. predicted ", tgtOrig), 
                 subtitle=paste0("(using ", predictorVarName, ")")
                 ) + 
            geom_text(aes(label=n)) + 
            geom_tile(aes(fill=correct), alpha=0.25)
        print(p1)
    }
    
    # Return data if requested
    if(isTRUE(returnData)) list(dfConfOrig=dfConfOrig, dfConfPred=dfConfPred, dfConfOverall=dfConfOverall)
    
}


# Process for chaining predictor, applier, and confusion matrix for categorical variables
simpleOneVarChain <- function(df,
                              tgt,
                              prd,
                              mapper=NULL, 
                              rankType="last", 
                              naMethod=TRUE, 
                              printReport=TRUE, 
                              plotDesc="",
                              returnData=TRUE, 
                              includeConfData=FALSE
                              ) {

    # FUNCTION ARGUMENTS:
    # df: data frame or tibble with key elements (training or testing data set)
    # tgt: target variable
    # prd: predictor variable
    # mapper: mapping file to be applied for predictions (NULL means create from simpleOneVarApply())
    # rankType: method for breaking ties of same n, passed to base::rank as ties.method=
    # naMethod: method for handling NA in ranks, passed to base::rank as na.last=    
    # printReport: boolean, should the confusion report data and plot be printed?
    # plotDesc: descriptive label to be included in front of plot title
    # returnData: boolean, should data elements be returned?
    # includeConfData: boolean, should confusion data be returned?
    
    # Create the summary of predictor-target-n
    dfFit <- simpleOneVarFit(df, tgt=tgt, prd=prd, rankType=rankType, naMethod=naMethod)     

    # Create the mapper if it does not already exist
    if(is.null(mapper)) mapper <- simpleOneVarMapper(dfFit, tgt=tgt, prd=prd)
    
    # Apply mapper to data
    dfApplied <- simpleOneVarApplyMapper(dfFit, tgt=tgt, prd=prd, mapper=mapper)

    # Create confusion data
    dfConfusion <- simpleOneVarConfusionData(dfApplied, tgtOrig=tgt, tgtPred="predicted")
    
    # Create confusion report if requested
    if(isTRUE(printReport) | isTRUE(includeConfData)) {
        dfConfReport <- simpleOneVarConfusionReport(df=dfConfusion, 
                                                    tgtOrig=tgt, 
                                                    tgtPred="predicted", 
                                                    nBucket=length(unique(dfApplied[[prd]])), 
                                                    predictorVarName=prd, 
                                                    printConf=printReport, 
                                                    plotConf=printReport,
                                                    plotDesc=plotDesc,
                                                    returnData=includeConfData
                                                    )
    }
    
    # Return data if requested
    if(isTRUE(returnData)) {
        ret <- list(dfFit=dfFit, mapper=mapper, dfApplied=dfApplied, dfConfusion=dfConfusion)
        if(isTRUE(includeConfData)) ret<-c(ret, list(dfConfData=dfConfReport))
        ret
    }
    
}


# Adds a train-test component for single variable predictions
simpleOneVarTrainTest <- function(dfTrain,
                                  dfTest,
                                  tgt,
                                  prd,
                                  rankType="last", 
                                  naMethod=TRUE, 
                                  printReport=FALSE, 
                                  includeConfData=TRUE, 
                                  returnData=TRUE
                              ) {

    # FUNCTION ARGUMENTS:
    # dfTrain: data frame or tibble with key elements (training data set)
    # dfTest: data frame or tibble with key elements (testing data set)
    # tgt: target variable
    # prd: predictor variable
    # rankType: method for breaking ties of same n, passed to base::rank as ties.method=
    # naMethod: method for handling NA in ranks, passed to base::rank as na.last=    
    # printReport: boolean, should the confusion report data and plot be printed?
    # includeConfData: boolean, should confusion data be returned?
    # returnData: boolean, should data elements be returned?
    
    # Fit the training data
    tmpTrain <- simpleOneVarChain(df=dfTrain, 
                                  tgt=tgt, 
                                  prd=prd,
                                  rankType=rankType,
                                  naMethod=naMethod,
                                  printReport=printReport,
                                  plotDesc="Training data: ",
                                  returnData=TRUE,
                                  includeConfData=includeConfData
                                  )
    
    # Fit the testing data
    tmpTest <- simpleOneVarChain(df=dfTest, 
                                 tgt=tgt, 
                                 prd=prd,
                                 mapper=tmpTrain$mapper,
                                 rankType=rankType,
                                 naMethod=naMethod,
                                 printReport=printReport,
                                 plotDesc="Testing data: ",
                                 returnData=TRUE,
                                 includeConfData=includeConfData
                                 )
    
    # Return data if requested
    if(isTRUE(returnData)) list(tmpTrain=tmpTrain, tmpTest=tmpTest)
    
}


# Plot the means by cluster and variable for a k-means object
plotClusterMeans <- function(km, nrow=NULL, ncol=NULL, scales="fixed") {

    # FUNCTION ARGUMENTS
    # km: object returned by stats::kmeans(...)
    # nrow: number of rows for faceting (NULL means default)
    # ncol: number of columns for faceting (NULL means default)
    # scales: passed to facet_wrap as scales=scales
    
    # Assess clustering by dimension
    p1 <- km$centers %>%
        tibble::as_tibble() %>%
        mutate(cluster=row_number()) %>%
        pivot_longer(cols=-c(cluster)) %>%
        ggplot(aes(x=fct_reorder(name, 
                                 value, 
                                 .fun=function(a) ifelse(length(a)==2, a[2]-a[1], diff(range(a)))
                                 ), 
                   y=value
                   )
               ) + 
        geom_point(aes(color=factor(cluster))) + 
        scale_color_discrete("Cluster") + 
        facet_wrap(~factor(cluster), nrow=nrow, ncol=ncol, scales=scales) +
        labs(title=paste0("Cluster means (kmeans, centers=", nrow(km$centers), ")"), 
             x="Metric", 
             y="Cluster mean"
             ) + 
        geom_hline(yintercept=median(km$centers), lty=2) +
        coord_flip()
    print(p1)
    
}


# Plot percentage by cluster
plotClusterPct <- function(df, km, keyVars, nRowFacet=1, printPlot=TRUE) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame initially passed to stats::kmeans(...)
    # km: object returned by stats::kmeans(...)
    # keyVars: character vector of length 1 (y-only, x will be cl) or length 2 (x, y, cl will facet)
    # nRowFacet: number of rows for facetting (only relevant if length(keyVars) is 2)
    # printPlot: boolean, should plot be printed? (if not true, plot will be returned)
    
    # Check length of keyVars
    if(!(length(keyVars) %in% c(1, 2))) stop("\nArgument keyVars must be length-1 or length-2\n")
    
    p1 <- df %>%
        mutate(cl=factor(km$cluster)) %>%
        group_by(across(c(all_of(keyVars), "cl"))) %>%
        summarize(n=n(), .groups="drop") %>%
        group_by(across(all_of(keyVars))) %>%
        mutate(pct=n/sum(n)) %>%
        ungroup() %>%
        ggplot() + 
        scale_fill_continuous(low="white", high="green") + 
        labs(title=paste0("Percentage by cluster (kmeans with ", nrow(km$centers), " centers)"), 
             x=ifelse(length(keyVars)==1, "Cluster", keyVars[1]), 
             y=ifelse(length(keyVars)==1, keyVars[1], keyVars[2])
             )
    if(length(keyVars)==1) p1 <- p1 + geom_tile(aes(fill=pct, x=cl, y=get(keyVars[1])))
    if(length(keyVars)==2) {
        p1 <- p1 + 
            geom_tile(aes(fill=pct, x=get(keyVars[1]), y=get(keyVars[2]))) + 
            facet_wrap(~cl, nrow=nRowFacet)
    }
    
    if(isTRUE(printPlot)) print(p1)
    else return(p1)
    
}


# Run k-means (or use passed k-means object) and plot centers and percentages of observations
runKMeans <- function(df, 
                      km=NULL,
                      vars=NULL, 
                      centers=2, 
                      nStart=1L, 
                      iter.max=10L, 
                      seed=NULL, 
                      plotMeans=FALSE,
                      nrowMeans=NULL,
                      plotPct=NULL, 
                      nrowPct=1, 
                      returnKM=is.null(km)
                      ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame for clustering
    # km: k-means object (will shut off k-means processing and run as plot-only)
    # vars: variables to be used for clustering (NULL means everything in df)
    # centers: number of centers
    # nStart: passed to kmeans
    # iter.max: passed to kmeans
    # seed: seed to be set (if NULL, no seed is set)
    # plotMeans: boolean, plot variable means by cluster?
    # nrowMeans: argument passed as nrow for faceting rows in plotClusterMeans() - NULL is default ggplot2
    # plotPct: list of character vectors to be passed sequentially as keyVars to plotClusterPct()
    #          NULL means do not run
    #          pctByCluster=list(c("var1"), c("var2", "var3")) will run plotting twice
    # nrowPct: argument for faceting number of rows in plotClusterPct()
    # returnKM: boolean, should the k-means object be returned?
    
    # Set seed if requested
    if(!is.null(seed)) set.seed(seed)
    
    # Get the variable names if passed as NULL
    if(is.null(vars)) vars <- names(df)
    
    # Run the k-means process if the object has not been passed
    if(is.null(km)) {
        km <- df %>%
            select(all_of(vars)) %>% 
            kmeans(centers=centers, iter.max=iter.max, nstart=nStart)
    }

    # Assess clustering by dimension if requested
    if(isTRUE(plotMeans)) plotClusterMeans(km, nrow=nrowMeans)
    if(!is.null((plotPct))) 
        for(ctr in 1:length(plotPct)) 
            plotClusterPct(df=df, km=km, keyVars=plotPct[[ctr]], nRowFacet=nrowPct)
    
    # Return the k-means object
    if(isTRUE(returnKM)) return(km)
    
}


# Assign points to closest center of a passed k-means object
assignKMeans <- function(km, df, returnAllDistanceData=FALSE) {
    
    # FUNCTION ARGUMENTS:
    # km: a k-means object
    # df: data frame or tibble
    # returnAllDistanceData: boolean, should the distance data and clusters be returned?
    #                        TRUE returns a data frame with distances as V1, V2, ..., and cluster as cl
    #                        FALSE returns a vector of cluster assignments as integers
    
    # Select columns from df to match km
    df <- df %>% select(all_of(colnames(km$centers)))
    if(!all.equal(names(df), colnames(km$centers))) stop("\nName mismatch in clustering and frame\n")
    
    # Create the distances and find clusters
    distClust <- sapply(seq_len(nrow(km$centers)), 
                        FUN=function(x) sqrt(rowSums(sweep(as.matrix(df), 
                                                           2, 
                                                           t(as.matrix(km$centers[x,,drop=FALSE]))
                                                           )**2
                                                     )
                                             )
                        ) %>% 
        as.data.frame() %>% 
        tibble::as_tibble() %>% 
        mutate(cl=apply(., 1, which.min))
    
    # Return the proper file
    if(isTRUE(returnAllDistanceData)) return(distClust)
    else return(distClust$cl)
    
}


```

As well, specific functions from _v002 are copied:  
```{r}

runSimpleRF <- function(df, yVar, xVars=NULL, ...) {

    # FUNCTION ARGUMENTS:
    # df: data frame containing observations
    # yVar: variable to be predicted (numeric for regression, categorical for classification)
    # xVars: predictor variables (NULL means everything in df except for yVar)
    # ...: other arguments passed to ranger::ranger
    
    # Create xVars if passed as NULL
    if(is.null(xVars)) xVars <- setdiff(names(df), yVar)
    
    # Simple random forest model
    ranger::ranger(as.formula(paste0(yVar, "~", paste0(xVars, collapse="+"))), 
                   data=df[, c(yVar, xVars)], 
                   ...
                   )
    
}

plotRFImportance <- function(rf, 
                             impName="variable.importance", 
                             divBy=1000, 
                             plotTitle=NULL, 
                             plotData=TRUE, 
                             returnData=!isTRUE(plotData)
                             ) {
    
    # FUNCTION ARGUMENTS:
    # rf: output list from random forest with an element for importance
    # impName: name of the element to extract from rf
    # divBy: divisor for the importance variable
    # plotTitle: title for plot (NULL means use default)
    # plotData: boolean, should the importance plot be created and printed?
    # returnData: boolean, should the processed data be returned?
    
    # Create title if not provided
    if(is.null(plotTitle)) plotTitle <- "Importance for simple random forest"

    # Create y-axis label
    yAxisLabel="Variable Importance"
    if(!isTRUE(all.equal(divBy, 1))) yAxisLabel <- paste0(yAxisLabel, " (", divBy, "s)")
    
    # Create variable importance
    df <- rf[[impName]] %>% 
        as.data.frame() %>% 
        purrr::set_names("imp") %>% 
        rownames_to_column("metric") %>% 
        tibble::as_tibble() 
    
    # Create and print plot if requested
    if(isTRUE(plotData)) {
        p1 <- df %>%
            ggplot(aes(x=fct_reorder(metric, imp), y=imp/divBy)) + 
            geom_col(fill="lightblue") + 
            labs(x=NULL, y=yAxisLabel, title=plotTitle) +
            coord_flip()
        print(p1)
    }
    
    # Return data if requested
    if(isTRUE(returnData)) return(df)
    
}

predictRF <- function(rf, df, newCol="pred", predsOnly=FALSE) {
    
    # FUNCTION ARGUMENTS:
    # rf: a trained random forest model
    # df: data frame for adding predictions
    # newCol: name for new column to be added to df
    # predsOnly: boolean, should only the vector of predictions be returned?
    #            if FALSE, a column named newCol is added to df, with df returned

    # Performance on holdout data
    preds <- predict(rf, data=df)$predictions
    
    # Return just the predictions if requested otherwise add as final column to df
    if(isTRUE(predsOnly)) return(preds)
    else {
        df[newCol] <- preds
        return(df)
    }
    
}

# Update for continuous variables
reportAccuracy <- function(df, 
                           trueCol, 
                           predCol="pred", 
                           reportAcc=TRUE, 
                           rndReport=2, 
                           useLabel="requested data",
                           returnAcc=!isTRUE(reportAcc), 
                           reportR2=FALSE
                           ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame containing actual and predictions
    # trueCol: column containing true value
    # predCol: column containing predicted value
    # reportAcc: boolean, should accuracy be reported (printed to output)?
    # rndReport: number of significant digits for reporting (will be converted to percentage first)
    # useLabel: label for data to be used in reporting
    # returnAcc: boolean, should the accuracy be returned 
    #            return value is not converted to percentage, not rounded
    # reportR2: boolean, should accuracy be calculated as R-squared?
    #           (default FALSE measures as categorical)
    
    # Continuous or categorical reporting
    if(isTRUE(reportR2)) {
        tc <- df %>% pull(get(trueCol))
        pc <- df %>% pull(get(predCol))
        mseNull <- mean((tc-mean(tc))**2)
        msePred <- mean((tc-pc)**2)
        r2 <- 1 - msePred/mseNull
        if(isTRUE(reportAcc)) 
            cat("\nR-squared of ", 
                useLabel, 
                " is: ", 
                round(100*r2, rndReport), 
                "% (RMSE ",
                round(sqrt(msePred), 2), 
                " vs. ", 
                round(sqrt(mseNull), 2),
                " null)\n", 
                sep=""
                )
        acc <- c("mseNull"=mseNull, "msePred"=msePred, "r2"=r2)
    } else {
        acc <- mean(df[trueCol]==df[predCol])
        if(isTRUE(reportAcc)) 
            cat("\nAccuracy of ", useLabel, " is: ", round(100*acc, rndReport), "%\n", sep="")    
    }
    
    # Return accuracy statistic if requested
    if(isTRUE(returnAcc)) return(acc)
    
}

# Update for automated rounding
plotConfusion <- function(df, 
                          trueCol, 
                          predCol="pred", 
                          useTitle=NULL,
                          useSub=NULL, 
                          plotCont=FALSE, 
                          rndTo=NULL,
                          rndBucketsAuto=100,
                          nSig=NULL,
                          refXY=FALSE
                          ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame containing actual and predictions
    # trueCol: column containing true value
    # predCol: column containing predicted value
    # useTitle: title to be used for chart (NULL means create from trueCol)
    # useSub: subtitle to be used for chart (NULL means none)
    # plotCont: boolean, should plotting assume continuous variables?
    #           (default FALSE assumes confusion plot for categorical variables)
    # rndTo: every number in x should be rounded to the nearest rndTo
    #        NULL means no rounding (default)
    #        -1L means make an estimate based on data
    # rndBucketsAuto: integer, if rndTo is -1L, about how many buckets are desired for predictions?
    # nSig: number of significant digits for automatically calculated rounding parameter
    #       (NULL means calculate exactly)
    # refXY: boolean, should a reference line for y=x be included? (relevant only for continuous)
    
    # Create title if not supplied
    if(is.null(useTitle)) useTitle <- paste0("Predicting ", trueCol)

    # Function auto-round returns vector as-is when rndTo is NULL and auto-rounds when rndTo is -1L
    df <- df %>%
        mutate(across(all_of(c(trueCol, predCol)), 
                      .fns=function(x) autoRound(x, rndTo=rndTo, rndBucketsAuto=rndBucketsAuto, nSig=nSig)
                      )
               )
    
    # Create base plot (applicable to categorical or continuous variables)
    # Use x as true and y as predicted, for more meaningful geom_smooth() if continuous
    # Flip coordinates if categorical
    p1 <- df %>%
        group_by(across(all_of(c(trueCol, predCol)))) %>%
        summarize(n=n(), .groups="drop") %>%
        ggplot(aes(y=get(predCol), x=get(trueCol))) + 
        labs(y="Predicted", x="Actual", title=useTitle, subtitle=useSub)
        
    # Update plot as appropriate
    if(isTRUE(plotCont)) {
        p1 <- p1 +
            geom_point(aes(size=n), alpha=0.5) + 
            scale_size_continuous("# Obs") +
            geom_smooth(aes(weight=n), method="lm")
        if(isTRUE(refXY)) p1 <- p1 + geom_abline(slope=1, intercept=0, lty=2, color="red")
    } else {
        p1 <- p1 + 
            geom_tile(aes(fill=n)) + 
            geom_text(aes(label=n), size=2.5) +
            coord_flip() +
            scale_fill_continuous("", low="white", high="green")
    }
    
    # Output plot
    print(p1)
    
}

runFullRF <- function(dfTrain, 
                      yVar, 
                      xVars, 
                      dfTest=dfTrain,
                      useLabel="test data",
                      useSub=NULL, 
                      isContVar=FALSE,
                      rndTo=NULL,
                      rndBucketsAuto=100,
                      nSig=NULL,
                      refXY=FALSE,
                      makePlots=TRUE,
                      plotImp=makePlots,
                      plotConf=makePlots,
                      returnData=FALSE, 
                      ...
                      ) {
    
    # FUNCTION ARGUMENTS:
    # dfTrain: training data
    # yVar: dependent variable
    # xVars: column(s) containing independent variables
    # dfTest: test dataset for applying predictions
    # useLabel: label to be used for reporting accuracy
    # useSub: subtitle to be used for confusion chart (NULL means none)
    # isContVar: boolean, is the variable continuous? (default FALSE means categorical)
    # rndTo: every number in x should be rounded to the nearest rndTo
    #        NULL means no rounding (default)
    #        -1L means make an estimate based on data
    # rndBucketsAuto: integer, if rndTo is -1L, about how many buckets are desired for predictions?
    # nSig: number of significant digits for automatically calculated rounding parameter
    #       (NULL means calculate exactly)    
    # refXY: boolean, should a reference line for y=x be included? (relevant only for continuous)
    # makePlots: boolean, should plots be created for variable importance and confusion matrix?
    # plotImp: boolean, should variable importance be plotted? (default is makePlots)
    # plotConf: boolean, should confusion matrix be plotted? (default is makePlots)
    # returnData: boolean, should data be returned?
    # ...: additional parameters to pass to runSimpleRF(), which are then passed to ranger::ranger()

    # 1. Run random forest using impurity for importance
    rf <- runSimpleRF(df=dfTrain, yVar=yVar, xVars=xVars, importance="impurity", ...)

    # 2. Create, and optionally plot, variable importance
    rfImp <- plotRFImportance(rf, plotData=plotImp, returnData=TRUE)

    # 3. Predict on test dataset
    tstPred <- predictRF(rf=rf, df=dfTest)

    # 4. Report on accuracy (updated for continuous or categorical)
    rfAcc <- reportAccuracy(tstPred, 
                            trueCol=yVar, 
                            rndReport=3, 
                            useLabel=useLabel, 
                            reportR2=isTRUE(isContVar),
                            returnAcc=TRUE
                            )

    # 5. Plot confusion data (updated for continuous vs. categorical) if requested
    if(isTRUE(plotConf)) {
        plotConfusion(tstPred, 
                      trueCol=yVar, 
                      useSub=useSub, 
                      plotCont=isTRUE(isContVar), 
                      rndTo=rndTo, 
                      rndBucketsAuto=rndBucketsAuto,
                      nSig=nSig,
                      refXY=refXY
                      )
    }
    
    #6. Return data if requested
    if(isTRUE(returnData)) return(list(rf=rf, rfImp=rfImp, tstPred=tstPred, rfAcc=rfAcc))
    
}

runPartialImportanceRF <- function(dfTrain, 
                                   yVar, 
                                   dfTest,
                                   impDB=dfImp,
                                   nImp=+Inf,
                                   otherX=c(),
                                   isContVar=TRUE, 
                                   useLabel=keyLabel, 
                                   useSub=stringr::str_to_sentence(keyLabel), 
                                   rndTo=NULL,
                                   rndBucketsAuto=50,
                                   nSig=NULL,
                                   refXY=FALSE,
                                   makePlots=FALSE, 
                                   returnElem=c("rfImp", "rfAcc")
                                   ) {
    
    # FUNCTION ARGUMENTS
    # dfTrain: training data
    # yVar: y variable in dfTrain
    # dfTest: test data
    # impDB: tibble containing variable importance by dependent variable
    # nImp: use the top nImp variables by variable importance
    # otherX: include these additional x variables
    # isContVar: boolean, is this a continuous variable (regression)? FALSE means classification
    # useLabel: label for description
    # useSub: label for plot
    # rndTo: controls the rounding parameter for plots, passed to runFullRF 
    #        (NULL means no rounding)
    #        -1L means make an estimate based on underlying data
    # rndBucketsAuto: integer, if rndTo is -1L, about how many buckets are desired for predictions?
    # nSig: number of significant digits for automatically calculated rounding parameter
    #       (NULL means calculate exactly)    
    # refXY: controls the reference line parameter for plots, passed to runFullRF
    # makePlots: boolean, should plots be created?
    # returnElem: character vector of list elements to be returned

    runFullRF(dfTrain=dfTrain, 
              yVar=yVar, 
              xVars=unique(c(impDB %>% filter(n<=nImp, src==yVar) %>% pull(metric), otherX)), 
              dfTest=dfTest, 
              isContVar = isContVar, 
              useLabel=useLabel, 
              useSub=useSub, 
              rndTo=rndTo,
              rndBucketsAuto=rndBucketsAuto,
              nSig=nSig,
              refXY=refXY,
              makePlots=makePlots,
              returnData=TRUE
              )[returnElem]
    
}

autoRound <- function(x, rndTo=-1L, rndBucketsAuto=100, nSig=NULL) {

    # FUNCTION ARGUMENTS
    # x: vector to be rounded
    # rndTo: every number in x should be rounded to the nearest rndTo
    #        NULL means no rounding
    #        -1L means make an estimate based on data (default)
    # rndBucketsAuto: integer, if rndTo is -1L, about how many buckets are desired for predictions?
    # nSig: number of significant digits for automatically calculated rounding parameter
    #       (NULL means calculate exactly)
    
    # If rndTo is passed as NULL, return x as-is
    if(is.null(rndTo)) return(x)
    
    # If rndTo is passed as -1L, make an estimate for rndTo
    if(isTRUE(all.equal(-1L, rndTo))) {
        # Get the number of unique values in x
        nUq <- length(unique(x))
        # If the number of unique values is no more than 150% of rndToBucketsAuto, return as-is
        if(nUq <= 1.5*rndBucketsAuto) return(x)
        # Otherwise, calculate a value for rndTo
        rndTo <- diff(range(x)) / rndBucketsAuto
        # Truncate to requested number of significant digits
        if(!is.null(nSig)) rndTo <- signif(rndTo, digits=nSig)
    }
    
    # Return the rounded vector if it was not already returned
    return(round(x/rndTo)*rndTo)

}


```

Key mapping tables for available metrics are also copied:  
```{r}

hourlyMetrics <- "temperature_2m,relativehumidity_2m,dewpoint_2m,apparent_temperature,pressure_msl,surface_pressure,precipitation,rain,snowfall,cloudcover,cloudcover_low,cloudcover_mid,cloudcover_high,shortwave_radiation,direct_radiation,direct_normal_irradiance,diffuse_radiation,windspeed_10m,windspeed_100m,winddirection_10m,winddirection_100m,windgusts_10m,et0_fao_evapotranspiration,weathercode,vapor_pressure_deficit,soil_temperature_0_to_7cm,soil_temperature_7_to_28cm,soil_temperature_28_to_100cm,soil_temperature_100_to_255cm,soil_moisture_0_to_7cm,soil_moisture_7_to_28cm,soil_moisture_28_to_100cm,soil_moisture_100_to_255cm"
dailyMetrics <- "weathercode,temperature_2m_max,temperature_2m_min,apparent_temperature_max,apparent_temperature_min,precipitation_sum,rain_sum,snowfall_sum,precipitation_hours,sunrise,sunset,windspeed_10m_max,windgusts_10m_max,winddirection_10m_dominant,shortwave_radiation_sum,et0_fao_evapotranspiration"

hourlyDescription <- "Air temperature at 2 meters above ground\nRelative humidity at 2 meters above ground\nDew point temperature at 2 meters above ground\nApparent temperature is the perceived feels-like temperature combining wind chill factor, relative humidity and solar radiation\nAtmospheric air pressure reduced to mean sea level (msl) or pressure at surface. Typically pressure on mean sea level is used in meteorology. Surface pressure gets lower with increasing elevation.\nAtmospheric air pressure reduced to mean sea level (msl) or pressure at surface. Typically pressure on mean sea level is used in meteorology. Surface pressure gets lower with increasing elevation.\nTotal precipitation (rain, showers, snow) sum of the preceding hour. Data is stored with a 0.1 mm precision. If precipitation data is summed up to monthly sums, there might be small inconsistencies with the total precipitation amount.\nOnly liquid precipitation of the preceding hour including local showers and rain from large scale systems.\nSnowfall amount of the preceding hour in centimeters. For the water equivalent in millimeter, divide by 7. E.g. 7 cm snow = 10 mm precipitation water equivalent\nTotal cloud cover as an area fraction\nLow level clouds and fog up to 2 km altitude\nMid level clouds from 2 to 6 km altitude\nHigh level clouds from 6 km altitude\nShortwave solar radiation as average of the preceding hour. This is equal to the total global horizontal irradiation\nDirect solar radiation as average of the preceding hour on the horizontal plane and the normal plane (perpendicular to the sun)\nDirect solar radiation as average of the preceding hour on the horizontal plane and the normal plane (perpendicular to the sun)\nDiffuse solar radiation as average of the preceding hour\nWind speed at 10 or 100 meters above ground. Wind speed on 10 meters is the standard level.\nWind speed at 10 or 100 meters above ground. Wind speed on 10 meters is the standard level.\nWind direction at 10 or 100 meters above ground\nWind direction at 10 or 100 meters above ground\nGusts at 10 meters above ground of the indicated hour. Wind gusts in CERRA are defined as the maximum wind gusts of the preceding hour. Please consult the ECMWF IFS documentation for more information on how wind gusts are parameterized in weather models.\nET0 Reference Evapotranspiration of a well watered grass field. Based on FAO-56 Penman-Monteith equations ET0 is calculated from temperature, wind speed, humidity and solar radiation. Unlimited soil water is assumed. ET0 is commonly used to estimate the required irrigation for plants.\nWeather condition as a numeric code. Follow WMO weather interpretation codes. See table below for details. Weather code is calculated from cloud cover analysis, precipitation and snowfall. As barely no information about atmospheric stability is available, estimation about thunderstorms is not possible.\nVapor Pressure Deificit (VPD) in kilopascal (kPa). For high VPD (>1.6), water transpiration of plants increases. For low VPD (<0.4), transpiration decreases\nAverage temperature of different soil levels below ground.\nAverage temperature of different soil levels below ground.\nAverage temperature of different soil levels below ground.\nAverage temperature of different soil levels below ground.\nAverage soil water content as volumetric mixing ratio at 0-7, 7-28, 28-100 and 100-255 cm depths.\nAverage soil water content as volumetric mixing ratio at 0-7, 7-28, 28-100 and 100-255 cm depths.\nAverage soil water content as volumetric mixing ratio at 0-7, 7-28, 28-100 and 100-255 cm depths.\nAverage soil water content as volumetric mixing ratio at 0-7, 7-28, 28-100 and 100-255 cm depths."
dailyDescription <- "The most severe weather condition on a given day\nMaximum and minimum daily air temperature at 2 meters above ground\nMaximum and minimum daily air temperature at 2 meters above ground\nMaximum and minimum daily apparent temperature\nMaximum and minimum daily apparent temperature\nSum of daily precipitation (including rain, showers and snowfall)\nSum of daily rain\nSum of daily snowfall\nThe number of hours with rain\nSun rise and set times\nSun rise and set times\nMaximum wind speed and gusts on a day\nMaximum wind speed and gusts on a day\nDominant wind direction\nThe sum of solar radiaion on a given day in Megajoules\nDaily sum of ET0 Reference Evapotranspiration of a well watered grass field"

# Create tibble for hourly metrics
tblMetricsHourly <- tibble::tibble(metric=hourlyMetrics %>% str_split_1(","), 
                                   description=hourlyDescription %>% str_split_1("\n")
                                   )
tblMetricsHourly %>% 
    print(n=50)

# Create tibble for daily metrics
tblMetricsDaily <- tibble::tibble(metric=dailyMetrics %>% str_split_1(","), 
                                  description=dailyDescription %>% str_split_1("\n")
                                   )
tblMetricsDaily

```

Core datasets (previously downloaded) are loaded, with explanatory variables added for future processing:  
```{r cache=TRUE}

# Read daily JSON file
nycOMDaily <- readOpenMeteoJSON("testOM_daily_nyc.json")
nycOMDaily
prettyOpenMeteoMeta(nycOMDaily)

# Read hourly JSON file
nycOMHourly <- readOpenMeteoJSON("testOM_hourly_nyc.json")
nycOMHourly
prettyOpenMeteoMeta(nycOMHourly)

# Create percentiles for numeric variables
nycTemp <- nycOMHourly$tblHourly %>%
    mutate(year=year(date), 
           month=factor(month.abb[lubridate::month(date)], levels=month.abb), 
           hour=lubridate::hour(time), 
           fct_hour=factor(hour), 
           tod=ifelse(hour>=7 & hour<=18, "Day", "Night"), 
           season=case_when(month %in% c("Mar", "Apr", "May") ~ "Spring", 
                            month %in% c("Jun", "Jul", "Aug") ~ "Summer", 
                            month %in% c("Sep", "Oct", "Nov") ~ "Fall", 
                            month %in% c("Dec", "Jan", "Feb") ~ "Winter", 
                            TRUE~"typo"
                            ), 
           todSeason=paste0(season, "-", tod), 
           tod=factor(tod, levels=c("Day", "Night")), 
           season=factor(season, levels=c("Spring", "Summer", "Fall", "Winter")), 
           todSeason=factor(todSeason, 
                            levels=paste0(rep(c("Spring", "Summer", "Fall", "Winter"), each=2), 
                                          "-", 
                                          c("Day", "Night")
                                          )
                            ),
           across(where(is.numeric), .fns=function(x) round(100*percent_rank(x)), .names="pct_{.col}")
           )

glimpse(nycTemp)
nycTemp %>% 
    count(year, month) %>% 
    ggplot(aes(y=factor(year), x=month)) + 
    geom_tile(aes(fill=n)) + 
    geom_text(aes(label=n), size=3) + 
    scale_fill_continuous("# Records", low="white", high="green") + 
    labs(title="Records by year and month", x=NULL, y=NULL)
nycTemp %>% count(todSeason, season, tod)
nycTemp %>% count(hour, fct_hour, tod) %>% print(n=30)
nycTemp %>% count(month, season)

```
  
```{r}

# Add random variables to dataset, then split in to test and train
set.seed(24020416)
nycTempRand <- nycTemp %>%
    mutate(pct_0005=sample(0:5, size=nrow(.), replace=TRUE),
           pct_0025=sample(0:25, size=nrow(.), replace=TRUE), 
           pct_0100=sample(0:100, size=nrow(.), replace=TRUE), 
           pct_0250=sample(0:250, size=nrow(.), replace=TRUE),
           pct_0500=sample(0:500, size=nrow(.), replace=TRUE), 
           pct_1000=sample(0:1000, size=nrow(.), replace=TRUE), 
           pct_2500=sample(0:2500, size=nrow(.), replace=TRUE), 
           pct_5000=sample(0:5000, size=nrow(.), replace=TRUE)
           )

# Split in to test and train data (3:1 split in favor of test)
idxTrain <- sort(sample(1:nrow(nycTempRand), size=round(0.75*nrow(nycTempRand)), replace=FALSE))
nycTempTrain <- nycTempRand[idxTrain, ]
nycTempTest <- nycTempRand[-idxTrain, ]

```

Holdout data are created from a succeeding year, and the function is tested on categorical variable month:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Create holdout data and labels
dfTrain <- filter(nycTempTrain, lubridate::year(date)<2022) %>% mutate(doy=yday(date))
dfTest <- filter(bind_rows(nycTempTest, nycTempTrain), lubridate::year(date)==2022) %>% mutate(doy=yday(date))
keyLabel <- "predictions based on pre-2022 training data applied to 2022 holdout dataset"

# Create set of relevant training variables
varsTrain <- nycTempTrain %>%
    select(starts_with("pct")) %>%
    select(-pct_hour, -pct_weathercode, -pct_year, -ends_with("0"), -ends_with("5")) %>%
    names()
varsTrain

rfMonth <- runFullRF(dfTrain=dfTrain, 
                     yVar="month", 
                     xVars=varsTrain, 
                     dfTest=dfTest, 
                     useLabel=keyLabel, 
                     useSub=stringr::str_to_sentence(keyLabel), 
                     returnData=TRUE
                     )

```
  
The function is tested on continuous variable temperature:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rfTemp2m <- runFullRF(dfTrain=dfTrain, 
                      yVar="temperature_2m", 
                      xVars=c(varsTrain[!str_detect(varsTrain, "pct_temp|apparent")], "month", "tod", "doy"), 
                      dfTest=dfTest, 
                      useLabel=keyLabel, 
                      useSub=stringr::str_to_sentence(keyLabel), 
                      isContVar=TRUE,
                      rndTo=-1L,
                      refXY=TRUE,
                      returnData=TRUE
                      )

```
  
The function is tested on continuous variable soil temperature:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rfSoil255 <- runFullRF(dfTrain=dfTrain, 
                       yVar="soil_temperature_100_to_255cm", 
                       xVars=c(varsTrain[!str_detect(varsTrain, "pct_soil_temp")], "month", "tod", "doy"), 
                       dfTest=dfTest, 
                       useLabel=keyLabel, 
                       useSub=stringr::str_to_sentence(keyLabel), 
                       isContVar=TRUE,
                       rndTo=-1L,
                       refXY=TRUE,
                       returnData=TRUE
                       )

```
  
Variable importance is extracted, and cumulative variance explained is explored:  
```{r, fig.height=9, fig.width=9}

dfImp <- map_dfr(list("month"=rfMonth, 
                      "temperature_2m"=rfTemp2m, 
                      "soil_temperature_100_to_255cm"=rfSoil255
                      ), 
                 .f=function(x) x$rfImp, 
                 .id="src"
                 ) %>% 
    arrange(src, -imp) %>% 
    group_by(src) %>%
    mutate(pct=imp/sum(imp), cspct=cumsum(pct), n=row_number()) %>%
    ungroup()
dfImp

dfImp %>%
    select(src, n, cspct) %>%
    bind_rows(group_by(., src) %>% filter(n==1) %>% mutate(n=0, cspct=0) %>% ungroup) %>%
    ggplot(aes(x=n, y=cspct)) +
    geom_line(aes(group=src, color=src)) + 
    labs(x="# Variables", y="Cumulative %", title="Cumulative Variance Explained vs. # Variables") + 
    scale_color_discrete("Dependent\nVariable")

```
  
Month is predicted using only the four top importance variables:
```{r, fig.height=9, fig.width=9, cache=TRUE}

runPartialImportanceRF(dfTrain=dfTrain, 
                       yVar="month", 
                       dfTest=dfTest, 
                       isContVar=FALSE,
                       impDB=dfImp,
                       nImp=4, 
                       makePlots=TRUE
                       )

```

Prediction accuracy is decreased by ~10% as predictors are limited to 4. A series of models are run, using a variable number of predictors:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Variable importance number of variables to explore
impNums <- c(1:10, 16, 25, nrow(filter(dfImp, src=="month")))

# Accuracy on holdout data
rpiMonth <- tibble::tibble(nImp=impNums, 
                           rfAcc=sapply(impNums, 
                                        FUN=function(x) runPartialImportanceRF(dfTrain=dfTrain, 
                                                                               yVar="month", 
                                                                               dfTest=dfTest, 
                                                                               isContVar=FALSE, 
                                                                               impDB=dfImp, 
                                                                               nImp=x, 
                                                                               makePlots=FALSE)[["rfAcc"]]
                                        )
                           )
rpiMonth

```
  
```{r, fig.height=9, fig.width=9}

# Plot of holdout accuracy vs. number of variables
rpiMonth %>%
    bind_rows(tibble::tibble(nImp=0, rfAcc=0)) %>%
    ggplot(aes(x=nImp, y=rfAcc)) + 
    geom_line() + 
    geom_point() + 
    labs(title="Accuracy on holdout data vs. number of predictors", 
         subtitle="Predicting month",
         y="Accuracy on holdout data", 
         x="# Predictors (selected in order of variable importance in full model)"
         ) + 
    lims(y=c(0, 1)) + 
    geom_hline(data=~filter(., rfAcc==max(rfAcc)), aes(yintercept=rfAcc), lty=2)

# Correlations
dfTrain %>% 
    select(all_of(varsTrain)) %>% 
    cor() %>% 
    as.data.frame() %>% 
    rownames_to_column("V1") %>% 
    tibble::tibble() %>% 
    pivot_longer(cols=-c(V1), names_to="V2") %>% 
    filter(V1 %in% pull(filter(dfImp, src=="month", n<=8), "metric"), 
           V2 %in% pull(filter(dfImp, src=="month", n<=8), "metric")
           ) %>% 
    ggplot(aes(x=fct_rev(V1), y=V2)) + 
    geom_tile(aes(fill=value)) + 
    geom_text(aes(label=round(value, 2))) + 
    scale_fill_gradient2(high="green") + 
    labs(title="Correlations of select predictors in training data", x=NULL, y=NULL)

```

Accuracy on holdout data is not monotonically increasing with number of predictors (sorted by original variable importance). Maximum accuracy is reached with ~7 predictors. Filtering or transforming to account for correlated predictors could be merited

Temperature is predicted using only the four top importance variables:
```{r, fig.height=9, fig.width=9, cache=TRUE}

runPartialImportanceRF(dfTrain=dfTrain, 
                       yVar="temperature_2m", 
                       dfTest=dfTest, 
                       isContVar=TRUE,
                       impDB=dfImp,
                       nImp=4, 
                       makePlots=TRUE, 
                       rndTo=-1L, 
                       refXY=TRUE
                       )

```

A series of models are run, using a variable number of predictors:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Variable importance number of variables to explore
impNums <- c(1:10, 16, 25, nrow(filter(dfImp, src=="temperature_2m")))

# Accuracy on holdout data
rpiTemp <- tibble::tibble(nImp=impNums, 
                          r2=sapply(impNums, 
                                    FUN=function(x) runPartialImportanceRF(dfTrain=dfTrain, 
                                                                           yVar="temperature_2m", 
                                                                           dfTest=dfTest, 
                                                                           isContVar=TRUE, 
                                                                           impDB=dfImp, 
                                                                           nImp=x, 
                                                                           makePlots=FALSE)[["rfAcc"]]["r2"]
                                    )
                          )
rpiTemp

```
  
```{r, fig.height=9, fig.width=9}

# Plot of holdout accuracy vs. number of variables
rpiTemp %>%
    bind_rows(tibble::tibble(nImp=0, r2=0)) %>%
    ggplot(aes(x=nImp, y=r2)) + 
    geom_line(data=~filter(., nImp>0)) + 
    geom_point(data=~filter(., nImp>0)) + 
    labs(title="R-squared on holdout data vs. number of predictors", 
         subtitle="Predicting temperature",
         y="R-squared on holdout data", 
         x="# Predictors (selected in order of variable importance in full model)"
         ) + 
    lims(y=c(NA, 1)) + 
    geom_hline(data=~filter(., r2==max(r2)), aes(yintercept=r2), lty=2)

```

Soil temperature is predicted using only the four top importance variables:
```{r, fig.height=9, fig.width=9, cache=TRUE}

runPartialImportanceRF(dfTrain=dfTrain, 
                       yVar="soil_temperature_100_to_255cm", 
                       dfTest=dfTest, 
                       isContVar=TRUE,
                       impDB=dfImp,
                       nImp=4, 
                       makePlots=TRUE, 
                       rndTo=-1L, 
                       refXY=TRUE
                       )

```

A series of models are run, using a variable number of predictors:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Variable importance number of variables to explore
impNums <- c(1:10, 16, 25, nrow(filter(dfImp, src=="soil_temperature_100_to_255cm")))

# Accuracy on holdout data
rpiSoil <- tibble::tibble(nImp=impNums, 
                          r2=sapply(impNums, 
                                    FUN=function(x) runPartialImportanceRF(dfTrain=dfTrain, 
                                                                           yVar="soil_temperature_100_to_255cm", 
                                                                           dfTest=dfTest, 
                                                                           isContVar=TRUE, 
                                                                           impDB=dfImp, 
                                                                           nImp=x, 
                                                                           makePlots=FALSE)[["rfAcc"]]["r2"]
                                    )
                          )
rpiSoil

```
  
```{r, fig.height=9, fig.width=9}

# Plot of holdout accuracy vs. number of variables
rpiSoil %>%
    bind_rows(tibble::tibble(nImp=0, r2=0)) %>%
    ggplot(aes(x=nImp, y=r2)) + 
    geom_line(data=~filter(., nImp>0)) + 
    geom_point(data=~filter(., nImp>0)) + 
    labs(title="R-squared on holdout data vs. number of predictors", 
         subtitle="Predicting deep soil temperature",
         y="R-squared on holdout data", 
         x="# Predictors (selected in order of variable importance in full model)"
         ) + 
    lims(y=c(NA, 1)) + 
    geom_hline(data=~filter(., r2==max(r2)), aes(yintercept=r2), lty=2)

```
  
Deep soil temperature is so seasonal that using the best predictor (day of year) drives slightly more accurate predictions than models using day of year and multiple other features

The function is tested on variable day of year, as an integer, without access to month:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rfDOYInt <- runFullRF(dfTrain=dfTrain, 
                      yVar="doy", 
                      xVars=c(varsTrain[!str_detect(varsTrain, "doy")], "tod"), 
                      dfTest=dfTest, 
                      useLabel=keyLabel, 
                      useSub=stringr::str_to_sentence(keyLabel), 
                      isContVar=TRUE,
                      rndTo=1,
                      refXY=TRUE,
                      returnData=TRUE
                      )

rfDOYInt$tstPred %>%
    group_by(month) %>%
    summarize(doyrmse=mean((pred-doy)**2)**0.5, n=n(), .groups="drop")

```
  
Not surprisingly, predictions for winter have high error, as there is little difference between day 360 and day 5. Predictions outside of winter are generally within 5-10 days, based primarily on soil characteristics

The function is tested on variable day of year, rounded to nearest 10 days and converted to factor, without access to month:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rfDOYFct <- runFullRF(dfTrain=dfTrain %>% filter(doy<=365) %>% mutate(doy=factor(10*round(doy/10))), 
                      yVar="doy", 
                      xVars=c(varsTrain[!str_detect(varsTrain, "doy")], "tod"), 
                      dfTest=dfTest %>% filter(doy<=365) %>% mutate(doy=factor(10*round(doy/10))), 
                      useLabel=keyLabel, 
                      useSub=stringr::str_to_sentence(keyLabel), 
                      isContVar=FALSE,
                      rndTo=NULL,
                      returnData=TRUE
                      )

rfDOYFct$tstPred %>%
    group_by(month) %>%
    summarize(doyacc=mean(doy==pred), 
              doy10acc=mean(abs(as.integer(as.character(doy))-as.integer(as.character(pred))) %in% c(0, 10, 360)),
              n=n(), 
              .groups="drop"
              )

```
  
Soil temperature and moisture patterns generally make day of year predictions accurate to within 10-20 days

Day of year is predicted using only the four top importance variables:
```{r, fig.height=9, fig.width=9, cache=TRUE}

dfImp <- map_dfr(list("month"=rfMonth, 
                      "temperature_2m"=rfTemp2m, 
                      "soil_temperature_100_to_255cm"=rfSoil255, 
                      "doy"=rfDOYFct
                      ), 
                 .f=function(x) x$rfImp, 
                 .id="src"
                 ) %>% 
    arrange(src, -imp) %>% 
    group_by(src) %>%
    mutate(pct=imp/sum(imp), cspct=cumsum(pct), n=row_number()) %>%
    ungroup()
dfImp

rfDOYpi <- runPartialImportanceRF(dfTrain=dfTrain %>% filter(doy<=365) %>% mutate(doy=factor(10*round(doy/10))), 
                                  yVar="doy", 
                                  dfTest=dfTest %>% filter(doy<=365) %>% mutate(doy=factor(10*round(doy/10))), 
                                  isContVar=FALSE,
                                  impDB=dfImp,
                                  nImp=4, 
                                  makePlots=TRUE, 
                                  returnElem=c("rfImp", "rfAcc", "tstPred")
                                  )

rfDOYpi$tstPred %>%
    group_by(month) %>%
    summarize(doyacc=mean(doy==pred), 
              doy10acc=mean(abs(as.integer(as.character(doy))-as.integer(as.character(pred))) %in% c(0, 10, 360)),
              n=n(), 
              .groups="drop"
              )

```

Restricting to the top 4 predictors still drives most predictions to within 10-20 days

A series of models are run, using a variable number of predictors:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Variable importance number of variables to explore
impNums <- c(1:10, 16, 25, nrow(filter(dfImp, src=="doy")))

# Accuracy on holdout data
rpiDOY <- tibble::tibble(nImp=impNums, 
                         rfAcc=sapply(impNums, 
                                      FUN=function(x) runPartialImportanceRF(dfTrain=dfTrain %>% 
                                                                                 filter(doy<=365) %>%
                                                                                 mutate(doy=factor(10*round(doy/10))),
                                                                             yVar="doy", 
                                                                             dfTest=dfTest %>% 
                                                                                 filter(doy<=365) %>%
                                                                                 mutate(doy=factor(10*round(doy/10))), 
                                                                             isContVar=FALSE, 
                                                                             impDB=dfImp, 
                                                                             nImp=x, 
                                                                             makePlots=FALSE
                                                                             )[["rfAcc"]]
                                      )
                         )
rpiDOY

```

  
```{r, fig.height=9, fig.width=9}

# Plot of holdout accuracy vs. number of variables
rpiDOY %>%
    bind_rows(tibble::tibble(nImp=0, rfAcc=0)) %>%
    ggplot(aes(x=nImp, y=rfAcc)) + 
    geom_line() + 
    geom_point() + 
    labs(title="Accuracy on holdout data vs. number of predictors", 
         subtitle="Predicting day of year, rounded to nearest 10, as factor",
         y="Accuracy on holdout data", 
         x="# Predictors (selected in order of variable importance in full model)"
         ) + 
    lims(y=c(0, 1)) + 
    geom_hline(data=~filter(., rfAcc==max(rfAcc)), aes(yintercept=rfAcc), lty=2)

```
  
Two soil temperature metrics (1.00m-2.55 m and 0.28m-1.00m) as a standalone drive accuracy nearly as high as including all 33 predictors

Soil metrics are especially predictive of time of year:  
```{r, fig.height=9, fig.width=9}

dfPlot <- nycTempTrain %>%
    bind_rows(nycTempTest) %>%
    arrange(time) %>%
    mutate(doy=lubridate::yday(time))

dfPlot %>%
    count(month, soil_temperature_28_to_100cm, soil_temperature_100_to_255cm) %>%
    ggplot(aes(x=soil_temperature_28_to_100cm, y=soil_temperature_100_to_255cm)) + 
    geom_point(aes(color=month, size=n)) + 
    labs(title="Soil temperature readings by month and year")

dfPlot %>%
    count(year, month, soil_temperature_28_to_100cm, soil_temperature_100_to_255cm) %>%
    ggplot(aes(x=soil_temperature_28_to_100cm, y=soil_temperature_100_to_255cm)) + 
    geom_point(aes(color=month, size=n)) + 
    facet_wrap(~year) + 
    labs(title="Soil temperature readings by month and year")

dfPlot %>%
    count(year, month, soil_temperature_28_to_100cm, soil_temperature_100_to_255cm) %>%
    ggplot(aes(x=soil_temperature_28_to_100cm, y=soil_temperature_100_to_255cm)) + 
    geom_point(aes(color=factor(year), size=n)) + 
    facet_wrap(~month) + 
    labs(title="Soil temperature readings by month and year") + 
    scale_color_discrete(NULL)

dfPlot %>%
    group_by(doy, year) %>%
    summarize(across(.cols=c(soil_temperature_28_to_100cm, soil_temperature_100_to_255cm), 
                     .fns=list(mean=mean, sd=sd)
                     ), 
              .groups="drop"
              ) %>%
    pivot_longer(cols=-c(year, doy)) %>%
    ggplot(aes(x=doy, y=value)) + 
    geom_line(aes(group=year, color=factor(year))) + 
    facet_wrap(~name) + 
    scale_color_discrete(NULL) + 
    labs(title="Mean and sd for hourly soil temperature readings by day of year", x="Day of Year", y=NULL)

```

Deep soil temperatures are stable over extended time periods and display a repeatable, highly seasonal pattern. This makes them ideal predictors for metrics such as month or day of year

In contrast, air temperature and dewpoint show more intraday variability and less association with day of year:  
```{r, fig.height=9, fig.width=9}

dfPlotTemp <- dfPlot %>%
    mutate(across(.cols=c(temperature_2m, dewpoint_2m), .fns=round))

dfPlotTemp %>%
    count(month, temperature_2m, dewpoint_2m) %>%
    ggplot(aes(x=temperature_2m, y=dewpoint_2m)) + 
    geom_point(aes(color=month, size=n)) + 
    labs(title="Temperature and dewpoint readings by month and year", 
         subtitle="Readings taken hourly, rounded to nearest 1 degree C"
         )

dfPlotTemp %>%
    count(year, month, temperature_2m, dewpoint_2m) %>%
    ggplot(aes(x=temperature_2m, y=dewpoint_2m)) + 
    geom_point(aes(color=factor(year), size=n)) + 
    facet_wrap(~month) + 
    labs(title="Temperature and dewpoint readings by month and year", 
         subtitle="Readings taken hourly, rounded to nearest 1 degree C"
         ) +
    scale_color_discrete(NULL)

dfPlotTemp %>%
    group_by(doy, year) %>%
    summarize(across(.cols=c(temperature_2m, dewpoint_2m), 
                     .fns=list(mean=mean, sd=sd)
                     ), 
              .groups="drop"
              ) %>%
    pivot_longer(cols=-c(year, doy)) %>%
    ggplot(aes(x=doy, y=value)) + 
    geom_line(aes(group=year, color=factor(year))) + 
    facet_wrap(~name) + 
    scale_color_discrete(NULL) + 
    labs(title="Mean and sd for hourly air temperature and dewpoint readings by day of year", 
         x="Day of Year", 
         y=NULL, 
         subtitle="Rounded to nearest 1 degree C"
         )

dfPlotTemp %>%
    group_by(doy, year) %>%
    summarize(across(.cols=c(temperature_2m, dewpoint_2m), 
                     .fns=list(mean=mean, sd=sd)
                     ), 
              .groups="drop"
              ) %>%
    pivot_longer(cols=-c(year, doy)) %>%
    group_by(name) %>%
    summarize(dailyMean=mean(value), dailySD=sd(value))

```

Soil moisture metrics are also explored:  
```{r, fig.height=9, fig.width=9}

dfPlot %>%
    count(month, soil_moisture_28_to_100cm, soil_moisture_100_to_255cm) %>%
    ggplot(aes(x=soil_moisture_28_to_100cm, y=soil_moisture_100_to_255cm)) + 
    geom_point(aes(color=month, size=n)) + 
    labs(title="Soil moisture readings by month and year")

dfPlot %>%
    count(year, month, soil_moisture_28_to_100cm, soil_moisture_100_to_255cm) %>%
    ggplot(aes(x=soil_moisture_28_to_100cm, y=soil_moisture_100_to_255cm)) + 
    geom_point(aes(color=month, size=n)) + 
    facet_wrap(~year) + 
    labs(title="Soil moisture readings by month and year")

dfPlot %>%
    count(year, month, soil_moisture_28_to_100cm, soil_moisture_100_to_255cm) %>%
    ggplot(aes(x=soil_moisture_28_to_100cm, y=soil_moisture_100_to_255cm)) + 
    geom_point(aes(color=factor(year), size=n)) + 
    facet_wrap(~month) + 
    labs(title="Soil moisture readings by month and year") + 
    scale_color_discrete(NULL)

dfPlot %>%
    group_by(doy, year) %>%
    summarize(across(.cols=c(soil_moisture_28_to_100cm, soil_moisture_100_to_255cm), 
                     .fns=list(mean=mean, sd=sd)
                     ), 
              .groups="drop"
              ) %>%
    pivot_longer(cols=-c(year, doy)) %>%
    ggplot(aes(x=doy, y=value)) + 
    geom_line(aes(group=year, color=factor(year))) + 
    facet_wrap(~name) + 
    scale_color_discrete(NULL) + 
    labs(title="Mean and sd for hourly soil moisture readings by day of year", x="Day of Year", y=NULL)

```

Deep soil moisture is less reproducibly seasonal, making it a less effective predictor of time of year

The function is tested on categorical variable year:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Create holdout data and labels
dfTrain_v2 <- filter(nycTempTrain, lubridate::year(date)<2023) %>% mutate(doy=yday(date), fct_year=factor(year))
dfTest_v2 <- filter(nycTempTest, lubridate::year(date)<2023) %>% mutate(doy=yday(date), fct_year=factor(year))
keyLabel_v2 <- "predictions based on training data applied to holdout dataset"

rfYear <- runFullRF(dfTrain=dfTrain_v2, 
                     yVar="fct_year", 
                     xVars=varsTrain, 
                     dfTest=dfTest_v2, 
                     useLabel=keyLabel_v2, 
                     useSub=stringr::str_to_sentence(keyLabel_v2), 
                     returnData=TRUE
                     )

dfImp <- map_dfr(list("month"=rfMonth, 
                      "temperature_2m"=rfTemp2m, 
                      "soil_temperature_100_to_255cm"=rfSoil255, 
                      "doy"=rfDOYFct,
                      "fct_year"=rfYear
                      ), 
                 .f=function(x) x$rfImp, 
                 .id="src"
                 ) %>% 
    arrange(src, -imp) %>% 
    group_by(src) %>%
    mutate(pct=imp/sum(imp), cspct=cumsum(pct), n=row_number()) %>%
    ungroup()
dfImp

```
  
There is both daily stability and annual variation in the combined metrics such that seeing ~70% of the hourly observations for each day is sufficient to determine the year


A series of models are run, using a variable number of predictors:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Variable importance number of variables to explore
impNums <- c(1:10, 16, 25, nrow(filter(dfImp, src=="fct_year")))

# Accuracy on holdout data
rpiYear <- tibble::tibble(nImp=impNums, 
                          rfAcc=sapply(impNums, 
                                       FUN=function(x) runPartialImportanceRF(dfTrain=dfTrain_v2,
                                                                              yVar="fct_year", 
                                                                              dfTest=dfTest_v2, 
                                                                              isContVar=FALSE, 
                                                                              impDB=dfImp, 
                                                                              nImp=x, 
                                                                              makePlots=FALSE
                                                                              )[["rfAcc"]]
                                       )
                          )
rpiYear

```

  
```{r, fig.height=9, fig.width=9}

# Plot of holdout accuracy vs. number of variables
rpiYear %>%
    bind_rows(tibble::tibble(nImp=0, rfAcc=0)) %>%
    ggplot(aes(x=nImp, y=rfAcc)) + 
    geom_line() + 
    geom_point() + 
    labs(title="Accuracy on holdout data vs. number of predictors", 
         subtitle="Predicting year as factor",
         y="Accuracy on holdout data", 
         x="# Predictors (selected in order of variable importance in full model)"
         ) + 
    lims(y=c(0, 1)) + 
    geom_hline(data=~filter(., rfAcc==max(rfAcc)), aes(yintercept=rfAcc), lty=2)

```
  
The function is tested on categorical variable hour:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Create holdout data and labels
dfTrain_v3 <- filter(nycTempTrain, lubridate::year(date)<2022) %>% mutate(doy=yday(date))
dfTest_v3 <- filter(nycTempTest, lubridate::year(date)==2022) %>% mutate(doy=yday(date))
keyLabel_v3 <- "predictions based on training data applied to holdout dataset"

rfHour <- runFullRF(dfTrain=dfTrain_v3, 
                     yVar="fct_hour", 
                     xVars=c(varsTrain, "month", "doy"), 
                     dfTest=dfTest_v3, 
                     useLabel=keyLabel_v3, 
                     useSub=stringr::str_to_sentence(keyLabel_v3), 
                     returnData=TRUE
                     )

dfImp <- map_dfr(list("month"=rfMonth, 
                      "temperature_2m"=rfTemp2m, 
                      "soil_temperature_100_to_255cm"=rfSoil255, 
                      "doy"=rfDOYFct,
                      "fct_year"=rfYear, 
                      "fct_hour"=rfHour
                      ), 
                 .f=function(x) x$rfImp, 
                 .id="src"
                 ) %>% 
    arrange(src, -imp) %>% 
    group_by(src) %>%
    mutate(pct=imp/sum(imp), cspct=cumsum(pct), n=row_number()) %>%
    ungroup()
dfImp

```
  
Hour (as factor) is predicted using only the four top importance variables:
```{r, fig.height=9, fig.width=9, cache=TRUE}

runPartialImportanceRF(dfTrain=dfTrain_v3, 
                       yVar="fct_hour", 
                       dfTest=dfTest_v3, 
                       isContVar=FALSE,
                       impDB=dfImp,
                       nImp=4, 
                       makePlots=TRUE
                       )

```

Prediction accuracy is decreased by ~5% as predictors are limited to 4, with some of the nighttime hours never predicted. A series of models are run, using a variable number of predictors:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Variable importance number of variables to explore
impNums <- c(1:10, 16, 25, nrow(filter(dfImp, src=="fct_hour")))

# Accuracy on holdout data
rpiHour <- tibble::tibble(nImp=impNums, 
                          rfAcc=sapply(impNums, 
                                       FUN=function(x) runPartialImportanceRF(dfTrain=dfTrain_v3, 
                                                                              yVar="fct_hour", 
                                                                              dfTest=dfTest_v3, 
                                                                              isContVar=FALSE, 
                                                                              impDB=dfImp, 
                                                                              nImp=x, 
                                                                              makePlots=FALSE)[["rfAcc"]]
                                       )
                          )
rpiHour

```
  
```{r, fig.height=9, fig.width=9}

# Plot of holdout accuracy vs. number of variables
rpiHour %>%
    bind_rows(tibble::tibble(nImp=0, rfAcc=0)) %>%
    ggplot(aes(x=nImp, y=rfAcc)) + 
    geom_line() + 
    geom_point() + 
    labs(title="Accuracy on holdout data vs. number of predictors", 
         subtitle="Predicting hour",
         y="Accuracy on holdout data", 
         x="# Predictors (selected in order of variable importance in full model)"
         ) + 
    lims(y=c(0, 1)) + 
    geom_hline(data=~filter(., rfAcc==max(rfAcc)), aes(yintercept=rfAcc), lty=2)

# Correlations
dfTrain %>% 
    select(all_of(varsTrain)) %>% 
    cor() %>% 
    as.data.frame() %>% 
    rownames_to_column("V1") %>% 
    tibble::tibble() %>% 
    pivot_longer(cols=-c(V1), names_to="V2") %>% 
    filter(V1 %in% pull(filter(dfImp, src=="fct_hour", n<=8), "metric"), 
           V2 %in% pull(filter(dfImp, src=="fct_hour", n<=8), "metric")
           ) %>% 
    ggplot(aes(x=fct_rev(V1), y=V2)) + 
    geom_tile(aes(fill=value)) + 
    geom_text(aes(label=round(value, 2))) + 
    scale_fill_gradient2(high="green") + 
    labs(title="Correlations of select predictors in training data", x=NULL, y=NULL)

```

Accuracy generally increases with number of predictors, plateauing around 40% with 4+ predictors

The process for running partial importance is converted to functional form:  
```{r, fig.height=9, fig.width=9}

autoPartialImportance <- function(dfTrain, 
                                  dfTest, 
                                  yVar, 
                                  isContVar,
                                  impDB=dfImp,
                                  impNums=c(1:10, 16, 25, nrow(filter(dfImp, src==yVar)))
                                  ) {
    
    # FUNCTION ARGUMENTS:
    # dfTrain: training data
    # dfTest: test (holdout) data
    # yVar: dependent variable
    # isContVar: boolean, is this a contnuous variable (R-2) or categorical variable (accuracy)?
    # impDB: tibble containing sorted variable importances by predictor
    # impNums: vector of number of variables to run (each element in vector run)
    
    # Accuracy on holdout data
    tblRPI <- tibble::tibble(nImp=impNums, 
                             rfAcc=sapply(impNums, 
                                          FUN=function(x) {y <- runPartialImportanceRF(dfTrain=dfTrain, 
                                                                                       yVar=yVar, 
                                                                                       dfTest=dfTest, 
                                                                                       isContVar=isContVar, 
                                                                                       impDB=impDB, 
                                                                                       nImp=x, 
                                                                                       makePlots=FALSE
                                                                                       )[["rfAcc"]]
                                                           if(isTRUE(isContVar)) y <- y["r2"]
                                                           y
                                                           }
                                          )
                             )
    print(tblRPI)

    # Plot of holdout accuracy/r-squared vs. number of variables
    # if(isTRUE(isContVar)) tblRPI <- tblRPI %>% mutate(rfAcc=r2)
    if(isTRUE(isContVar)) prtDesc <- "R-squared" else prtDesc <- "Accuracy"
    p1 <- tblRPI %>%
        select(nImp, rfAcc) %>%
        bind_rows(tibble::tibble(nImp=0, rfAcc=0)) %>%
        ggplot(aes(x=nImp, y=rfAcc)) + 
        geom_line() + 
        geom_point() + 
        labs(title=paste0(prtDesc, " on holdout data vs. number of predictors"), 
             subtitle=paste0("Predicting ", yVar),
             y=paste0(prtDesc, " on holdout data"), 
             x="# Predictors (selected in order of variable importance in full model)"
             ) + 
        lims(y=c(0, 1)) + 
        geom_hline(data=~filter(., rfAcc==max(rfAcc)), aes(yintercept=rfAcc), lty=2)
    print(p1)
    
    return(tblRPI)
    
}

```

The function is tested on hour, as factor:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

apiHour <- autoPartialImportance(dfTrain=dfTrain_v3, dfTest=dfTest_v3, yVar="fct_hour", isContVar=FALSE)

apiHour %>%
    colRenamer(c("rfAcc"="apiAcc")) %>%
    full_join(rpiHour, by=c("nImp")) %>%
    colRenamer(c("rfAcc"="rpiAcc")) %>%
    pivot_longer(cols=-c(nImp)) %>%
    ggplot(aes(x=nImp, y=value)) + 
    geom_point(aes(color=name)) + 
    geom_line(aes(group=name, color=name)) + 
    labs(title=paste0("Accuracy", " on holdout data vs. number of predictors"), 
             subtitle=paste0("Predicting ", "hour as factor", " using function api and previous results rpi"),
             y=paste0("Accuracy", " on holdout data"), 
             x="# Predictors (selected in order of variable importance in full model)"
             ) + 
    lims(y=c(0, 1)) + 
    scale_color_discrete(NULL)

```
  
While there are minor differences due to different random states, the function broadly gives the same results as the previous code

The function is tested on temperature:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

apiTemp <- autoPartialImportance(dfTrain=dfTrain, dfTest=dfTest, yVar="temperature_2m", isContVar=TRUE)

apiTemp %>%
    colRenamer(c("rfAcc"="apiR2")) %>%
    full_join(rpiTemp, by=c("nImp")) %>%
    colRenamer(c("r2"="rpiR2")) %>%
    pivot_longer(cols=-c(nImp)) %>%
    ggplot(aes(x=nImp, y=value)) + 
    geom_point(aes(color=name)) + 
    geom_line(aes(group=name, color=name)) + 
    labs(title=paste0("R-squared", " on holdout data vs. number of predictors"), 
             subtitle=paste0("Predicting ", "temperature", " using function api and previous results rpi"),
             y=paste0("R-squared", " on holdout data"), 
             x="# Predictors (selected in order of variable importance in full model)"
             ) + 
    lims(y=c(0, 1)) + 
    scale_color_discrete(NULL)

```
  
While there are minor differences due to different random states, the function broadly gives the same results as the previous code

The function is tested on categorical variable todSeason (a mix of day/night and the four seasons):  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rfTODS <- runFullRF(dfTrain=dfTrain_v3, 
                    yVar="todSeason", 
                    xVars=c(varsTrain), 
                    dfTest=dfTest_v3, 
                    useLabel=keyLabel_v3, 
                    useSub=stringr::str_to_sentence(keyLabel_v3), 
                    returnData=TRUE
                    )

dfImp <- map_dfr(list("month"=rfMonth, 
                      "temperature_2m"=rfTemp2m, 
                      "soil_temperature_100_to_255cm"=rfSoil255, 
                      "doy"=rfDOYFct,
                      "fct_year"=rfYear, 
                      "fct_hour"=rfHour, 
                      "todSeason"=rfTODS
                      ), 
                 .f=function(x) x$rfImp, 
                 .id="src"
                 ) %>% 
    arrange(src, -imp) %>% 
    group_by(src) %>%
    mutate(pct=imp/sum(imp), cspct=cumsum(pct), n=row_number()) %>%
    ungroup()
dfImp

```
  
Variable todSeason is predicted using only the four top importance variables:
```{r, fig.height=9, fig.width=9, cache=TRUE}

runPartialImportanceRF(dfTrain=dfTrain_v3, 
                       yVar="todSeason", 
                       dfTest=dfTest_v3, 
                       isContVar=FALSE,
                       impDB=dfImp,
                       nImp=4, 
                       makePlots=TRUE
                       )

```

Prediction accuracy is decreased as predictors are limited to 4, with day/night especially impacted due to lack of a radiation variable. A series of models are run, using a variable number of predictors:  

Variable todSeason is predicted using a range of predictors:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

apiTODS <- autoPartialImportance(dfTrain=dfTrain_v3, dfTest=dfTest_v3, yVar="todSeason", isContVar=FALSE)

```

Prediction accuracy soars when a soil temperature variable and a radiation variable are both included

Each possible predictor is run on a stand-alone basis:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

tstOneVar <- sapply(varsTrain, FUN=function(x) {
    runFullRF(dfTrain=dfTrain_v3, 
              yVar="todSeason", 
              xVars=x,
              dfTest=dfTest_v3, 
              useLabel=keyLabel_v3, 
              useSub=stringr::str_to_sentence(keyLabel_v3), 
              makePlots=FALSE,
              returnData=TRUE
              )[["rfAcc"]]
    }
)

tstOneVar %>% 
    as.data.frame() %>% 
    purrr::set_names("rfAcc") %>% 
    rownames_to_column("pred") %>% 
    tibble::tibble() %>%
    arrange(desc(rfAcc)) %>%
    print(n=40)

```

Each possible predictor is run on a stand-alone basis, along with the best predictor:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

bestOneVar <- (tstOneVar %>% sort(decreasing = TRUE) %>% names())[1]
bestOneVar

tstTwoVar <- sapply(setdiff(varsTrain, bestOneVar), FUN=function(x) {
    runFullRF(dfTrain=dfTrain_v3, 
              yVar="todSeason", 
              xVars=c(x, bestOneVar),
              dfTest=dfTest_v3, 
              useLabel=keyLabel_v3, 
              useSub=stringr::str_to_sentence(keyLabel_v3), 
              makePlots=FALSE,
              returnData=TRUE
              )[["rfAcc"]]
    }
)

tstTwoVar %>% 
    as.data.frame() %>% 
    purrr::set_names("rfAcc") %>% 
    rownames_to_column("pred") %>% 
    tibble::tibble() %>%
    arrange(desc(rfAcc)) %>%
    print(n=40)

```

Each possible predictor is run on a stand-alone basis, along with the best two predictors:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

bestTwoVar <- (tstTwoVar %>% sort(decreasing = TRUE) %>% names())[1]
bestTwoVar

tstThreeVar <- sapply(setdiff(varsTrain, c(bestOneVar, bestTwoVar)), FUN=function(x) {
    runFullRF(dfTrain=dfTrain_v3, 
              yVar="todSeason", 
              xVars=c(x, bestOneVar, bestTwoVar),
              dfTest=dfTest_v3, 
              useLabel=keyLabel_v3, 
              useSub=stringr::str_to_sentence(keyLabel_v3), 
              makePlots=FALSE,
              returnData=TRUE
              )[["rfAcc"]]
    }
)

tstThreeVar %>% 
    as.data.frame() %>% 
    purrr::set_names("rfAcc") %>% 
    rownames_to_column("pred") %>% 
    tibble::tibble() %>%
    arrange(desc(rfAcc)) %>%
    print(n=40)

```

Each possible predictor is run on a stand-alone basis, along with the best three predictors:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

bestThreeVar <- (tstThreeVar %>% sort(decreasing = TRUE) %>% names())[1]
bestThreeVar

tstFourVar <- sapply(setdiff(varsTrain, c(bestOneVar, bestTwoVar, bestThreeVar)), FUN=function(x) {
    runFullRF(dfTrain=dfTrain_v3, 
              yVar="todSeason", 
              xVars=c(x, bestOneVar, bestTwoVar, bestThreeVar),
              dfTest=dfTest_v3, 
              useLabel=keyLabel_v3, 
              useSub=stringr::str_to_sentence(keyLabel_v3), 
              makePlots=FALSE,
              returnData=TRUE
              )[["rfAcc"]]
    }
)

tstFourVar %>% 
    as.data.frame() %>% 
    purrr::set_names("rfAcc") %>% 
    rownames_to_column("pred") %>% 
    tibble::tibble() %>%
    arrange(desc(rfAcc)) %>%
    print(n=40)

```

The evolution in prediction accuracy is plotted:  
```{r, fig.height=9, fig.width=9}

tibble::tibble(x=0:4, 
               y=c(0, sapply(list(tstOneVar, tstTwoVar, tstThreeVar, tstFourVar), FUN=function(x) max(x)))
               ) %>%
    bind_rows(apiTODS %>% filter(nImp==max(nImp)) %>% select(x=nImp, y=rfAcc)) %>%
    ggplot(aes(x=x, y=y)) + 
    geom_point() + 
    geom_line() + 
    geom_text(aes(label=round(y, 2), y=ifelse(x>=4, y=y-0.05, y), x=ifelse(x>=4, x+1, x-0.5)), 
              hjust=1, 
              size=3
              ) +
    geom_hline(aes(yintercept=max(y)), lty=2) +
    lims(y=c(0, 1)) + 
    labs(x="# Predictors", 
         y="Accuracy on holdout data", 
         title="Accuracy of predicting day-night season by number of predictors"
         )

```

The first three predictors each significantly improve accuracy. A soil temperature variable helps predict season, then a radiation variable helps predict day-night, then a second soil temperature variable significantly refines prediction of season. There is very little gain for 4+ predictors

The process is converted to functional form:
```{r, fig.height=9, fig.width=9}

runNextBestPredictor <- function(varsRun, 
                                 xFix, 
                                 yVar, 
                                 isContVar,
                                 dfTrain,
                                 dfTest=dfTrain, 
                                 useLabel="predictions based on training data applied to holdout dataset",
                                 useSub=stringr::str_to_sentence(keyLabel_v3), 
                                 makePlots=FALSE
                                 ) {
    
    # FUNCTION ARGUMENTS:
    # varsRun: variables to be run as potential next-best predictors
    # xFix: variables that are already included in every test of next-best
    # yVar: dependent variable of interest
    # isContVar: boolean, is yvar continuous?
    # dfTrain: training data
    # dfTest: test data
    # useLabel: descriptive label
    # useSub: subtitle description
    # makePlots: boolean, should plots be created for each predictor run?
    
    vecAcc <- sapply(varsRun, FUN=function(x) {
        y <- runFullRF(dfTrain=dfTrain, 
                  yVar=yVar, 
                  xVars=c(xFix, x),
                  dfTest=dfTest, 
                  useLabel=useLabel, 
                  useSub=useSub,
                  isContVar=isContVar,
                  makePlots=makePlots,
                  returnData=TRUE
                  )[["rfAcc"]]
        if(isTRUE(isContVar)) y[["r2"]] else y
        }
        )

    vecAcc %>% 
        as.data.frame() %>% 
        purrr::set_names("rfAcc") %>% 
        rownames_to_column("pred") %>% 
        tibble::tibble() %>%
        arrange(desc(rfAcc)) %>%
        print(n=40)
    
    vecAcc

}

```

The function is tested for a categorical variable:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rnbpThree <- runNextBestPredictor(varsRun=(tstThreeVar %>% sort(decreasing=TRUE) %>% names), 
                                  xFix=c(bestOneVar, bestTwoVar), 
                                  yVar="todSeason", 
                                  isContVar=FALSE, 
                                  dfTrain=dfTrain_v3, 
                                  dfTest=dfTest_v3
                                  )

```

Results are compared to the previous process, with only slight differences likely due to different random states observed: 
```{r, fig.height=9, fig.width=9}

rownames_to_column(as.data.frame(rnbpThree), "predictor") %>% 
    full_join(rownames_to_column(as.data.frame(tstThreeVar), "predictor"), by="predictor") %>% 
    tibble::tibble() %>% 
    pivot_longer(cols=-c(predictor)) %>% 
    ggplot(aes(x=fct_reorder(predictor, value), y=value)) + 
    geom_point(aes(color=c("rnbpThree"="New\nFunction", "tstThreeVar"="Previous\nResult")[name])) + 
    coord_flip() + 
    geom_hline(lty=2, yintercept=max(tstTwoVar)) +
    labs(y="Accuracy", 
         x=NULL, 
         title="Accuracy for each predictor added standalone as next-best third predictor",
         subtitle="Dashed line is baseline two-predictor accuracy"
         ) + 
    scale_color_discrete(NULL)

```

The function is tested for a continuous variable:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rnbpContOne <- runNextBestPredictor(varsRun=c(varsTrain[!str_detect(varsTrain, "pct_temp|apparent")], 
                                              "month", 
                                              "tod", 
                                              "doy"
                                              ), 
                                    xFix=c(), 
                                    yVar="temperature_2m", 
                                    isContVar=TRUE, 
                                    dfTrain=dfTrain, 
                                    dfTest=dfTest
                                    )

```

The best predictor for temperature is extracted, with a function written for reuse:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

getNextBestVar <- function(x, returnTbl=FALSE, n=if(isTRUE(returnTbl)) +Inf else 1) {
    
    # FUNCTION ARGUMENTS:
    # x: named vector of accuracy or r-squared
    # returnTbl: boolean, if TRUE convert to tibble and return, if FALSE return vector of top-n predictors 
    # n: number of predictrs to return (+Inf will return the full tibble or vector)
    
    tbl <- vecToTibble(x, colNameName="pred") %>%
        arrange(-value) %>%
        slice_head(n=n)
    if(isTRUE(returnTbl)) return(tbl)
    else return(tbl %>% pull(pred))
    
}

getNextBestVar(rnbpContOne)
getNextBestVar(rnbpContOne, n=4)
getNextBestVar(rnbpContOne, returnTbl=TRUE)

```
  
The functions are run recursively for the first three predictors of continuous variable temperature:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

yVar <- "temperature_2m"
yCont <- TRUE
varsTemp <- c(varsTrain[!str_detect(varsTrain, "pct_temp|apparent")], "month", "tod", "doy")
varsRun <- 3
rnbpTempList <- vector("list", varsRun)

for(intCtr in 1:varsRun) { 
    if(intCtr==1) xFix<-character(0) 
    else xFix<-lapply(rnbpTempList[1:(intCtr-1)], FUN=function(x) x$pred[1]) %>% reduce(.f=c)
    rnbpTempList[[intCtr]] <- runNextBestPredictor(varsRun=setdiff(varsTemp, xFix), 
                                                   xFix=xFix, 
                                                   yVar=yVar, 
                                                   isContVar=yCont, 
                                                   dfTrain=dfTrain, 
                                                   dfTest=dfTest
                                                   ) %>% 
        getNextBestVar(returnTbl = TRUE)
}

rnbpTempList

```

Improvements in R-squared are plotted:  
```{r, fig.height=9, fig.width=9}

rnbpTempList %>% 
    bind_rows(.id="src") %>%
    arrange(src, value) %>%
    group_by(src) %>%
    mutate(rn=row_number()) %>%
    ungroup() %>%
    ggplot(aes(x=rn, y=value)) + 
    geom_line(aes(group=src, color=src)) + 
    scale_color_discrete("# Preds") + 
    labs(title="R-squared by next predictor", y="R-squared", x="Next-best sorted from worst to best") + 
    facet_wrap(~src, scales="free_y") + 
    lims(y=c(NA, 1)) + 
    geom_hline(yintercept=1, lty=2)

```

There are generally a handful of potential next-best predictors that significantly outperform the others

There are combinations of 2 variables that outperform the accuracy of the iterative approach:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Iterative model
runFullRF(dfTrain=dfTrain, 
          yVar="temperature_2m", 
          xVars=c("pct_soil_temperature_0_to_7cm", "pct_dewpoint_2m"), 
          dfTest=dfTest, 
          isContVar=TRUE,
          useLabel=keyLabel_v3, 
          useSub=stringr::str_to_sentence(keyLabel_v3), 
          returnData=FALSE
          )

# Relative humidity and vapor pressure deficit
runFullRF(dfTrain=dfTrain, 
          yVar="temperature_2m", 
          xVars=c("pct_relativehumidity_2m", "pct_vapor_pressure_deficit"), 
          dfTest=dfTest, 
          isContVar=TRUE,
          useLabel=keyLabel_v3, 
          useSub=stringr::str_to_sentence(keyLabel_v3), 
          returnData=FALSE
          )

# Dewpoint and relative humidity
runFullRF(dfTrain=dfTrain, 
          yVar="temperature_2m", 
          xVars=c("pct_dewpoint_2m", "pct_relativehumidity_2m"), 
          dfTest=dfTest, 
          isContVar=TRUE,
          useLabel=keyLabel_v3, 
          useSub=stringr::str_to_sentence(keyLabel_v3), 
          returnData=FALSE
          )

# Dewpoint and vapor pressure deficit
runFullRF(dfTrain=dfTrain, 
          yVar="temperature_2m", 
          xVars=c("pct_dewpoint_2m", "pct_vapor_pressure_deficit"), 
          dfTest=dfTest, 
          isContVar=TRUE,
          useLabel=keyLabel_v3, 
          useSub=stringr::str_to_sentence(keyLabel_v3), 
          returnData=FALSE
          )

```

All else equal at a given locale, temperature and dewpoint mathematically determine relative humidity and vapor pressure deficit. So, while relative humidity has no standalone predictive power on temperature, in combination with dewpoint, it drives nearly 100% R-squared

The relationships between temperature, dewpoint, and relative humidity are explored:  
```{r, fig.height=9, fig.width=9}

dfMiniTest <- dfTrain %>%
    select(t=temperature_2m, d=dewpoint_2m, rh=relativehumidity_2m) %>%
    # mutate(across(.cols=everything(), .fns=function(x) round(x))) %>%
    count(t, d, rh) %>%
    filter(rh %in% c(30, 50, 70, 90)) 

dfMiniTest %>%
    ggplot(aes(x=d, y=t)) + 
    geom_point(aes(color=factor(rh), size=n)) + 
    geom_abline(slope=1, intercept=0, lty=2) + 
    scale_color_discrete("% RH") + 
    labs(title="Dewpoint vs. Temperature for Select Relative Humidities", y="Temp", x="Dew Point")

lm(t~factor(rh)+d:factor(rh)+0, data=dfMiniTest) %>% summary()

```

All possible combinations of 2 variables are explored on a smaller dataset:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

possTempVars <- c(varsTrain[!str_detect(varsTrain, "pct_temp|apparent")], "month", "tod", "doy")
set.seed(24031815)
idxSmall <- sample(1:nrow(dfTrain), 5000, replace=FALSE)
mtxSmall <- matrix(nrow=0, ncol=3)

for(idx1 in 1:(length(possTempVars)-1)) {
    for(idx2 in (idx1+1):length(possTempVars)) {
        r2Small <- runFullRF(dfTrain=dfTrain[idxSmall,], 
                             yVar="temperature_2m", 
                             xVars=possTempVars[c(idx1, idx2)], 
                             dfTest=dfTest, 
                             useLabel=keyLabel, 
                             useSub=stringr::str_to_sentence(keyLabel), 
                             isContVar=TRUE,
                             makePlots=FALSE,
                             returnData=TRUE
                             )[["rfAcc"]][["r2"]]
        mtxSmall <- rbind(mtxSmall, c(idx1, idx2, r2Small))
    }
}

```

Predictive success by metric is explored:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

dfSmallR2 <- as.data.frame(mtxSmall) %>% 
    purrr::set_names(c("idx1", "idx2", "r2")) %>% 
    tibble::as_tibble() %>% 
    mutate(var1=possTempVars[idx1], var2=possTempVars[idx2], rn=row_number()) 
dfSmallR2 %>% arrange(desc(r2)) %>% select(var1, var2, r2) %>% print(n=20)

dfSmallR2 %>% 
    pivot_longer(cols=c(var1, var2)) %>% 
    group_by(value) %>% 
    summarize(across(r2, .fns=list("min"=min, "mu"=mean, "max"=max))) %>% 
    ggplot(aes(x=fct_reorder(value, r2_mu))) + 
    coord_flip() + 
    geom_point(aes(y=r2_mu)) + 
    geom_errorbar(aes(ymin=r2_min, ymax=r2_max)) + 
    lims(y=c(NA, 1)) + 
    geom_hline(yintercept=1, lty=2, color="red") +
    labs(title="R-squared in every 2-predictor model including self and one other", 
         subtitle="Predicting temperature_2m", 
         y="Range of R2 (min-mean-max)", 
         x=NULL
         )

```

The variables with the best maximum R-squared are dewpoint, vapor pressure deficit, and relative humidity. Of note, these variables paired with suboptimal second predictors can also produce very poor predictions, such as the negative R-squared for the worst 2-variable model including relative humidity

The best combinations are explored using the full training dataset:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

possLargeVars <- dfSmallR2 %>% 
    arrange(desc(r2)) %>% 
    filter(r2>=0.975) %>% 
    select(r2, rn, var1, var2) %>% 
    pivot_longer(cols=c(var1, var2)) %>% 
    pull(value) %>% 
    unique()
possLargeVars
mtxLarge <- matrix(nrow=0, ncol=3)

for(idx1 in 1:(length(possLargeVars)-1)) {
    for(idx2 in (idx1+1):length(possLargeVars)) {
        r2Large <- runFullRF(dfTrain=dfTrain[,], 
                             yVar="temperature_2m", 
                             xVars=possLargeVars[c(idx1, idx2)], 
                             dfTest=dfTest, 
                             useLabel=keyLabel, 
                             useSub=stringr::str_to_sentence(keyLabel), 
                             isContVar=TRUE,
                             makePlots=FALSE,
                             returnData=TRUE
        )[["rfAcc"]][["r2"]]
        mtxLarge <- rbind(mtxLarge, c(idx1, idx2, r2Large))
    }
}

dfLargeR2 <- as.data.frame(mtxLarge) %>% 
    purrr::set_names(c("idx1", "idx2", "r2")) %>% 
    tibble::as_tibble() %>% 
    mutate(var1=possLargeVars[idx1], var2=possLargeVars[idx2], rn=row_number()) 
dfLargeR2 %>% arrange(desc(r2)) %>% select(var1, var2, r2) %>% print(n=20)

```

The process is repeated for categorical variable todSeason, which combines day-night and season:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

possTODSVars <- c(varsTrain)
set.seed(24032104)
idxSmallTODS <- sample(1:nrow(dfTrain_v3), 5000, replace=FALSE)
mtxSmallTODS <- matrix(nrow=0, ncol=3)

for(idx1 in 1:(length(possTODSVars)-1)) {
    for(idx2 in (idx1+1):length(possTODSVars)) {
        r2SmallTODS <- runFullRF(dfTrain=dfTrain_v3[idxSmallTODS,], 
                                 yVar="todSeason", 
                                 xVars=possTODSVars[c(idx1, idx2)], 
                                 dfTest=dfTest_v3, 
                                 useLabel=keyLabel, 
                                 useSub=stringr::str_to_sentence(keyLabel), 
                                 isContVar=FALSE,
                                 makePlots=FALSE,
                                 returnData=TRUE
                                 )[["rfAcc"]]
        mtxSmallTODS <- rbind(mtxSmallTODS, c(idx1, idx2, r2SmallTODS))
    }
}

```

Predictive success by metric is explored:  
```{r, fig.height=9, fig.width=9}

dfSmallR2TODS <- as.data.frame(mtxSmallTODS) %>% 
    purrr::set_names(c("idx1", "idx2", "r2")) %>% 
    tibble::as_tibble() %>% 
    mutate(var1=possTODSVars[idx1], var2=possTODSVars[idx2], rn=row_number()) 
dfSmallR2TODS %>% arrange(desc(r2)) %>% select(var1, var2, r2) %>% print(n=20)

dfSmallR2TODS %>% 
    pivot_longer(cols=c(var1, var2)) %>% 
    group_by(value) %>% 
    summarize(across(r2, .fns=list("min"=min, "mu"=mean, "max"=max))) %>% 
    ggplot(aes(x=fct_reorder(value, r2_mu))) + 
    coord_flip() + 
    geom_point(aes(y=r2_mu)) + 
    geom_errorbar(aes(ymin=r2_min, ymax=r2_max)) + 
    lims(y=c(NA, 1)) + 
    geom_hline(yintercept=1, lty=2, color="red") +
    labs(title="R-squared in every 2-predictor model including self and one other", 
         subtitle="Predicting todSeason", 
         y="Range of R2 (min-mean-max)", 
         x=NULL
         )

```

The variables with the best maximum R-squared radiation (day/night) and soil temperature/moisture (season). This is consistent with the previous iterative approach, as there is no standalone 2-variable formula for perfectly predicting both time of day and season

The best combinations are explored using the full training dataset:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

possLargeVarsTODS <- dfSmallR2TODS %>% 
    arrange(desc(r2)) %>% 
    filter(row_number()<=5) %>% 
    select(r2, rn, var1, var2) %>% 
    pivot_longer(cols=c(var1, var2)) %>% 
    pull(value) %>% 
    unique()
possLargeVarsTODS
mtxLargeTODS <- matrix(nrow=0, ncol=3)

for(idx1 in 1:(length(possLargeVarsTODS)-1)) {
    for(idx2 in (idx1+1):length(possLargeVarsTODS)) {
        r2LargeTODS <- runFullRF(dfTrain=dfTrain_v3[,], 
                             yVar="todSeason", 
                             xVars=possLargeVarsTODS[c(idx1, idx2)], 
                             dfTest=dfTest_v3, 
                             useLabel=keyLabel, 
                             useSub=stringr::str_to_sentence(keyLabel), 
                             isContVar=FALSE,
                             makePlots=FALSE,
                             returnData=TRUE
        )[["rfAcc"]]
        mtxLargeTODS <- rbind(mtxLargeTODS, c(idx1, idx2, r2LargeTODS))
    }
}

dfLargeR2TODS <- as.data.frame(mtxLargeTODS) %>% 
    purrr::set_names(c("idx1", "idx2", "r2")) %>% 
    tibble::as_tibble() %>% 
    mutate(var1=possLargeVarsTODS[idx1], var2=possLargeVarsTODS[idx2], rn=row_number()) 
dfLargeR2TODS %>% arrange(desc(r2)) %>% select(var1, var2, r2) %>% print(n=20)

```

The process is repeated for categorical variable fct_hour, which converts hour to a factor:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

possHourVars <- c(varsTrain, "month", "doy")
set.seed(24032415)
idxSmallHour <- sample(1:nrow(dfTrain_v3), 5000, replace=FALSE)
mtxSmallHour <- matrix(nrow=0, ncol=3)

for(idx1 in 1:(length(possHourVars)-1)) {
    for(idx2 in (idx1+1):length(possHourVars)) {
        r2SmallHour <- runFullRF(dfTrain=dfTrain_v3[idxSmallHour,], 
                                 yVar="fct_hour", 
                                 xVars=possHourVars[c(idx1, idx2)], 
                                 dfTest=dfTest_v3, 
                                 useLabel=keyLabel, 
                                 useSub=stringr::str_to_sentence(keyLabel), 
                                 isContVar=FALSE,
                                 makePlots=FALSE,
                                 returnData=TRUE
                                 )[["rfAcc"]]
        mtxSmallHour <- rbind(mtxSmallHour, c(idx1, idx2, r2SmallHour))
    }
}

```

Predictive success by metric is explored:  
```{r, fig.height=9, fig.width=9}

dfSmallR2Hour <- as.data.frame(mtxSmallHour) %>% 
    purrr::set_names(c("idx1", "idx2", "r2")) %>% 
    tibble::as_tibble() %>% 
    mutate(var1=possHourVars[idx1], var2=possHourVars[idx2], rn=row_number()) 
dfSmallR2Hour %>% arrange(desc(r2)) %>% select(var1, var2, r2) %>% print(n=20)

dfSmallR2Hour %>% 
    pivot_longer(cols=c(var1, var2)) %>% 
    group_by(value) %>% 
    summarize(across(r2, .fns=list("min"=min, "mu"=mean, "max"=max))) %>% 
    ggplot(aes(x=fct_reorder(value, r2_mu))) + 
    coord_flip() + 
    geom_point(aes(y=r2_mu)) + 
    geom_errorbar(aes(ymin=r2_min, ymax=r2_max)) + 
    lims(y=c(NA, 1)) + 
    geom_hline(yintercept=1, lty=2, color="red") +
    labs(title="R-squared in every 2-predictor model including self and one other", 
         subtitle="Predicting fct_hour", 
         y="Range of R2 (min-mean-max)", 
         x=NULL
    )

```

The best combinations are explored using the full training dataset:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

possLargeVarsHour <- dfSmallR2Hour %>% 
    arrange(desc(r2)) %>% 
    filter(row_number()<=6) %>% 
    select(r2, rn, var1, var2) %>% 
    pivot_longer(cols=c(var1, var2)) %>% 
    pull(value) %>% 
    unique()
possLargeVarsHour
mtxLargeHour <- matrix(nrow=0, ncol=3)

for(idx1 in 1:(length(possLargeVarsHour)-1)) {
    for(idx2 in (idx1+1):length(possLargeVarsHour)) {
        r2LargeHour <- runFullRF(dfTrain=dfTrain_v3[,], 
                                 yVar="fct_hour", 
                                 xVars=possLargeVarsHour[c(idx1, idx2)], 
                                 dfTest=dfTest_v3, 
                                 useLabel=keyLabel, 
                                 useSub=stringr::str_to_sentence(keyLabel), 
                                 isContVar=FALSE,
                                 makePlots=FALSE,
                                 returnData=TRUE
        )[["rfAcc"]]
        mtxLargeHour <- rbind(mtxLargeHour, c(idx1, idx2, r2LargeHour))
    }
}

dfLargeR2Hour <- as.data.frame(mtxLargeHour) %>% 
    purrr::set_names(c("idx1", "idx2", "r2")) %>% 
    tibble::as_tibble() %>% 
    mutate(var1=possLargeVarsHour[idx1], var2=possLargeVarsHour[idx2], rn=row_number()) 
dfLargeR2Hour %>% arrange(desc(r2)) %>% select(var1, var2, r2) %>% print(n=20)

```

Relationships among month, hour, and radiation are explored:  
```{r, fig.height=9, fig.width=9}

dfTrain_v3 %>%
    select(month, fct_hour, s=shortwave_radiation) %>%
    ggplot(aes(x=fct_hour, y=s)) + 
    geom_boxplot(fill="lightblue") + 
    facet_wrap(~month) + 
    labs(title="Shortwave radiation by month and hour", x="Hour", y="Shortwave Radiation")

dfTrain_v3 %>%
    select(month, fct_hour, s=shortwave_radiation) %>%
    mutate(rndS=round(s/40)*40) %>%
    ggplot(aes(x=s)) + 
    geom_histogram(data=~filter(., s>0), fill="lightblue") + 
    geom_text(data=~summarize(group_by(., month), s0=sum(s==0)), 
              aes(x=500, y=500, label=paste0(s0, " obs of 0\nnot plotted")), 
              size=2.5, 
              hjust=0
              ) +
    facet_wrap(~month) + 
    labs(title="Shortwave Radiation Histogram", x="Shortwave Radiation", y=NULL)

dfTrain_v3 %>%
    select(month, fct_hour, s=shortwave_radiation) %>%
    mutate(rndS=round(s/40)*40) %>%
    ggplot(aes(x=factor(rndS))) + 
    geom_bar(aes(fill=fct_hour), position="fill") + 
    facet_wrap(~month) + 
    labs(title="Shortwave Radiation by Month and Hour", x="Shortwave Radiation", y=NULL)

```

With no solar radiation at night, there is no predictive power for solar radiation as to specific hour of night. As well, since solar radiation generally follows a sinusoidal trend from dawn to dusk, it has little predictive power as to before solar noon or after solar noon. Solar radiation is generally useful for distinguishing night from day, as well as rough magnitude of time from solar noon (during daylight hours and given month)

Hour is converted to blocks of time for easier interpretation:  
```{r, fig.height=9, fig.width=9}

tmpHourBucket <- dfTrain_v3 %>%
    select(month, fct_hour, s=shortwave_radiation) %>%
    mutate(num_hour=as.numeric(as.character(fct_hour)), 
           bkt_hour=case_when(num_hour<=7 ~ "8pm-8am", 
                              num_hour>=20 ~ "8pm-8am", 
                              num_hour<12 ~ "8am-noon", 
                              num_hour<16 ~ "noon-4pm", 
                              TRUE~"4pm-8pm"
                              ), 
           bkt_hour=factor(bkt_hour, levels=c("8pm-8am", "8am-noon", "noon-4pm", "4pm-8pm"))
           )
tmpHourBucket %>% count(bkt_hour, fct_hour) %>% print(n=30)

tmpHourBucket %>%
    ggplot(aes(x=bkt_hour, y=s)) + 
    geom_boxplot(fill="lightblue") + 
    facet_wrap(~month) + 
    labs(title="Shortwave radiation by month and hour", x="Hour (bucketed)", y="Shortwave Radiation")

tmpHourBucket %>%
    mutate(rndS=round(s/40)*40) %>%
    ggplot(aes(x=factor(rndS))) + 
    geom_bar(aes(fill=bkt_hour), position="fill") + 
    facet_wrap(~month) + 
    labs(title="Shortwave Radiation by Month and Hour", x="Shortwave Radiation", y=NULL)

```

Daily and hourly data are downloaded for Chicago, cached to avoid multiple hits to the server:  
```{r cache=TRUE}

# Hourly data download for Chicago, IL
testURLHourly <- helperOpenMeteoURL(cityName="Chicago IL", 
                                    hourlyIndices=1:nrow(tblMetricsHourly),
                                    startDate="2010-01-01", 
                                    endDate="2023-12-31", 
                                    tz="America/Chicago"
                                    )
testURLHourly

# Download file
if(!file.exists("testOM_hourly_chi.json")) {
    fileDownload(fileName="testOM_hourly_chi.json", url=testURLHourly)
} else {
    cat("\nFile testOM_hourly_chi.json already exists, skipping download\n")
}


# Daily data download for New York, NY
testURLDaily <- helperOpenMeteoURL(cityName="Chicago IL", 
                                   dailyIndices=1:nrow(tblMetricsDaily),
                                   startDate="2010-01-01", 
                                   endDate="2023-12-31", 
                                   tz="America/Chicago"
                                   )
testURLDaily

# Download file
if(!file.exists("testOM_daily_chi.json")) {
    fileDownload(fileName="testOM_daily_chi.json", url=testURLDaily)
} else {
    cat("\nFile testOM_daily_chi.json already exists, skipping download\n")
}

```

Core datasets for the new city are loaded, with explanatory variables added for future processing:  
```{r cache=TRUE}

# Read daily JSON file
chiOMDaily <- readOpenMeteoJSON("testOM_daily_chi.json")
chiOMDaily
prettyOpenMeteoMeta(chiOMDaily)

# Read hourly JSON file
chiOMHourly <- readOpenMeteoJSON("testOM_hourly_chi.json")
chiOMHourly
prettyOpenMeteoMeta(chiOMHourly)

# Create percentiles for numeric variables
chiTemp <- chiOMHourly$tblHourly %>%
    mutate(year=year(date), 
           month=factor(month.abb[lubridate::month(date)], levels=month.abb), 
           hour=lubridate::hour(time), 
           fct_hour=factor(hour), 
           tod=ifelse(hour>=7 & hour<=18, "Day", "Night"), 
           doy=yday(date),
           season=case_when(month %in% c("Mar", "Apr", "May") ~ "Spring", 
                            month %in% c("Jun", "Jul", "Aug") ~ "Summer", 
                            month %in% c("Sep", "Oct", "Nov") ~ "Fall", 
                            month %in% c("Dec", "Jan", "Feb") ~ "Winter", 
                            TRUE~"typo"
           ), 
           todSeason=paste0(season, "-", tod), 
           tod=factor(tod, levels=c("Day", "Night")), 
           season=factor(season, levels=c("Spring", "Summer", "Fall", "Winter")), 
           todSeason=factor(todSeason, 
                            levels=paste0(rep(c("Spring", "Summer", "Fall", "Winter"), each=2), 
                                          "-", 
                                          c("Day", "Night")
                            )
           ),
           across(where(is.numeric), .fns=function(x) round(100*percent_rank(x)), .names="pct_{.col}")
    )

glimpse(chiTemp)
chiTemp %>% 
    count(doy, month) %>% 
    ggplot(aes(y=doy, x=month)) + 
    geom_boxplot(aes(weight=n), fill="lightblue") + 
    labs(title="Observations by day-of-year and month", x=NULL, y="Day of Year")
chiTemp %>% 
    count(year, month) %>% 
    ggplot(aes(y=factor(year), x=month)) + 
    geom_tile(aes(fill=n)) + 
    geom_text(aes(label=n), size=3) + 
    scale_fill_continuous("# Records", low="white", high="green") + 
    labs(title="Records by year and month", x=NULL, y=NULL)
chiTemp %>% count(todSeason, season, tod)
chiTemp %>% count(hour, fct_hour, tod) %>% print(n=30)
chiTemp %>% count(month, season)

```
  
The existing model (for a different city) for predicting temperature is applied to the new data:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Predict on new dataset
tstChiPred <- predictRF(rf=rfTemp2m$rf, df=chiTemp)

# Report on accuracy
rfChiAcc <- reportAccuracy(tstChiPred, 
                           trueCol="temperature_2m", 
                           rndReport=2, 
                           useLabel="temperature predictions using previous city model on new city", 
                           reportR2=TRUE,
                           returnAcc=TRUE
                           )

# Plot confusion data
plotConfusion(tstChiPred, 
              trueCol="temperature_2m", 
              useSub="Predictions using previous city model on new city", 
              plotCont=TRUE, 
              rndTo=0.5, 
              refXY=TRUE
              )

```

Predictions are reasonably accurate, though meaningful error remains given that a few predictors standalone (e.g., dewpoint and relative humidity) can mathematically predict the dependent variable, temperature

The temperature model is re-run on the first city data, using only the mathematically related predictors:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rfTemp2mBest3 <- runFullRF(dfTrain=dfTrain, 
                           yVar="temperature_2m", 
                           xVars=c("pct_dewpoint_2m", "pct_vapor_pressure_deficit", "pct_relativehumidity_2m"), 
                           dfTest=dfTest, 
                           useLabel=keyLabel, 
                           useSub=stringr::str_to_sentence(keyLabel), 
                           isContVar=TRUE,
                           rndTo=-1L,
                           refXY=TRUE,
                           returnData=TRUE
                           )

```

A function is written to apply a random forest model to new data and report on accuracy of predictions:  
```{r, fig.height=9, fig.width=9}

newCityPredict <- function(rf, 
                           dfTest, 
                           trueCol, 
                           isContVar=FALSE,
                           reportR2=isTRUE(isContVar), 
                           plotCont=isTRUE(isContVar), 
                           reportAcc=TRUE, 
                           rndReport=2, 
                           useLabel="requested data",
                           useTitle=NULL,
                           useSub=NULL, 
                           rndTo=NULL,
                           rndBucketsAuto=100,
                           nSig=NULL,
                           refXY=FALSE, 
                           returnData=TRUE
                           ) {
    
    # FUNCTION ARGUMENTS:
    # rf: The existing "ranger" model OR a list containing element "rf" that has the existing "ranger" model
    # dfTest: the new dataset for predictions
    # trueCol: column containing true value
    # isContVar: boolean, is the variable continuous? (default FALSE means categorical)
    # reportR2: boolean, should accuracy be calculated as R-squared?
    #           (FALSE measures as categorical)
    # plotCont: boolean, should plotting assume continuous variables?
    #           (FALSE assumes confusion plot for categorical variables)
    # reportAcc: boolean, should accuracy be reported (printed to output)?
    # rndReport: number of significant digits for reporting (will be converted to percentage first)
    # useLabel: label for data to be used in reporting
    # useTitle: title to be used for chart (NULL means create from trueCol)
    # useSub: subtitle to be used for chart (NULL means none)
    # rndTo: every number in x should be rounded to the nearest rndTo
    #        NULL means no rounding (default)
    #        -1L means make an estimate based on data
    # rndBucketsAuto: integer, if rndTo is -1L, about how many buckets are desired for predictions?
    # nSig: number of significant digits for automatically calculated rounding parameter
    #       (NULL means calculate exactly)
    # refXY: boolean, should a reference line for y=x be included? (relevant only for continuous)
    # returnData: boolean, should a list be returned containing tstPred and rfAcc?
    
    # Get the ranger data
    if(!("ranger" %in% class(rf))) {
        if(!("rf" %in% names(rf))) {
            stop("\nERROR: rf must be of class 'ranger' OR a list with element 'rf' that is of class 'ranger")
        }
        rf <- rf[["rf"]]
    }
    if(!("ranger" %in% class(rf)))
        stop("\nERROR: rf must be of class 'ranger' OR a list with element 'rf' that is of class 'ranger")
    
    # Predict on new dataset
    tstPred <- predictRF(rf=rf, df=dfTest)

    # Report on accuracy
    rfAcc <- reportAccuracy(tstPred, 
                            trueCol=trueCol, 
                            reportAcc=reportAcc,
                            rndReport=rndReport, 
                            useLabel=useLabel, 
                            reportR2=reportR2,
                            returnAcc=TRUE
                            )

    # Plot confusion data
    plotConfusion(tstPred, 
                  trueCol=trueCol, 
                  useTitle=useTitle,
                  useSub=useSub, 
                  plotCont=plotCont, 
                  rndTo=rndTo,
                  rndBucketsAuto=rndBucketsAuto,
                  nSig=nSig,
                  refXY=refXY
                  )
    
    # Return data if requested
    if(isTRUE(returnData)) return(list(tstPred=tstPred, rfAcc=rfAcc))
    
}

```

The function is applied to make predictions for the new city:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

newPreds <- newCityPredict(rfTemp2mBest3, 
                           dfTest=chiTemp, 
                           trueCol="temperature_2m", 
                           isContVar=TRUE, 
                           rndTo=0.5, 
                           refXY=TRUE
                           )[["tstPred"]][,c("temperature_2m", "pred")]

tmpGG <- newPreds %>%
    mutate(act5=round(temperature_2m/5)*5, err=pred-temperature_2m, err2=err**2) %>%
    group_by(act5) %>%
    summarize(across(.cols=where(is.numeric), .fns=function(x) mean(x)), n=n())
tmpGG

tmpGG %>% 
    select(act5, temperature_2m, pred) %>%
    pivot_longer(cols=-c(act5)) %>%
    ggplot(aes(x=act5, y=value)) + 
    geom_line(aes(group=name, 
                  color=c("pred"="Predicted Mean", "temperature_2m"="Actual Mean")[name]
                  )
              ) + 
    labs(title="Actual vs. Predicted Temperature Using Old City Model on New City Data", 
         x="New city actual temperature (rounded to nearest 5)", 
         y="Average temperature for metric"
         ) + 
    scale_color_discrete("Metric") + 
    geom_abline(slope=1, intercept=0, lty=2)

```

Temperature predictions are consistently biased high, particularly on the coldest days since the new city experiences low temperatures not seen in the original city training data. Even at warmer temperatures, a slight bias remains such that predictions are generally too high

A basic linear model can drive better temperature predictions:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

lmMiniTemp <- dfTrain %>%
    select(t=temperature_2m, d=dewpoint_2m, rh=relativehumidity_2m) %>%
    lm(t~rh+d+rh:d+1, data=.) 
summary(lmMiniTemp)

ggMiniTemp <- predict(lmMiniTemp, newdata=chiTemp %>% select(rh=relativehumidity_2m, d=dewpoint_2m)) %>% 
    mutate(select(chiTemp, temperature_2m), 
           pred=., 
           err=pred-temperature_2m, 
           err2=err**2, 
           rnd5=round(temperature_2m/5)*5
           ) %>% 
    group_by(rnd5) %>% 
    summarize(n=n(), across(.cols=where(is.numeric), .fns=mean))
ggMiniTemp

ggMiniTemp %>% 
    select(rnd5, temperature_2m, pred) %>%
    pivot_longer(cols=-c(rnd5)) %>%
    ggplot(aes(x=rnd5, y=value)) + 
    geom_line(aes(group=name, 
                  color=c("pred"="Predicted Mean", "temperature_2m"="Actual Mean")[name]
                  )
              ) + 
    labs(title="Actual vs. Predicted Temperature Using Old City Linear Model on New City Data", 
         x="New city actual temperature (rounded to nearest 5)", 
         y="Average temperature for metric"
         ) + 
    scale_color_discrete("Metric") + 
    geom_abline(slope=1, intercept=0, lty=2)

```

The linear model transfers readily from original city to new city, accurately predicting (given that the true formula is close to linear even outside the training data range) even temperatures it has not been trained on

The random forest is re-run using actual data rather than percentiles for predictors:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

rfTemp2mBest3Actual <- runFullRF(dfTrain=dfTrain, 
                                 yVar="temperature_2m", 
                                 xVars=c("dewpoint_2m", "vapor_pressure_deficit", "relativehumidity_2m"), 
                                 dfTest=dfTest, 
                                 useLabel=keyLabel, 
                                 useSub=stringr::str_to_sentence(keyLabel), 
                                 isContVar=TRUE,
                                 rndTo=-1L,
                                 refXY=TRUE,
                                 returnData=TRUE
                                 )

```

The function is applied to make predictions for the new city:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

newPredsActual <- newCityPredict(rfTemp2mBest3Actual, 
                           dfTest=chiTemp, 
                           trueCol="temperature_2m", 
                           isContVar=TRUE, 
                           rndTo=0.5, 
                           refXY=TRUE
                           )[["tstPred"]][,c("temperature_2m", "pred")]

tmpGGActual <- newPredsActual %>%
    mutate(act5=round(temperature_2m/5)*5, err=pred-temperature_2m, err2=err**2) %>%
    group_by(act5) %>%
    summarize(across(.cols=where(is.numeric), .fns=function(x) mean(x)), n=n())
tmpGGActual

tmpGGActual %>% 
    select(act5, temperature_2m, pred) %>%
    pivot_longer(cols=-c(act5)) %>%
    ggplot(aes(x=act5, y=value)) + 
    geom_line(aes(group=name, 
                  color=c("pred"="Predicted Mean", "temperature_2m"="Actual Mean")[name]
                  )
              ) + 
    labs(title="Actual vs. Predicted Temperature Using Old City Model on New City Data", 
         x="New city actual temperature (rounded to nearest 5)", 
         y="Average temperature for metric"
         ) + 
    scale_color_discrete("Metric") + 
    geom_abline(slope=1, intercept=0, lty=2)

```
  
Temperature predictions are generally accurate, with the exception of the coldest days since the new city experiences low temperatures not seen in the original city training data

Errors by modeling technique are compared:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

tmpGGActual %>% 
    bind_rows(tmpGG, rename(ggMiniTemp, act5=rnd5), .id="src") %>% 
    mutate(src=c("1"="RF\nActual", "2"="RF\nPercentile", "3"="Linear")[src], rmse=sqrt(err2)) %>% 
    select(src, act5, err, err2, rmse) %>% 
    pivot_longer(cols=c("err", "err2", "rmse")) %>% 
    ggplot(aes(x=act5, y=value)) + 
    geom_line(aes(group=src, color=src)) + 
    facet_wrap(~name, scales="free_y") + 
    labs(x="Actual Temperature (rounded to nearest 5)", y=NULL) + 
    scale_color_discrete("Model")

```

The linear model is best able to predict temperatures it has not been trained on, while the RF model using raw  values as predictors is best able to predict temperatures it has been trained on. The RF model using percentiles as predictors is least accurate, as the meaning of 50%le on dewpoint will vary by city

The function is applied to make predictions for month for the new city, once using the new city's data and once using the old city's data:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Split new city data in to test and train data (3:1 split in favor of test)
idxTrainChi <- sort(sample(1:nrow(chiTemp), size=round(0.75*nrow(chiTemp)), replace=FALSE))
chiTempTrain <- chiTemp[idxTrainChi, ]
chiTempTest <- chiTemp[-idxTrainChi, ]

# Using own data, object not returned
chiPredsMonth <- runFullRF(dfTrain=chiTempTrain %>% filter(year(date) < 2022), 
                           yVar="month", 
                           xVars=varsTrain, 
                           dfTest=chiTempTest %>% filter(year(date)==2022), 
                           useLabel=keyLabel, 
                           useSub=stringr::str_to_sentence(keyLabel), 
                           returnData=TRUE
                           )[["tstPred"]]

# Using previous city data
newPredsMonth <- newCityPredict(rfMonth, 
                                dfTest=chiTemp, 
                                trueCol="month", 
                                isContVar=FALSE, 
                                useSub="Previous city percentile model applied to make new city predictions"
                                )[["tstPred"]][,c("month", "pred")]

```

Month is predicted reasonably when applying the old city model to the new city data, with ~70% accuracy and most errors being +/- 1 month. Predictions are stronger when using new city data as inputs to the model, with ~85% accuracy and almost no prediction errors of 2+ month

Frequency of prediction errors is explored:  
```{r, fig.height=9, fig.width=9}

tmpAccDF <- newPredsMonth %>% 
    count(month, pred) %>% 
    mutate(dist=as.integer(month)-as.integer(pred), 
           moddist=(dist+5) %% 12 - 5
           ) 

tmpAccDF %>% 
    count(dist, moddist, wt=n) %>% 
    mutate(pct=n/sum(n))

tmpAccDF %>% 
    count(moddist, wt=n) %>% 
    mutate(pct=n/sum(n))

```

The model more often predicts one month forward rather than one month backwards:  
```{r, fig.height=9, fig.width=9}

tmpAccDF %>%
    group_by(month) %>%
    mutate(pct=n/sum(n)) %>%
    ungroup() %>%
    mutate(plotdist=ifelse(moddist<(-1), -2, ifelse(moddist>1, 2, moddist))) %>%
    group_by(plotdist, month) %>%
    summarize(pct=sum(pct), .groups="drop") %>%
    ggplot(aes(x=factor(plotdist), y=pct)) + 
    geom_col(fill="lightblue") + 
    geom_text(aes(label=round(pct, 3)), vjust=0, size=2.5) +
    lims(y=c(0, 1)) +
    facet_wrap(~month) + 
    labs(x="Actual month minus predicted month", y="% Observations", title="Accuracy by actual month")

tmpAccDF %>%
    group_by(pred) %>%
    mutate(pct=n/sum(n)) %>%
    ungroup() %>%
    mutate(plotdist=ifelse(moddist<(-1), -2, ifelse(moddist>1, 2, moddist))) %>%
    group_by(plotdist, pred) %>%
    summarize(pct=sum(pct), .groups="drop") %>%
    ggplot(aes(x=factor(plotdist), y=pct)) + 
    geom_col(fill="lightblue") + 
    geom_text(aes(label=round(pct, 3)), vjust=0, size=2.5) +
    lims(y=c(0, 1)) +
    facet_wrap(~pred) + 
    labs(x="Actual month minus predicted month", y="% Observations", title="Accuracy by predicted month")

```

A similar approach is explored for predictions using the new city data:  
```{r, fig.height=9, fig.width=9}

tmpAccDF_v2 <- chiPredsMonth %>% 
    count(month, pred) %>% 
    mutate(dist=as.integer(month)-as.integer(pred), 
           moddist=(dist+5) %% 12 - 5
           ) 

tmpAccDF_v2 %>% 
    count(dist, moddist, wt=n) %>% 
    mutate(pct=n/sum(n))

tmpAccDF_v2 %>% 
    count(moddist, wt=n) %>% 
    mutate(pct=n/sum(n))

tmpAccDF_v2 %>%
    group_by(month) %>%
    mutate(pct=n/sum(n)) %>%
    ungroup() %>%
    mutate(plotdist=ifelse(moddist<(-1), -2, ifelse(moddist>1, 2, moddist))) %>%
    group_by(plotdist, month) %>%
    summarize(pct=sum(pct), .groups="drop") %>%
    ggplot(aes(x=factor(plotdist), y=pct)) + 
    geom_col(fill="lightblue") + 
    geom_text(aes(label=round(pct, 3)), vjust=0, size=2.5) +
    lims(y=c(0, 1)) +
    facet_wrap(~month) + 
    labs(x="Actual month minus predicted month", y="% Observations", title="Accuracy by actual month")

tmpAccDF_v2 %>%
    group_by(pred) %>%
    mutate(pct=n/sum(n)) %>%
    ungroup() %>%
    mutate(plotdist=ifelse(moddist<(-1), -2, ifelse(moddist>1, 2, moddist))) %>%
    group_by(plotdist, pred) %>%
    summarize(pct=sum(pct), .groups="drop") %>%
    ggplot(aes(x=factor(plotdist), y=pct)) + 
    geom_col(fill="lightblue") + 
    geom_text(aes(label=round(pct, 3)), vjust=0, size=2.5) +
    lims(y=c(0, 1)) +
    facet_wrap(~pred) + 
    labs(x="Actual month minus predicted month", y="% Observations", title="Accuracy by predicted month")

```

Using previous years of new city data to predict a later year of new city month results in ~85% accuracy
