---
title: "Additional Coding: Update #6"
author: "davegoblue"
date: "November 6, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Overview  
This document explores video poker hands, using <http://wizardofodds.com/games/video-poker/methodology/> as a template, and applying DataCamp_Insights_v001 materials where applicable.  This document builds on the more salient components of the analysis in AdditionalCoding_v005.Rmd.  In particular, the preparatory components are cached and saved, with a functional approach taken for assessing pay tables.  

## Analysis Approach  
The Wizard of Odds suggests an 11-step approach to calculating the returns for a video poker pay table:  
  
1.  Initialize arrays for discarding 0-5 cards  
2.  Loop through all 52c5 hands, score them based on their poker value, then place them in the appropriate arrays (each of discard 0 through discard 5)  
3.  Create the 134,459 non-duplicate starting hands possible (e.g., Ad Kh Tc 9c 3d is the same as As Kh Td 9d 3s), and assign it a weighting based on how much duplication it covers  
4.  Lookup each of the 134,459 hands and score the discard 0 (hold 5) option  
5.  Lookup every possible discard 1 (hold 4) option, find the EV in the discard 1 array and then subtract the outcome in the discard 0 array (cannot get back the same hand)  
6.  Lookup every possible discard 2 (hold 3) option, find the EV in the discard 2 array and then subtract the outcomes in the discard 1 array and then add back the outcome in the discard 0 array (double-subtracted)  
7.  Lookup every possible discard 3 (hold 2) option, find the EV in the discard 3 array and then subtract the outcomes in the discard 2 array and then add back the outcomes in the discard 1 array and then subtract out the outcome in the discard 0 array (typical set theory add/subtract)  
8.  Lookup every possible discard 4 (hold 1) option, find the EV in the discard 4 array and then subtract the outcomes in the discard 3 array and then add back the outcomes in the discard 2 array and then subtract out the outcome in the discard 1 array and then add back the outcome in the discard 0 array (typical set theory add/subtract)  
9.  Lookup every possible discard 5 (hold 0) option, find the EV in the discard 5 array and then subtract the outcomes in the discard 4 array and then add back the outcomes in the discard 3 array and then subtract out the outcome in the discard 2 array and then add back the outcome in the discard 1 array and then subtract out the outcome of the discard 0 array (typical set theory add/subtract)  
10.  Calculate the EV of every possible decision, and assign the appropriate weightings  
11.  Determine overall return, or other statistics of interest about the game  
  
This program adapts the approach as follows:  
  
* Preparatory work (cached) - create full matrices of hand types, and de-duplicated (weighted) matrix of unique starting hands  
* Scoring - apply pay table to cached preparatory work  
* Analysis - simulate pay table  
  
### Preparatory Work  
Key libraries are sourced and global parameters set.  In addition, all possible combinatorics are stored in an array, with functions declared to convert any given cards to an index.  This component is not cached:  
```{r}

library(tidyr)
library(dplyr)
library(ggplot2)


startTime <- proc.time()
totStart <- startTime

# Declare overall game variables
nHandTypes <- 50  # Number of hand types supported
nScores <- 16  # Number of final scores supported - many hand types may map to the same score


proc.time() - startTime


# Create a matrix to hold results for choose(n, k)
mtxCombin <- matrix(data=0L, nrow=52, ncol=5)
for (intCtr in 1:52) {
    for (intCtr2 in 1:5) {
        # Note that choose() is a guarded function where choose(n, k) returns 0 for k > n
        mtxCombin[intCtr, intCtr2] <- as.integer(choose(intCtr, intCtr2))
    }
}


idxCard1 <- function(c1) {
    # Just return yourself
    c1
}

idxCard2 <- function(c1, c2) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    as.integer(  1 + mtxCombin[52, 2] - mtxCombin[53-c1, 2] + 
                     mtxCombin[52-c1, 1] - mtxCombin[53-c2, 1]
              ) 
}

idxCard3 <- function(c1, c2, c3) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    as.integer(
        1 + mtxCombin[52, 3] - mtxCombin[53-c1, 3] +
            mtxCombin[52-c1, 2] - mtxCombin[53-c2, 2] +
            mtxCombin[52-c2, 1] - mtxCombin[53-c3, 1]
              )
}

idxCard4 <- function(c1, c2, c3, c4) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    as.integer(
        1 + mtxCombin[52, 4] - mtxCombin[53-c1, 4] +
            mtxCombin[52-c1, 3] - mtxCombin[53-c2, 3] +
            mtxCombin[52-c2, 2] - mtxCombin[53-c3, 2] + 
            mtxCombin[52-c3, 1] - mtxCombin[53-c4, 1]
              )
}

idxCard5 <- function(c1, c2, c3, c4, c5) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    as.integer(
        1 + mtxCombin[52, 5] - mtxCombin[53-c1, 5] +
            mtxCombin[52-c1, 4] - mtxCombin[53-c2, 4] +
            mtxCombin[52-c2, 3] - mtxCombin[53-c3, 3] + 
            mtxCombin[52-c3, 2] - mtxCombin[53-c4, 2] +
            mtxCombin[52-c4, 1] - mtxCombin[53-c5, 1]
             )
}

proc.time() - startTime

```
  
Each of the 52c5 possible starting hands are created, with hand types declared.  Of particular interest will be tracking the following, with results cached for time considerations:  
  
* Nothing (0)  
* Royal Flush (1)   
* Straight Flush (2)  
* Full House (3)  
* Flush (4)  
* Straight (5)  
* Trips (6)  
* Two Pair (7)  
* Pair AA (8)  
* Pair KK (9)  
* Pair QQ (10)  
* Pair JJ (11)  
* Pair TT (12)  
* Pair 22-99 (13)  
* AAAA with 2-4 (14)  
* AAAA with J-K (15)  
* AAAA with 5-T (16)  
* 2222/3333/4444 with A (17)  
* 2222/3333/4444 with 2-4 (18)  
* 2222/3333/4444 with J-K (19)  
* 2222/3333/4444 with 5-T (20)  
* JJJJ/QQQQ/KKKK with A (21)  
* JJJJ/QQQQ/KKKK with 2-4 (22)  
* JJJJ/QQQQ/KKKK with J-K (23)  
* JJJJ/QQQQ/KKKK with 5-T (24)  
* 5555-TTTT (25)  
  
```{r, cache=TRUE}

startTime <- proc.time()


# Create the 52c5 hands
aHands <- t(combn(1:52, 5))
str(aHands)


proc.time() - startTime


findTypes <- function (aHands, retAll=FALSE) {
    
    # Find the ranks and suits
    aRanks <- 1 + (aHands-1) %% 13
    aSuits <- (aHands-1) %/% 13
    
    # Find the flushes
    aFlush <- aSuits[, 1] == aSuits[, 5]

    # Find the straights
    strMatrix <- matrix(data=0L, nrow=13, ncol=10)
    strMatrix[c(1, 10, 11, 12, 13), 1] <- 1L
    for (intCtr in 1:9) { strMatrix[intCtr:(intCtr+4), intCtr+1] <- 1L }

    aRankCount <- matrix(data=-1L, nrow=choose(52, 5), ncol=13)
    for (intCtr in 1:13) { aRankCount[, intCtr] <- rowSums(aRanks == intCtr) }

    # Find max and count of ranks (sufficient to determine quads, full houses, trips, two pair, and pair)
    aQuads <- rowSums(aRankCount == 4)
    aTrips <- rowSums(aRankCount == 3)
    aPairs <- rowSums(aRankCount == 2)
    aStraight <- rowSums( ((aRankCount == 1) %*% strMatrix) == 5)

    # Default is that a hand has nothing
    aType <- rep(0L, choose(52, 5))

    # Declare types for mainline (RF, SF, FH, FL, ST, 3K, 2P)
    aType[aFlush == 1 & aStraight == 1 & aRankCount[, 1] == 1 & 
              aRankCount[, 13] == 1] <- 1  # Royal Flush
    aType[aFlush == 1 & aStraight == 1 & 
              (aRankCount[, 1] == 0 | aRankCount[, 13] == 0)] <- 2  # Straight Flush
    aType[aTrips == 1 & aPairs == 1] <- 3  # Full House
    aType[aFlush == 1 & aStraight == 0] <- 4  # Flush
    aType[aFlush == 0 & aStraight == 1] <- 5  # Straight
    aType[aTrips == 1 & aPairs == 0] <- 6  # Trips
    aType[aPairs == 2] <- 7  # Two Pair

    # Declare types for pairs
    aType[aTrips == 0 & aPairs == 1 & aRankCount[, 1] == 2] <- 8  # Pair Aces
    aType[aTrips == 0 & aPairs == 1 & aRankCount[, 13] == 2] <- 9  # Pair Kings
    aType[aTrips == 0 & aPairs == 1 & aRankCount[, 12] == 2] <- 10  # Pair Queens
    aType[aTrips == 0 & aPairs == 1 & aRankCount[, 11] == 2] <- 11  # Pair Jacks
    aType[aTrips == 0 & aPairs == 1 & aRankCount[, 10] == 2] <- 12  # Pair Tens
    aType[aTrips == 0 & aPairs == 1 & !(aType %in% c(8, 9, 10, 11, 12))] <- 13  # Pair 22-99

    # Declare types for quads
    quadSubset <- aRankCount[aQuads == 1, ]
    quadType <- apply(quadSubset, 1, FUN=function(x) { c(which(x == 4), which(x == 1)) } )
    quadScore <- rep(-1L, ncol(quadType))

    quadScore[quadType[1, ] == 1 & quadType[2, ] %in% c(2, 3, 4)] <- 14  ## AAAA with 2-4
    quadScore[quadType[1, ] == 1 & quadType[2, ] %in% c(11, 12, 13)] <- 15  ## AAAA with J-K
    quadScore[quadType[1, ] == 1 & quadType[2, ] %in% c(5, 6, 7, 8, 9, 10)] <- 16  ## AAAA with 5-T

    quadScore[quadType[1, ] %in% c(2, 3, 4) & 
                  quadType[2, ] %in% c(1)] <- 17  ## 2222/3333/4444 with A
    quadScore[quadType[1, ] %in% c(2, 3, 4) & 
                  quadType[2, ] %in% c(2, 3, 4)] <- 18  ## 2222/3333/4444 with 2-4
    quadScore[quadType[1, ] %in% c(2, 3, 4) & 
                  quadType[2, ] %in% c(11, 12, 13)] <- 19  ## 2222/3333/4444 with J-K
    quadScore[quadType[1, ] %in% c(2, 3, 4) & 
                  quadType[2, ] %in% c(5, 6, 7, 8, 9, 10)] <- 20  ## 2222/3333/4444 with 5-T

    quadScore[quadType[1, ] %in% c(11, 12, 13) & 
                  quadType[2, ] %in% c(1)] <- 21  ## JJJJ/QQQQ/KKKK with A
    quadScore[quadType[1, ] %in% c(11, 12, 13) & 
                  quadType[2, ] %in% c(2, 3, 4)] <- 22  ## JJJJ/QQQQ/KKKK with 2-4
    quadScore[quadType[1, ] %in% c(11, 12, 13) & 
                  quadType[2, ] %in% c(11, 12, 13)] <- 23  ## JJJJ/QQQQ/KKKK with J-K
    quadScore[quadType[1, ] %in% c(11, 12, 13) & 
                  quadType[2, ] %in% c(5, 6, 7, 8, 9, 10)] <- 24  ## JJJJ/QQQQ/KKKK with 5-T

    quadScore[quadType[1, ] %in% c(5, 6, 7, 8, 9, 10)] <- 25  ## 5555/6666/7777/8888/9999/TTTT with any

    # Populate quad results in to aType
    aType[aQuads == 1] <- quadScore
    data.frame(type=aType) %>% group_by(type) %>% summarize(ct=n()) %>% print.data.frame()

    if (retAll) {
        list(aType=aType, 
             aRankCount=aRankCount,
             aRanks=aRanks,
             aSuits=aSuits,
             quadSubset=quadSubset,
             quadType=quadType,
             aFlush=aFlush,
             aPairs=aPairs,
             aQuads=aQuads,
             aStraight=aStraight,
             aTrips=aTrips
             )
    } else {
        list(aType=aType) 
    }
}


listType <- findTypes(aHands=aHands, retAll=FALSE)
aType <- listType$aType


proc.time() - startTime

```
  
Further, each starting hand is assigned indices for keep0/discard5 down to keep5/discard0 .  Note that hand types have not yet been converted to scores; this is simply the step for finding the relevant indices (cached for run-time optimization):  
```{r, cache=TRUE}

startTime <- proc.time()


getIndices <- function(nKeep, keyFun) {

    mtxKeep <- combn(1:5, nKeep)
    retResults <- matrix(data=-1L, nrow=nrow(aHands), ncol=ncol(mtxKeep))

    for (intCtr in 1:ncol(mtxKeep)) {
        thisKey <- mtxKeep[, intCtr, drop=TRUE]
        thisList <- lapply(seq_along(thisKey), FUN=function(x) { aHands[, thisKey[x]] } )
        if (length(thisList) == 5) {
            retResults[, intCtr] <- keyFun(thisList[[1]], thisList[[2]], thisList[[3]], 
                                           thisList[[4]], thisList[[5]]
                                           )
        } else if (length(thisList) == 4) {
            retResults[, intCtr] <- keyFun(thisList[[1]], thisList[[2]], 
                                           thisList[[3]], thisList[[4]]
                                           )
        } else if (length(thisList) == 3) {
            retResults[, intCtr] <- keyFun(thisList[[1]], thisList[[2]], thisList[[3]])
        } else if (length(thisList) == 2) {
            retResults[, intCtr] <- keyFun(thisList[[1]], thisList[[2]])
        } else if (length(thisList) == 1) {
            retResults[, intCtr] <- keyFun(thisList[[1]])
        } else { stop(paste0("Incorrect list length: ", length(thisList))) }
    }

    # Pass back the outcome
    retResults
    
}


mtxIndices <- matrix(data=-1L, nrow=nrow(aHands), ncol=32)

# Populate the keep-all
mtxIndices[, 1] <- getIndices(nKeep=5, keyFun=idxCard5)
proc.time() - startTime

# Populate the keep-four
mtxIndices[, 2:6] <- getIndices(nKeep=4, keyFun=idxCard4)
proc.time() - startTime

# Populate the keep-three
mtxIndices[, 7:16] <- getIndices(nKeep=3, keyFun=idxCard3)
proc.time() - startTime

# Populate the keep-two
mtxIndices[, 17:26] <- getIndices(nKeep=2, keyFun=idxCard2)
proc.time() - startTime

# Populate the keep-one
mtxIndices[, 27:31] <- getIndices(nKeep=1, keyFun=idxCard1)
proc.time() - startTime

# Populate the keep-zero
mtxIndices[, 32] <- 0L


proc.time() - startTime

```
  
The next step creates the 134,459 non-duplicate starting hands possible (e.g., Ad Kh Tc 9c 3d is the same as As Kh Td 9d 3s), and assigns each a weighting based on how much duplication it covers.  
  
This is copied from v004/v005 which was adapted heavily from clever thinking at <http://wizardofodds.com/games/video-poker/methodology/>, using in order:  
  
* Four of a Kind (all that matters is what is the rank of the quad/kicker)  
* Full House (need to know ranks for A full of B, as well as whether B contains the fourth suit or not)  
* Trips (singletons can be all of fourth suit, one match and one fourth suit, no fourth suit/same, or no fourth suit/different)  
* Two Pair (suits matter for how much is in common between the two pairs, as well as the singleton)  
* Pair (many combinations for suits of the singletons)  
* Nothing (suits matter a great deal!)  
  
This component is cached for run-time performance:  
```{r, cache=TRUE}

startTime <- proc.time()


# Quads are simple - there are 13 possible quads and 12 possible kickers
# Each hand can be captured once with a weight of 4 since the kicker will always match one suit
quadSmall <- matrix(data=0L, nrow=13*12, ncol=5)
quadWeight <- rep(4L, times=13*12)
curIdx <- 1

for (intCtr in 1:13) {
    for (intCtr2 in (1:13)[-intCtr]) {
        quadSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr+39, intCtr2))
        curIdx <- curIdx + 1
    }
}


# Full Houses are not too much more complex, though there are two suit pairing options for each
fhSmall <- matrix(data=0L, nrow=13*12*2, ncol=5)
fhWeight <- rep(12L, times=13*12*2)
curIdx <- 1

for (intCtr in 1:13) {
    for (intCtr2 in (1:13)[-intCtr]) {
        # First option has both pairs matching the suits of the trips
        fhSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr2+13))
        # Second option has one pair not matching the suits of the trips
        fhSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr2+39))
        curIdx <- curIdx + 2
    }
}


# Trips become a touch more complicated
# There is weight 24 for both singletons match different trips suits
# There is weight 12 for one singleton matches and the other does not
# There is weight 12 for both singletons match the same trips suit
# There is weight 4 for both singletons match each other but not any of the trips suits
tripSmall <- matrix(data=0L, nrow=13*choose(12, 2)*5, ncol=5)
tripWeight <- rep(c(24, 12, 12, 12, 4), times=13*choose(12,2))
curIdx <- 1

for (intCtr in 1:13) {
    intAvail <- (1:13)[-intCtr]
    for (intCtr2 in intAvail[-length(intAvail)]) {
        for (intCtr3 in intAvail[intAvail > intCtr2]) {
            # First option has both singletons matching a different trips suit
            tripSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr3+13))
            # Second option has singleton one matching a trips suit and singleton two not
            tripSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr3+39))
            # Third option has singleton two matching a trips suit and singleton one not
            tripSmall[curIdx+2, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2+39, intCtr3))
            # Fourth option has both singletons matching the same trips suit
            tripSmall[curIdx+3, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr3))
            # Fifth option has both singletons failing to match a trips suit
            tripSmall[curIdx+4, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2+39, intCtr3+39))
            # Increment the index by 5
            curIdx <- curIdx + 5
        }
    }
}


# Two Pair becomes even more complicated
# There is weight 12 for four suits across the two pair -- singleton matches pair #1 or pair #2
# There is weight 24 for each of one suit match across the two pair; singleton can be four suits
# There is weight 12 for the two pair having identical suits; once for the singleton matching, once for not
twoSmall <- matrix(data=0L, nrow=choose(13, 2)*11*8, ncol=5)
twoWeight <- rep(c(12, 12, 24, 24, 24, 24, 12, 12), times=choose(13, 2)*11)
curIdx <- 1

for (intCtr in 1:12) {
    for (intCtr2 in (intCtr+1):13) {
        for (intCtr3 in (1:13)[-c(intCtr, intCtr2)]) {
            
            # First option has all two pair cards being different suits
            twoSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr2+39, intCtr3))
            twoSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr2+39, intCtr3+26))
            
            # Second option has one matched suits in the two pair
            twoSmall[curIdx+2, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3))
            twoSmall[curIdx+3, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3+13))
            twoSmall[curIdx+4, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3+26))
            twoSmall[curIdx+5, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3+39))
            
            # Third option has fully matched suits across the two pair
            twoSmall[curIdx+6, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+13, intCtr3))
            twoSmall[curIdx+7, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+13, intCtr3+26))
            
            # Increment the index by 8
            curIdx <- curIdx + 8
        }
    }
}


# One Pair becomes even more complicated
# The pair is (obviously) two-suited; consider them to be 1 and 2; the game is in the singletons
# Weight 12 (2): Singletons all same suit, once matching to a pair suit, and once not
# Weight 12 (3): Singletons are suited 2-1, all matching to the pairs - 112, 121, 211
# Weight 24 (3): Singletons are suited 2-1, two matching to the pairs - 113, 131, 311
# Weight 24 (3): Singletons are suited 2-1, one matching to the pairs - 133, 313, 331 
# Weight 12 (3): Singletons are suited 2-1, none matching to the pairs - 344, 434, 443
# Weight 24 (3): Singletons are suited 1-1-1, two matching to the pairs - 123, 132, 312
# Weight 24 (3): Singletons are suited 1-1-1, one matching to the pairs - 134, 314, 341
pairSmall <- matrix(data=0L, nrow=13*choose(12, 3)*20, ncol=5)
pairWeight <- rep(c(12, 12, 12, 12, 12, 24, 24, 24, 24, 24, 24, 
                    12, 12, 12, 24, 24, 24, 24, 24, 24), 
                  times=13*choose(12, 3)
                  )
curIdx <- 1

for (intCtr in 1:13) {
    intAvail <- (1:13)[-intCtr]
    for (intCtr2 in intAvail[-c(11, 12)]) {
        nextAvail <- (intCtr2+1):13
        nextAvail <- nextAvail[!(nextAvail %in% c(intCtr))]
        for (intCtr3 in nextAvail[-length(nextAvail)]) {
            lastAvail <- (intCtr3+1):13
            lastAvail <- lastAvail[!(lastAvail %in% c(intCtr))]
            for (intCtr4 in lastAvail) {
                # Weight 12 (2): Singletons all same suit, once matching to a pair suit, and once not
                pairSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3, intCtr4))
                pairSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+26, intCtr4+26))
            
                # Weight 12 (3): Singletons are suited 2-1, all matching to the pairs - 112, 121, 211
                pairSmall[curIdx+2, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3, intCtr4+13))
                pairSmall[curIdx+3, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+13, intCtr4))
                pairSmall[curIdx+4, ] <- sort(c(intCtr, intCtr+13, intCtr2+13, intCtr3, intCtr4))
                
                # Weight 24 (3): Singletons are suited 2-1, two matching to the pairs - 113, 131, 311
                pairSmall[curIdx+5, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3, intCtr4+26))
                pairSmall[curIdx+6, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4))
                pairSmall[curIdx+7, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4))
                
                # Weight 24 (3): Singletons are suited 2-1, one matching to the pairs - 133, 313, 331 
                pairSmall[curIdx+8, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4+26))
                pairSmall[curIdx+9, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4+26))
                pairSmall[curIdx+10, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+26, intCtr4))
                
                # Weight 12 (3): Singletons are suited 2-1, none matching to the pairs - 344, 434, 443
                pairSmall[curIdx+11, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+39, intCtr4+39))
                pairSmall[curIdx+12, ] <- sort(c(intCtr, intCtr+13, intCtr2+39, intCtr3+26, intCtr4+39))
                pairSmall[curIdx+13, ] <- sort(c(intCtr, intCtr+13, intCtr2+39, intCtr3+39, intCtr4+26))
                
                # Weight 24 (3): Singletons are suited 1-1-1, two matching to the pairs - 123, 132, 312
                pairSmall[curIdx+14, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+13, intCtr4+26))
                pairSmall[curIdx+15, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4+13))
                pairSmall[curIdx+16, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4+13))
                
                # Weight 24 (3): Singletons are suited 1-1-1, one matching to the pairs - 134, 314, 341
                pairSmall[curIdx+17, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4+39))
                pairSmall[curIdx+18, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4+39))
                pairSmall[curIdx+19, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+39, intCtr4))

                # Increment the index by 20
                curIdx <- curIdx + 20
            }
        }
    }
}


# No Pair becomes even more complicated
# The entire game is in the suits for the singletons
# Weight 4 (1): Singletons all same suit - 11111
# Weight 12 (5): Singletons are suited 4-1 - 11112, 11121, 11211, 12111, 21111
# Weight 12 (10): Singletons are suited 3-2 - 11122, 11212, 11221, 12112, 12121, 
#                                             12211, 21112, 21121, 21211, 22111
# Weight 24 (10): Singletons are suited 3-1-1 - 11123, 11213, 11231, 12113, 12131,
#                                               12311, 21113, 21131, 21311, 23111
# Weight 24 (15): Singletons are suited 2-2-1 - 11223, 12123, 12213, 11232, 12132, 
#                                               12231, 11322, 12312, 12321, 13122, 
#                                               13212, 13221, 31122, 31212, 31221
# Weight 24 (10): Singletons are suited 2-1-1-1 - 11234, 12134, 12314, 12341, 21134, 
#                                                 21314, 21341, 23114, 23141, 23411
noneSmall <- matrix(data=0L, nrow=choose(13, 5)*51, ncol=5)
noneWeight <- rep(c(4, 12, 12, 12, 12, 12, 
                    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 
                    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
                    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
                    24, 24, 24, 24, 24, 24, 24, 24, 24, 24
                    ), times=choose(13, 5)
                  )

mtxAdd <- matrix(data=c(0, 0, 0, 0, 0, 
                        0, 0, 0, 0, 1,
                        0, 0, 0, 1, 0, 
                        0, 0, 1, 0, 0, 
                        0, 1, 0, 0, 0, 
                        1, 0, 0, 0, 0, 
                        0, 0, 0, 1, 1,
                        0, 0, 1, 0, 1,
                        0, 1, 0, 0, 1,
                        1, 0, 0, 0, 1,
                        0, 0, 1, 1, 0,
                        0, 1, 0, 1, 0,
                        1, 0, 0, 1, 0,
                        0, 1, 1, 0, 0,
                        1, 0, 1, 0, 0,
                        1, 1, 0, 0, 0,
                        0, 0, 0, 1, 2,
                        0, 0, 1, 0, 2,
                        0, 1, 0, 0, 2,
                        1, 0, 0, 0, 2,
                        0, 0, 1, 2, 0,
                        0, 1, 0, 2, 0,
                        1, 0, 0, 2, 0,
                        0, 1, 2, 0, 0,
                        1, 0, 2, 0, 0,
                        1, 2, 0, 0, 0,
                        0, 0, 1, 1, 2,
                        0, 1, 0, 1, 2,
                        1, 0, 0, 1, 2,
                        0, 0, 1, 2, 1,
                        0, 1, 0, 2, 1,
                        1, 0, 0, 2, 1,
                        0, 0, 2, 1, 1,
                        0, 1, 2, 0, 1,
                        1, 0, 2, 0, 1,
                        0, 2, 0, 1, 1,
                        0, 2, 1, 0, 1,
                        1, 2, 0, 0, 1,
                        2, 0, 0, 1, 1,
                        2, 0, 1, 0, 1,
                        2, 1, 0, 0, 1,
                        0, 0, 1, 2, 3,
                        0, 1, 0, 2, 3,
                        0, 1, 2, 0, 3,
                        0, 1, 2, 3, 0,
                        1, 0, 0, 2, 3,
                        1, 0, 2, 0, 3,
                        1, 0, 2, 3, 0,
                        1, 2, 0, 0, 3,
                        1, 2, 0, 3, 0,
                        1, 2, 3, 0, 0
                        ) * 13, ncol=5, byrow=TRUE)

curIdx <- 1

for (intCtr in 1:9) {
    for (intCtr2 in (intCtr+1):10) {
        for (intCtr3 in (intCtr2+1):11) {
            for (intCtr4 in (intCtr3+1):12) {
                for (intCtr5 in (intCtr4+1):13) {
                    vecNone <- c(intCtr, intCtr2, intCtr3, intCtr4, intCtr5)
                    mtxNone <- matrix(data=rep(vecNone, times=51), ncol=5, byrow=TRUE)
                    # IMPORTANT - future classification relies on low-high sorting in each row
                    noneSmall[curIdx:(curIdx+50), ] <- 
                        t(apply(mtxNone + mtxAdd, 1, FUN=sort))
                    curIdx <- curIdx + 51
                }
            }
        }
    }
}


proc.time() - startTime

```
  
Further, the hands and weights are integrated to a single hand matrix and a single weighting vector:  
```{r}
startTime <- proc.time()


cardSmall <- rbind(quadSmall, fhSmall, tripSmall, twoSmall, pairSmall, noneSmall)
cardWeight <- c(quadWeight, fhWeight, tripWeight, twoWeight, pairWeight, noneWeight)

str(cardSmall)
str(cardWeight)

# Confirm that there are sill 52c5 hands after weighting
all.equal(sum(cardWeight), choose(52, 5))

# Confirm that dimensions of hands and weight match up
all.equal(nrow(cardSmall), length(cardWeight))
all.equal(ncol(cardSmall), 5)

# Report the degree of space savings due to the weighting
summary(cardWeight)


# Assign the index for each cardSmall
cardIndex <- idxCard5(cardSmall[, 1], cardSmall[, 2], cardSmall[, 3], 
                      cardSmall[, 4], cardSmall[, 5]
                      )
str(cardIndex)
summary(cardIndex)
all.equal(cardIndex, unique(cardIndex))

proc.time() - startTime

```
  
The weighting allows for ~19x reduction in duplication which speeds processing time by roughly ~19x when using "no replacement" for drawing hands.  This is a strong improvement in efficiency.  
  
### Scoring (apply pay table)  
A function is created to convert hand types to scores:  
```{r}

makeScores <- function(inType, type2Score, idx) {
    aScores <- type2Score$val[match(inType, idx)]
    
    print(summary(aScores))
    cat("\n")
    data.frame(aScores=aScores) %>% group_by(aScores) %>% summarize(ct=n()) %>% print()
    cat("\n")
    
    aScores
}

```
  
Next, a function is written to calculate each of the following, assuming that you can get back the original card(s) on the re-draw:  
  
* Keep 4  
* Keep 3  
* Keep 2  
* Keep 1  
  
There is no need to calculate Keep 5 (it is already aScores) or Keep 0 (it defaults to mean(aScores) everywhere):  
```{r}

findEV_YesRedraw <- function(useIdx, mtxIndices, aScores) {
    # Assuming re-draw of thrown cards
    tmpScores <- data.frame(idx=as.vector(mtxIndices[, useIdx]), 
                            val=rep(aScores, times=length(useIdx))
                            )
    
    # This is what will be returned - mean by Index
    tmpScores %>% group_by(idx) %>% summarize(ev=mean(val))
}


calcEV_YesRedraw <- function(mtxIndices, aScores) {

    tmpEVkeep4 <- findEV_YesRedraw(useIdx=2:6, mtxIndices=mtxIndices, aScores=aScores)
    tmpEVkeep3 <- findEV_YesRedraw(useIdx=7:16, mtxIndices=mtxIndices, aScores=aScores)
    tmpEVkeep2 <- findEV_YesRedraw(useIdx=17:26, mtxIndices=mtxIndices, aScores=aScores)
    tmpEVkeep1 <- findEV_YesRedraw(useIdx=27:31, mtxIndices=mtxIndices, aScores=aScores)

    print(summary(tmpEVkeep4$ev)); cat("\n")
    print(summary(tmpEVkeep3$ev)); cat("\n")
    print(summary(tmpEVkeep2$ev)); cat("\n")
    print(summary(tmpEVkeep1$ev)); cat("\n\n")

    print(sum(tmpEVkeep4$idx != 1:choose(52,4)))
    print(sum(tmpEVkeep3$idx != 1:choose(52,3)))
    print(sum(tmpEVkeep2$idx != 1:choose(52,2)))
    print(sum(tmpEVkeep1$idx != 1:choose(52,1)))

    list(tmpEVkeep4=tmpEVkeep4, tmpEVkeep3=tmpEVkeep3, 
         tmpEVkeep2=tmpEVkeep2, tmpEVkeep1=tmpEVkeep1
         )
}

```
  
The summary statistics and control totals are "as expected", and the process takes ~8 seconds.  This could be reduced to ~0.5 seconds by using a weighting that avoids redundancy.  However, further effort is needed to make sure that 1) discards are never returned, and 2) optimal holds for each starting hand can be calculated.  
  
### Analysis (simulate pay table)  
Next, all of the holds are run assuming you cannot re-draw discards, using the smaller database.  The key elements are 1) cardSmall (actual hands), 2) cardWeight (weightings for cardSmall), and 3) cardIndex (the mapping of each hand in cardSmall to the corresponding index of aScores:  
```{r}

makeNoReplace <- function(aScores, cardIndex, keyList, mtxIndices) {
    
    evSmallNoReplace <- matrix(data=0.0, nrow=length(cardIndex), ncol=32)
    
    tmpEVkeep4 <- keyList$tmpEVkeep4
    tmpEVkeep3 <- keyList$tmpEVkeep3
    tmpEVkeep2 <- keyList$tmpEVkeep2
    tmpEVkeep1 <- keyList$tmpEVkeep1
    
    # Keep 5
    evSmallNoReplace[, 1] <- aScores[cardIndex]


    # Keep 4 (intCtr: 2 is 1234, 3 is 1235, 4 is 1245, 5 is 1345, 6 is 2345)
    for (intCtr in 2:6) {
        evSmallNoReplace[, intCtr] <- (48 * tmpEVkeep4$ev[mtxIndices[cardIndex, intCtr]] - 
                                           evSmallNoReplace[, 1]) / 47
    }


    # Keep 3 (intCtr: 7 is 123, 8 is 124, 9 is 125, 10 is 134, 11 is 135)
    # Keep 3 (intCtr: 12 is 145, 13 is 234, 14 is 235, 15 is 245, 16 is 345)
    # Take the EV of the 3 cards assuming stand-alone
    # Subtract the EV of each of the 4 cards (3 + 1 discard) assuming stand-alone
    # Add back the EV of the 5 cards assuming stand-alone
    mapKeep3 <- data.frame(idx=7:16, 
                           keep1=c(2, 2, 3, 2, 3, 4, 2, 3, 4, 5), 
                           keep2=c(3, 4, 4, 5, 5, 5, 6, 6, 6, 6)
                           )
    for (intCtr in 7:16) {
        c1 <- mapKeep3$keep1[mapKeep3$idx == intCtr]
        c2 <- mapKeep3$keep2[mapKeep3$idx == intCtr]
        evSmallNoReplace[, intCtr] <- (choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, intCtr]] - 
                                      48 * tmpEVkeep4$ev[mtxIndices[cardIndex, c1]] -
                                      48 * tmpEVkeep4$ev[mtxIndices[cardIndex, c2]] + 
                                      evSmallNoReplace[, 1]
                                  ) / choose(47, 2)
    }


    # Keep 2 (intCtr: 17 is 12, 18 is 13, 19 is 14, 20 is 15, 21 is 23)
    # Keep 2 (intCtr: 22 is 24, 23 is 25, 24 is 34, 25 is 35, 26 is 45)
    # Take the EV of the 2 cards assuming stand-alone
    # Subtract the EV of each of the 3 cards (2 + 1 discard) assuming stand-alone
    # add back the EV of each of the 4 cards (2 + 2 discard) assuming stand-alone
    # Subtract the EV of the 5 cards assuming stand-alone
    mapKeep2 <- data.frame(idx=17:26, 
                           keep3_1=c(7,  7,  8,  9,  7,  8,  9, 10, 11, 12), 
                           keep3_2=c(8, 10, 10, 11, 13, 13, 14, 13, 14, 15),
                           keep3_3=c(9, 11, 12, 12, 14, 15, 15, 16, 16, 16),
                           keep4_1=c(2, 2, 2, 3, 2, 2, 3, 2, 3, 4),
                           keep4_2=c(3, 3, 4, 4, 3, 4, 4, 5, 5, 5),
                           keep4_3=c(4, 5, 5, 5, 6, 6, 6, 6, 6, 6)
                           )

    for (intCtr in 17:26) {
        c31 <- mapKeep2$keep3_1[mapKeep2$idx == intCtr]
        c32 <- mapKeep2$keep3_2[mapKeep2$idx == intCtr]
        c33 <- mapKeep2$keep3_3[mapKeep2$idx == intCtr]
    
        c41 <- mapKeep2$keep4_1[mapKeep2$idx == intCtr]
        c42 <- mapKeep2$keep4_2[mapKeep2$idx == intCtr]
        c43 <- mapKeep2$keep4_3[mapKeep2$idx == intCtr]
    
        evSmallNoReplace[, intCtr] <- (choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, intCtr]] - 
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c31]] -
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c32]] -
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c33]] +
                                      choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, c41]] +
                                      choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, c42]] +
                                      choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, c43]] -
                                      evSmallNoReplace[, 1]
                                    ) / choose(47, 3)
    }


    # Keep 1 (intCtr: 27 is 1, 28 is 2, 29 is 3, 30 is 4, 31 is 5)
    # Take the EV of the 1 card assuming stand-alone
    # Subtract the EV of the 2 cards (1 + 1 discard) assuming stand-alone
    # Add back the EV of each of the 3 cards (1 + 2 discard) assuming stand-alone
    # Subtract the EV of each of the 4 cards (1 + 3 discard) assuming stand-alone
    # Add back the EV of the 5 cards assuming stand-alone
    mapKeep1 <- data.frame(idx=27:31,
                           keep2_1=c(17, 17, 18, 19, 20),
                           keep2_2=c(18, 21, 21, 22, 23),
                           keep2_3=c(19, 22, 24, 24, 25),
                           keep2_4=c(20, 23, 25, 26, 26),
                           keep3_1=c(7,   7,  7,  8,  9), 
                           keep3_2=c(8,   8, 10, 10, 11),
                           keep3_3=c(9,   9, 11, 12, 12),
                           keep3_4=c(10, 13, 13, 13, 14),
                           keep3_5=c(11, 14, 14, 15, 15),
                           keep3_6=c(12, 15, 16, 16, 16),
                           keep4_1=c(2, 2, 2, 2, 3),
                           keep4_2=c(3, 3, 3, 4, 4),
                           keep4_3=c(4, 4, 5, 5, 5),
                           keep4_4=c(5, 6, 6, 6, 6)
                           )

    for (intCtr in 27:31) {
        c21 <- mapKeep1$keep2_1[mapKeep1$idx == intCtr]
        c22 <- mapKeep1$keep2_2[mapKeep1$idx == intCtr]
        c23 <- mapKeep1$keep2_3[mapKeep1$idx == intCtr]
        c24 <- mapKeep1$keep2_4[mapKeep1$idx == intCtr]
    
        c31 <- mapKeep1$keep3_1[mapKeep1$idx == intCtr]
        c32 <- mapKeep1$keep3_2[mapKeep1$idx == intCtr]
        c33 <- mapKeep1$keep3_3[mapKeep1$idx == intCtr]
        c34 <- mapKeep1$keep3_4[mapKeep1$idx == intCtr]
        c35 <- mapKeep1$keep3_5[mapKeep1$idx == intCtr]
        c36 <- mapKeep1$keep3_6[mapKeep1$idx == intCtr]
    
        c41 <- mapKeep1$keep4_1[mapKeep1$idx == intCtr]
        c42 <- mapKeep1$keep4_2[mapKeep1$idx == intCtr]
        c43 <- mapKeep1$keep4_3[mapKeep1$idx == intCtr]
        c44 <- mapKeep1$keep4_4[mapKeep1$idx == intCtr]
    
        evSmallNoReplace[, intCtr] <- (choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, intCtr]] - 
                                      choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, c21]] -
                                      choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, c22]] - 
                                      choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, c23]] - 
                                      choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, c24]] + 
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c31]] +
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c32]] +
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c33]] +
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c34]] +
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c35]] +
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c36]] -
                                      choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, c41]] -
                                      choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, c42]] -
                                      choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, c43]] -
                                      choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, c44]] +
                                      evSmallNoReplace[, 1]
                                ) / choose(47, 4)
    }


    # Keep 0 (column 32)
    # Take the EV of the 0 card assuming stand-alone
    # Subtract the EV of each 1 card (0 + 1 discard) assuming stand-alone
    # Add back the EV of each of the 2 cards (0 + 2 discard) assuming stand-alone
    # Subtract the EV of each of the 3 cards (0 + 3 discard) assuming stand-alone
    # Add back the EV of each of the 4 cards (0 + 4 discard) assuming stand-alone
    # Subtract the EV of the 5 cards assuming stand-alone

    evSmallNoReplace[, 32] <- (choose(52, 5) * mean(aScores) - 
                              choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, 31]] -
                              choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, 30]] - 
                              choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, 29]] - 
                              choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, 28]] - 
                              choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, 27]] +
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 26]] +
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 25]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 24]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 23]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 22]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 21]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 20]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 19]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 18]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 17]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 16]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 15]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 14]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 13]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 12]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 11]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 10]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 9]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 8]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 7]] +
                              choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, 6]] +
                              choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, 5]] +
                              choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, 4]] +
                              choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, 3]] +
                              choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, 2]] -
                              evSmallNoReplace[, 1]
                          ) / choose(47, 5)

    evSmallNoReplace
}


```
  
The optimal holds and aggregate EV are the assessed:  
```{r}

descStat <- function(tempSmallMax, cardWeight) {

    # Calculate descriptive statistics
    print(summary(rep(tempSmallMax[1, ], times=cardWeight))); cat("\n")
    print(1 + mean(rep(tempSmallMax[1, ], times=cardWeight))); cat("\n")

    hist(rep(tempSmallMax[2, ], times=cardWeight), breaks=0:33, main="Index for Cards Held", 
         xlab="1 (hold 5) --- 2-6 (hold 4: 1234, 1235, 1245, 1345, 2345) -- etc. -- 32 (hold 0)",
        col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
                rep("lightgreen", 10), rep("red", 5), rep("black", 1) 
            ) 
        )

    newSmallCutIdx <- cut(tempSmallMax[2, ], 
                     breaks=c(0.5, 1.5, 6.5, 16.5, 26.5, 31.5, 32.5)
                     )

    data.frame(newType=rep(newSmallCutIdx, times=cardWeight)) %>% 
        group_by(newType) %>% summarize(ct=n())

}

```
  
The control totals and expected values were as expected, and the program runs in ~10 seconds!  

Next, the scoring and analysis are converted to functions, with the simulation re-run:  
```{r}

# Simulate a specific pay-table
simGame <- function(aT=aType, h2S=hnd2Score, gameI=gameIndex, mtxI=mtxIndices, 
                    cardI=cardIndex, cardW=cardWeight, startT=startTime, 
                    grTitle="Simulation Results", allOut=FALSE
                    ) {
    
    # Convert to Scores
    aScores <- makeScores(inType=aT, type2Score=h2S, idx=gameI)

    # Get the EV assuming re-draws are allowed
    keyList <- calcEV_YesRedraw(mtxIndices=mtxI, aScores=aScores)

    # Make the EV grid for "no replacement"
    evSmallNoReplace <- makeNoReplace(aScores=aScores, cardIndex=cardI, 
                                      keyList=keyList, mtxIndices=mtxI
                                      )

    # Find the best holds
    tempSmallMax <- apply(evSmallNoReplace, 1, FUN=function(x) { c(max(x), which.max(x)) } )
    descStat(tempSmallMax=tempSmallMax, cardWeight=cardW)
    
    if (allOut) {
        return(list(tempSmallMax=tempSmallMax, 
                    evSmallNoReplace=evSmallNoReplace, 
                    aScores=aScores, 
                    keyList=keyList
                    )
               )
    } else {
        return(list(tempSmallMax=tempSmallMax, 
                    evSmallNoReplace=evSmallNoReplace
                    )
               )
    }
}


# Use one pay-table on a different game
simPayTable <- function(useEV, useHold, useWeights) {
    
    # Confirm dimensions
    if (length(useHold) != nrow(useEV) | length(useHold) != length(useWeights)) {
        print(str(useEV))
        print(str(useHold))
        print(str(useWeights))
        stop("Error: Inconsistent dimensions for simulation; check and re-try")
    }
    
    # useHold (vector 134,459) determines which column to use 
    # for each respective row of useEV (matrix 134,459 x 32)
    newEV <- useEV[ cbind(1:nrow(useEV), useHold) ]
    print(summary(rep(newEV, times=useWeights)))
    
    return(newEV)
}

```
  
The simulations take ~10 seconds each, and the results are cached for quicker run times:  
```{r, cache=TRUE}

startTime <- proc.time()


# Run the game for JB 96
gameIndex <- 0:25
jb96hnd2Score <- data.frame(idx=gameIndex, val=c( -1, 
                                                 799, 49,  8,  5,  3, 
                                                   2,  1,  0,  0,  0, 
                                                   0, -1, -1, 24, 24, 
                                                  24, 24, 24, 24, 24, 
                                                  24, 24, 24, 24, 24
                                            )
                        )

jb96List <- simGame(h2S=jb96hnd2Score)
proc.time() - startTime



# Run the game for JB 85
gameIndex <- 0:25
jb85hnd2Score <- data.frame(idx=gameIndex, val=c( -1, 
                                                 799, 49,  7,  4,  3, 
                                                   2,  1,  0,  0,  0, 
                                                   0, -1, -1, 24, 24, 
                                                  24, 24, 24, 24, 24, 
                                                  24, 24, 24, 24, 24
                                            )
                        )

jb85List <- simGame(h2S=jb85hnd2Score)
proc.time() - startTime



# Nothing
# RF, SF, FH, FL, ST
# Trips, 2P, AA, KK, QQ
# JJ, TT, 22-99, AAAA 2-4, AAAA J-K
# AAAA 5-T, 2222/3333/4444 A, 2222/3333/4444 2-4, 2222/3333/4444 J-K, 2222/3333/4444 5-T
# JJJJ/QQQQ/KKKK A, JJJJ/QQQQ/KKKK 2-4, JJJJ/QQQQ/KKKK J-K, JJJJ/QQQQ/KKKK 5-T, 5555-TTTT

# Run the game for BP 85
gameIndex <- 0:25
bp85hnd2Score <- data.frame(idx=gameIndex, val=c( -1, 
                                                 799, 49,  7,  4,  3, 
                                                   2,  1,  0,  0,  0, 
                                                   0, -1, -1, 79, 79, 
                                                  79, 39, 39, 39, 39, 
                                                  24, 24, 24, 24, 24
                                            )
                        )

bp85List <- simGame(h2S=bp85hnd2Score)
proc.time() - startTime



# Run the game for DDB 96
gameIndex <- 0:25
ddb96hnd2Score <- data.frame(idx=gameIndex, val=c( -1, 
                                                  799, 49,  8,  5,  3, 
                                                    2,  0,  0,  0,  0, 
                                                    0, -1, -1, 399, 159, 
                                                  159, 159, 159, 79, 79, 
                                                   49, 49, 49, 49, 49
                                             )
                         )

ddb96List <- simGame(h2S=ddb96hnd2Score)
proc.time() - startTime



# Run the game for TDB 97
gameIndex <- 0:25
tdb97hnd2Score <- data.frame(idx=gameIndex, val=c( -1, 
                                                  799,  49,   8,   6,   3, 
                                                    1,   0,   0,   0,   0, 
                                                    0,  -1,  -1, 799, 159, 
                                                  159, 399, 399,  79,  79, 
                                                   49,  49,  49,  49,  49
                                             )
                         )

tdb97List <- simGame(h2S=tdb97hnd2Score)
proc.time() - startTime



# Run the game for TDB 96
gameIndex <- 0:25
tdb96hnd2Score <- data.frame(idx=gameIndex, val=c( -1, 
                                                  799,  49,   8,   5,   3, 
                                                    1,   0,   0,   0,   0, 
                                                    0,  -1,  -1, 799, 159, 
                                                  159, 399, 399,  79,  79, 
                                                   49,  49,  49,  49,  49
                                             )
                         )

tdb96List <- simGame(h2S=tdb96hnd2Score)
proc.time() - startTime



# Run the game for BPD 96
gameIndex <- 0:25
bpd96hnd2Score <- data.frame(idx=gameIndex, val=c( -1, 
                                                  799,  49,   8,   5,   3, 
                                                    2,   0,   0,   0,   0, 
                                                    0,  -1,  -1,  79,  79, 
                                                   79,  79,  79,  79,  79, 
                                                   79,  79,  79,  79,  79
                                             )
                         )

bpd96List <- simGame(h2S=bpd96hnd2Score)
proc.time() - startTime

```
  
The various games are then assessed, including implications on EV when using strategy A on game B:  
```{r}

startTime <- proc.time()


# Find the EV for using the JB 96 strategy on the JB 85 game
sum(jb85List$tempSmallMax[2,] != jb96List$tempSmallMax[2,])
sum((jb85List$tempSmallMax[2,] != jb96List$tempSmallMax[2,]) * cardWeight)
jb85EV_jb96Holds <- simPayTable(useEV=jb85List$evSmallNoReplace, 
                                useHold=jb96List$tempSmallMax[2, ], 
                                useWeights=cardWeight
                                )
1 + mean(rep(jb85EV_jb96Holds, times=cardWeight))
mean(rep(jb85EV_jb96Holds - jb85List$tempSmallMax[1, ], times=cardWeight))
proc.time() - startTime



# Find the EV for using the JB 96 strategy on the BP 85 game
sum(bp85List$tempSmallMax[2,] != jb96List$tempSmallMax[2,])
sum((bp85List$tempSmallMax[2,] != jb96List$tempSmallMax[2,]) * cardWeight)
bp85EV_jb96Holds <- simPayTable(useEV=bp85List$evSmallNoReplace, 
                                useHold=jb96List$tempSmallMax[2, ], 
                                useWeights=cardWeight
                                )
1 + mean(rep(bp85EV_jb96Holds, times=cardWeight))
mean(rep(bp85EV_jb96Holds - bp85List$tempSmallMax[1, ], times=cardWeight))
proc.time() - startTime


# Find the EV for using the JB 96 strategy on the DDB 96 game
sum(ddb96List$tempSmallMax[2,] != jb96List$tempSmallMax[2,])
sum((ddb96List$tempSmallMax[2,] != jb96List$tempSmallMax[2,]) * cardWeight)
ddb96EV_jb96Holds <- simPayTable(useEV=ddb96List$evSmallNoReplace, 
                                useHold=jb96List$tempSmallMax[2, ], 
                                useWeights=cardWeight
                                )
1 + mean(rep(ddb96EV_jb96Holds, times=cardWeight))
d_jb96_ddb96 <- ddb96EV_jb96Holds - ddb96List$tempSmallMax[1, ]
mean(rep(d_jb96_ddb96, times=cardWeight))
data.frame(dEV=rep(d_jb96_ddb96, times=cardWeight)) %>% 
    mutate(rndDelta=round(dEV, 2)) %>% 
    group_by(rndDelta) %>%
    summarize(ct=n(), evLoss=100 * sum(rndDelta)/sum(cardWeight))
proc.time() - startTime


# Find the EV for using the DDB 96 strategy on the TDB 97 game
sum(tdb97List$tempSmallMax[2,] != ddb96List$tempSmallMax[2,])
sum((tdb97List$tempSmallMax[2,] != ddb96List$tempSmallMax[2,]) * cardWeight)
tdb97EV_ddb96Holds <- simPayTable(useEV=tdb97List$evSmallNoReplace, 
                                  useHold=ddb96List$tempSmallMax[2, ], 
                                  useWeights=cardWeight
                                  )
1 + mean(rep(tdb97EV_ddb96Holds, times=cardWeight))
d_ddb96_tdb97 <- tdb97EV_ddb96Holds - tdb97List$tempSmallMax[1, ]
mean(rep(d_ddb96_tdb97, times=cardWeight))
data.frame(dEV=rep(d_ddb96_tdb97, times=cardWeight)) %>% 
    mutate(rndDelta=round(dEV, 2)) %>% 
    group_by(rndDelta) %>%
    summarize(ct=n(), evLoss=100 * sum(rndDelta)/sum(cardWeight)) %>%
    print.data.frame()
proc.time() - startTime


# Find the EV for using the DDB 96 strategy on the TDB 96 game
sum(tdb96List$tempSmallMax[2,] != ddb96List$tempSmallMax[2,])
sum((tdb96List$tempSmallMax[2,] != ddb96List$tempSmallMax[2,]) * cardWeight)
tdb96EV_ddb96Holds <- simPayTable(useEV=tdb96List$evSmallNoReplace, 
                                  useHold=ddb96List$tempSmallMax[2, ], 
                                  useWeights=cardWeight
                                  )
1 + mean(rep(tdb96EV_ddb96Holds, times=cardWeight))
d_ddb96_tdb96 <- tdb96EV_ddb96Holds - tdb96List$tempSmallMax[1, ]
mean(rep(d_ddb96_tdb96, times=cardWeight))
data.frame(dEV=rep(d_ddb96_tdb96, times=cardWeight)) %>% 
    mutate(rndDelta=round(dEV, 2)) %>% 
    group_by(rndDelta) %>%
    summarize(ct=n(), evLoss=100 * sum(rndDelta)/sum(cardWeight)) %>%
    print.data.frame()
proc.time() - startTime


# Find the EV for using the DDB 96 strategy on the JB 96 game
sum(jb96List$tempSmallMax[2,] != ddb96List$tempSmallMax[2,])
sum((jb96List$tempSmallMax[2,] != ddb96List$tempSmallMax[2,]) * cardWeight)
jb96EV_ddb96Holds <- simPayTable(useEV=jb96List$evSmallNoReplace, 
                                 useHold=ddb96List$tempSmallMax[2, ], 
                                 useWeights=cardWeight
                                 )
1 + mean(rep(jb96EV_ddb96Holds, times=cardWeight))
d_ddb96_jb96 <- jb96EV_ddb96Holds - jb96List$tempSmallMax[1, ]
mean(rep(d_ddb96_jb96, times=cardWeight))
data.frame(dEV=rep(d_ddb96_jb96, times=cardWeight)) %>% 
    mutate(rndDelta=round(dEV, 2)) %>% 
    group_by(rndDelta) %>%
    summarize(ct=n(), evLoss=100 * sum(rndDelta)/sum(cardWeight)) %>%
    print.data.frame()
proc.time() - startTime



# Find the EV for using the JB 96 strategy on the BPD 96 game
sum(bpd96List$tempSmallMax[2,] != jb96List$tempSmallMax[2,])
sum((bpd96List$tempSmallMax[2,] != jb96List$tempSmallMax[2,]) * cardWeight)
bpd96EV_jb96Holds <- simPayTable(useEV=bpd96List$evSmallNoReplace, 
                                 useHold=jb96List$tempSmallMax[2, ], 
                                 useWeights=cardWeight
                                 )
1 + mean(rep(bpd96EV_jb96Holds, times=cardWeight))
d_jb96_bpd96 <- bpd96EV_jb96Holds - bpd96List$tempSmallMax[1, ]
mean(rep(d_jb96_bpd96, times=cardWeight))
data.frame(dEV=rep(d_jb96_bpd96, times=cardWeight)) %>% 
    mutate(rndDelta=round(dEV, 2)) %>% 
    group_by(rndDelta) %>%
    summarize(ct=n(), evLoss=100 * sum(rndDelta)/sum(cardWeight))
proc.time() - startTime



# Find variance for initial dealt cards in JB 96,  JB 85,  BP 85, 
#                                          DDB 96, TDB 97, TDB 96, and BPD 96
findMeanVar <- function(useList, useName, useWeight=cardWeight) {
    gameMean <- mean(rep(useList$tempSmallMax[1, ], times=useWeight))
    gameVar <- var(rep(useList$tempSmallMax[1, ], times=useWeight))
    print(paste0("Game ", useName, ":  Return: ", signif(1+gameMean, 5), 
                 " and Variance on Deal: ", signif(gameVar, 4)
                 )
          )
}

findMeanVar(useList=jb96List, useName="JB 96")
findMeanVar(useList=jb85List, useName="JB 85")
findMeanVar(useList=bp85List, useName="BP 85")
findMeanVar(useList=ddb96List, useName="DDB 96")
findMeanVar(useList=tdb97List, useName="TDB 97")
findMeanVar(useList=tdb96List, useName="TDB 96")
findMeanVar(useList=bpd96List, useName="BPD 96")

```
  
The functional approach takes ~10 seconds per game and generates the correct results.  

Specific to using the JB96 strategy on the DDB 96 game, errors are generated as follows:  
  
* AAppx (should just keep AA) - 19,008 hands, 0.18% penalty  
* AAAA with 5-K or 2222/3333/4444 with 5-K (should discard 5-K) - 144 hands, 0.17% penalty  
* A-Hx-T/L-L-L (should keep A) and inside-straight (go for it) - 234,852 hands, 0.13% penalty  
* AAA with 55/66/77/88/99/TT/JJ/QQ/KK (should just keep AAA) - 216 hands, 0.03% penalty  
* AAA with 22/33/44 (should just keep AAA) - 72 hands, 0.01% penalty  
* mix of HHTLL - 12,492 hands, 0.01% penalty  
* QJTT9 or QJT99 (should keep QJT9) - 696 hands, <0.01% penalty  
* AKQsJs (should keep AKQJ) - 756 hands, <0.01% penalty  
  
Specific to using the DDB96 strategy on the TDB97 and TDB96 games, errors are generated as follows:  
  
* TDB97 - ~10% of holds should change from DDB 96, with EV declining by ~1.1% from ~99.6% to ~98.5% otherwise (roughly ~0.7% of the decline is driven by what to hold with dealt AAA/222/333/444)  
* TDB96 - ~5% of holds should change from DDB 96, with EV declining by ~0.8% from ~98.2% to ~97.4% otherwise (roughly ~0.7% of the decline is driven by what to hold with dealt AAA/222/333/444)  
  
Specific to using the DDB 96 strategy on the JB 96 games, errors are generated of ~1.0% (reducing returns from ~99.5% to ~98.5%).  Almost all of the errors are related to the AAAxx, AAPPx, and AHHxx holds.  
  
Specific to using the JB 96 strategy on the BPD 96 games, only minimal (<0.1% EV) errors are generated.  
  
Broadly, playing strategy for the following games incurs minimal errors:  
  
* JB 96, JB 95, BP 85, BPD 96 - use the JB 96 strategy which has very minimal errors throughout  
* DDB 96 - modify the JB 96 strategy to account for value of Aces and Kickers (hold AAAA vs AAAA/5-K, hold AAA vs AAApp, hold AA vs AAppx, hold A vs AK/AQ/AJ/KQ/KJ/QJ)  
* TDB 96 (and to an extent TDP 97) - use the DDB 96 strategy, adjusted to keep kickers with AAA/222/333/444 if available  
  
Additionally, an algorithm is written to return the specific cards that are held for any given set of strategies:  
```{r}

findHolds <- function(idxKeep, myCards=cardSmall) {
    # 1     is keep all 5
    # 2-6   is keep 4 (1234, 1235, 1245, 1345, 2345)
    # 7-16  is keep 3 (123, 124, 125, 134, 135, 145, 234, 235, 245, 345)
    # 17-26 is keep 2 (12, 13, 14, 15, 23, 24, 25, 34, 35, 45)
    # 27-31 is keep 1 (1, 2, 3, 4, 5)
    # 32    is keep 0 ()
    
    storage.mode(myCards) <- "integer"
    
    keepCol <- matrix(data=TRUE, nrow=length(idxKeep), ncol=5)
    
    keepCol[, 1] <- idxKeep %in% c(1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 17, 18, 19, 20, 27)
    keepCol[, 2] <- idxKeep %in% c(1, 2, 3, 4, 6, 7, 8, 9, 13, 14, 15, 17, 21, 22, 23, 28)
    keepCol[, 3] <- idxKeep %in% c(1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 16, 18, 21, 24, 25, 29)
    keepCol[, 4] <- idxKeep %in% c(1, 2, 4, 5, 6, 8, 10, 12, 13, 15, 16, 19, 22, 24, 26, 30)
    keepCol[, 5] <- idxKeep %in% c(1, 3, 4, 5, 6, 9, 11, 12, 14, 15, 16, 20, 23, 25, 26, 31)
    
    myCards[!keepCol] <- NA_integer_
    
    myCards
}

diffHolds <- function(holdA, holdB) {
    holdA[is.na(holdA)] <- -1L
    holdB[is.na(holdB)] <- -1L
    
    deltaHolds <- rowSums(abs(holdA - holdB)) > 0
    
    deltaHolds
}

jb96Holds <- findHolds(idxKeep=jb96List$tempSmallMax[2, ])
bp85Holds <- findHolds(idxKeep=bp85List$tempSmallMax[2, ])
jb85Holds <- findHolds(idxKeep=jb85List$tempSmallMax[2, ])
bpd96Holds <- findHolds(idxKeep=bpd96List$tempSmallMax[2, ])
ddb96Holds <- findHolds(idxKeep=ddb96List$tempSmallMax[2, ])
tdb96Holds <- findHolds(idxKeep=tdb96List$tempSmallMax[2, ])

# Compare JB 96 and BP 85
jb96_vs_bp85Holds <- diffHolds(jb96Holds, bp85Holds)
sum(jb96_vs_bp85Holds)

if (sum(jb96_vs_bp85Holds) > 0) { 
    cbind(cardSmall[jb96_vs_bp85Holds, ], 
          jb96Holds[jb96_vs_bp85Holds, ], 
          bp85Holds[jb96_vs_bp85Holds, ]
          )[sort(sample(1:sum(jb96_vs_bp85Holds), 20)), ]
}


# Compare JB 96 and JB 85
jb96_vs_jb85Holds <- diffHolds(jb96Holds, jb85Holds)
sum(jb96_vs_jb85Holds)

if (sum(jb96_vs_jb85Holds) > 0) { 
    cbind(cardSmall[jb96_vs_jb85Holds, ], 
          jb96Holds[jb96_vs_jb85Holds, ], 
          jb85Holds[jb96_vs_jb85Holds, ]
          )[sort(sample(1:sum(jb96_vs_jb85Holds), 20)), ]
}


# Compare BP 85 and JB 85
bp85_vs_jb85Holds <- diffHolds(bp85Holds, jb85Holds)
sum(bp85_vs_jb85Holds)

if (sum(bp85_vs_jb85Holds) > 0) { 
    cbind(cardSmall[bp85_vs_jb85Holds, ], 
          bp85Holds[bp85_vs_jb85Holds, ], 
          jb85Holds[bp85_vs_jb85Holds, ]
          )[sort(sample(1:sum(bp85_vs_jb85Holds), 20)), ]
}


# Compare JB 96 and DDB 96
jb96_vs_ddb96Holds <- diffHolds(jb96Holds, ddb96Holds)
sum(jb96_vs_ddb96Holds)

if (sum(jb96_vs_ddb96Holds) > 0) { 
    cbind(cardSmall[jb96_vs_ddb96Holds, ], 
          jb96Holds[jb96_vs_ddb96Holds, ], 
          ddb96Holds[jb96_vs_ddb96Holds, ]
          )[sort(sample(1:sum(jb96_vs_ddb96Holds), 20)), ]
}


# Compare JB 96 and BPD 96
jb96_vs_bpd96Holds <- diffHolds(jb96Holds, bpd96Holds)
sum(jb96_vs_bpd96Holds)

if (sum(jb96_vs_bpd96Holds) > 0) { 
    cbind(cardSmall[jb96_vs_bpd96Holds, ], 
          jb96Holds[jb96_vs_bpd96Holds, ], 
          bpd96Holds[jb96_vs_bpd96Holds, ]
          )[sort(sample(1:sum(jb96_vs_bpd96Holds), 20)), ]
}


# Compare TDB 96 and DDB 96
tdb96_vs_ddb96Holds <- diffHolds(tdb96Holds, ddb96Holds)
sum(tdb96_vs_ddb96Holds)

if (sum(tdb96_vs_ddb96Holds) > 0) { 
    cbind(cardSmall[tdb96_vs_ddb96Holds, ], 
          tdb96Holds[tdb96_vs_ddb96Holds, ], 
          ddb96Holds[tdb96_vs_ddb96Holds, ]
          )[sort(sample(1:sum(tdb96_vs_ddb96Holds), 20)), ]
}


```
  
Next, a sampling of hands is taken assuming only the cards on the deal (draw assumed to provide exactly the EV of the deal; essentially n-play as n -> +Inf).  First, a function is written:  
```{r}

simDrawOnly <- function(useList, useWeight=cardWeight, nCards=1000, nSims=10) {
    # gameHold <- vector("list", length=nSims)
    gameHold <- base::sample(rep(useList$tempSmallMax[1, ], times=useWeight), 
                                           nCards*nSims, replace=TRUE
                                           )
    gameCtr <- rep(1:nSims, each=nCards)
    
    # for (intCtr in 1:nSims) {
    #     gameHold[[intCtr]] <- base::sample(rep(useList$tempSmallMax[1, ], times=useWeight), 
    #                                        nCards, replace=TRUE
    #                                        )
    # }
    
    gameResults <- tapply(gameHold, gameCtr, FUN=sum)
    gameMins <- tapply(gameHold, gameCtr, FUN=function(x) { min(cumsum(x)) })
    
    print(summary(gameResults))
    print(summary(gameMins))
    
    list(totalSum=gameResults, worstSum=gameMins)
}

```
  
Then, a 40,000 x 2,000 simulation is run for each of seven game types, with the results cached to improve run times:  
```{r, cache=TRUE}

nDeals <- 40000

jb96SimDraw <- simDrawOnly(useList=jb96List, nCards=nDeals, nSims=2000)
jb85SimDraw <- simDrawOnly(useList=jb85List, nCards=nDeals, nSims=2000)
bp85SimDraw <- simDrawOnly(useList=bp85List, nCards=nDeals, nSims=2000)
bpd96SimDraw <- simDrawOnly(useList=bpd96List, nCards=nDeals, nSims=2000)
ddb96SimDraw <- simDrawOnly(useList=ddb96List, nCards=nDeals, nSims=2000)
tdb96SimDraw <- simDrawOnly(useList=tdb96List, nCards=nDeals, nSims=2000)

```
  
The histograms and associated summary statistics are examined and compared:  
```{r}

fmtDeals <- prettyNum(nDeals, big.mark=",")

# JB 96 vs BP 85
hist(pmin(jb96SimDraw$totalSum/nDeals, 0.2), breaks=seq(-0.1, 0.2, by=0.005), 
     col=rgb(1, 0, 0, 0.4), 
     main=paste0("Cumulative Returns (deal-only EV) for ", fmtDeals, " Hands"), 
     xlab=paste0("Cumulative Return after ", fmtDeals, " Hands (capped at 20%)")
     )
hist(pmin(bp85SimDraw$totalSum/nDeals, 0.2), breaks=seq(-0.1, 0.2, by=0.005), 
     col=rgb(0, 0, 1, 0.4), add=TRUE
     )
legend("topright", pch=19, legend=c("JB 96", "BP 85", "Overlap"), 
       col=c(rgb(1, 0, 0, 0.4), rgb(0, 0, 1, 0.4), rgb(0.5, 0, 0.5, 0.6))
       )


# JB 96 vs JB 85
hist(pmin(jb96SimDraw$totalSum/nDeals, 0.2), breaks=seq(-0.1, 0.2, by=0.005), 
     col=rgb(1, 0, 0, 0.4), 
     main=paste0("Cumulative Returns (deal-only EV) for ", fmtDeals, " Hands"), 
     xlab=paste0("Cumulative Return after ", fmtDeals, " Hands (capped at 20%)")
     )
hist(pmin(jb85SimDraw$totalSum/nDeals, 0.2), breaks=seq(-0.1, 0.2, by=0.005), 
     col=rgb(0, 0, 1, 0.4), add=TRUE
     )
legend("topright", pch=19, legend=c("JB 96", "JB 85", "Overlap"), 
       col=c(rgb(1, 0, 0, 0.4), rgb(0, 0, 1, 0.4), rgb(0.5, 0, 0.5, 0.6))
       )


# JB 96 vs BPD 96
hist(pmin(jb96SimDraw$totalSum/nDeals, 0.2), breaks=seq(-0.1, 0.2, by=0.005), 
     col=rgb(1, 0, 0, 0.4), 
     main=paste0("Cumulative Returns (deal-only EV) for ", fmtDeals, " Hands"), 
     xlab=paste0("Cumulative Return after ", fmtDeals, " Hands (capped at 20%)")
     )
hist(pmin(bpd96SimDraw$totalSum/nDeals, 0.2), breaks=seq(-0.1, 0.2, by=0.005), 
     col=rgb(0, 0, 1, 0.4), add=TRUE
     )
legend("topright", pch=19, legend=c("JB 96", "BPD 96", "Overlap"), 
       col=c(rgb(1, 0, 0, 0.4), rgb(0, 0, 1, 0.4), rgb(0.5, 0, 0.5, 0.6))
       )


# JB 96 vs DDB 96
hist(pmin(jb96SimDraw$totalSum/nDeals, 0.2), breaks=seq(-0.1, 0.2, by=0.005), 
     col=rgb(1, 0, 0, 0.4), 
     main=paste0("Cumulative Returns (deal-only EV) for ", fmtDeals, " Hands"), 
     xlab=paste0("Cumulative Return after ", fmtDeals, " Hands (capped at 20%)")
     )
hist(pmin(ddb96SimDraw$totalSum/nDeals, 0.2), breaks=seq(-0.1, 0.2, by=0.005), 
     col=rgb(0, 0, 1, 0.4), add=TRUE
     )
legend("topright", pch=19, legend=c("JB 96", "DDB 96", "Overlap"), 
       col=c(rgb(1, 0, 0, 0.4), rgb(0, 0, 1, 0.4), rgb(0.5, 0, 0.5, 0.6))
       )


# DDB 96 vs TDB 96
hist(pmin(ddb96SimDraw$totalSum/nDeals, 0.2), breaks=seq(-0.1, 0.2, by=0.005), 
     col=rgb(1, 0, 0, 0.4), 
     main=paste0("Cumulative Returns (deal-only EV) for ", fmtDeals, " Hands"), 
     xlab=paste0("Cumulative Return after ", fmtDeals, " Hands (capped at 20%)")
     )
hist(pmin(tdb96SimDraw$totalSum/nDeals, 0.2), breaks=seq(-0.1, 0.2, by=0.005), 
     col=rgb(0, 0, 1, 0.4), add=TRUE
     )
legend("topright", pch=19, legend=c("DDB 96", "TDB 96", "Overlap"), 
       col=c(rgb(1, 0, 0, 0.4), rgb(0, 0, 1, 0.4), rgb(0.5, 0, 0.5, 0.6))
       )


# Comparisons of percentiles
keyQuant <- c(0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99)

jb96Quant <- quantile(jb96SimDraw$totalSum/nDeals, keyQuant)
jb85Quant <- quantile(jb85SimDraw$totalSum/nDeals, keyQuant)
bp85Quant <- quantile(bp85SimDraw$totalSum/nDeals, keyQuant)
bpd96Quant <- quantile(bpd96SimDraw$totalSum/nDeals, keyQuant)
ddb96Quant <- quantile(ddb96SimDraw$totalSum/nDeals, keyQuant)
tdb96Quant <- quantile(tdb96SimDraw$totalSum/nDeals, keyQuant)

allQuant <- cbind(jb85Quant, jb96Quant, bp85Quant, bpd96Quant, ddb96Quant, tdb96Quant)

xBounds <- c(floor(50*min(allQuant))/50, ceiling(50*max(allQuant))/50)

# Plot the 1%
plot(y=1:ncol(allQuant), x=allQuant[1, ], type="l", lty=2, col="red", xlim=xBounds,
     ylab="Game Type", yaxt="n", main="Percentiles by Game", 
     xlab=paste0("EV of Deal-Only at ", fmtDeals, " Hands") 
     )
axis(2, at=6:1, labels=c("TDB 96", "DDB 96", "BPD 96", "BP 85", "JB 96","JB 85"), cex.axis=0.8)
points(y=1:ncol(allQuant), x=allQuant[1, ], pch=19, cex=2, col="red")

# Plot the 5%
lines(y=1:ncol(allQuant), x=allQuant[2, ], lty=2, col="orange")
points(y=1:ncol(allQuant), x=allQuant[2, ], lty=2, col="orange", pch=19, cex=2)

# Plot the 10%
lines(y=1:ncol(allQuant), x=allQuant[3, ], lty=2, col="purple")
points(y=1:ncol(allQuant), x=allQuant[3, ], lty=2, col="purple", pch=19, cex=2)

# Plot the 50%
lines(y=1:ncol(allQuant), x=allQuant[5, ], lty=2, col="black")
points(y=1:ncol(allQuant), x=allQuant[5, ], lty=2, col="black", pch=19, cex=2)

# Plot the 75%
lines(y=1:ncol(allQuant), x=allQuant[6, ], lty=2, col="dark blue")
points(y=1:ncol(allQuant), x=allQuant[6, ], lty=2, col="dark blue", pch=19, cex=2)

# Plot the 95%
lines(y=1:ncol(allQuant), x=allQuant[8, ], lty=2, col="dark green")
points(y=1:ncol(allQuant), x=allQuant[8, ], lty=2, col="dark green", pch=19, cex=2)

legend("bottomright", legend=c("1%", "5%", "10%", "50%", "75%", "95%"),
       col=c("red", "orange", "purple", "black", "dark blue", "dark green"),
       lty=2, pch=19
       )

# Show ratios
round(allQuant[1:5, ] / allQuant[1:5, 2], 2)


```
    
Next, a single game type is simulated through various numbers of hands, with percentiles assessed.  For starters, a function is built:  
```{r}

simPercentile <- function(keyList, useName, 
                          runSims=2000, 
                          useQuant=c(0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99), 
                          yVal=c(500, 1000, 2000, 4000, 8000, 16000, 25000, 40000), 
                          ptCol=c("red", "pink", "orange", "purple", "black", 
                                  "blue", "light green", "dark green", "grey"
                                  )
                          ) {

    keySim <- vector("list", length(yVal))
    keyQuants <- vector("list", length(yVal))

    for (intCtr in seq_along(yVal)) {
        keySim[[intCtr]] <- simDrawOnly(useList=keyList, nCards=yVal[intCtr], nSims=runSims)
        keyQuants[[intCtr]] <- quantile(keySim[[intCtr]]$totalSum/yVal[intCtr], useQuant)
    }

    xVal <- sapply(keyQuants, FUN=function(x) { x })
    
    plot(x=as.vector(xVal), y=log10(rep(yVal, each=length(useQuant))), 
         col=rep(ptCol, times=length(useQuant)), ylab="Log 10 (# Hands Dealt)", 
         xlab="EV of Deal-Only", main=paste0(useName, ": EV of Deal-Only Components"),
         pch=19, ylim=c(log10(0.5 * min(yVal)), log10(2 * max(yVal)))
        )
    legend("top", col=ptCol, pch=19, ncol=length(useQuant), 
           legend=paste0(100*useQuant, "%")
           )

    list(keySim=keySim, keyQuants=keyQuants)
}

```
  
Next, the JB 96 game is simulated, with results cached for later usage:  
```{r, cache=TRUE}

set.seed(1611260741)
jb96Sim <- simPercentile(keyList=jb96List, useName="JB 96")

```
  
Then, the BP 85 game is simulated, with results cached for later usage:  
```{r, cache=TRUE}

set.seed(2016112607)
bp85Sim <- simPercentile(keyList=bp85List, useName="BP 85")

```
  
Then, the DDB 96 game is simulated, with results cached for later usage:  
```{r, cache=TRUE}

set.seed(1126201607)
ddb96Sim <- simPercentile(keyList=ddb96List, useName="DDB 96")

```

Then, the BPD 96 game is simulated, with results cached for later usage:  
```{r, cache=TRUE}

set.seed(1127201606)
bpd96Sim <- simPercentile(keyList=bpd96List, useName="BPD 96")

```

Then, the TDB 96 game is simulated, with results cached for later usage:  
```{r, cache=TRUE}

set.seed(16112706)
tdb96Sim <- simPercentile(keyList=tdb96List, useName="TDB 96")

```
  
There are some interesting disconnects in the 99% EV of deal-only components, driven by the small possibilities of a nice pat hand.  For example:  
```{r}

library(dplyr)

data.frame(rndScore=round(rep(jb96List$tempSmallMax[1, ], times=cardWeight), 0)) %>%
    group_by(rndScore) %>%
    summarize(ct=n(), per=round(choose(52, 5)/ct, 1)) %>%
    print.data.frame()

data.frame(rndScore=round(rep(bp85List$tempSmallMax[1, ], times=cardWeight), 0)) %>%
    group_by(rndScore) %>%
    summarize(ct=n(), per=round(choose(52, 5)/ct, 1)) %>%
    print.data.frame()

data.frame(rndScore=round(rep(ddb96List$tempSmallMax[1, ], times=cardWeight), 0)) %>%
    group_by(rndScore) %>%
    summarize(ct=n(), per=round(choose(52, 5)/ct, 1)) %>%
    print.data.frame()

data.frame(rndScore=round(rep(bpd96List$tempSmallMax[1, ], times=cardWeight), 0)) %>%
    group_by(rndScore) %>%
    summarize(ct=n(), per=round(choose(52, 5)/ct, 1)) %>%
    print.data.frame()

data.frame(rndScore=round(rep(tdb96List$tempSmallMax[1, ], times=cardWeight), 0)) %>%
    group_by(rndScore) %>%
    summarize(ct=n(), per=round(choose(52, 5)/ct, 1)) %>%
    print.data.frame()

```

With simulations of size X, the "1% cut-off" on average includes dealt hands occuring every 100*X times.  For JB 96, dealt-hands with EV of 799 could be expected in the "1% cut-off" for simulations of size 6500+.  So, at simulation size 8,000, there is an expected "bump" as this component is worth ~10% (799/8000).  The "best 1%" line can be expected to jump to median+10%, since a sequence that has a dealt 799 but otherwise runs at median should now find its way near the lower portion of the top 1% (the 1% cut-off).  
  
This effect is less evident for BP 85 and (especially) DDB 96 since with additional high-dealt-EV components, the impact of the dealt-royal is less impactful.  For example, in DDB 96, the dealt Aces Kicker is worth half as much as the dealt Royal but occurs three times as often.  So, merely obtaining a dealt Royal is much less likely to convert an otherwise mundane sequence to being in the "top 1%".  
  
This effect is more or less non-existent for BPD 96 (all quads +79) and TDB 96 (premium quads +399/+799) since there are a series of higher-frequency hands with good dealt-EV rather than an occasional hand with good dealt-EV.  So, the top 1% will almost always include some good dealt hands for BPD 96 and TDB 96 even if the sample size is too small for a dealt RF.

### Variance on the Draw  
Much of the variance of the game occurs during the draw, as a particular hold may allow for anything from a Royal Flush through nothing, frequently with a few back-door good pays (e.g., getting the 3 cards needed to finish a Flush or Straight), many pushes (improving to a high pair), and a great many losses.  The EV on the deal averages across all of these, masking a huge portion of the game's variance.  This is particularly salient when considering the impact of N-play (one dealt hand, one hold applied across hands, N independent draws without replacement scored).  
  
For starters, calculating variance on the draw requires keeping all of the possible outcomes.  The previous function (as well as its calls to functions) that used EVs is adapted to output a matrix of possible outcomes:  
```{r}

findFreq_YesRedraw <- function(useIdx, mtxIndices, aTypes) {
    # Assuming re-draw of thrown cards
    tmpScores <- data.frame(idx=as.vector(mtxIndices[, useIdx]), 
                            val=rep(as.integer(aTypes), times=length(useIdx))
                            )
    
    # Convert them to the relevant tbl_df (chkTidy will have idx and '0' through '25' as the columns)
    chkTidy <- tmpScores %>% 
        group_by(idx, val) %>% 
        summarize(ct=n()) %>% 
        spread(val, ct, fill=0)
    
    # Double check that the proper number of columns exist
    if (length(names(chkTidy)) != 27 | 
        names(chkTidy)[1] != "idx" |
        !isTRUE(all.equal(as.integer(names(chkTidy)[-1]), 0:25))
        ) {
        print(names(chkTidy))
        stop("The tidy process needs to produce a tbl_df with names 'idx' and then '0' through '25'")
    }
    
    # Return the thing as a matrix
    as.matrix(chkTidy)
}


calcFreq_YesRedraw <- function(mtxIndices, aTypes) {

    tmpEVkeep5 <- findFreq_YesRedraw(useIdx=1, mtxIndices=mtxIndices, aTypes=aTypes)
    tmpEVkeep4 <- findFreq_YesRedraw(useIdx=2:6, mtxIndices=mtxIndices, aTypes=aTypes)
    tmpEVkeep3 <- findFreq_YesRedraw(useIdx=7:16, mtxIndices=mtxIndices, aTypes=aTypes)
    tmpEVkeep2 <- findFreq_YesRedraw(useIdx=17:26, mtxIndices=mtxIndices, aTypes=aTypes)
    tmpEVkeep1 <- findFreq_YesRedraw(useIdx=27:31, mtxIndices=mtxIndices, aTypes=aTypes)
    tmpEVkeep0 <- findFreq_YesRedraw(useIdx=32, mtxIndices=mtxIndices, aTypes=aTypes)

    print(dim(tmpEVkeep5))
    print(dim(tmpEVkeep4))
    print(dim(tmpEVkeep3))
    print(dim(tmpEVkeep2))
    print(dim(tmpEVkeep1))
    print(dim(tmpEVkeep0))
    print(tmpEVkeep0)
    
    print(sum(tmpEVkeep5[, 1] != 1:choose(52,5)))
    print(sum(tmpEVkeep4[, 1] != 1:choose(52,4)))
    print(sum(tmpEVkeep3[, 1] != 1:choose(52,3)))
    print(sum(tmpEVkeep2[, 1] != 1:choose(52,2)))
    print(sum(tmpEVkeep1[, 1] != 1:choose(52,1)))
    print(sum(tmpEVkeep0[, 1] != 1:choose(52,0)))

    list(tmpEVkeep5=tmpEVkeep5, tmpEVkeep4=tmpEVkeep4, 
         tmpEVkeep3=tmpEVkeep3, tmpEVkeep2=tmpEVkeep2, 
         tmpEVkeep1=tmpEVkeep1, tmpEVkeep0=tmpEVkeep0
         )
}



drawNoReplace <- function(cardIndex, cardHolds, keyList, mtxIndices) {
    
    # cardHolds will come in small [by cardIndex] and should be used for filtering
    
    drawSmallNoReplace <- matrix(data=0L, nrow=length(cardIndex), ncol=ncol(keyList$tmpEVkeep5))
    
    tmpDrawkeep5 <- keyList$tmpEVkeep5
    tmpDrawkeep4 <- keyList$tmpEVkeep4
    tmpDrawkeep3 <- keyList$tmpEVkeep3
    tmpDrawkeep2 <- keyList$tmpEVkeep2
    tmpDrawkeep1 <- keyList$tmpEVkeep1
    tmpDrawkeep0 <- keyList$tmpEVkeep0
    
    # Manage the keep5 subset
    drawSmallNoReplace[cardHolds == 1, ] <- tmpDrawkeep5[cardIndex, ][cardHolds == 1, ]

    # Manage the keep4 subset
    # Keep 4 (intCtr: 2 is 1234, 3 is 1235, 4 is 1245, 5 is 1345, 6 is 2345)
    for (intCtr in 2:6) {
        drawSmallNoReplace[cardHolds == intCtr, -1] <- 
            tmpDrawkeep4[mtxIndices[cardIndex, intCtr], -1][cardHolds == intCtr, ] - 
            tmpDrawkeep5[cardIndex, ][cardHolds == intCtr, -1]
    }
    
    # Manage the keep3 subset
    # Keep 3 (intCtr: 7 is 123, 8 is 124, 9 is 125, 10 is 134, 11 is 135)
    # Keep 3 (intCtr: 12 is 145, 13 is 234, 14 is 235, 15 is 245, 16 is 345)
    # Take the results of the 3 cards assuming stand-alone
    # Subtract the results for each of the 4 cards (3 + 1 discard) assuming stand-alone
    # Add back the results of the 5 cards assuming stand-alone
    mapKeep3 <- data.frame(idx=7:16, 
                           keep1=c(2, 2, 3, 2, 3, 4, 2, 3, 4, 5), 
                           keep2=c(3, 4, 4, 5, 5, 5, 6, 6, 6, 6)
                           )
    
    for (intCtr in 7:16) {
        c1 <- mapKeep3$keep1[mapKeep3$idx == intCtr]
        c2 <- mapKeep3$keep2[mapKeep3$idx == intCtr]
        
        drawSmallNoReplace[cardHolds == intCtr, -1] <- 
            tmpDrawkeep3[mtxIndices[cardIndex, intCtr], -1][cardHolds == intCtr, ] -
            tmpDrawkeep4[mtxIndices[cardIndex, c1], -1][cardHolds == intCtr, ] -
            tmpDrawkeep4[mtxIndices[cardIndex, c2], -1][cardHolds == intCtr, ] +
            tmpDrawkeep5[cardIndex, ][cardHolds == intCtr, -1]        
    }
    

    # Manage the keep2 subset
    # Keep 2 (intCtr: 17 is 12, 18 is 13, 19 is 14, 20 is 15, 21 is 23)
    # Keep 2 (intCtr: 22 is 24, 23 is 25, 24 is 34, 25 is 35, 26 is 45)
    # Take the results of the 2 cards assuming stand-alone
    # Subtract the results of each of the 3 cards (2 + 1 discard) assuming stand-alone
    # Add back the results of each of the 4 cards (2 + 2 discard) assuming stand-alone
    # Subtract the results of the 5 cards assuming stand-alone
    mapKeep2 <- data.frame(idx=17:26, 
                           keep3_1=c(7,  7,  8,  9,  7,  8,  9, 10, 11, 12), 
                           keep3_2=c(8, 10, 10, 11, 13, 13, 14, 13, 14, 15),
                           keep3_3=c(9, 11, 12, 12, 14, 15, 15, 16, 16, 16),
                           keep4_1=c(2, 2, 2, 3, 2, 2, 3, 2, 3, 4),
                           keep4_2=c(3, 3, 4, 4, 3, 4, 4, 5, 5, 5),
                           keep4_3=c(4, 5, 5, 5, 6, 6, 6, 6, 6, 6)
                           )
    
    for (intCtr in 17:26) {
        c31 <- mapKeep2$keep3_1[mapKeep2$idx == intCtr]
        c32 <- mapKeep2$keep3_2[mapKeep2$idx == intCtr]
        c33 <- mapKeep2$keep3_3[mapKeep2$idx == intCtr]
    
        c41 <- mapKeep2$keep4_1[mapKeep2$idx == intCtr]
        c42 <- mapKeep2$keep4_2[mapKeep2$idx == intCtr]
        c43 <- mapKeep2$keep4_3[mapKeep2$idx == intCtr]
    
        drawSmallNoReplace[cardHolds == intCtr, -1] <- 
            tmpDrawkeep2[mtxIndices[cardIndex, intCtr], -1][cardHolds == intCtr, ] -
            tmpDrawkeep3[mtxIndices[cardIndex, c31], -1][cardHolds == intCtr, ] -
            tmpDrawkeep3[mtxIndices[cardIndex, c32], -1][cardHolds == intCtr, ] -
            tmpDrawkeep3[mtxIndices[cardIndex, c33], -1][cardHolds == intCtr, ] +
            tmpDrawkeep4[mtxIndices[cardIndex, c41], -1][cardHolds == intCtr, ] +
            tmpDrawkeep4[mtxIndices[cardIndex, c42], -1][cardHolds == intCtr, ] +
            tmpDrawkeep4[mtxIndices[cardIndex, c43], -1][cardHolds == intCtr, ] -
            tmpDrawkeep5[cardIndex, ][cardHolds == intCtr, -1]
    }
    

    # Manage the keep1 subset
    # Keep 1 (intCtr: 27 is 1, 28 is 2, 29 is 3, 30 is 4, 31 is 5)
    # Take the results of the 1 card assuming stand-alone
    # Subtract the results of the 2 cards (1 + 1 discard) assuming stand-alone
    # Add back the results of each of the 3 cards (1 + 2 discard) assuming stand-alone
    # Subtract the results of each of the 4 cards (1 + 3 discard) assuming stand-alone
    # Add back the results of the 5 cards assuming stand-alone
    mapKeep1 <- data.frame(idx=27:31,
                           keep2_1=c(17, 17, 18, 19, 20),
                           keep2_2=c(18, 21, 21, 22, 23),
                           keep2_3=c(19, 22, 24, 24, 25),
                           keep2_4=c(20, 23, 25, 26, 26),
                           keep3_1=c(7,   7,  7,  8,  9), 
                           keep3_2=c(8,   8, 10, 10, 11),
                           keep3_3=c(9,   9, 11, 12, 12),
                           keep3_4=c(10, 13, 13, 13, 14),
                           keep3_5=c(11, 14, 14, 15, 15),
                           keep3_6=c(12, 15, 16, 16, 16),
                           keep4_1=c(2, 2, 2, 2, 3),
                           keep4_2=c(3, 3, 3, 4, 4),
                           keep4_3=c(4, 4, 5, 5, 5),
                           keep4_4=c(5, 6, 6, 6, 6)
                           )
    
    for (intCtr in 27:31) {
        c21 <- mapKeep1$keep2_1[mapKeep1$idx == intCtr]
        c22 <- mapKeep1$keep2_2[mapKeep1$idx == intCtr]
        c23 <- mapKeep1$keep2_3[mapKeep1$idx == intCtr]
        c24 <- mapKeep1$keep2_4[mapKeep1$idx == intCtr]
    
        c31 <- mapKeep1$keep3_1[mapKeep1$idx == intCtr]
        c32 <- mapKeep1$keep3_2[mapKeep1$idx == intCtr]
        c33 <- mapKeep1$keep3_3[mapKeep1$idx == intCtr]
        c34 <- mapKeep1$keep3_4[mapKeep1$idx == intCtr]
        c35 <- mapKeep1$keep3_5[mapKeep1$idx == intCtr]
        c36 <- mapKeep1$keep3_6[mapKeep1$idx == intCtr]
    
        c41 <- mapKeep1$keep4_1[mapKeep1$idx == intCtr]
        c42 <- mapKeep1$keep4_2[mapKeep1$idx == intCtr]
        c43 <- mapKeep1$keep4_3[mapKeep1$idx == intCtr]
        c44 <- mapKeep1$keep4_4[mapKeep1$idx == intCtr]
        
        drawSmallNoReplace[cardHolds == intCtr, -1] <- 
            tmpDrawkeep1[mtxIndices[cardIndex, intCtr], -1][cardHolds == intCtr, ] -
            tmpDrawkeep2[mtxIndices[cardIndex, c21], -1][cardHolds == intCtr, ] -
            tmpDrawkeep2[mtxIndices[cardIndex, c22], -1][cardHolds == intCtr, ] -
            tmpDrawkeep2[mtxIndices[cardIndex, c23], -1][cardHolds == intCtr, ] -
            tmpDrawkeep2[mtxIndices[cardIndex, c24], -1][cardHolds == intCtr, ] +
            tmpDrawkeep3[mtxIndices[cardIndex, c31], -1][cardHolds == intCtr, ] +
            tmpDrawkeep3[mtxIndices[cardIndex, c32], -1][cardHolds == intCtr, ] +
            tmpDrawkeep3[mtxIndices[cardIndex, c33], -1][cardHolds == intCtr, ] +
            tmpDrawkeep3[mtxIndices[cardIndex, c34], -1][cardHolds == intCtr, ] +
            tmpDrawkeep3[mtxIndices[cardIndex, c35], -1][cardHolds == intCtr, ] +
            tmpDrawkeep3[mtxIndices[cardIndex, c36], -1][cardHolds == intCtr, ] -
            tmpDrawkeep4[mtxIndices[cardIndex, c41], -1][cardHolds == intCtr, ] -
            tmpDrawkeep4[mtxIndices[cardIndex, c42], -1][cardHolds == intCtr, ] -
            tmpDrawkeep4[mtxIndices[cardIndex, c43], -1][cardHolds == intCtr, ] -
            tmpDrawkeep4[mtxIndices[cardIndex, c44], -1][cardHolds == intCtr, ] +
            tmpDrawkeep5[cardIndex, ][cardHolds == intCtr, -1]
    }
    

    # Manage the keep0 subset
    # Keep 0 (column 32)
    # Take the results of the 0 card assuming stand-alone
    # Subtract the results of each 1 card (0 + 1 discard) assuming stand-alone
    # Add back the results of each of the 2 cards (0 + 2 discard) assuming stand-alone
    # Subtract the results of each of the 3 cards (0 + 3 discard) assuming stand-alone
    # Add back the results of each of the 4 cards (0 + 4 discard) assuming stand-alone
    # Subtract the results of the 5 cards assuming stand-alone

    drawSmallNoReplace[cardHolds == 32, -1] <- 
        matrix(data=rep(tmpDrawkeep0[, -1], times=sum(cardHolds==32)), 
               nrow=sum(cardHolds==32), byrow=TRUE
               ) -
        tmpDrawkeep1[mtxIndices[cardIndex, 31], -1][cardHolds == 32, ] -
        tmpDrawkeep1[mtxIndices[cardIndex, 30], -1][cardHolds == 32, ] -
        tmpDrawkeep1[mtxIndices[cardIndex, 29], -1][cardHolds == 32, ] -
        tmpDrawkeep1[mtxIndices[cardIndex, 28], -1][cardHolds == 32, ] -
        tmpDrawkeep1[mtxIndices[cardIndex, 27], -1][cardHolds == 32, ] +
        tmpDrawkeep2[mtxIndices[cardIndex, 26], -1][cardHolds == 32, ] +
        tmpDrawkeep2[mtxIndices[cardIndex, 25], -1][cardHolds == 32, ] +
        tmpDrawkeep2[mtxIndices[cardIndex, 24], -1][cardHolds == 32, ] +
        tmpDrawkeep2[mtxIndices[cardIndex, 23], -1][cardHolds == 32, ] +
        tmpDrawkeep2[mtxIndices[cardIndex, 22], -1][cardHolds == 32, ] +
        tmpDrawkeep2[mtxIndices[cardIndex, 21], -1][cardHolds == 32, ] +
        tmpDrawkeep2[mtxIndices[cardIndex, 20], -1][cardHolds == 32, ] +
        tmpDrawkeep2[mtxIndices[cardIndex, 19], -1][cardHolds == 32, ] +
        tmpDrawkeep2[mtxIndices[cardIndex, 18], -1][cardHolds == 32, ] +
        tmpDrawkeep2[mtxIndices[cardIndex, 17], -1][cardHolds == 32, ] -
        tmpDrawkeep3[mtxIndices[cardIndex, 16], -1][cardHolds == 32, ] -
        tmpDrawkeep3[mtxIndices[cardIndex, 15], -1][cardHolds == 32, ] -
        tmpDrawkeep3[mtxIndices[cardIndex, 14], -1][cardHolds == 32, ] -
        tmpDrawkeep3[mtxIndices[cardIndex, 13], -1][cardHolds == 32, ] -
        tmpDrawkeep3[mtxIndices[cardIndex, 12], -1][cardHolds == 32, ] -
        tmpDrawkeep3[mtxIndices[cardIndex, 11], -1][cardHolds == 32, ] -
        tmpDrawkeep3[mtxIndices[cardIndex, 10], -1][cardHolds == 32, ] -
        tmpDrawkeep3[mtxIndices[cardIndex, 9], -1][cardHolds == 32, ] -
        tmpDrawkeep3[mtxIndices[cardIndex, 8], -1][cardHolds == 32, ] -
        tmpDrawkeep3[mtxIndices[cardIndex, 7], -1][cardHolds == 32, ] +
        tmpDrawkeep4[mtxIndices[cardIndex, 6], -1][cardHolds == 32, ] +
        tmpDrawkeep4[mtxIndices[cardIndex, 5], -1][cardHolds == 32, ] +
        tmpDrawkeep4[mtxIndices[cardIndex, 4], -1][cardHolds == 32, ] +
        tmpDrawkeep4[mtxIndices[cardIndex, 3], -1][cardHolds == 32, ] +
        tmpDrawkeep4[mtxIndices[cardIndex, 2], -1][cardHolds == 32, ] -
        tmpDrawkeep5[cardIndex, ][cardHolds == 32, -1]
    

    # evSmallNoReplace[, 32] <- (choose(52, 5) * mean(aScores) - 
    #                           choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, 31]] -
    #                           choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, 30]] - 
    #                           choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, 29]] - 
    #                           choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, 28]] - 
    #                           choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, 27]] +
    #                           choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 26]] +
    #                           choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 25]] + 
    #                           choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 24]] + 
    #                           choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 23]] + 
    #                           choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 22]] + 
    #                           choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 21]] + 
    #                           choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 20]] + 
    #                           choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 19]] + 
    #                           choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 18]] + 
    #                           choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 17]] -
    #                           choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 16]] -
    #                           choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 15]] -
    #                           choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 14]] -
    #                           choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 13]] -
    #                           choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 12]] -
    #                           choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 11]] -
    #                           choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 10]] -
    #                           choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 9]] -
    #                           choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 8]] -
    #                           choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 7]] +
    #                           choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, 6]] +
    #                           choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, 5]] +
    #                           choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, 4]] +
    #                           choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, 3]] +
    #                           choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, 2]] -
    #                           evSmallNoReplace[, 1]
    #                       ) / choose(47, 5)

    drawSmallNoReplace
}



# Simulate a specific pay-table given a known sequence of holds
simDrawVar <- function(aT=aType, mtxI=mtxIndices, useHolds,
                       cardI=cardIndex, cardW=cardWeight, startT=startTime, 
                       grTitle="EV Draw Simulation Results", allOut=FALSE
                       ) {
    
    # Get the possible outcomes assuming re-draws are allowed
    keyList <- calcFreq_YesRedraw(mtxIndices=mtxI, aTypes=aT)

    # Next, need to adapt the code for no re-draws
    
    drawSmallNoReplace <- drawNoReplace(cardIndex=cardI, cardHolds=useHolds,
                                        keyList=keyList, mtxIndices=mtxI
                                        )

    if (allOut) {
        return(list(drawSmallNoReplace=drawSmallNoReplace,
                    keyList=keyList
                    )
               )
    } else {
        return(list(drawSmallNoReplace=drawSmallNoReplace
                    )
               )
    }

}


```
  
Then, a functions is built to assess the overall mean, variance on the deal, variance on the draw, and distribution of the variances for a given game:  
```{r}

calcMeanVar <- function (tempDraws, hnd2Score, mainName, wgts=cardWeight) {
    drawTemp <- tempDraws$drawSmallNoReplace[, -1]
    cat("\n", "Summary of", mainName,"starting with row sums\n")
    print(table(rowSums(drawTemp)))
    
    drawOdds <- drawTemp / matrix(data=rep(rowSums(drawTemp), ncol(drawTemp)), 
                                  nrow=nrow(drawTemp), byrow=FALSE
                                  )
    print(table(rowSums(drawOdds)))
    
    drawEV <-  drawOdds %*% matrix(data=hnd2Score$val, ncol=1)
    drawEV2 <- drawOdds %*% matrix(data=hnd2Score$val^2, ncol=1)
    
    cat("\n")
    print(paste0(mainName, ": Overall EV and Mean"))
    print(summary(rep(drawEV, times=wgts)))
    print(paste0("Overall Return: ", round(1 + mean(rep(drawEV, times=wgts)), 6)))
    
    cat("\n")
    print(paste0(mainName, ": Variances (Deal, Draw)"))
    print(paste0("Deal Variance: ", round(var(rep(drawEV, times=wgts)), 4)))
    print("Draw Variance Summary Statistics")
    print(summary(rep(drawEV2 - drawEV^2, times=wgts)))
    cat("\n")
    
    hist(log10(1 + rep(drawEV2 - drawEV^2, times=wgts)), col="light blue", 
         main=paste0("Deal Variance for: ", mainName), xlab="1 + log10(Deal Variance)"
         )
}


```
  
Games are then simulated for variance, with the outcomes cached for run-time optimization:  
```{r, cache=TRUE}
# Assess JB 96 game
jb96Draws <- simDrawVar(aT=aType, mtxI=mtxIndices, useHolds=jb96List$tempSmallMax[2, ],
                        cardI=cardIndex, cardW=cardWeight, startT=startTime, 
                        grTitle="EV Draw Simulation Results", allOut=FALSE
                        )
```

```{r, cache=TRUE}
# Assess BP 85 game
bp85Draws <- simDrawVar(aT=aType, mtxI=mtxIndices, useHolds=bp85List$tempSmallMax[2, ],
                        cardI=cardIndex, cardW=cardWeight, startT=startTime, 
                        grTitle="EV Draw Simulation Results", allOut=FALSE
                        )

```


```{r, cache=TRUE}
# Assess BPD 96 game
bpd96Draws <- simDrawVar(aT=aType, mtxI=mtxIndices, useHolds=bpd96List$tempSmallMax[2, ],
                         cardI=cardIndex, cardW=cardWeight, startT=startTime, 
                         grTitle="EV Draw Simulation Results", allOut=FALSE
                         )

```
  
```{r, cache=TRUE}
# Assess DDB 96 game
ddb96Draws <- simDrawVar(aT=aType, mtxI=mtxIndices, useHolds=ddb96List$tempSmallMax[2, ],
                         cardI=cardIndex, cardW=cardWeight, startT=startTime, 
                         grTitle="EV Draw Simulation Results", allOut=FALSE
                         )

```
  

```{r, cache=TRUE}
# Assess the TDB 96 game
tdb96Draws <- simDrawVar(aT=aType, mtxI=mtxIndices, useHolds=tdb96List$tempSmallMax[2, ],
                        cardI=cardIndex, cardW=cardWeight, startT=startTime, 
                        grTitle="EV Draw Simulation Results", allOut=FALSE
                        )

```
  
And, the function is then applied to each of the games:  
```{r}

calcMeanVar(tempDraws=jb96Draws, hnd2Score=jb96hnd2Score, mainName="JB 96")
calcMeanVar(tempDraws=bp85Draws, hnd2Score=bp85hnd2Score, mainName="BP 85")
calcMeanVar(tempDraws=bpd96Draws, hnd2Score=bpd96hnd2Score, mainName="BPD 96")
calcMeanVar(tempDraws=ddb96Draws, hnd2Score=ddb96hnd2Score, mainName="DDB 96")
calcMeanVar(tempDraws=tdb96Draws, hnd2Score=tdb96hnd2Score, mainName="TDB 96")

```

The differences in means and variances are evident:  
  
* JB 96:    99.54%   1.97 + 17.55 =  19.52  
* BP 85:    99.17%   2.12 + 18.78 =  20.90  
* BPD 96:   99.64%   3.69 + 28.45 =  32.14  
* DDB 96:   98.98%   4.81 + 37.18 =  41.99  
* TDB 96:   98.15%  10.68 + 89.44 = 100.12  
  
So, the overall mean (99.544%) and variance on the deal (17.55) for JB 96 match theoretical. Similarly, the overall mean (99.17%) and variance on the deal (18.78) for BP 85 match tehoretical. And, the overall mean (98.15%) for TDB 96 matches theoretical, with an extremely large (89.44) variance on the deal.
  
All else equal, the variance of TDB 96 is ~5x the variance of JB 96 / BP 85, and with a lower starting return.  Further, the "average" variance is itself very spiky, comprised of starting hands that vary as much as ~1000x greater than the average!

Next, the individual means and variances for the starting hands of a given game are explored:  
```{r}

indMeanVar <- function(hnd2Score, listDraws, useName, 
                       cIndex=cardIndex, cWeight=cardWeight, allOut=FALSE
                       ) {

    # Get the vector of outcomes for each starting hand (no longer concerned with all 25)
    possOutcomes <- unique(hnd2Score$val)
    mtxOutcomes <- matrix(data=0L, nrow=length(cIndex), ncol=length(possOutcomes)+2)

    # Probably should have created the unique key in the functions; will want it here, so add it
    mtxOutcomes[, 1] <- cIndex
    mtxOutcomes[, 2] <- cWeight

    cat("\n\nThis will assess the", useName, "means and variances\n\n")
    # Next, work through each possible outcome for the draws
    for (intCtr in seq_along(possOutcomes)) {
        keyCol <- hnd2Score$idx[hnd2Score$val == possOutcomes[intCtr]] + 2
        cat(intCtr, possOutcomes[intCtr], keyCol, "\n")
        mtxOutcomes[, intCtr + 2] <- rowSums(listDraws$drawSmallNoReplace[, keyCol, drop=FALSE])
    }

    # Next, see how many starting hand types there are, considering any starting hands
    # that generate the identical outcomes vector to be indetical for these purposes
    print(nrow(unique(mtxOutcomes[, -(1:2)])))

    # Next, create histograms by the row sums (which is analogous to number of cards held)
    mtxUnique <- unique(mtxOutcomes[, -(1:2)])
    str(mtxUnique)
    data.frame(rSum=rowSums(mtxUnique)) %>% 
        group_by(rSum) %>% 
        summarize(ct=n()) %>%
        print.data.frame()

    # Next, create the mean and variance (of the draw) for each of the unique hands
    # Further, summarize these split by hand type
    myUniqueFrame <- data.frame(rSum=rowSums(mtxUnique), 
                                possSum=mtxUnique %*% possOutcomes,
                                possSum2=mtxUnique %*% possOutcomes^2
                                )

    myUniqueFrame$uqMean <- myUniqueFrame$possSum / myUniqueFrame$rSum
    myUniqueFrame$uqVar <- (myUniqueFrame$possSum2 / myUniqueFrame$rSum) - myUniqueFrame$uqMean^2

    # Send back the unique frame to whoever called the function
    # STILL NEED TO GET THIS TO ADD THE WEIGHTS by Hand Types!!!
    charAll <- apply(mtxOutcomes[, -(1:2)], 1, FUN=paste0, collapse="-")
    charUnique <- apply(mtxUnique, 1, FUN=paste0, collapse="-")
    str(charAll)
    str(charUnique)

    charMatch <- match(charAll, charUnique)
    str(charMatch)
    # print(summary(charMatch))
    
    sumUnique <- tapply(cWeight, charMatch, FUN=sum)
    str(sumUnique)
    # print(summary(sumUnique))
        
    myUniqueCards <- cbind(mtxUnique, sumUnique)
    
    if (!isTRUE(allOut)) {
        list(uqFrame=myUniqueFrame)
    } else {
        list(uqFrame=myUniqueFrame,
             uqCards=myUniqueCards,
             mapOuts=possOutcomes
             )
    }
    
}

```
  
Then, the function is run for JB 96, BP 85, BPD 96, DDB 96, and TDB 96, preserving the key counts for all of the relevant unique hands:  
```{r}

jb96UniqueList <- indMeanVar(hnd2Score=jb96hnd2Score, listDraws=jb96Draws, 
                             useName="JB 96", allOut=TRUE
                             )
bp85UniqueList <- indMeanVar(hnd2Score=bp85hnd2Score, listDraws=bp85Draws, 
                             useName="BP 85", allOut=TRUE
                             )
bpd96UniqueList <- indMeanVar(hnd2Score=bpd96hnd2Score, listDraws=bpd96Draws, 
                              useName="BPD 96", allOut=TRUE
                              )
ddb96UniqueList <- indMeanVar(hnd2Score=ddb96hnd2Score, listDraws=ddb96Draws, 
                              useName="DDB 96", allOut=TRUE
                              )
tdb96UniqueList <- indMeanVar(hnd2Score=tdb96hnd2Score, listDraws=tdb96Draws, 
                              useName="TDB 96", allOut=TRUE
                              )

```

With a "flavor" being defined as the full class of starting hands that have an identical payout vector, the following number of flavors are observed per game:  
  
* JB 96 - 1,279 flavors  
* BP 85 - 1,647 flavors (increase due to different types of quads)  
* BPD 96 - 851 flavors (decrease due to fewer 0-card holds, which tends to be a high-flavor if rare hold)  
* DDB 96 - 1,260 flavors (like BPD 96 but with more flavors of quads)  
* TDB 96 - 945 flavors  
  
* "Hold 5" flavors by game - JB (6), BP(8), BPD(6), DDB(7), TDB (6)  
* "Hold 4" flavors by game - JB (34), BP(34), BPD(36), DDB(38), TDB (43)  
* "Hold 3" flavors by game - JB (105), BP(106), BPD(104), DDB(118), TDB (140)  
* "Hold 2" flavors by game - JB (104), BP(95), BPD(95), DDB(94), TDB (83)  
* "Hold 1" flavors by game - JB (155), BP(451), BPD(158), DDB(507), TDB (369)  
* "Hold 0" flavors by game - JB (875), BP(953), BPD(452), DDB(496), TDB (304)  
  
While hold 0 is the rarest of the starting hands, it contains the most "flavors" of JB 96 since there are many different "penalties" to straights and flushes that may have been discarded.  On the other hand, since TDB 96 will frequently go for long-shots (inside straight draws), there are even fewer flavors of hold 0, but more flavors of hold 4, hold 3, and (especially) hold 1.  
  
Next, a function is created for graphing the various outcomes:  
```{r}

graphMeanVar <- function(useFrame, useName) {
    
    # Hold all 5
    dummy <- useFrame[useFrame$rSum == choose(47, 0), ]
    plot(x=log10(1+sqrt(dummy$uqVar)), y=log10(2+dummy$uqMean), col="dark green", pch=19, 
         xlab="Log10 of [1+SD] (SQRT of Variance)", ylab="Log 10 of [2+Mean]", 
         main=paste("Outcomes of Starting Flavors for", useName), 
         xlim=c(0, log10(100 * max(ceiling(sqrt(useFrame$uqVar)/100)))), ylim=c(0, 3)
         )

    # Hold 4 of 5
    dummy <- useFrame[useFrame$rSum == choose(47, 1), ]
    points(x=log10(1+sqrt(dummy$uqVar)), y=log10(2+dummy$uqMean), col="light green", pch=19)

    # Hold 3 of 5
    dummy <- useFrame[useFrame$rSum == choose(47, 2), ]
    points(x=log10(1+sqrt(dummy$uqVar)), y=log10(2+dummy$uqMean), col="purple", pch=19)

    # Hold 2 of 5
    dummy <- useFrame[useFrame$rSum == choose(47, 3), ]
    points(x=log10(1+sqrt(dummy$uqVar)), y=log10(2+dummy$uqMean), col="blue", pch=19)

    # Hold 1 of 5
    dummy <- useFrame[useFrame$rSum == choose(47, 4), ]
    points(x=log10(1+sqrt(dummy$uqVar)), y=log10(2+dummy$uqMean), col="orange", pch=19)

    # Hold 0 of 5
    dummy <- useFrame[useFrame$rSum == choose(47, 5), ]
    points(x=log10(1+sqrt(dummy$uqVar)), y=log10(2+dummy$uqMean), col=rgb(1, 0, 0, 0.25), pch=19)

    legend("top", legend=paste("Hold", 5:0), pch=19, ncol=3,
           col=c("dark green", "light green", "purple", "blue", "orange", "red")
           )

    abline(h=log10(2+c(-1, 0, 2)), lty=2)
    abline(v=log10(1+c(1.5, 4)), lty=2)

}

```
  
The function is then run for JB 96, BP 85, BPD 96, DDB 96, and TDB 96:  
```{r}

graphMeanVar(useFrame=jb96UniqueList$uqFrame, useName="JB 96")
graphMeanVar(useFrame=bp85UniqueList$uqFrame, useName="BP 85")
graphMeanVar(useFrame=bpd96UniqueList$uqFrame, useName="BPD 96")
graphMeanVar(useFrame=ddb96UniqueList$uqFrame, useName="DDB 96")
graphMeanVar(useFrame=tdb96UniqueList$uqFrame, useName="TDB 96")

```

  
The draws can then be assessed as in several classes for JB 96:  
  
* High mean, zero variance - all hold 5  
* High-medium mean, very high variance - handful of hold 3/4  
* Medium mean, medium-high variance - handful of hold 2/4  
* Low mean, very high variance - handful of hold 2  
* Low mean, high variance - handful of hold 1/3  
* Low mean, medium variance - handful of hold 2/3/4, and all hold 5  
* Low mean, low variance - handful of hold 1/2  
  
Categorized differently (still for JB 96):  
  
* Hold 5 - always high mean and zero variance  
* Hold 4 - mean and variance range from low to very high, with mean and variance correlated  
* Hold 3 - generally medium-high variance with medium-low mean  
* Hold 2 - generally medium-high variance with medium-low mean  
* Hold 1 - generally low-medium variance and low mean  
* Hold 0 - low mean, medium variance  
  
Notably, the DDB 96 and TDB 96 games have many higher variance holds, consistent with overall high variance.  

Next, pre-processing is run to begin assessing the impact of N-play (1 deal, 1 hold, N iid draws).  The impact of N-play can be calculated only once for each "flavor" of hands, then weighted by the likelihood of being dealt that flavor:  
```{r}

assessFlavor <- function(uqList) {

    lastCol <- ncol(uqList$uqCards)
    keyCounts <- uqList$uqCards[, lastCol]

    # Check that means and variances of the draw still make sense
    print(1 + weighted.mean(uqList$uqFrame$uqMean, w=keyCounts))
    print(weighted.mean(uqList$uqFrame$uqVar, w=keyCounts))

    # Report on the number of hands by cards held
    totVar <- sum(uqList$uqFrame$uqVar * keyCounts)
    cbind(uqList$uqFrame, keyCounts) %>%
        group_by(rSum) %>%
        summarize(nFlv=n(), nH=sum(keyCounts), 
                  sumFlv=sum(keyCounts*uqMean),
                  meanFlv=round(sumFlv/nH, 5), 
                  contFlv=round(sumFlv/choose(52, 5), 5),
                  varFMean=round(sum(keyCounts*uqVar)/nH, 1), 
                  varFPct=round(sum(keyCounts*uqVar)/totVar, 3)
                  )
    
}

assessFlavor(uqList=jb96UniqueList)
assessFlavor(uqList=bp85UniqueList)
assessFlavor(uqList=bpd96UniqueList)
assessFlavor(uqList=ddb96UniqueList)
assessFlavor(uqList=tdb96UniqueList)

```
  
Next, the total potential outcomes are calculated:  
```{r}

totOutcomes <- function(keyList, useName) {

    # Convert each row so it sums to 5 * choose(47, 5) * cardWeight 
    # (which is in the final column)
    keyFrame <- keyList$uqCards
    mapScore <- keyList$mapOuts
    lastCol <- ncol(keyFrame)

    keySums <- rowSums(keyFrame[, -lastCol])
    keyMult <- 5 * choose(47, 5) / keySums

    useFrame <- keyFrame[, -lastCol]

    for (intCtr in 1:(lastCol-1)) {
        useFrame[, intCtr] <- keyFrame[, intCtr] * keyMult * keyFrame[, lastCol]
    }

    # Get the percentages by outcome
    showTable <- data.frame(scoreType=mapScore, 
                            occPer=sum(useFrame) / colSums(useFrame),
                            contRet=colSums(useFrame) * mapScore / sum(useFrame)
                            )
    showTable$occFreq <- 1/showTable$occPer
    showTable <- showTable[order(-showTable$scoreType), ]

    printShowTable <- showTable
    printShowTable$occPer <- signif(showTable$occPer, 4)
    printShowTable$contRet <- round(showTable$contRet, 6)
    printShowTable$occFreq <- round(showTable$occFreq, 8)
    print(printShowTable)
    
    psEX <- sum(printShowTable$contRet)
    psEX2 <- sum(printShowTable$occFreq * printShowTable$scoreType^2) / sum(printShowTable$occFreq)
    cat("\nPrinted table suggests", useName, "mean return:", 1+psEX, 
        "and overall variance:", psEX2 - psEX^2, "\n\n"
        )

}

totOutcomes(keyList=jb96UniqueList, useName="JB 96")
totOutcomes(keyList=bp85UniqueList, useName="BP 85")
totOutcomes(keyList=bpd96UniqueList, useName="BPD 96")
totOutcomes(keyList=ddb96UniqueList, useName="DDB 96")
totOutcomes(keyList=tdb96UniqueList, useName="TDB 96")

```
  
Next, a function is written to look at N-play (defaulted to 3-play and limited to 1-5 or 10 play):  
```{r}

assessNPlay <- function(keyList, nPlay=3L) {
    
    hnd2Value <- keyList$mapOuts
    uqCol <- ncol(keyList$uqCards)
    cWeight <- keyList$uqCards[, uqCol]
    uqHands <- keyList$uqCards[, -uqCol]
    
    # Only allow nPlay of 1-5 or 10 for now (need to improve algorithm otherwise)
    if (nPlay > 10) {
        print("Cannot have nPlay > 10, will be re-set to 10")
        nPlay <- 10L
        nBase <- 5L  # Run it as a 5-play draw multiplied due to vector sizes/memory
    } else if (nPlay == 10) {
        print("nPlay 10 assessed using nPlay 5 frequencies appropriately multiplied/summed")
        nBase <- 5L  # Run it as a 5-play draw multiplied due to vector sizes/memory
    } else if (nPlay > 5) {
        print("Only nPlay of 1-5 or 10 may be used, will be re-set to 5")
        nPlay <- 5L
        nBase <- 5L  
    } else if (nPlay < 1) {
        print("Cannot have nPlay < 1, will be re-set to 1")
        nPlay <- 1L
        nBase <- 1L
    } else if (!all.equal(as.integer(nPlay), nPlay)) {
        print("nPlay will be coerced to an integer")
        nPlay <- as.integer(nPlay)
        nBase <- nPlay
    } else {
        nBase <- nPlay
    }
    
    mtxNPlay <- matrix(data=0, nrow=(uqCol-1)^nBase, ncol=(2+nBase), 
                       dimnames=list(NULL, c("Value", "Freq", paste0("C", 1:nBase)))
                       )
    
    # Find and store the key positions
    cNum <- vector("list", length=nBase)
    for (intCtr in 1:nBase) {
        cNum[[intCtr]] <- rep(rep(1:(uqCol-1), each=(uqCol-1)^(nBase-intCtr)
                                  ), times=(uqCol-1)^(intCtr-1)
                              )
    }

    str(cNum)
    
    
    # Populate the value of the key positions
    for (intCtr in 1:nBase) {
        mtxNPlay[, (intCtr+2)] <- hnd2Value[cNum[[intCtr]]]
    }
    
    # Populate the overall value of the outcome
    mtxNPlay[, 1] <- rowSums(mtxNPlay[, -(1:2), drop=FALSE])

    # Populate the overall frequencies of the outcome
    uqSums <- rowSums(uqHands)
    mtxFreqs <- uqHands / uqSums[row(uqHands)]
    print(table(rowSums(mtxFreqs)))
    
    cVec <- sapply(cNum, FUN=function(x) { as.vector(x) })
    str(cVec)
    print(head(cVec))

    # See the number of unique outcomes
    cat("\n\nNumber of unique outcome types:", length(table(mtxNPlay[, 1])), "\n")

    # Calculate the possible ways to get a particular outcome
    dfOutcome <- data.frame(nOutcome=mtxNPlay[, 1]) %>% 
        group_by(nOutcome) %>% summarize(ct=n())
    dfOutcome$wts <- 0
    vecRow <- as.vector(row(mtxNPlay[, 1, drop=FALSE]))
    mtxNFirst <- mtxNPlay[, 1, drop=TRUE]
    keyOutcome <- dfOutcome$nOutcome
    
    # Create all the 2-column multiplications
    mtxFreq_2x2 <- matrix(data=NA, nrow=nrow(mtxFreqs), ncol=ncol(mtxFreqs)^2)
    grid_2x2 <- expand.grid(1:ncol(mtxFreqs), 1:ncol(mtxFreqs))
    for (intCtr in 1:nrow(grid_2x2)) {
        c1 <- grid_2x2[intCtr, 1]
        c2 <- grid_2x2[intCtr, 2]
        
        mtxFreq_2x2[, intCtr] <- mtxFreqs[, c1] * mtxFreqs[, c2]
    }
    
    # Create all the 3-column multiplications
    mtxFreq_3x3 <- matrix(data=NA, nrow=nrow(mtxFreqs), ncol=ncol(mtxFreqs)^3)
    grid_3x3 <- expand.grid(1:ncol(mtxFreqs), 1:ncol(mtxFreqs), 1:ncol(mtxFreqs))
    for (intCtr in 1:nrow(grid_3x3)) {
        c1 <- grid_3x3[intCtr, 1]
        c2 <- grid_3x3[intCtr, 2]
        c3 <- grid_3x3[intCtr, 3]
        
        mtxFreq_3x3[, intCtr] <- mtxFreqs[, c1] * mtxFreqs[, c2] * mtxFreqs[, c3]
    }
    
    
    cat("\nMoving to assess the:", nrow(dfOutcome), "rows of outcomes\n")
    
    # Use a work-around specific to 5/10-play (expand and generalize the logic later)
    if (nPlay %in% c(5, 10)) {
        
        storeOutcomes <- matrix(data=NA, nrow=nrow(mtxFreqs), ncol=length(dfOutcome$nOutcome))
        
        for (intCtr in 1:nrow(dfOutcome)) {
            # Find the key outcome
            keyOut <- keyOutcome[intCtr]
        
            # Get the row numbers of cVec that will be associated to the key outcome
            keyRow <- vecRow[mtxNFirst == keyOut]
        
            # Convert these row numbers to the relevant 3x3 and 2x2 lookups
            ncKey <- ncol(mtxFreqs)
            keyMtx <- cVec[keyRow, , drop=FALSE]
            col_3x3 <- 1 + (keyMtx[, 1] - 1 + ncKey * (keyMtx[, 2] - 1) + ncKey^2 * (keyMtx[, 3] - 1))
            col_2x2 <- 1 + (keyMtx[, 4] - 1 + ncKey * (keyMtx[, 5] - 1))
            
            # Use the lookups to get the key values
            mtxApply <- 
                mtxFreq_3x3[, col_3x3, drop=FALSE] * mtxFreq_2x2[, col_2x2, drop=FALSE]
            
            if (intCtr %% 100 == 0) {
                str(mtxApply)
                str(rowSums(mtxApply))
                print(intCtr)
            }
        
            dfOutcome$wts[intCtr] <- dfOutcome$wts[intCtr] + sum(cWeight * rowSums(mtxApply))
            storeOutcomes[, intCtr] <- rowSums(mtxApply)    
        }
        
    } else {
        
        storeOutcomes <- NULL  # Not needed for these hands (nPlay of 1-4)
        
        for (intCtr in 1:nrow(dfOutcome)) {
        
            # Find the key outcome
            keyOut <- keyOutcome[intCtr]
        
            # Get the row numbers of cVec that will be associated to the key outcome
            keyRow <- vecRow[mtxNFirst == keyOut]
        
            mtxKey <- array(data=mtxFreqs[, t(cVec[keyRow, , drop=FALSE]), drop=FALSE], 
                            dim=c(nrow(mtxFreqs), nPlay, length(keyRow))
                            )
    
            mtxApply <- apply(mtxKey, c(1, 3), FUN=prod)
        
            if (intCtr %% 100 == 0) {
                str(mtxKey)
                str(mtxApply)
                str(rowSums(mtxApply))
                print(intCtr)
            }
        
            dfOutcome$wts[intCtr] <- dfOutcome$wts[intCtr] + sum(cWeight * rowSums(mtxApply))
            
        }
    
    }
    
    if (nPlay %in% c(1, 2, 3, 4, 5)) {
        
        # Mean expressed on a percentage basis
        # keyMean <- sum(mtxNPlay[, 2] * mtxNPlay[, 1]) / sum(mtxNPlay[, 2])
        keyMean <- sum(dfOutcome$wts * dfOutcome$nOutcome) / sum(dfOutcome$wts)
        cat("\n\nMean:", 1 + keyMean/nPlay)  # To move this back to a "per full bet" basis

        # Variance expressed as the overall variance per "base unit"
        # keyVar <- sum(mtxNPlay[, 2] * mtxNPlay[, 1]^2) / sum(mtxNPlay[, 2]) - keyMean^2
        keyVar <- sum(dfOutcome$wts * dfOutcome$nOutcome^2) / sum(dfOutcome$wts) - keyMean^2
        cat("\t\tVariance:", keyVar, "\n")  # Leave this "as is"; it is the full variance amount
        
        out10Play <- NULL
        
    } else if (nPlay %in% c(10)) {
        
        # Matrix multiply the key starting outcome hands
        mtxOutcomeProbs <- t(storeOutcomes * cWeight) %*% storeOutcomes
        mtxOutcomeValues <- dfOutcome$nOutcome[row(mtxOutcomeProbs)] +
            dfOutcome$nOutcome[col(mtxOutcomeProbs)]
        
        # Make the out10Play frame using dplyr
        out10Play <- data.frame(nOutcome=mtxOutcomeValues, 
                                s_wts=as.vector(mtxOutcomeProbs)
                                ) %>%
            group_by(nOutcome) %>%
            summarize(wts=sum(s_wts))
        
        # Find the potential results (perhaps matricize . . .)
        # out10Play <- data.frame(nOutcome=sort(unique(grid10$sumRes)), wts=0)
        # for (intCtr in 1:nrow(grid10)) {
        #     keyVal <- storeOutcomes[, grid10$Var1[intCtr]] * storeOutcomes[, grid10$Var2[intCtr]]
        #     out10Spot <- which(out10Play$nOutcome == grid10$sumRes[intCtr])
        #     out10Play$wts[out10Spot] <- out10Play$wts[out10Spot] + sum(cWeight * keyVal)
        # }
        
        
        # Report back on the mean and the variance

        # Mean expressed on a percentage basis
        keyMean <- sum(out10Play$wts * out10Play$nOutcome) / sum(out10Play$wts)
        cat("\n\nMean:", 1 + keyMean/nPlay)  # To move this back to a "per full bet" basis

        # Variance expressed as the overall variance per "base unit"
        keyVar <- sum(out10Play$wts * out10Play$nOutcome^2) / sum(out10Play$wts) - keyMean^2
        cat("\t\tVariance:", keyVar, "\n")  # Leave this "as is"; it is the full variance amount
        
        # Convert back to a pure data frame
        out10Play <- as.data.frame(out10Play)
        
    }
    
    list(dfOutcome=dfOutcome, mtxNPlay=mtxNPlay, 
         storeOutcomes=storeOutcomes, out10Play=out10Play
         )
    
}


# Run as 1/3/5-play for JB 96, BP 85, BPD 96, DDB 96, and TDB 96
jb96_1Play <- assessNPlay(keyList=jb96UniqueList, nPlay=1L)
jb96_3Play <- assessNPlay(keyList=jb96UniqueList, nPlay=3L)
jb96_5Play <- assessNPlay(keyList=jb96UniqueList, nPlay=5L)

bp85_1Play <- assessNPlay(keyList=bp85UniqueList, nPlay=1L)
bp85_3Play <- assessNPlay(keyList=bp85UniqueList, nPlay=3L)
bp85_5Play <- assessNPlay(keyList=bp85UniqueList, nPlay=5L)

bpd96_1Play <- assessNPlay(keyList=bpd96UniqueList, nPlay=1L)
bpd96_3Play <- assessNPlay(keyList=bpd96UniqueList, nPlay=3L)
bpd96_5Play <- assessNPlay(keyList=bpd96UniqueList, nPlay=5L)

ddb96_1Play <- assessNPlay(keyList=ddb96UniqueList, nPlay=1L)
ddb96_3Play <- assessNPlay(keyList=ddb96UniqueList, nPlay=3L)
ddb96_5Play <- assessNPlay(keyList=ddb96UniqueList, nPlay=5L)

tdb96_1Play <- assessNPlay(keyList=tdb96UniqueList, nPlay=1L)
tdb96_3Play <- assessNPlay(keyList=tdb96UniqueList, nPlay=3L)
tdb96_5Play <- assessNPlay(keyList=tdb96UniqueList, nPlay=5L)

```
  
The 10-play variant no longer needs to be cached since the vectorized solution for driving 5-play to 10-play runs extremely quickly:    
```{r}

# Run as 10-play for JB 96, BP 85, BPD 96, DDB 96, and TDB 96
jb96_10Play <- assessNPlay(keyList=jb96UniqueList, nPlay=10L)
bp85_10Play <- assessNPlay(keyList=bp85UniqueList, nPlay=10L)
bpd96_10Play <- assessNPlay(keyList=bpd96UniqueList, nPlay=10L)
ddb96_10Play <- assessNPlay(keyList=ddb96UniqueList, nPlay=10L)
tdb96_10Play <- assessNPlay(keyList=tdb96UniqueList, nPlay=10L)

```

Next, 2,000 simulations are run for up to 16,000 hands, with the percentiles assessed:  
```{r}

sim_NPlay <- function(keyFrame, useName, nPlay, nHands, nSims) {
    
    # Extract outcomes and associated odds from the N-play list
    oddsNPlay <- round(100 * keyFrame$wts, 0)
    resNPlay <- keyFrame$nOutcome
    
    # Validate that the rouding of odds has not adversely impacted mean/variance
    meanNPlay <- sum(oddsNPlay * resNPlay) / sum(oddsNPlay)
    varNPlay <- sum(oddsNPlay * resNPlay^2) / sum(oddsNPlay) - meanNPlay^2
    cat("\nMean return per hand:", 1+meanNPlay/nPlay, "with total variance:", varNPlay)
    
    # Take an appropriately sized sample from the resNPlay
    holdNPlay <- base::sample(rep(resNPlay, times=oddsNPlay), 
                              nSims*nHands, replace=TRUE
                              )
    
    # Convert to the overall outcomes (each column is a simulation)
    sumsNPlay <- colSums(matrix(holdNPlay, ncol=nSims))
    
    # Report on the overall mean and variance/standard deviation
    meanOverall <- mean(sumsNPlay) / nHands
    varOverall <- var(sumsNPlay)
    sdOverall <- sd(sumsNPlay)
    cat("\nMean return per hand:", 
        paste0(round(100 * (1 + meanOverall/nPlay), 3), "%"), 
        "with total variance (sd as % of total bet):", 
        prettyNum(round(varOverall, 0), big.mark=","), "(", 
        paste0(round(100*sdOverall/nHands/nPlay, 2), "%"), ")\n"
        )
    print(round(quantile(sumsNPlay/nHands/nPlay, 
                         c(0.01, 0.05, 0.10, 0.25, 0.5, 0.75, 0.90, 0.95, 0.99)
                         )
                , 4)
          )
    
    # Report on the percentage distributions
    par(mfrow=c(1, 2))
    hist(sumsNPlay/nHands/nPlay, col="light blue", 
         main=paste0("% Ret: ", nPlay, "-play (", nHands, " ", useName," deals)")
         )
    plot(x=(1:nSims)/nSims, y=sort(sumsNPlay/nHands/nPlay), pch=19, col="navy blue", 
         main=paste0("% Ret: ", nPlay, "-play (", nHands, " ", useName," deals)"), 
         xlab="Percentile", ylab="% Returns"
         )
    abline(h=0, v=0.5, lty=2)
    par(mfrow=c(1, 1))

    sumsNPlay
    
}


# Run for 10/5-play with 2,000 simulations of 16,000 hands
set.seed(1612200748)
jb96_10Sim <- sim_NPlay(keyFrame=jb96_10Play$out10Play, useName="JB 96", 
                        nPlay=10, nHands=16000, nSim=2000
                        )
set.seed(1612210738)
jb96_5Sim <- sim_NPlay(keyFrame=jb96_5Play$dfOutcome, useName="JB 96", 
                       nPlay=5, nHands=16000, nSim=2000
                       )


set.seed(1612201348)
bp85_10Sim <- sim_NPlay(keyFrame=bp85_10Play$out10Play, useName="BP 85", 
                        nPlay=10, nHands=16000, nSim=2000
                        )
set.seed(1612211338)
bp85_5Sim <- sim_NPlay(keyFrame=bp85_5Play$dfOutcome, useName="BP 85", 
                       nPlay=5, nHands=16000, nSim=2000
                       )


set.seed(2016122008)
bpd96_10Sim <- sim_NPlay(keyFrame=bpd96_10Play$out10Play, useName="BPD 96", 
                         nPlay=10, nHands=16000, nSim=2000
                         )
set.seed(2016122108)
bpd96_5Sim <- sim_NPlay(keyFrame=bpd96_5Play$dfOutcome, useName="BPD 96", 
                        nPlay=5, nHands=16000, nSim=2000
                        )


set.seed(1220160749)
ddb96_10Sim <- sim_NPlay(keyFrame=ddb96_10Play$out10Play, useName="DDB 96", 
                         nPlay=10, nHands=16000, nSim=2000
                         )
set.seed(1221160739)
ddb96_5Sim <- sim_NPlay(keyFrame=ddb96_5Play$dfOutcome, useName="DDB 96", 
                        nPlay=5, nHands=16000, nSim=2000
                        )


set.seed(1220201608)
tdb96_10Sim <- sim_NPlay(keyFrame=tdb96_10Play$out10Play, useName="TDB 96", 
                         nPlay=10, nHands=16000, nSim=2000
                         )
set.seed(1221201608)
tdb96_5Sim <- sim_NPlay(keyFrame=tdb96_5Play$dfOutcome, useName="TDB 96", 
                        nPlay=5, nHands=16000, nSim=2000
                        )


```
  
A second attempt is made to further vectorize the n-play process, with results compared to the previous results:  
```{r}

# Function to create the 1-play data
get_uq1Play <- function(keyList) {

    # Get the basic parameters
    uq_1PlayRes <- keyList$mapOuts
    uqCol <- ncol(keyList$uqCards)
    cWeight <- keyList$uqCards[, uqCol]
    uqHands <- keyList$uqCards[, -uqCol]

    # Convert uqHands to percentage outcomes by hand
    uq_1Play <- diag(1/rowSums(uqHands)) %*% uqHands
    str(uq_1Play)
    table(rowSums(uq_1Play))
    
    list(uq_Play=uq_1Play, uq_Res=uq_1PlayRes, cWeight=cWeight)
    
}


# Get the 1-play data for JB 96, BP 85, and TDB 96
startTime <- proc.time()

jb96_uq001 <- get_uq1Play(keyList=jb96UniqueList)
str(jb96_uq001)

bp85_uq001 <- get_uq1Play(keyList=bp85UniqueList)
str(bp85_uq001)

tdb96_uq001 <- get_uq1Play(keyList=tdb96UniqueList)
str(tdb96_uq001)

proc.time() - startTime


# Function to cross-product n-play and m-play
create_mnPlay <- function(keyN, keyM) {
    
    aTest <- matrix(data=0, nrow=nrow(keyN$uq_Play), 
                    ncol=ncol(keyM$uq_Play)*ncol(keyN$uq_Play)
                    )
    
    # Matrix multiply by "flavor" (unique rows)
    for (intCtr in 1:nrow(keyN$uq_Play)) {
        aTest[intCtr, ] <- as.vector( outer( keyN$uq_Play[intCtr, ], keyM$uq_Play[intCtr, ] ) )
    }
 
    # Sum outcomes for matrix cross product (column values for aTest)
    aScore <- as.vector(outer(keyN$uq_Res, keyM$uq_Res, FUN="+"))
    
    # Find and sort the unique scores
    uqRes <- sort(unique(aScore))

    # Convert the full aTest in to unique hands with values by column
    map_Play <- matrix(data=0L, nrow=ncol(aTest), ncol=length(uqRes))
    map_Mtx <- matrix(data=c(1:length(aScore), match(aScore, uqRes)), 
                      nrow=length(aScore)
                      ) 
    map_Play[ map_Mtx ] <- 1L
    uq_Play <- aTest %*% map_Play
    
    list(uq_Play=uq_Play, uq_Res=uqRes, cWeight=keyN$cWeight)
        
}


# Take JB 96, BP 85, and TDB 96 and expand from 1-play to 2-5 play
startTime <- proc.time()

jb96_uq002 <- create_mnPlay(keyN=jb96_uq001, keyM=jb96_uq001)
jb96_uq003 <- create_mnPlay(keyN=jb96_uq002, keyM=jb96_uq001)
jb96_uq004 <- create_mnPlay(keyN=jb96_uq003, keyM=jb96_uq001)
jb96_uq005 <- create_mnPlay(keyN=jb96_uq004, keyM=jb96_uq001)

proc.time() - startTime

bp85_uq002 <- create_mnPlay(keyN=bp85_uq001, keyM=bp85_uq001)
bp85_uq003 <- create_mnPlay(keyN=bp85_uq002, keyM=bp85_uq001)
bp85_uq004 <- create_mnPlay(keyN=bp85_uq003, keyM=bp85_uq001)
bp85_uq005 <- create_mnPlay(keyN=bp85_uq004, keyM=bp85_uq001)

proc.time() - startTime

tdb96_uq002 <- create_mnPlay(keyN=tdb96_uq001, keyM=tdb96_uq001)
tdb96_uq003 <- create_mnPlay(keyN=tdb96_uq002, keyM=tdb96_uq001)
tdb96_uq004 <- create_mnPlay(keyN=tdb96_uq003, keyM=tdb96_uq001)
tdb96_uq005 <- create_mnPlay(keyN=tdb96_uq004, keyM=tdb96_uq001)

proc.time() - startTime


# Compare with the former algorithm (JB 96)
new_2dfOutcome <- data.frame(nOutcome=jb96_uq002$uq_Res, 
                             wts=colSums(diag(jb96_uq002$cWeight) %*% jb96_uq002$uq_Play)
                             )
new_5dfOutcome <- data.frame(nOutcome=jb96_uq005$uq_Res, 
                             wts=colSums(diag(jb96_uq005$cWeight) %*% jb96_uq005$uq_Play)
                             )

jb96_2Play <- assessNPlay(keyList=jb96UniqueList, nPlay=2L)
jb96_5Play <- assessNPlay(keyList=jb96UniqueList, nPlay=5L)

all.equal(as.data.frame(jb96_2Play$dfOutcome[, -2]), new_2dfOutcome)
all.equal(as.data.frame(jb96_5Play$dfOutcome[, -2]), new_5dfOutcome)


# Compare with the former algorithm (BP 85)
new_2dfOutcome <- data.frame(nOutcome=bp85_uq002$uq_Res, 
                             wts=colSums(diag(bp85_uq002$cWeight) %*% bp85_uq002$uq_Play)
                             )
new_5dfOutcome <- data.frame(nOutcome=bp85_uq005$uq_Res, 
                             wts=colSums(diag(bp85_uq005$cWeight) %*% bp85_uq005$uq_Play)
                             )

bp85_2Play <- assessNPlay(keyList=bp85UniqueList, nPlay=2L)
bp85_5Play <- assessNPlay(keyList=bp85UniqueList, nPlay=5L)

all.equal(as.data.frame(bp85_2Play$dfOutcome[, -2]), new_2dfOutcome)
all.equal(as.data.frame(bp85_5Play$dfOutcome[, -2]), new_5dfOutcome)


# Compare with the former algorithm (TDB 96)
new_2dfOutcome <- data.frame(nOutcome=tdb96_uq002$uq_Res, 
                             wts=colSums(diag(tdb96_uq002$cWeight) %*% tdb96_uq002$uq_Play)
                             )
new_5dfOutcome <- data.frame(nOutcome=tdb96_uq005$uq_Res, 
                             wts=colSums(diag(tdb96_uq005$cWeight) %*% tdb96_uq005$uq_Play)
                             )

tdb96_2Play <- assessNPlay(keyList=tdb96UniqueList, nPlay=2L)
tdb96_5Play <- assessNPlay(keyList=tdb96UniqueList, nPlay=5L)

all.equal(as.data.frame(tdb96_2Play$dfOutcome[, -2]), new_2dfOutcome)
all.equal(as.data.frame(tdb96_5Play$dfOutcome[, -2]), new_5dfOutcome)


```
  
So, the algorithm is a quicker way for expanding n-Play for reasonably small values of n (in the ~5 range) that preserve the "by outcome flavor" nature of the matrix.
  
Additionally, an algorithm is written to simplify away flavors that have a very low probability of occuring.  For example, while it is theoretically possible to get 4 RF and 1 4 AwaK by holding a naked Ace, the probabilities of this occuring are vanishingly small.  Because the matrices propagate forward, this very improbable outcome can then be combined with getting an A-5 SF, 4 2/3/4wA, and the like.  The upshot is a lot of clutter in the matrices (straining memory and run-time) with no pragmatic impact on mean and variance.

As a default, an outcome (N-play flavor) is considered to be extremely unlikely if it would be observed less that once ever 25 billion dealt hands (10,000 cycles), though this tolerance can be adjusted.  These probabilities can either be ignored (all other probabilities scaled up accordingly), placed in their own column with the appropriate mean, or allocated to existing columns nearest to them.  
```{r}

clean_NPlay <- function(nPlayInput, nTol=0.0001, reAlloc=TRUE, makeOwn=FALSE) {
    
    cWeight <- nPlayInput$cWeight
    uq_Play <- nPlayInput$uq_Play
    uq_Res <- nPlayInput$uq_Res
    
    colWts <- colSums( cWeight * uq_Play )
    tooSmall <- (colWts < nTol)
    
    # Grab the contributions tomean and variance for tooSmall, !tooSmall, and all
    fullSum <- sum(colWts * uq_Res)
    lrgSum <- sum(colWts[!tooSmall] * uq_Res[!tooSmall])
    smlSum <- sum(colWts[tooSmall] * uq_Res[tooSmall])
    
    fullSum2 <- sum(colWts * uq_Res^2)
    lrgSum2 <- sum(colWts[!tooSmall] * uq_Res[!tooSmall]^2)
    smlSum2 <- sum(colWts[tooSmall] * uq_Res[tooSmall]^2)    
    
    
    cat("\n\nContributions to SUM:", 
        prettyNum(round(fullSum, 1), big.mark=","), 
        prettyNum(round(lrgSum, 1), big.mark=","), 
        paste0("(", round(100*lrgSum/fullSum, 2), "%)"), 
        prettyNum(round(smlSum, 1), big.mark=","), 
        paste0("(", round(100*smlSum/fullSum, 2), "%)")
        )

    cat("\nContributions to SUM-SQUARED:", 
        prettyNum(round(fullSum2, 0), big.mark=","), 
        prettyNum(round(lrgSum2, 0), big.mark=","), 
        paste0("(", round(100*lrgSum2/fullSum2, 2), "%)"), 
        prettyNum(round(smlSum2, 0), big.mark=","), 
        paste0("(", round(100*smlSum2/fullSum2, 2), "%)")
        )
    
    cat("\n\nMeans Assuming All, Large, Small:", 
        round(fullSum/sum(colWts), 6),
        round(lrgSum/sum(colWts[!tooSmall]), 6), 
        round(smlSum/sum(colWts[!tooSmall]), 6)
        )
    
    cat("\nVariances Assuming All, Large, Small:", 
        prettyNum(fullSum2/sum(colWts) - (fullSum/sum(colWts))^2, big.mark=","),
        prettyNum(lrgSum2/sum(colWts[!tooSmall]) - (lrgSum/sum(colWts[!tooSmall]))^2, big.mark=","), 
        prettyNum(smlSum2/sum(colWts[tooSmall]) - (fullSum/sum(colWts[tooSmall]))^2, big.mark=","), 
        "\n"
        )

    if (isTRUE(reAlloc)) {
        cleanNList <- list(uq_Play=(uq_Play[, !tooSmall] / rowSums(uq_Play[, !tooSmall])), 
                           uq_Res=uq_Res[!tooSmall], 
                           cWeight=cWeight
                           )
    } else {
        stop("Still need to implement other return modes")
    }
    
    newCSum <- colSums(cleanNList$cWeight * cleanNList$uq_Play)
    cat("\nMeans shifted from/to:", 
        round(fullSum/sum(colWts), 6), 
        round(sum(newCSum * cleanNList$uq_Res)/sum(newCSum), 6)
        )
    cat("\nE[X^2] shifted from/to:", 
        round(fullSum2/sum(colWts), 3), 
        round(sum(newCSum * cleanNList$uq_Res^2)/sum(newCSum), 3),
        "\n\n"
        )
    
    cleanNList
        
}

# Expand BP 85 (carefully) to 10-play
bp85_cl005 <- clean_NPlay(nPlayInput=bp85_uq005)
bp85_uqcl006 <- create_mnPlay(keyN=bp85_cl005, keyM=bp85_uq001)

bp85_cl006 <- clean_NPlay(nPlayInput=bp85_uqcl006)
bp85_uqcl007 <- create_mnPlay(keyN=bp85_cl006, keyM=bp85_uq001)

bp85_cl007 <- clean_NPlay(nPlayInput=bp85_uqcl007)
bp85_uqcl008 <- create_mnPlay(keyN=bp85_cl007, keyM=bp85_uq001)

bp85_cl008 <- clean_NPlay(nPlayInput=bp85_uqcl008)
bp85_uqcl009 <- create_mnPlay(keyN=bp85_cl008, keyM=bp85_uq001)

bp85_cl009 <- clean_NPlay(nPlayInput=bp85_uqcl009)
bp85_uqcl010 <- create_mnPlay(keyN=bp85_cl009, keyM=bp85_uq001)

bp85_cl010 <- clean_NPlay(nPlayInput=bp85_uqcl010)

```

