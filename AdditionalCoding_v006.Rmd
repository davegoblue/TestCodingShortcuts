---
title: "Additional Coding: Update #6"
author: "davegoblue"
date: "November 6, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Overview  
This document explores video poker hands, using <http://wizardofodds.com/games/video-poker/methodology/> as a template, and applying DataCamp_Insights_v001 materials where applicable.  This document builds on the more salient components of the analysis in AdditionalCoding_v005.Rmd.  In particular, the preparatory components are cached and saved, with a functional approach taken for assessing pay tables.  

## Analysis Approach  
The Wizard of Odds suggests an 11-step approach to calculating the returns for a video poker pay table:  
  
1.  Initialize arrays for discarding 0-5 cards  
2.  Loop through all 52c5 hands, score them based on their poker value, then place them in the appropriate arrays (each of discard 0 through discard 5)  
3.  Create the 134,459 non-duplicate starting hands possible (e.g., Ad Kh Tc 9c 3d is the same as As Kh Td 9d 3s), and assign it a weighting based on how much duplication it covers  
4.  Lookup each of the 134,459 hands and score the discard 0 (hold 5) option  
5.  Lookup every possible discard 1 (hold 4) option, find the EV in the discard 1 array and then subtract the outcome in the discard 0 array (cannot get back the same hand)  
6.  Lookup every possible discard 2 (hold 3) option, find the EV in the discard 2 array and then subtract the outcomes in the discard 1 array and then add back the outcome in the discard 0 array (double-subtracted)  
7.  Lookup every possible discard 3 (hold 2) option, find the EV in the discard 3 array and then subtract the outcomes in the discard 2 array and then add back the outcomes in the discard 1 array and then subtract out the outcome in the discard 0 array (typical set theory add/subtract)  
8.  Lookup every possible discard 4 (hold 1) option, find the EV in the discard 4 array and then subtract the outcomes in the discard 3 array and then add back the outcomes in the discard 2 array and then subtract out the outcome in the discard 1 array and then add back the outcome in the discard 0 array (typical set theory add/subtract)  
9.  Lookup every possible discard 5 (hold 0) option, find the EV in the discard 5 array and then subtract the outcomes in the discard 4 array and then add back the outcomes in the discard 3 array and then subtract out the outcome in the discard 2 array and then add back the outcome in the discard 1 array and then subtract out the outcome of the discard 0 array (typical set theory add/subtract)  
10.  Calculate the EV of every possible decision, and assign the appropriate weightings  
11.  Determine overall return, or other statistics of interest about the game  
  
This program adapts the approach as follows:  
  
* Preparatory work (cached) - create full matrices of hand types, and de-duplicated (weighted) matrix of unique starting hands  
* Scoring - apply pay table to cached preparatory work  
* Analysis - simulate pay table  
  
### Preparatory Work  
Key libraries are sourced and global parameters set.  In addition, all possible combinatorics are stored in an array, with functions declared to convert any given cards to an index.  This component is not cached:  
```{r}

library(tidyr)
library(dplyr)
library(ggplot2)


startTime <- proc.time()
totStart <- startTime

# Declare overall game variables
nHandTypes <- 50  # Number of hand types supported
nScores <- 16  # Number of final scores supported - many hand types may map to the same score


proc.time() - startTime


# Create a matrix to hold results for choose(n, k)
mtxCombin <- matrix(data=0L, nrow=52, ncol=5)
for (intCtr in 1:52) {
    for (intCtr2 in 1:5) {
        # Note that choose() is a guarded function where choose(n, k) returns 0 for k > n
        mtxCombin[intCtr, intCtr2] <- as.integer(choose(intCtr, intCtr2))
    }
}


idxCard1 <- function(c1) {
    # Just return yourself
    c1
}

idxCard2 <- function(c1, c2) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    as.integer(  1 + mtxCombin[52, 2] - mtxCombin[53-c1, 2] + 
                     mtxCombin[52-c1, 1] - mtxCombin[53-c2, 1]
              ) 
}

idxCard3 <- function(c1, c2, c3) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    as.integer(
        1 + mtxCombin[52, 3] - mtxCombin[53-c1, 3] +
            mtxCombin[52-c1, 2] - mtxCombin[53-c2, 2] +
            mtxCombin[52-c2, 1] - mtxCombin[53-c3, 1]
              )
}

idxCard4 <- function(c1, c2, c3, c4) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    as.integer(
        1 + mtxCombin[52, 4] - mtxCombin[53-c1, 4] +
            mtxCombin[52-c1, 3] - mtxCombin[53-c2, 3] +
            mtxCombin[52-c2, 2] - mtxCombin[53-c3, 2] + 
            mtxCombin[52-c3, 1] - mtxCombin[53-c4, 1]
              )
}

idxCard5 <- function(c1, c2, c3, c4, c5) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    as.integer(
        1 + mtxCombin[52, 5] - mtxCombin[53-c1, 5] +
            mtxCombin[52-c1, 4] - mtxCombin[53-c2, 4] +
            mtxCombin[52-c2, 3] - mtxCombin[53-c3, 3] + 
            mtxCombin[52-c3, 2] - mtxCombin[53-c4, 2] +
            mtxCombin[52-c4, 1] - mtxCombin[53-c5, 1]
             )
}

proc.time() - startTime

```
  
Each of the 52c5 possible starting hands are created, with hand types declared.  Of particular interest will be tracking the following, with results cached for time considerations:  
  
* Nothing (0)  
* Royal Flush (1)   
* Straight Flush (2)  
* Full House (3)  
* Flush (4)  
* Straight (5)  
* Trips (6)  
* Two Pair (7)  
* Pair AA (8)  
* Pair KK (9)  
* Pair QQ (10)  
* Pair JJ (11)  
* Pair TT (12)  
* Pair 22-99 (13)  
* AAAA with 2-4 (14)  
* AAAA with J-K (15)  
* AAAA with 5-T (16)  
* 2222/3333/4444 with A (17)  
* 2222/3333/4444 with 2-4 (18)  
* 2222/3333/4444 with J-K (19)  
* 2222/3333/4444 with 5-T (20)  
* JJJJ/QQQQ/KKKK with A (21)  
* JJJJ/QQQQ/KKKK with 2-4 (22)  
* JJJJ/QQQQ/KKKK with J-K (23)  
* JJJJ/QQQQ/KKKK with 5-T (24)  
* 5555-TTTT (25)  
  
```{r, cache=TRUE}

startTime <- proc.time()


# Create the 52c5 hands
aHands <- t(combn(1:52, 5))
str(aHands)


proc.time() - startTime


findTypes <- function (aHands, retAll=FALSE) {
    
    # Find the ranks and suits
    aRanks <- 1 + (aHands-1) %% 13
    aSuits <- (aHands-1) %/% 13
    
    # Find the flushes
    aFlush <- aSuits[, 1] == aSuits[, 5]

    # Find the straights
    strMatrix <- matrix(data=0L, nrow=13, ncol=10)
    strMatrix[c(1, 10, 11, 12, 13), 1] <- 1L
    for (intCtr in 1:9) { strMatrix[intCtr:(intCtr+4), intCtr+1] <- 1L }

    aRankCount <- matrix(data=-1L, nrow=choose(52, 5), ncol=13)
    for (intCtr in 1:13) { aRankCount[, intCtr] <- rowSums(aRanks == intCtr) }

    # Find max and count of ranks (sufficient to determine quads, full houses, trips, two pair, and pair)
    aQuads <- rowSums(aRankCount == 4)
    aTrips <- rowSums(aRankCount == 3)
    aPairs <- rowSums(aRankCount == 2)
    aStraight <- rowSums( ((aRankCount == 1) %*% strMatrix) == 5)

    # Default is that a hand has nothing
    aType <- rep(0L, choose(52, 5))

    # Declare types for mainline (RF, SF, FH, FL, ST, 3K, 2P)
    aType[aFlush == 1 & aStraight == 1 & aRankCount[, 1] == 1 & 
              aRankCount[, 13] == 1] <- 1  # Royal Flush
    aType[aFlush == 1 & aStraight == 1 & 
              (aRankCount[, 1] == 0 | aRankCount[, 13] == 0)] <- 2  # Straight Flush
    aType[aTrips == 1 & aPairs == 1] <- 3  # Full House
    aType[aFlush == 1 & aStraight == 0] <- 4  # Flush
    aType[aFlush == 0 & aStraight == 1] <- 5  # Straight
    aType[aTrips == 1 & aPairs == 0] <- 6  # Trips
    aType[aPairs == 2] <- 7  # Two Pair

    # Declare types for pairs
    aType[aTrips == 0 & aPairs == 1 & aRankCount[, 1] == 2] <- 8  # Pair Aces
    aType[aTrips == 0 & aPairs == 1 & aRankCount[, 13] == 2] <- 9  # Pair Kings
    aType[aTrips == 0 & aPairs == 1 & aRankCount[, 12] == 2] <- 10  # Pair Queens
    aType[aTrips == 0 & aPairs == 1 & aRankCount[, 11] == 2] <- 11  # Pair Jacks
    aType[aTrips == 0 & aPairs == 1 & aRankCount[, 10] == 2] <- 12  # Pair Tens
    aType[aTrips == 0 & aPairs == 1 & !(aType %in% c(8, 9, 10, 11, 12))] <- 13  # Pair 22-99

    # Declare types for quads
    quadSubset <- aRankCount[aQuads == 1, ]
    quadType <- apply(quadSubset, 1, FUN=function(x) { c(which(x == 4), which(x == 1)) } )
    quadScore <- rep(-1L, ncol(quadType))

    quadScore[quadType[1, ] == 1 & quadType[2, ] %in% c(2, 3, 4)] <- 14  ## AAAA with 2-4
    quadScore[quadType[1, ] == 1 & quadType[2, ] %in% c(11, 12, 13)] <- 15  ## AAAA with J-K
    quadScore[quadType[1, ] == 1 & quadType[2, ] %in% c(5, 6, 7, 8, 9, 10)] <- 16  ## AAAA with 5-T

    quadScore[quadType[1, ] %in% c(2, 3, 4) & 
                  quadType[2, ] %in% c(1)] <- 17  ## 2222/3333/4444 with A
    quadScore[quadType[1, ] %in% c(2, 3, 4) & 
                  quadType[2, ] %in% c(2, 3, 4)] <- 18  ## 2222/3333/4444 with 2-4
    quadScore[quadType[1, ] %in% c(2, 3, 4) & 
                  quadType[2, ] %in% c(11, 12, 13)] <- 19  ## 2222/3333/4444 with J-K
    quadScore[quadType[1, ] %in% c(2, 3, 4) & 
                  quadType[2, ] %in% c(5, 6, 7, 8, 9, 10)] <- 20  ## 2222/3333/4444 with 5-T

    quadScore[quadType[1, ] %in% c(11, 12, 13) & 
                  quadType[2, ] %in% c(1)] <- 21  ## JJJJ/QQQQ/KKKK with A
    quadScore[quadType[1, ] %in% c(11, 12, 13) & 
                  quadType[2, ] %in% c(2, 3, 4)] <- 22  ## JJJJ/QQQQ/KKKK with 2-4
    quadScore[quadType[1, ] %in% c(11, 12, 13) & 
                  quadType[2, ] %in% c(11, 12, 13)] <- 23  ## JJJJ/QQQQ/KKKK with J-K
    quadScore[quadType[1, ] %in% c(11, 12, 13) & 
                  quadType[2, ] %in% c(5, 6, 7, 8, 9, 10)] <- 24  ## JJJJ/QQQQ/KKKK with 5-T

    quadScore[quadType[1, ] %in% c(5, 6, 7, 8, 9, 10)] <- 25  ## 5555/6666/7777/8888/9999/TTTT with any

    # Populate quad results in to aType
    aType[aQuads == 1] <- quadScore
    data.frame(type=aType) %>% group_by(type) %>% summarize(ct=n()) %>% print.data.frame()

    if (retAll) {
        list(aType=aType, 
             aRankCount=aRankCount,
             aRanks=aRanks,
             aSuits=aSuits,
             quadSubset=quadSubset,
             quadType=quadType,
             aFlush=aFlush,
             aPairs=aPairs,
             aQuads=aQuads,
             aStraight=aStraight,
             aTrips=aTrips
             )
    } else {
        list(aType=aType) 
    }
}


listType <- findTypes(aHands=aHands, retAll=FALSE)
aType <- listType$aType


proc.time() - startTime

```
  
Further, each starting hand is assigned indices for keep0/discard5 down to keep5/discard0 .  Note that hand types have not yet been converted to scores; this is simply the step for finding the relevant indices (cached for run-time optimization):  
```{r, cache=TRUE}

startTime <- proc.time()


getIndices <- function(nKeep, keyFun) {

    mtxKeep <- combn(1:5, nKeep)
    retResults <- matrix(data=-1L, nrow=nrow(aHands), ncol=ncol(mtxKeep))

    for (intCtr in 1:ncol(mtxKeep)) {
        thisKey <- mtxKeep[, intCtr, drop=TRUE]
        thisList <- lapply(seq_along(thisKey), FUN=function(x) { aHands[, thisKey[x]] } )
        if (length(thisList) == 5) {
            retResults[, intCtr] <- keyFun(thisList[[1]], thisList[[2]], thisList[[3]], 
                                           thisList[[4]], thisList[[5]]
                                           )
        } else if (length(thisList) == 4) {
            retResults[, intCtr] <- keyFun(thisList[[1]], thisList[[2]], 
                                           thisList[[3]], thisList[[4]]
                                           )
        } else if (length(thisList) == 3) {
            retResults[, intCtr] <- keyFun(thisList[[1]], thisList[[2]], thisList[[3]])
        } else if (length(thisList) == 2) {
            retResults[, intCtr] <- keyFun(thisList[[1]], thisList[[2]])
        } else if (length(thisList) == 1) {
            retResults[, intCtr] <- keyFun(thisList[[1]])
        } else { stop(paste0("Incorrect list length: ", length(thisList))) }
    }

    # Pass back the outcome
    retResults
    
}


mtxIndices <- matrix(data=-1L, nrow=nrow(aHands), ncol=32)

# Populate the keep-all
mtxIndices[, 1] <- getIndices(nKeep=5, keyFun=idxCard5)
proc.time() - startTime

# Populate the keep-four
mtxIndices[, 2:6] <- getIndices(nKeep=4, keyFun=idxCard4)
proc.time() - startTime

# Populate the keep-three
mtxIndices[, 7:16] <- getIndices(nKeep=3, keyFun=idxCard3)
proc.time() - startTime

# Populate the keep-two
mtxIndices[, 17:26] <- getIndices(nKeep=2, keyFun=idxCard2)
proc.time() - startTime

# Populate the keep-one
mtxIndices[, 27:31] <- getIndices(nKeep=1, keyFun=idxCard1)
proc.time() - startTime

# Populate the keep-zero
mtxIndices[, 32] <- 0L


proc.time() - startTime

```
  
The next step creates the 134,459 non-duplicate starting hands possible (e.g., Ad Kh Tc 9c 3d is the same as As Kh Td 9d 3s), and assigns each a weighting based on how much duplication it covers.  
  
This is copied from v004/v005 which was adapted heavily from clever thinking at <http://wizardofodds.com/games/video-poker/methodology/>, using in order:  
  
* Four of a Kind (all that matters is what is the rank of the quad/kicker)  
* Full House (need to know ranks for A full of B, as well as whether B contains the fourth suit or not)  
* Trips (singletons can be all of fourth suit, one match and one fourth suit, no fourth suit/same, or no fourth suit/different)  
* Two Pair (suits matter for how much is in common between the two pairs, as well as the singleton)  
* Pair (many combinations for suits of the singletons)  
* Nothing (suits matter a great deal!)  
  
This component is cached for run-time performance:  
```{r, cache=TRUE}

startTime <- proc.time()


# Quads are simple - there are 13 possible quads and 12 possible kickers
# Each hand can be captured once with a weight of 4 since the kicker will always match one suit
quadSmall <- matrix(data=0L, nrow=13*12, ncol=5)
quadWeight <- rep(4L, times=13*12)
curIdx <- 1

for (intCtr in 1:13) {
    for (intCtr2 in (1:13)[-intCtr]) {
        quadSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr+39, intCtr2))
        curIdx <- curIdx + 1
    }
}


# Full Houses are not too much more complex, though there are two suit pairing options for each
fhSmall <- matrix(data=0L, nrow=13*12*2, ncol=5)
fhWeight <- rep(12L, times=13*12*2)
curIdx <- 1

for (intCtr in 1:13) {
    for (intCtr2 in (1:13)[-intCtr]) {
        # First option has both pairs matching the suits of the trips
        fhSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr2+13))
        # Second option has one pair not matching the suits of the trips
        fhSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr2+39))
        curIdx <- curIdx + 2
    }
}


# Trips become a touch more complicated
# There is weight 24 for both singletons match different trips suits
# There is weight 12 for one singleton matches and the other does not
# There is weight 12 for both singletons match the same trips suit
# There is weight 4 for both singletons match each other but not any of the trips suits
tripSmall <- matrix(data=0L, nrow=13*choose(12, 2)*5, ncol=5)
tripWeight <- rep(c(24, 12, 12, 12, 4), times=13*choose(12,2))
curIdx <- 1

for (intCtr in 1:13) {
    intAvail <- (1:13)[-intCtr]
    for (intCtr2 in intAvail[-length(intAvail)]) {
        for (intCtr3 in intAvail[intAvail > intCtr2]) {
            # First option has both singletons matching a different trips suit
            tripSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr3+13))
            # Second option has singleton one matching a trips suit and singleton two not
            tripSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr3+39))
            # Third option has singleton two matching a trips suit and singleton one not
            tripSmall[curIdx+2, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2+39, intCtr3))
            # Fourth option has both singletons matching the same trips suit
            tripSmall[curIdx+3, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr3))
            # Fifth option has both singletons failing to match a trips suit
            tripSmall[curIdx+4, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2+39, intCtr3+39))
            # Increment the index by 5
            curIdx <- curIdx + 5
        }
    }
}


# Two Pair becomes even more complicated
# There is weight 12 for four suits across the two pair -- singleton matches pair #1 or pair #2
# There is weight 24 for each of one suit match across the two pair; singleton can be four suits
# There is weight 12 for the two pair having identical suits; once for the singleton matching, once for not
twoSmall <- matrix(data=0L, nrow=choose(13, 2)*11*8, ncol=5)
twoWeight <- rep(c(12, 12, 24, 24, 24, 24, 12, 12), times=choose(13, 2)*11)
curIdx <- 1

for (intCtr in 1:12) {
    for (intCtr2 in (intCtr+1):13) {
        for (intCtr3 in (1:13)[-c(intCtr, intCtr2)]) {
            
            # First option has all two pair cards being different suits
            twoSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr2+39, intCtr3))
            twoSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr2+39, intCtr3+26))
            
            # Second option has one matched suits in the two pair
            twoSmall[curIdx+2, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3))
            twoSmall[curIdx+3, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3+13))
            twoSmall[curIdx+4, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3+26))
            twoSmall[curIdx+5, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3+39))
            
            # Third option has fully matched suits across the two pair
            twoSmall[curIdx+6, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+13, intCtr3))
            twoSmall[curIdx+7, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+13, intCtr3+26))
            
            # Increment the index by 8
            curIdx <- curIdx + 8
        }
    }
}


# One Pair becomes even more complicated
# The pair is (obviously) two-suited; consider them to be 1 and 2; the game is in the singletons
# Weight 12 (2): Singletons all same suit, once matching to a pair suit, and once not
# Weight 12 (3): Singletons are suited 2-1, all matching to the pairs - 112, 121, 211
# Weight 24 (3): Singletons are suited 2-1, two matching to the pairs - 113, 131, 311
# Weight 24 (3): Singletons are suited 2-1, one matching to the pairs - 133, 313, 331 
# Weight 12 (3): Singletons are suited 2-1, none matching to the pairs - 344, 434, 443
# Weight 24 (3): Singletons are suited 1-1-1, two matching to the pairs - 123, 132, 312
# Weight 24 (3): Singletons are suited 1-1-1, one matching to the pairs - 134, 314, 341
pairSmall <- matrix(data=0L, nrow=13*choose(12, 3)*20, ncol=5)
pairWeight <- rep(c(12, 12, 12, 12, 12, 24, 24, 24, 24, 24, 24, 
                    12, 12, 12, 24, 24, 24, 24, 24, 24), 
                  times=13*choose(12, 3)
                  )
curIdx <- 1

for (intCtr in 1:13) {
    intAvail <- (1:13)[-intCtr]
    for (intCtr2 in intAvail[-c(11, 12)]) {
        nextAvail <- (intCtr2+1):13
        nextAvail <- nextAvail[!(nextAvail %in% c(intCtr))]
        for (intCtr3 in nextAvail[-length(nextAvail)]) {
            lastAvail <- (intCtr3+1):13
            lastAvail <- lastAvail[!(lastAvail %in% c(intCtr))]
            for (intCtr4 in lastAvail) {
                # Weight 12 (2): Singletons all same suit, once matching to a pair suit, and once not
                pairSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3, intCtr4))
                pairSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+26, intCtr4+26))
            
                # Weight 12 (3): Singletons are suited 2-1, all matching to the pairs - 112, 121, 211
                pairSmall[curIdx+2, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3, intCtr4+13))
                pairSmall[curIdx+3, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+13, intCtr4))
                pairSmall[curIdx+4, ] <- sort(c(intCtr, intCtr+13, intCtr2+13, intCtr3, intCtr4))
                
                # Weight 24 (3): Singletons are suited 2-1, two matching to the pairs - 113, 131, 311
                pairSmall[curIdx+5, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3, intCtr4+26))
                pairSmall[curIdx+6, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4))
                pairSmall[curIdx+7, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4))
                
                # Weight 24 (3): Singletons are suited 2-1, one matching to the pairs - 133, 313, 331 
                pairSmall[curIdx+8, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4+26))
                pairSmall[curIdx+9, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4+26))
                pairSmall[curIdx+10, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+26, intCtr4))
                
                # Weight 12 (3): Singletons are suited 2-1, none matching to the pairs - 344, 434, 443
                pairSmall[curIdx+11, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+39, intCtr4+39))
                pairSmall[curIdx+12, ] <- sort(c(intCtr, intCtr+13, intCtr2+39, intCtr3+26, intCtr4+39))
                pairSmall[curIdx+13, ] <- sort(c(intCtr, intCtr+13, intCtr2+39, intCtr3+39, intCtr4+26))
                
                # Weight 24 (3): Singletons are suited 1-1-1, two matching to the pairs - 123, 132, 312
                pairSmall[curIdx+14, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+13, intCtr4+26))
                pairSmall[curIdx+15, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4+13))
                pairSmall[curIdx+16, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4+13))
                
                # Weight 24 (3): Singletons are suited 1-1-1, one matching to the pairs - 134, 314, 341
                pairSmall[curIdx+17, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4+39))
                pairSmall[curIdx+18, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4+39))
                pairSmall[curIdx+19, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+39, intCtr4))

                # Increment the index by 20
                curIdx <- curIdx + 20
            }
        }
    }
}


# No Pair becomes even more complicated
# The entire game is in the suits for the singletons
# Weight 4 (1): Singletons all same suit - 11111
# Weight 12 (5): Singletons are suited 4-1 - 11112, 11121, 11211, 12111, 21111
# Weight 12 (10): Singletons are suited 3-2 - 11122, 11212, 11221, 12112, 12121, 
#                                             12211, 21112, 21121, 21211, 22111
# Weight 24 (10): Singletons are suited 3-1-1 - 11123, 11213, 11231, 12113, 12131,
#                                               12311, 21113, 21131, 21311, 23111
# Weight 24 (15): Singletons are suited 2-2-1 - 11223, 12123, 12213, 11232, 12132, 
#                                               12231, 11322, 12312, 12321, 13122, 
#                                               13212, 13221, 31122, 31212, 31221
# Weight 24 (10): Singletons are suited 2-1-1-1 - 11234, 12134, 12314, 12341, 21134, 
#                                                 21314, 21341, 23114, 23141, 23411
noneSmall <- matrix(data=0L, nrow=choose(13, 5)*51, ncol=5)
noneWeight <- rep(c(4, 12, 12, 12, 12, 12, 
                    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 
                    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
                    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
                    24, 24, 24, 24, 24, 24, 24, 24, 24, 24
                    ), times=choose(13, 5)
                  )

mtxAdd <- matrix(data=c(0, 0, 0, 0, 0, 
                        0, 0, 0, 0, 1,
                        0, 0, 0, 1, 0, 
                        0, 0, 1, 0, 0, 
                        0, 1, 0, 0, 0, 
                        1, 0, 0, 0, 0, 
                        0, 0, 0, 1, 1,
                        0, 0, 1, 0, 1,
                        0, 1, 0, 0, 1,
                        1, 0, 0, 0, 1,
                        0, 0, 1, 1, 0,
                        0, 1, 0, 1, 0,
                        1, 0, 0, 1, 0,
                        0, 1, 1, 0, 0,
                        1, 0, 1, 0, 0,
                        1, 1, 0, 0, 0,
                        0, 0, 0, 1, 2,
                        0, 0, 1, 0, 2,
                        0, 1, 0, 0, 2,
                        1, 0, 0, 0, 2,
                        0, 0, 1, 2, 0,
                        0, 1, 0, 2, 0,
                        1, 0, 0, 2, 0,
                        0, 1, 2, 0, 0,
                        1, 0, 2, 0, 0,
                        1, 2, 0, 0, 0,
                        0, 0, 1, 1, 2,
                        0, 1, 0, 1, 2,
                        1, 0, 0, 1, 2,
                        0, 0, 1, 2, 1,
                        0, 1, 0, 2, 1,
                        1, 0, 0, 2, 1,
                        0, 0, 2, 1, 1,
                        0, 1, 2, 0, 1,
                        1, 0, 2, 0, 1,
                        0, 2, 0, 1, 1,
                        0, 2, 1, 0, 1,
                        1, 2, 0, 0, 1,
                        2, 0, 0, 1, 1,
                        2, 0, 1, 0, 1,
                        2, 1, 0, 0, 1,
                        0, 0, 1, 2, 3,
                        0, 1, 0, 2, 3,
                        0, 1, 2, 0, 3,
                        0, 1, 2, 3, 0,
                        1, 0, 0, 2, 3,
                        1, 0, 2, 0, 3,
                        1, 0, 2, 3, 0,
                        1, 2, 0, 0, 3,
                        1, 2, 0, 3, 0,
                        1, 2, 3, 0, 0
                        ) * 13, ncol=5, byrow=TRUE)

curIdx <- 1

for (intCtr in 1:9) {
    for (intCtr2 in (intCtr+1):10) {
        for (intCtr3 in (intCtr2+1):11) {
            for (intCtr4 in (intCtr3+1):12) {
                for (intCtr5 in (intCtr4+1):13) {
                    vecNone <- c(intCtr, intCtr2, intCtr3, intCtr4, intCtr5)
                    mtxNone <- matrix(data=rep(vecNone, times=51), ncol=5, byrow=TRUE)
                    # IMPORTANT - future classification relies on low-high sorting in each row
                    noneSmall[curIdx:(curIdx+50), ] <- 
                        t(apply(mtxNone + mtxAdd, 1, FUN=sort))
                    curIdx <- curIdx + 51
                }
            }
        }
    }
}


proc.time() - startTime

```
  
Further, the hands and weights are integrated to a single hand matrix and a single weighting vector:  
```{r}
startTime <- proc.time()


cardSmall <- rbind(quadSmall, fhSmall, tripSmall, twoSmall, pairSmall, noneSmall)
cardWeight <- c(quadWeight, fhWeight, tripWeight, twoWeight, pairWeight, noneWeight)

str(cardSmall)
str(cardWeight)

# Confirm that there are sill 52c5 hands after weighting
all.equal(sum(cardWeight), choose(52, 5))

# Confirm that dimensions of hands and weight match up
all.equal(nrow(cardSmall), length(cardWeight))
all.equal(ncol(cardSmall), 5)

# Report the degree of space savings due to the weighting
summary(cardWeight)


# Assign the index for each cardSmall
cardIndex <- idxCard5(cardSmall[, 1], cardSmall[, 2], cardSmall[, 3], 
                      cardSmall[, 4], cardSmall[, 5]
                      )
str(cardIndex)
summary(cardIndex)
all.equal(cardIndex, unique(cardIndex))

proc.time() - startTime

```
  
The weighting allows for ~19x reduction in duplication which speeds processing time by roughly ~19x when using "no replacement" for drawing hands.  This is a strong improvement in efficiency.  
  
### Scoring (apply pay table)  
A function is created to convert hand types to scores:  
```{r}

makeScores <- function(inType, type2Score, idx) {
    aScores <- type2Score$val[match(inType, idx)]
    
    print(summary(aScores))
    cat("\n")
    data.frame(aScores=aScores) %>% group_by(aScores) %>% summarize(ct=n()) %>% print()
    cat("\n")
    
    aScores
}

```
  
Next, a function is written to calculate each of the following, assuming that you can get back the original card(s) on the re-draw:  
  
* Keep 4  
* Keep 3  
* Keep 2  
* Keep 1  
  
There is no need to calculate Keep 5 (it is already aScores) or Keep 0 (it defaults to mean(aScores) everywhere):  
```{r}

findEV_YesRedraw <- function(useIdx, mtxIndices, aScores) {
    # Assuming re-draw of thrown cards
    tmpScores <- data.frame(idx=as.vector(mtxIndices[, useIdx]), 
                            val=rep(aScores, times=length(useIdx))
                            )
    
    # This is what will be returned - mean by Index
    tmpScores %>% group_by(idx) %>% summarize(ev=mean(val))
}


calcEV_YesRedraw <- function(mtxIndices, aScores) {

    tmpEVkeep4 <- findEV_YesRedraw(useIdx=2:6, mtxIndices=mtxIndices, aScores=aScores)
    tmpEVkeep3 <- findEV_YesRedraw(useIdx=7:16, mtxIndices=mtxIndices, aScores=aScores)
    tmpEVkeep2 <- findEV_YesRedraw(useIdx=17:26, mtxIndices=mtxIndices, aScores=aScores)
    tmpEVkeep1 <- findEV_YesRedraw(useIdx=27:31, mtxIndices=mtxIndices, aScores=aScores)

    print(summary(tmpEVkeep4$ev)); cat("\n")
    print(summary(tmpEVkeep3$ev)); cat("\n")
    print(summary(tmpEVkeep2$ev)); cat("\n")
    print(summary(tmpEVkeep1$ev)); cat("\n\n")

    print(sum(tmpEVkeep4$idx != 1:choose(52,4)))
    print(sum(tmpEVkeep3$idx != 1:choose(52,3)))
    print(sum(tmpEVkeep2$idx != 1:choose(52,2)))
    print(sum(tmpEVkeep1$idx != 1:choose(52,1)))

    list(tmpEVkeep4=tmpEVkeep4, tmpEVkeep3=tmpEVkeep3, 
         tmpEVkeep2=tmpEVkeep2, tmpEVkeep1=tmpEVkeep1
         )
}

```
  
The summary statistics and control totals are "as expected", and the process takes ~8 seconds.  This could be reduced to ~0.5 seconds by using a weighting that avoids redundancy.  However, further effort is needed to make sure that 1) discards are never returned, and 2) optimal holds for each starting hand can be calculated.  
  
### Analysis (simulate pay table)  
Next, all of the holds are run assuming you cannot re-draw discards, using the smaller database.  The key elements are 1) cardSmall (actual hands), 2) cardWeight (weightings for cardSmall), and 3) cardIndex (the mapping of each hand in cardSmall to the corresponding index of aScores:  
```{r}

makeNoReplace <- function(aScores, cardIndex, keyList, mtxIndices) {
    
    evSmallNoReplace <- matrix(data=0.0, nrow=length(cardIndex), ncol=32)
    
    tmpEVkeep4 <- keyList$tmpEVkeep4
    tmpEVkeep3 <- keyList$tmpEVkeep3
    tmpEVkeep2 <- keyList$tmpEVkeep2
    tmpEVkeep1 <- keyList$tmpEVkeep1
    
    # Keep 5
    evSmallNoReplace[, 1] <- aScores[cardIndex]


    # Keep 4 (intCtr: 2 is 1234, 3 is 1235, 4 is 1245, 5 is 1345, 6 is 2345)
    for (intCtr in 2:6) {
        evSmallNoReplace[, intCtr] <- (48 * tmpEVkeep4$ev[mtxIndices[cardIndex, intCtr]] - 
                                           evSmallNoReplace[, 1]) / 47
    }


    # Keep 3 (intCtr: 7 is 123, 8 is 124, 9 is 125, 10 is 134, 11 is 135)
    # Keep 3 (intCtr: 12 is 145, 13 is 234, 14 is 235, 15 is 245, 16 is 345)
    # Take the EV of the 3 cards assuming stand-alone
    # Subtract the EV of each of the 4 cards (3 + 1 discard) assuming stand-alone
    # Add back the EV of the 5 cards assuming stand-alone
    mapKeep3 <- data.frame(idx=7:16, 
                           keep1=c(2, 2, 3, 2, 3, 4, 2, 3, 4, 5), 
                           keep2=c(3, 4, 4, 5, 5, 5, 6, 6, 6, 6)
                           )
    for (intCtr in 7:16) {
        c1 <- mapKeep3$keep1[mapKeep3$idx == intCtr]
        c2 <- mapKeep3$keep2[mapKeep3$idx == intCtr]
        evSmallNoReplace[, intCtr] <- (choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, intCtr]] - 
                                      48 * tmpEVkeep4$ev[mtxIndices[cardIndex, c1]] -
                                      48 * tmpEVkeep4$ev[mtxIndices[cardIndex, c2]] + 
                                      evSmallNoReplace[, 1]
                                  ) / choose(47, 2)
    }


    # Keep 2 (intCtr: 17 is 12, 18 is 13, 19 is 14, 20 is 15, 21 is 23)
    # Keep 2 (intCtr: 22 is 24, 23 is 25, 24 is 34, 25 is 35, 26 is 45)
    # Take the EV of the 2 cards assuming stand-alone
    # Subtract the EV of each of the 3 cards (2 + 1 discard) assuming stand-alone
    # add back the EV of each of the 4 cards (2 + 2 discard) assuming stand-alone
    # Subtract the EV of the 5 cards assuming stand-alone
    mapKeep2 <- data.frame(idx=17:26, 
                           keep3_1=c(7,  7,  8,  9,  7,  8,  9, 10, 11, 12), 
                           keep3_2=c(8, 10, 10, 11, 13, 13, 14, 13, 14, 15),
                           keep3_3=c(9, 11, 12, 12, 14, 15, 15, 16, 16, 16),
                           keep4_1=c(2, 2, 2, 3, 2, 2, 3, 2, 3, 4),
                           keep4_2=c(3, 3, 4, 4, 3, 4, 4, 5, 5, 5),
                           keep4_3=c(4, 5, 5, 5, 6, 6, 6, 6, 6, 6)
                           )

    for (intCtr in 17:26) {
        c31 <- mapKeep2$keep3_1[mapKeep2$idx == intCtr]
        c32 <- mapKeep2$keep3_2[mapKeep2$idx == intCtr]
        c33 <- mapKeep2$keep3_3[mapKeep2$idx == intCtr]
    
        c41 <- mapKeep2$keep4_1[mapKeep2$idx == intCtr]
        c42 <- mapKeep2$keep4_2[mapKeep2$idx == intCtr]
        c43 <- mapKeep2$keep4_3[mapKeep2$idx == intCtr]
    
        evSmallNoReplace[, intCtr] <- (choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, intCtr]] - 
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c31]] -
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c32]] -
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c33]] +
                                      choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, c41]] +
                                      choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, c42]] +
                                      choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, c43]] -
                                      evSmallNoReplace[, 1]
                                    ) / choose(47, 3)
    }


    # Keep 1 (intCtr: 27 is 1, 28 is 2, 29 is 3, 30 is 4, 31 is 5)
    # Take the EV of the 1 card assuming stand-alone
    # Subtract the EV of the 2 cards (1 + 1 discard) assuming stand-alone
    # Add back the EV of each of the 3 cards (1 + 2 discard) assuming stand-alone
    # Subtract the EV of each of the 4 cards (1 + 3 discard) assuming stand-alone
    # Add back the EV of the 5 cards assuming stand-alone
    mapKeep1 <- data.frame(idx=27:31,
                           keep2_1=c(17, 17, 18, 19, 20),
                           keep2_2=c(18, 21, 21, 22, 23),
                           keep2_3=c(19, 22, 24, 24, 25),
                           keep2_4=c(20, 23, 25, 26, 26),
                           keep3_1=c(7,   7,  7,  8,  9), 
                           keep3_2=c(8,   8, 10, 10, 11),
                           keep3_3=c(9,   9, 11, 12, 12),
                           keep3_4=c(10, 13, 13, 13, 14),
                           keep3_5=c(11, 14, 14, 15, 15),
                           keep3_6=c(12, 15, 16, 16, 16),
                           keep4_1=c(2, 2, 2, 2, 3),
                           keep4_2=c(3, 3, 3, 4, 4),
                           keep4_3=c(4, 4, 5, 5, 5),
                           keep4_4=c(5, 6, 6, 6, 6)
                           )

    for (intCtr in 27:31) {
        c21 <- mapKeep1$keep2_1[mapKeep1$idx == intCtr]
        c22 <- mapKeep1$keep2_2[mapKeep1$idx == intCtr]
        c23 <- mapKeep1$keep2_3[mapKeep1$idx == intCtr]
        c24 <- mapKeep1$keep2_4[mapKeep1$idx == intCtr]
    
        c31 <- mapKeep1$keep3_1[mapKeep1$idx == intCtr]
        c32 <- mapKeep1$keep3_2[mapKeep1$idx == intCtr]
        c33 <- mapKeep1$keep3_3[mapKeep1$idx == intCtr]
        c34 <- mapKeep1$keep3_4[mapKeep1$idx == intCtr]
        c35 <- mapKeep1$keep3_5[mapKeep1$idx == intCtr]
        c36 <- mapKeep1$keep3_6[mapKeep1$idx == intCtr]
    
        c41 <- mapKeep1$keep4_1[mapKeep1$idx == intCtr]
        c42 <- mapKeep1$keep4_2[mapKeep1$idx == intCtr]
        c43 <- mapKeep1$keep4_3[mapKeep1$idx == intCtr]
        c44 <- mapKeep1$keep4_4[mapKeep1$idx == intCtr]
    
        evSmallNoReplace[, intCtr] <- (choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, intCtr]] - 
                                      choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, c21]] -
                                      choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, c22]] - 
                                      choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, c23]] - 
                                      choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, c24]] + 
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c31]] +
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c32]] +
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c33]] +
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c34]] +
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c35]] +
                                      choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, c36]] -
                                      choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, c41]] -
                                      choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, c42]] -
                                      choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, c43]] -
                                      choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, c44]] +
                                      evSmallNoReplace[, 1]
                                ) / choose(47, 4)
    }


    # Keep 0 (column 32)
    # Take the EV of the 0 card assuming stand-alone
    # Subtract the EV of each 1 card (0 + 1 discard) assuming stand-alone
    # Add back the EV of each of the 2 cards (0 + 2 discard) assuming stand-alone
    # Subtract the EV of each of the 3 cards (0 + 3 discard) assuming stand-alone
    # Add back the EV of each of the 4 cards (0 + 4 discard) assuming stand-alone
    # Subtract the EV of the 5 cards assuming stand-alone

    evSmallNoReplace[, 32] <- (choose(52, 5) * mean(aScores) - 
                              choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, 31]] -
                              choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, 30]] - 
                              choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, 29]] - 
                              choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, 28]] - 
                              choose(51, 4) * tmpEVkeep1$ev[mtxIndices[cardIndex, 27]] +
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 26]] +
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 25]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 24]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 23]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 22]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 21]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 20]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 19]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 18]] + 
                              choose(50, 3) * tmpEVkeep2$ev[mtxIndices[cardIndex, 17]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 16]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 15]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 14]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 13]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 12]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 11]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 10]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 9]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 8]] -
                              choose(49, 2) * tmpEVkeep3$ev[mtxIndices[cardIndex, 7]] +
                              choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, 6]] +
                              choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, 5]] +
                              choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, 4]] +
                              choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, 3]] +
                              choose(48, 1) * tmpEVkeep4$ev[mtxIndices[cardIndex, 2]] -
                              evSmallNoReplace[, 1]
                          ) / choose(47, 5)

    evSmallNoReplace
}


```
  
The optimal holds and aggregate EV are the assessed:  
```{r}

descStat <- function(tempSmallMax, cardWeight) {

    # Calculate descriptive statistics
    print(summary(rep(tempSmallMax[1, ], times=cardWeight))); cat("\n")
    print(1 + mean(rep(tempSmallMax[1, ], times=cardWeight))); cat("\n")

    hist(rep(tempSmallMax[2, ], times=cardWeight), breaks=0:33, main="Index for Cards Held", 
         xlab="1 (hold 5) --- 2-6 (hold 4: 1234, 1235, 1245, 1345, 2345) -- etc. -- 32 (hold 0)",
        col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
                rep("lightgreen", 10), rep("red", 5), rep("black", 1) 
            ) 
        )

    newSmallCutIdx <- cut(tempSmallMax[2, ], 
                     breaks=c(0.5, 1.5, 6.5, 16.5, 26.5, 31.5, 32.5)
                     )

    data.frame(newType=rep(newSmallCutIdx, times=cardWeight)) %>% 
        group_by(newType) %>% summarize(ct=n())

}

```
  
The control totals and expected values are as expected, and the program runs in ~10 seconds!  

Next, the scoring and analysis are converted to functions, with the simulation re-run:  
```{r}

# Simulate a specific pay-table
simGame <- function(aT=aType, h2S=hnd2Score, gameI=gameIndex, mtxI=mtxIndices, 
                    cardI=cardIndex, cardW=cardWeight, startT=startTime, 
                    grTitle="Simulation Results", allOut=FALSE
                    ) {
    
    # Convert to Scores
    aScores <- makeScores(inType=aT, type2Score=h2S, idx=gameI)

    # Get the EV assuming re-draws are allowed
    keyList <- calcEV_YesRedraw(mtxIndices=mtxI, aScores=aScores)

    # Make the EV grid for "no replacement"
    evSmallNoReplace <- makeNoReplace(aScores=aScores, cardIndex=cardI, 
                                      keyList=keyList, mtxIndices=mtxI
                                      )

    # Find the best holds
    tempSmallMax <- apply(evSmallNoReplace, 1, FUN=function(x) { c(max(x), which.max(x)) } )
    descStat(tempSmallMax=tempSmallMax, cardWeight=cardW)
    
    if (allOut) {
        return(list(tempSmallMax=tempSmallMax, 
                    evSmallNoReplace=evSmallNoReplace, 
                    aScores=aScores, 
                    keyList=keyList
                    )
               )
    } else {
        return(list(tempSmallMax=tempSmallMax, 
                    evSmallNoReplace=evSmallNoReplace
                    )
               )
    }
}


# Use one pay-table on a different game
simPayTable <- function(useEV, useHold, useWeights) {
    
    # Confirm dimensions
    if (length(useHold) != nrow(useEV) | length(useHold) != length(useWeights)) {
        print(str(useEV))
        print(str(useHold))
        print(str(useWeights))
        stop("Error: Inconsistent dimensions for simulation; check and re-try")
    }
    
    # useHold (vector 134,459) determines which column to use 
    # for each respective row of useEV (matrix 134,459 x 32)
    newEV <- useEV[ cbind(1:nrow(useEV), useHold) ]
    print(summary(rep(newEV, times=useWeights)))
    
    return(newEV)
}



startTime <- proc.time()



# Run the game for JB 96
gameIndex <- 0:25
jb96hnd2Score <- data.frame(idx=gameIndex, val=c( -1, 
                                                 799, 49,  8,  5,  3, 
                                                   2,  1,  0,  0,  0, 
                                                   0, -1, -1, 24, 24, 
                                                  24, 24, 24, 24, 24, 
                                                  24, 24, 24, 24, 24
                                            )
                        )

jb96List <- simGame(h2S=jb96hnd2Score)
proc.time() - startTime



# Run the game for JB 85
gameIndex <- 0:25
jb85hnd2Score <- data.frame(idx=gameIndex, val=c( -1, 
                                                 799, 49,  7,  4,  3, 
                                                   2,  1,  0,  0,  0, 
                                                   0, -1, -1, 24, 24, 
                                                  24, 24, 24, 24, 24, 
                                                  24, 24, 24, 24, 24
                                            )
                        )

jb85List <- simGame(h2S=jb85hnd2Score)
proc.time() - startTime



# Nothing
# RF, SF, FH, FL, ST
# Trips, 2P, AA, KK, QQ
# JJ, TT, 22-99, AAAA 2-4, AAAA J-K
# AAAA 5-T, 2222/3333/4444 A, 2222/3333/4444 2-4, 2222/3333/4444 J-K, 2222/3333/4444 5-T
# JJJJ/QQQQ/KKKK A, JJJJ/QQQQ/KKKK 2-4, JJJJ/QQQQ/KKKK J-K, JJJJ/QQQQ/KKKK 5-T, 5555-TTTT

# Run the game for BP 85
gameIndex <- 0:25
bp85hnd2Score <- data.frame(idx=gameIndex, val=c( -1, 
                                                 799, 49,  7,  4,  3, 
                                                   2,  1,  0,  0,  0, 
                                                   0, -1, -1, 79, 79, 
                                                  79, 39, 39, 39, 39, 
                                                  24, 24, 24, 24, 24
                                            )
                        )

bp85List <- simGame(h2S=bp85hnd2Score)
proc.time() - startTime



# Run the game for DDB 96
gameIndex <- 0:25
ddb96hnd2Score <- data.frame(idx=gameIndex, val=c( -1, 
                                                  799, 49,  8,  5,  3, 
                                                    2,  0,  0,  0,  0, 
                                                    0, -1, -1, 399, 159, 
                                                  159, 159, 159, 79, 79, 
                                                   49, 49, 49, 49, 49
                                             )
                         )

ddb96List <- simGame(h2S=ddb96hnd2Score)
proc.time() - startTime



# Run the game for TDB 97
gameIndex <- 0:25
tdb97hnd2Score <- data.frame(idx=gameIndex, val=c( -1, 
                                                  799,  49,   8,   6,   3, 
                                                    1,   0,   0,   0,   0, 
                                                    0,  -1,  -1, 799, 159, 
                                                  159, 399, 399,  79,  79, 
                                                   49,  49,  49,  49,  49
                                             )
                         )

tdb97List <- simGame(h2S=tdb97hnd2Score)
proc.time() - startTime



# Run the game for TDB 96
gameIndex <- 0:25
tdb96hnd2Score <- data.frame(idx=gameIndex, val=c( -1, 
                                                  799,  49,   8,   5,   3, 
                                                    1,   0,   0,   0,   0, 
                                                    0,  -1,  -1, 799, 159, 
                                                  159, 399, 399,  79,  79, 
                                                   49,  49,  49,  49,  49
                                             )
                         )

tdb96List <- simGame(h2S=tdb96hnd2Score)
proc.time() - startTime



# Run the game for BPD 96
gameIndex <- 0:25
bpd96hnd2Score <- data.frame(idx=gameIndex, val=c( -1, 
                                                  799,  49,   8,   5,   3, 
                                                    2,   0,   0,   0,   0, 
                                                    0,  -1,  -1,  79,  79, 
                                                   79,  79,  79,  79,  79, 
                                                   79,  79,  79,  79,  79
                                             )
                         )

bpd96List <- simGame(h2S=bpd96hnd2Score)
proc.time() - startTime



# Find the EV for using the JB 96 strategy on the JB 85 game
sum(jb85List$tempSmallMax[2,] != jb96List$tempSmallMax[2,])
sum((jb85List$tempSmallMax[2,] != jb96List$tempSmallMax[2,]) * cardWeight)
jb85EV_jb96Holds <- simPayTable(useEV=jb85List$evSmallNoReplace, 
                                useHold=jb96List$tempSmallMax[2, ], 
                                useWeights=cardWeight
                                )
1 + mean(rep(jb85EV_jb96Holds, times=cardWeight))
mean(rep(jb85EV_jb96Holds - jb85List$tempSmallMax[1, ], times=cardWeight))
proc.time() - startTime



# Find the EV for using the JB 96 strategy on the BP 85 game
sum(bp85List$tempSmallMax[2,] != jb96List$tempSmallMax[2,])
sum((bp85List$tempSmallMax[2,] != jb96List$tempSmallMax[2,]) * cardWeight)
bp85EV_jb96Holds <- simPayTable(useEV=bp85List$evSmallNoReplace, 
                                useHold=jb96List$tempSmallMax[2, ], 
                                useWeights=cardWeight
                                )
1 + mean(rep(bp85EV_jb96Holds, times=cardWeight))
mean(rep(bp85EV_jb96Holds - bp85List$tempSmallMax[1, ], times=cardWeight))
proc.time() - startTime


# Find the EV for using the JB 96 strategy on the DDB 96 game
sum(ddb96List$tempSmallMax[2,] != jb96List$tempSmallMax[2,])
sum((ddb96List$tempSmallMax[2,] != jb96List$tempSmallMax[2,]) * cardWeight)
ddb96EV_jb96Holds <- simPayTable(useEV=ddb96List$evSmallNoReplace, 
                                useHold=jb96List$tempSmallMax[2, ], 
                                useWeights=cardWeight
                                )
1 + mean(rep(ddb96EV_jb96Holds, times=cardWeight))
d_jb96_ddb96 <- ddb96EV_jb96Holds - ddb96List$tempSmallMax[1, ]
mean(rep(d_jb96_ddb96, times=cardWeight))
data.frame(dEV=rep(d_jb96_ddb96, times=cardWeight)) %>% 
    mutate(rndDelta=round(dEV, 2)) %>% 
    group_by(rndDelta) %>%
    summarize(ct=n(), evLoss=100 * sum(rndDelta)/sum(cardWeight))
proc.time() - startTime


# Find the EV for using the DDB 96 strategy on the TDB 97 game
sum(tdb97List$tempSmallMax[2,] != ddb96List$tempSmallMax[2,])
sum((tdb97List$tempSmallMax[2,] != ddb96List$tempSmallMax[2,]) * cardWeight)
tdb97EV_ddb96Holds <- simPayTable(useEV=tdb97List$evSmallNoReplace, 
                                  useHold=ddb96List$tempSmallMax[2, ], 
                                  useWeights=cardWeight
                                  )
1 + mean(rep(tdb97EV_ddb96Holds, times=cardWeight))
d_ddb96_tdb97 <- tdb97EV_ddb96Holds - tdb97List$tempSmallMax[1, ]
mean(rep(d_ddb96_tdb97, times=cardWeight))
data.frame(dEV=rep(d_ddb96_tdb97, times=cardWeight)) %>% 
    mutate(rndDelta=round(dEV, 2)) %>% 
    group_by(rndDelta) %>%
    summarize(ct=n(), evLoss=100 * sum(rndDelta)/sum(cardWeight)) %>%
    print.data.frame()
proc.time() - startTime


# Find the EV for using the DDB 96 strategy on the TDB 96 game
sum(tdb96List$tempSmallMax[2,] != ddb96List$tempSmallMax[2,])
sum((tdb96List$tempSmallMax[2,] != ddb96List$tempSmallMax[2,]) * cardWeight)
tdb96EV_ddb96Holds <- simPayTable(useEV=tdb96List$evSmallNoReplace, 
                                  useHold=ddb96List$tempSmallMax[2, ], 
                                  useWeights=cardWeight
                                  )
1 + mean(rep(tdb96EV_ddb96Holds, times=cardWeight))
d_ddb96_tdb96 <- tdb96EV_ddb96Holds - tdb96List$tempSmallMax[1, ]
mean(rep(d_ddb96_tdb96, times=cardWeight))
data.frame(dEV=rep(d_ddb96_tdb96, times=cardWeight)) %>% 
    mutate(rndDelta=round(dEV, 2)) %>% 
    group_by(rndDelta) %>%
    summarize(ct=n(), evLoss=100 * sum(rndDelta)/sum(cardWeight)) %>%
    print.data.frame()
proc.time() - startTime


# Find the EV for using the DDB 96 strategy on the JB 96 game
sum(jb96List$tempSmallMax[2,] != ddb96List$tempSmallMax[2,])
sum((jb96List$tempSmallMax[2,] != ddb96List$tempSmallMax[2,]) * cardWeight)
jb96EV_ddb96Holds <- simPayTable(useEV=jb96List$evSmallNoReplace, 
                                 useHold=ddb96List$tempSmallMax[2, ], 
                                 useWeights=cardWeight
                                 )
1 + mean(rep(jb96EV_ddb96Holds, times=cardWeight))
d_ddb96_jb96 <- jb96EV_ddb96Holds - jb96List$tempSmallMax[1, ]
mean(rep(d_ddb96_jb96, times=cardWeight))
data.frame(dEV=rep(d_ddb96_jb96, times=cardWeight)) %>% 
    mutate(rndDelta=round(dEV, 2)) %>% 
    group_by(rndDelta) %>%
    summarize(ct=n(), evLoss=100 * sum(rndDelta)/sum(cardWeight)) %>%
    print.data.frame()
proc.time() - startTime



# Find the EV for using the JB 96 strategy on the BPD 96 game
sum(bpd96List$tempSmallMax[2,] != jb96List$tempSmallMax[2,])
sum((bpd96List$tempSmallMax[2,] != jb96List$tempSmallMax[2,]) * cardWeight)
bpd96EV_jb96Holds <- simPayTable(useEV=bpd96List$evSmallNoReplace, 
                                 useHold=jb96List$tempSmallMax[2, ], 
                                 useWeights=cardWeight
                                 )
1 + mean(rep(bpd96EV_jb96Holds, times=cardWeight))
d_jb96_bpd96 <- bpd96EV_jb96Holds - bpd96List$tempSmallMax[1, ]
mean(rep(d_jb96_bpd96, times=cardWeight))
data.frame(dEV=rep(d_jb96_bpd96, times=cardWeight)) %>% 
    mutate(rndDelta=round(dEV, 2)) %>% 
    group_by(rndDelta) %>%
    summarize(ct=n(), evLoss=100 * sum(rndDelta)/sum(cardWeight))
proc.time() - startTime



# Find variance for initial dealt cards in JB 96,  JB 85,  BP 85, 
#                                          DDB 96, TDB 97, TDB 96, and BPD 96
findMeanVar <- function(useList, useName, useWeight=cardWeight) {
    gameMean <- mean(rep(useList$tempSmallMax[1, ], times=useWeight))
    gameVar <- var(rep(useList$tempSmallMax[1, ], times=useWeight))
    print(paste0("Game ", useName, ":  Return: ", signif(1+gameMean, 5), 
                 " and Variance on Deal: ", signif(gameVar, 4)
                 )
          )
}

findMeanVar(useList=jb96List, useName="JB 96")
findMeanVar(useList=jb85List, useName="JB 85")
findMeanVar(useList=bp85List, useName="BP 85")
findMeanVar(useList=ddb96List, useName="DDB 96")
findMeanVar(useList=tdb97List, useName="TDB 97")
findMeanVar(useList=tdb96List, useName="TDB 96")
findMeanVar(useList=bpd96List, useName="BPD 96")

```
  
The functional approach takes ~10 seconds and generates the correct results.  

Specific to using the JB96 strategy on the DDB 96 game, errors are generated as follows:  
  
* AAppx (should just keep AA) - 19,008 hands, 0.18% penalty  
* AAAA with 5-K or 2222/3333/4444 with 5-K (should discard 5-K) - 144 hands, 0.17% penalty  
* A-Hx-T/L-L-L (should keep A) and inside-straight (go for it) - 234,852 hands, 0.13% penalty  
* AAA with 55/66/77/88/99/TT/JJ/QQ/KK (should just keep AAA) - 216 hands, 0.03% penalty  
* AAA with 22/33/44 (should just keep AAA) - 72 hands, 0.01% penalty  
* mix of HHTLL - 12,492 hands, 0.01% penalty  
* QJTT9 or QJT99 (should keep QJT9) - 696 hands, <0.01% penalty  
* AKQsJs (should keep AKQJ) - 756 hands, <0.01% penalty  
  
Specific to using the DDB96 strategy on the TDB97 and TDB96 games, errors are generated as follows:  
  
* TDB97 - ~10% of holds should change from DDB 96, with EV declining by ~1.1% from ~99.6% to ~98.5% otherwise (roughly ~0.7% of the decline is driven by what to hold with dealt AAA/222/333/444)  
* TDB96 - ~5% of holds should change from DDB 96, with EV declining by ~0.8% from ~98.2% to ~97.4% otherwise (roughly ~0.7% of the decline is driven by what to hold with dealt AAA/222/333/444)  
  
Specific to using the DDB 96 strategy on the JB 96 games, errors are generated of ~1.0% (reducing returns from ~99.5% to ~98.5%).  Almost all of the errors are related to the AAAxx, AAPPx, and AHHxx holds.  
  
Specific to using the JB 96 strategy on the BPD 96 games, only minimal (<0.1% EV) errors are generated.  
  
Broadly, playing strategy for the following games incurs minimal errors:  
  
* JB 96, JB 95, BP 85, BPD 96 - use the JB 96 strategy which has very minimal errors throughout  
* DDB 96 - modify the JB 96 strategy to account for value of Aces and Kickers (hold AAAA vs AAAA/5-K, hold AAA vs AAApp, hold AA vs AAppx, hold A vs AK/AQ/AJ/KQ/KJ/QJ)  
* TDB 96 (and to an extent TDP 97) - use the DDB 96 strategy, adjusted to keep kickers with AAA/222/333/444 if available  
  
Additionally, an algorithm is written to return the specific cards that are held for any given set of strategies:  
```{r}

findHolds <- function(idxKeep, myCards=cardSmall) {
    # 1     is keep all 5
    # 2-6   is keep 4 (1234, 1235, 1245, 1345, 2345)
    # 7-16  is keep 3 (123, 124, 125, 134, 135, 145, 234, 235, 245, 345)
    # 17-26 is keep 2 (12, 13, 14, 15, 23, 24, 25, 34, 35, 45)
    # 27-31 is keep 1 (1, 2, 3, 4, 5)
    # 32    is keep 0 ()
    
    storage.mode(myCards) <- "integer"
    
    keepCol <- matrix(data=TRUE, nrow=length(idxKeep), ncol=5)
    
    keepCol[, 1] <- idxKeep %in% c(1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 17, 18, 19, 20, 27)
    keepCol[, 2] <- idxKeep %in% c(1, 2, 3, 4, 6, 7, 8, 9, 13, 14, 15, 17, 21, 22, 23, 28)
    keepCol[, 3] <- idxKeep %in% c(1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 16, 18, 21, 24, 25, 29)
    keepCol[, 4] <- idxKeep %in% c(1, 2, 4, 5, 6, 8, 10, 12, 13, 15, 16, 19, 22, 24, 26, 30)
    keepCol[, 5] <- idxKeep %in% c(1, 3, 4, 5, 6, 9, 11, 12, 14, 15, 16, 20, 23, 25, 26, 31)
    
    myCards[!keepCol] <- NA_integer_
    
    myCards
}

diffHolds <- function(holdA, holdB) {
    holdA[is.na(holdA)] <- -1L
    holdB[is.na(holdB)] <- -1L
    
    deltaHolds <- rowSums(abs(holdA - holdB)) > 0
    
    deltaHolds
}

jb96Holds <- findHolds(idxKeep=jb96List$tempSmallMax[2, ])
bp85Holds <- findHolds(idxKeep=bp85List$tempSmallMax[2, ])
jb85Holds <- findHolds(idxKeep=jb85List$tempSmallMax[2, ])

# Compare JB 96 and BP 85
jb96_vs_bp85Holds <- diffHolds(jb96Holds, bp85Holds)
sum(jb96_vs_bp85Holds)

if (sum(jb96_vs_bp85Holds) > 0) { 
    cbind(cardSmall[jb96_vs_bp85Holds, ], 
          jb96Holds[jb96_vs_bp85Holds, ], 
          bp85Holds[jb96_vs_bp85Holds, ]
          )[sort(sample(1:sum(jb96_vs_bp85Holds), 20)), ]
}


# Compare JB 96 and JB 85
jb96_vs_jb85Holds <- diffHolds(jb96Holds, jb85Holds)
sum(jb96_vs_jb85Holds)

if (sum(jb96_vs_jb85Holds) > 0) { 
    cbind(cardSmall[jb96_vs_jb85Holds, ], 
          jb96Holds[jb96_vs_jb85Holds, ], 
          bp85Holds[jb96_vs_jb85Holds, ]
          )[sort(sample(1:sum(jb96_vs_jb85Holds), 20)), ]
}


# Compare BP 85 and JB 85
bp85_vs_jb85Holds <- diffHolds(bp85Holds, jb85Holds)
sum(bp85_vs_jb85Holds)

if (sum(bp85_vs_jb85Holds) > 0) { 
    cbind(cardSmall[bp85_vs_jb85Holds, ], 
          jb96Holds[bp85_vs_jb85Holds, ], 
          bp85Holds[bp85_vs_jb85Holds, ]
          )[sort(sample(1:sum(bp85_vs_jb85Holds), 20)), ]
}


```
  
