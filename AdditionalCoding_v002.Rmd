---
title: "Additional Coding Examples"
author: "davegoblue"
date: "August 14, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background  
This document explores video poker hands, using <http://wizardofodds.com/games/video-poker/methodology/> as a template, and applying DataCamp_Insights_v001 materials where applicable.  This document builds on the more salient components of the analysis in AdditionalCoding_v001.Rmd.  
  
## Simulations  
### Potential Hand Types  
The card deck will be considered to be 1-52, where 1-13, 14-26, 27-39, and 40-52 shall each be the suits.  Further, the lowest number of each suit shall be considered the Ace, and the highest shall be considered the King.  There are 52c5 (2,598,960) hands applicable to a typical poker game with a 52-card deck.  All of the possible combinations are created and assessed, with caching due to moderate run times:  
```{r, cache=TRUE}
jbHands <- matrix(data=0L, nrow=choose(52, 5), ncol=5)

startTime <- proc.time()
intCtr <- 1
for (i in 1:48) {
    for (j in (i+1):49) {
        for (k in (j+1):50) {
            for (m in (k+1):51) {
                for (n in (m+1):52) {
                               jbHands[intCtr, ] <- c(i, j, k, m, n)
                               intCtr <- intCtr + 1
                }
            }

        }
    }
}
proc.time() - startTime


## Find the flushes
jbFlush <- apply(jbHands, 1, FUN = function(x) { diff(range( (x-1) %/% 13 )) == 0 })

## Find the number of uniques
jbUniques <- apply(jbHands, 1, FUN = function(x) { length(unique(x %% 13)) })

## Find the range, specifically is it exactly 5
foo <- function(x) {
    min( diff(range( (x-1) %% 13 )) , diff(range( (x-2) %% 13 )) )
}
jbRange <- apply(jbHands, 1, FUN = foo)

# Is the maximum number of cards equal to 3 (only for jbUniques %in% c(2, 3))
foo <- function(x) {
    max(table(x %% 13))
}
jbMax <- apply(jbHands[jbUniques %in% c(2, 3), ], 1, FUN=foo)

# Get the totals by card rank
cRank <- matrix(data=0L, nrow=choose(52, 5), ncol=13)
for (intCtr in 1:13) {
    cRank[, intCtr] <- as.integer( rowSums( (jbHands %% 13) == (intCtr %% 13) ) )
}

proc.time() - startTime
```
  
Hand types are then declared, with this portion not cached since 1) it will need further refinement, and 2) it runs quickly (with the exception of the table function, later updated with dplyr/tidyr for speed):  
```{r}
jbType <- rep(-1L, nrow(jbHands))  # Default value is -1

# Manage the pairs - only convert if pair is 1 (Ace) or 11-13 (J, Q, K)
hiPair <- cRank[, 1] == 2 | cRank[, 11] == 2 | cRank[, 12] == 2 | cRank[, 13] == 2
jbType[jbUniques == 4 & hiPair] <- 0

# Manage the straights and flushes, including SF and RF
jbType[jbFlush == FALSE & jbUniques == 5 & jbRange == 4] <- 3  # Straights as 3
jbType[jbFlush == TRUE & jbRange > 4] <- 5  # Flushes as 5

# Declare the straight flush and royal flush
rfVector <- c(1L, 10L, 11L, 12L, 0L)
foo <- function(x) {
    if (sum( x %% 13 == rfVector ) ==5 ) { return(799) }
    else { return(49) }
}
jbType[jbFlush == TRUE & jbRange == 4] <- apply(jbHands[jbFlush == TRUE & jbRange == 4, ], 1, FUN=foo)

# Look at the subset that composes Two Pair, Trips, Full House, and Quads
jbTemp <- jbUniques[jbUniques %in% c(2, 3)]
jbTempValue <- rep(0L, length(jbTemp))

jbTempValue[jbTemp == 3 & jbMax != 3] <- 1  # Two Pair
jbTempValue[jbTemp == 3 & jbMax == 3] <- 2  # Trips
jbTempValue[jbTemp == 2 & jbMax == 3] <- 8  # Full House
jbTempValue[jbTemp == 2 & jbMax != 3] <- 24  # Quads

jbType[jbUniques %in% c(2, 3)] <- jbTempValue


library(dplyr)
library(tidyr)
library(ggplot2)

# Use dplyr and tidyr since they are MUCH faster than table() for the cross-tabs
data.frame(jbType=jbType) %>% group_by(jbType) %>% summarize(count=n())
data.frame(jbType=jbType, jbUniques=jbUniques) %>% 
    group_by(jbType, jbUniques) %>% 
    summarize(count=n()) %>%
    spread(jbUniques, count, fill=0)
data.frame(jbType=jbType, jbRange=jbRange) %>% 
    group_by(jbType, jbRange) %>% 
    summarize(count=n()) %>%
    spread(jbType, count, fill=0)

```
  
Potential refinements will include allowing rank and kickers to impact value of quads (e.g., Bonus or Double Double Bonus).  
  
Sample plots are created using ggplot2 (cached, since they take a while to plot off the large frame):  
```{r, cache=TRUE}
# Practice with ggplot2
library(ggplot2)

graphFrame <- data.frame(jbFlush=as.integer(jbFlush), jbRange=jbRange, 
                         jbType=jbType, jbUniques=jbUniques
                         )

# Bar chart for jbRange x jbUniques
ggplot(graphFrame, aes(x=as.factor(jbRange))) + geom_bar(aes(fill=as.factor(jbUniques)))

# Stacked bar chart for jbRange x jbUniques
ggplot(graphFrame, aes(x=as.factor(jbRange))) + 
    geom_bar(aes(fill=as.factor(jbUniques)), position="fill")

# Bar chart for jbRange x jbUniques, faceted by jbType
ggplot(graphFrame, aes(x=as.factor(jbRange))) + 
    geom_bar(aes(fill=as.factor(jbUniques))) + 
    facet_wrap(~ jbType, ncol=5)

# Stacked bar chart for jbRange x jbUniques, faceted by jbType
ggplot(graphFrame, aes(x=as.factor(jbRange))) + 
    geom_bar(aes(fill=as.factor(jbUniques)), position="fill") + 
    facet_wrap(~ jbType, ncol=5)

```
  
As per the tables, the graphs line up with expectations.  
  
Next, the program takes a stab at implementing the algorithm described by the Wizard of Odds at <http://wizardofodds.com/games/video-poker/methodology/> for vastly reducing run times for a program of this type.  The Wizard recommends an 11-step process, including:  
  
1.  Initialize array 0 (2,598,960) for the result of a single dealt hand with 0 draws, array 1 (270,725 x 16) for a 1-card draw, array 2 (22,100 x 16) for a 2-card draw, array 3 (1,326 x 16) for a 3-card draw, array 4 (52 x 16) for a 4-card draw, and array 5 (1 x 16) for a 5-card draw.  The 16 is for the maximum number of outcomes (e.g., -1 or +799) for the hand, and could be expanded if a game had more than 16 paying types.  
  
2.  Loop through every possible hand (these are the jbHands and jbType in this algorithm), and populate array0, array1, array2, array3, array4, and array5 based on possible permutations of cards held on the draw  
  
First, the 16-hand condition is tested, and the relevant arrays are set up:
```{r}

nrowArray0 <- data.frame(jbType=jbType) %>% 
    group_by(jbType) %>% 
    summarize(ct=n()) %>%
    arrange(jbType)
nrowArray0

if (nrow(nrowArray0) > 16) { 
    stop(paste0("There are too many hand types, cap is 16, this will have: ", nrow(nrowArray0)))
}
print("OK")

# Initialize array1-array5
array1 <- matrix(data=0L, nrow=choose(52, 4), ncol=16)
array2 <- matrix(data=0L, nrow=choose(52, 3), ncol=16)
array3 <- matrix(data=0L, nrow=choose(52, 2), ncol=16)
array4 <- matrix(data=0L, nrow=choose(52, 1), ncol=16)
array5 <- matrix(data=0L, nrow=choose(52, 0), ncol=16)

# Create array0 which will have an index number corresponding to the associated jbType
array0 <- match(jbType, nrowArray0[[1]])

data.frame(array0=array0) %>% 
    group_by(array0) %>%
    summarize(ct=n()) %>%
    arrange(array0)

```
  
One area for exploration is to associate indices to each combination of cards, start with an nCm array as per <http://wizardofvegas.com/forum/questions-and-answers/math/13687-my-methodology-for-video-poker-analysis-article-question/>.  
```{r}
mtxCombin <- matrix(data=0L, nrow=52, ncol=5)
for (intCtr in 1:52) {
    for (intCtr2 in 1:5) {
        # Note that choose() is a guarded function where choose(n, k) returns 0 for k > n
        mtxCombin[intCtr, intCtr2] <- choose(intCtr, intCtr2)
    }
}
```
  
The array can then be used to convert any 2 cards to an index, as follows:  
```{r}
idxCard2 <- function(c1, c2) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    1 + mtxCombin[52, 2] - mtxCombin[53-c1, 2] +
        mtxCombin[52-c1, 1] - mtxCombin[53-c2, 1]
}

# Test the index creation process
mtxA <- matrix(data=0L, nrow=choose(52, 2), ncol=3)
curRow <- 1
for (intCtr in 1:51) {
    for (intCtr2 in (intCtr+1):52) {
        mtxA[curRow, 1:3] <- c(intCtr, intCtr2, idxCard2(c1=intCtr, c2=intCtr2))
        curRow <- curRow + 1
    }
}

# Make sure it worked OK!
head(mtxA)
tail(mtxA)
length(mtxA[, 3]) == length(unique(mtxA[, 3]))
range(mtxA[, 3]) == c(1, choose(52, 2))
```
  
The array can also be used to convert any 3 cards to an index, as follows:  
```{r}
idxCard3 <- function(c1, c2, c3) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    1 + mtxCombin[52, 3] - mtxCombin[53-c1, 3] +
        mtxCombin[52-c1, 2] - mtxCombin[53-c2, 2] +
        mtxCombin[52-c2, 1] - mtxCombin[53-c3, 1]
}

# Test the index creation process
mtxA <- matrix(data=0L, nrow=choose(52, 3), ncol=4)
curRow <- 1
for (intCtr in 1:50) {
    for (intCtr2 in (intCtr+1):51) {
        for (intCtr3 in (intCtr2+1):52) {
            mtxA[curRow, 1:4] <- c(intCtr, intCtr2, intCtr3, 
                                   idxCard3(c1=intCtr, c2=intCtr2, c3=intCtr3)
                                   )
            curRow <- curRow + 1
        }
    }
}

# Make sure it worked OK!
head(mtxA)
tail(mtxA)
length(mtxA[, 4]) == length(unique(mtxA[, 4]))
range(mtxA[, 4]) == c(1, choose(52, 3))
```
  
And, the same algorithm can be used for 4 cards, an area which should save substantial time:  
```{r}
idxCard4 <- function(c1, c2, c3, c4) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    1 + mtxCombin[52, 4] - mtxCombin[53-c1, 4] +
        mtxCombin[52-c1, 3] - mtxCombin[53-c2, 3] +
        mtxCombin[52-c2, 2] - mtxCombin[53-c3, 2] + 
        mtxCombin[52-c3, 1] - mtxCombin[53-c4, 1]
}

# Test the index creation process
mtxA <- matrix(data=0L, nrow=choose(52, 4), ncol=5)
curRow <- 1
for (intCtr in 1:49) {
    for (intCtr2 in (intCtr+1):50) {
        for (intCtr3 in (intCtr2+1):51) {
            for (intCtr4 in (intCtr3+1):52) {
                mtxA[curRow, 1:5] <- c(intCtr, intCtr2, intCtr3, intCtr4, 
                                       idxCard4(c1=intCtr, c2=intCtr2, c3=intCtr3, c4=intCtr4)
                                       )
                curRow <- curRow + 1
            }
        }
    }
}

# Make sure it worked OK!
head(mtxA)
tail(mtxA)
length(mtxA[, 5]) == length(unique(mtxA[, 5]))
range(mtxA[, 5]) == c(1, choose(52, 4))
```
  
These functions should simplify and speed-up the conversion of any given 5-card hand to a score if it is instead held as a 0-4 card hand.  

The algorithms are then tested against jbHands (the 2,598,960 x 5 data frame representing all possible hands) and its associated array0 (the 2,598,960 x 1 integer vector representing the hand value as a 1-10).  
```{r}

# The array for keeping everything (jbHands as 2,598,960 x 5 for the cards, 
# and array0 as 2,598,960 x 1 for the outcomes) is already populated
startTime <- proc.time()

dim(jbHands)
length(array0)
data.frame(array0=array0) %>% 
    group_by(array0) %>% 
    summarize(ct=n()) %>% 
    arrange(-array0)

proc.time() - startTime


# Fill the array (array5 as 1 x 16) for keeping nothing
startTime <- proc.time()

a <- data.frame(val=array0) %>% group_by(val) %>% 
    summarize(ct=n()) %>% arrange(val)

for ( intCtr in seq_along(unique(a$val)) ) {
    array5[1, intCtr] <- a$ct[a$val == intCtr]
}

proc.time() - startTime


# Test keeping a single card, and fill the array (array4 as 52 x 16) for keeping 1
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
for (c1 in 1:5) {
    temp <- data.frame(card1=jbHands[, c1], val=array0) %>% 
        group_by(card1, val) %>%
        summarize(ct=n()) %>%
        arrange(card1, val)
    
    temp$idx <- temp$card1
    
    idx <- c(idx, temp$idx)
    val <- c(val, temp$val)
    ct <- c(ct, temp$ct)
    
}

a <- data.frame(idx=idx, val=val, ct=ct) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct))

for ( intCtr in seq_along(unique(a$val)) ) {
    array4[a$idx[a$val == intCtr], intCtr] <- a$ct[a$val == intCtr]
}

proc.time() - startTime


# Test keeping two cards, and fill the array (array3 as 1,326 x 16) for keeping two cards
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
for (c1 in 1:4) {
    for (c2 in (c1+1):5) {
        temp <- data.frame(card1=jbHands[, c1], card2=jbHands[, c2], val=array0) %>% 
            group_by(card1, card2, val) %>%
            summarize(ct=n()) %>%
            arrange(card1, card2, val)
    
        temp$idx <- idxCard2(c1=temp$card1, c2=temp$card2)
    
        idx <- c(idx, temp$idx)
        val <- c(val, temp$val)
        ct <- c(ct, temp$ct)
    
    }
}

a <- data.frame(idx=idx, val=val, ct=ct) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct))

for ( intCtr in seq_along(unique(a$val)) ) {
    array3[a$idx[a$val == intCtr], intCtr] <- a$ct[a$val == intCtr]
}

proc.time() - startTime


# Test keeping three cards, and fill the array (array2 as 22,100 x 16) for keeping three cards
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
for (c1 in 1:3) {
    for (c2 in (c1+1):4) {
        for (c3 in (c2+1):5) {
            temp <- data.frame(card1=jbHands[, c1], card2=jbHands[, c2], 
                               card3=jbHands[, c3], val=array0
                               ) %>% 
                group_by(card1, card2, card3, val) %>%
                summarize(ct=n()) %>%
                arrange(card1, card2, card3, val)
    
            temp$idx <- idxCard3(c1=temp$card1, c2=temp$card2, c3=temp$card3)
    
            idx <- c(idx, temp$idx)
            val <- c(val, temp$val)
            ct <- c(ct, temp$ct)
    
        }
    }
}

a <- data.frame(idx=idx, val=val, ct=ct) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct))

for ( intCtr in seq_along(unique(a$val)) ) {
    array2[a$idx[a$val == intCtr], intCtr] <- a$ct[a$val == intCtr]
}

proc.time() - startTime


# Test keeping four cards, and fill the array (array1 as 270,725 x 16) for keeping four cards
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
for (c1 in 1:2) {
    for (c2 in (c1+1):3) {
        for (c3 in (c2+1):4) {
            for (c4 in (c3+1):5) {
                temp <- data.frame(card1=jbHands[, c1], card2=jbHands[, c2], 
                                   card3=jbHands[, c3], card4=jbHands[, c4], 
                                   val=array0
                                   ) %>% 
                    group_by(card1, card2, card3, card4, val) %>%
                    summarize(ct=n()) %>%
                    arrange(card1, card2, card3, card4, val)
    
                temp$idx <- idxCard4(c1=temp$card1, c2=temp$card2, 
                                     c3=temp$card3, c4=temp$card4
                                     )
    
                idx <- c(idx, temp$idx)
                val <- c(val, temp$val)
                ct <- c(ct, temp$ct)
            
            }
        }
    }
}

a <- data.frame(idx=idx, val=val, ct=ct) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct))

for ( intCtr in seq_along(unique(a$val)) ) {
    array1[a$idx[a$val == intCtr], intCtr] <- a$ct[a$val == intCtr]
}

proc.time() - startTime

```
  
While this is still running an order of magnitude slower than the Wizard of Odds methodology, it is encouraging that the "order of magnitude" is 30 seconds vs. 3 seconds.  There may be room for further streamlining, but the code appears to be functional and with a reasonable run-time for next steps.
  
The dimensions and counts of the various arrays are then confirmed:  
```{r}
# The actual arrays (array1-array5)
sapply(list(array5=array5, array4=array4, array3=array3, array2=array2, array1=array1), 
       FUN=function(x) {c(sum(x)/choose(52, 5), sum(rowSums(x) > 0), sum(colSums(x) > 0)) } 
       )

# The original array
length(array0)/choose(52, 5)
nrow(jbHands)
length(unique(array0))
```
  
The arrays are all of the proper dimensions and counts.  Next, a process is built to look at a subset of hands and to evaluate each of the potential options assuming cards CAN be replaced (the next step will be to reverse this assumption):  
```{r}
set.seed(1609010715)

# Take a smaller sample of the hands
# keyHands <- sort(sample(nrow(jbHands), 400000, replace=FALSE))
keyHands <- 1:nrow(jbHands)
jbSmall <- jbHands[keyHands, ]


startTime <- proc.time()

# Convert each of the arrays to a value
mapArray <- matrix(data=c(-1, 0, 1, 2, 3, 5, 8, 24, 49, 799, 0, 0, 0, 0, 0, 0), ncol=1)
dim(mapArray)

expVal5 <- (array5 %*% mapArray) / choose(52, 5)
expVal4 <- (array4 %*% mapArray) / choose(51, 4)
expVal3 <- (array3 %*% mapArray) / choose(50, 3)
expVal2 <- (array2 %*% mapArray) / choose(49, 2)
expVal1 <- (array1 %*% mapArray) / choose(48, 1)
expVal0 <- matrix(data=mapArray[array0, 1], ncol=1)

# Evaluate all the draw-0 options
draw0 <- matrix(data=expVal0[keyHands, ], ncol=1)

# Evaluate all the draw-5 options
draw5 <- matrix(data=expVal5, nrow=nrow(jbSmall), ncol=1)

# Evaluate all the draw-4 options
keyData <- integer(0)
for (intCtr in 1:5) {
    keyData <- c(keyData, expVal4[jbSmall[, intCtr], 1, drop=TRUE])
}
draw4 <- matrix(data=keyData, ncol=5, byrow=FALSE)

# Evaluate all the draw-3 options
keyData <- integer(0)
for (intCtr in 1:4) {
    for (intCtr2 in (intCtr+1):5) {
        keyData <- c(keyData, 
                     expVal3[idxCard2( c1=jbSmall[ , intCtr], c2=jbSmall[ , intCtr2] ), 
                             1, drop=TRUE]
                     )
    }
}
draw3 <- matrix(data=keyData, ncol=10, byrow=FALSE)

# Evaluate all the draw-2 options
keyData <- integer(0)
for (intCtr in 1:3) {
    for (intCtr2 in (intCtr+1):4) {
        for (intCtr3 in (intCtr2+1):5) {
            keyData <- c(keyData, 
                         expVal2[idxCard3( c1=jbSmall[, intCtr], c2=jbSmall[, intCtr2] ,
                                           c3=jbSmall[, intCtr3]
                                          ), 1, drop=TRUE]
                         )
        }
    }
}
draw2 <- matrix(data=keyData, ncol=10, byrow=FALSE)

# Evaluate all the draw-1 options
keyData <- integer(0)
for (intCtr in 1:2) {
    for (intCtr2 in (intCtr+1):3) {
        for (intCtr3 in (intCtr2+1):4) {
            for (intCtr4 in (intCtr3+1):5) {
                keyData <- c(keyData, 
                             expVal1[idxCard4( c1=jbSmall[, intCtr], c2=jbSmall[, intCtr2] ,
                                               c3=jbSmall[, intCtr3], c4=jbSmall[, intCtr4]
                                              ), 1, drop=TRUE]
                            )
            }
        }
    }
}
draw1 <- matrix(data=keyData, ncol=5, byrow=FALSE)

# Integrate the drawing summaries
cmbDraw <- cbind(draw0, draw1, draw2, draw3, draw4, draw5)

# Assess the best option by row
cmbBestIdx <- apply(cmbDraw, 1, FUN=which.max)
hist(cmbBestIdx, breaks=0:33, col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
                                     rep("lightgreen", 10), rep("red", 5), rep("black", 1) ) )


# Assess the best value by row
cmbBestVal <- apply(cmbDraw, 1, FUN=max)
summary(cmbBestVal)


proc.time() - startTime

```
  
While still an order of magnitude slower than the reference code, this runs through all the options in 30 seconds.  
  
Next, the draw-one situation is assessed assuming that you do NOT sample with replacement, which is to say that you will never get back the card you discarded on the redraw:  
```{r}

# Evaluate all the draw-1 options
keyData <- integer(0)
for (intCtr in 1:2) {
    for (intCtr2 in (intCtr+1):3) {
        for (intCtr3 in (intCtr2+1):4) {
            for (intCtr4 in (intCtr3+1):5) {
                newEV <- expVal1[idxCard4( c1=jbSmall[, intCtr], c2=jbSmall[, intCtr2] ,
                                               c3=jbSmall[, intCtr3], c4=jbSmall[, intCtr4]
                                           ), 1, drop=TRUE]
                newEV <- (48 * newEV - expVal0[, 1, drop=TRUE]) / 47
                str(newEV)
                keyData <- c(keyData, newEV)
            }
        }
    }
}
newDraw1 <- matrix(data=keyData, ncol=5, byrow=FALSE)


# Assess the best option by row
newBestIdx <- apply(cbind(cmbDraw[, 1, drop=FALSE], newDraw1, cmbDraw[, 7:32]), 1, FUN=which.max)
hist(newBestIdx, breaks=0:33, col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
                                     rep("lightgreen", 10), rep("red", 5), rep("black", 1) ) )

# Assess the best value by row
newBestVal <- apply(cbind(cmbDraw[, 1, drop=FALSE], newDraw1, cmbDraw[, 7:32]), 1, FUN=max)
summary(newBestVal)

# Summarize the changes in index
sum(newBestIdx != cmbBestIdx)
data.frame(oldIdx=cmbBestIdx, newIdx=newBestIdx) %>% 
    group_by(oldIdx, newIdx) %>% summarize(ct=n()) %>% 
    ggplot(aes(x=oldIdx, y=newIdx)) + geom_point(aes(size=ct), col="blue")

# Summarize the changes in value
sum(newBestVal != cmbBestVal)
sum(newBestVal > cmbBestVal)
sum(newBestVal < cmbBestVal)

hist((newBestVal - cmbBestVal)[newBestVal != cmbBestVal], col="lightblue")
temp <- data.frame(newIdx=newBestIdx, newVal=newBestVal, oldVal=cmbBestVal) %>%
        mutate(deltaVal = ((newVal - oldVal) != 0), changeVal=(newVal - oldVal)) %>% 
        group_by(newIdx) %>% 
        summarize(nHands=n(), nChg=sum(deltaVal), totChg=sum(changeVal), 
                  maxChg=max(changeVal), minChg=min(changeVal), meanChg=mean(changeVal)
                  )
print(as.data.frame(temp))
```
  
The results are as expected, including:  
  
* Some hands that previously had an optimal play other than draw 1 now fall under draw 1  
* All hands that now optimize as draw1 have a positively changed EV, averaging in the 1%-2% range  
  
Next, the draw-two situation is assessed assuming that you do NOT sample with replacement, which is to say that you will never get back either of the cards you discarded on the redraw.  Essentially, this requires deleting the EV of each of the 4-card combinations, then adding back the EV of the 5-card combination (which is double-deleted, once in each of the 4-card deletions):  
```{r}
keyData <- integer(0)
for (intCtr in 1:3) {
    for (intCtr2 in (intCtr+1):4) {
        for (intCtr3 in (intCtr2+1):5) {
            
            basEV <- expVal2[idxCard3( c1=jbSmall[, intCtr], c2=jbSmall[, intCtr2] , 
                                       c3=jbSmall[, intCtr3]
                                       ), 1, drop=TRUE]
            
            keyA <- (1:5)[-c(intCtr, intCtr2, intCtr3)][1]
            keyB <- (1:5)[-c(intCtr, intCtr2, intCtr3)][2]
            
            sortA <- sort(c(intCtr, intCtr2, intCtr3, keyA))
            sortB <- sort(c(intCtr, intCtr2, intCtr3, keyB))
            
            expA <- expVal1[idxCard4( c1=jbSmall[, sortA[1]], c2=jbSmall[, sortA[2]], 
                                      c3=jbSmall[, sortA[3]], c4=jbSmall[, sortA[4]]
                                      ), 1, drop=TRUE]
            
            expB <- expVal1[idxCard4( c1=jbSmall[, sortB[1]], c2=jbSmall[, sortB[2]], 
                                      c3=jbSmall[, sortB[3]], c4=jbSmall[, sortB[4]]
                                      ), 1, drop=TRUE]
            
            str(basEV)
            str(expA)
            str(expB)
            
            newEV <- (1176 * basEV - 48 * expA - 48 * expB + expVal0[, 1, drop=TRUE]) / 1081
            str(newEV)
            
            keyData <- c(keyData, newEV)
        }
    }
}
newDraw2 <- matrix(data=keyData, ncol=10, byrow=FALSE)

# Assess the best option by row (adding in only the changed 2-card draws, not the 1-card from above)
newBestIdx <- apply(cbind(cmbDraw[, 1:6, drop=FALSE], newDraw2, cmbDraw[, 17:32]), 1, FUN=which.max)
hist(newBestIdx, breaks=0:33, col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
                                     rep("lightgreen", 10), rep("red", 5), rep("black", 1) ) )

# Assess the best value by row (adding in only the changed 2-card draws)
newBestVal <- apply(cbind(cmbDraw[, 1:6, drop=FALSE], newDraw2, cmbDraw[, 17:32]), 1, FUN=max)
summary(newBestVal)

# Summarize the changes in index
sum(newBestIdx != cmbBestIdx)
data.frame(oldIdx=cmbBestIdx, newIdx=newBestIdx) %>% 
    group_by(oldIdx, newIdx) %>% summarize(ct=n()) %>% 
    ggplot(aes(x=oldIdx, y=newIdx)) + geom_point(aes(size=ct), col="blue")

# Summarize the changes in value
sum(newBestVal != cmbBestVal)
sum(newBestVal > cmbBestVal)
sum(newBestVal < cmbBestVal)

hist((newBestVal - cmbBestVal)[newBestVal != cmbBestVal], col="lightblue")
temp <- data.frame(newIdx=newBestIdx, newVal=newBestVal, oldVal=cmbBestVal) %>%
        mutate(deltaVal = ((newVal - oldVal) != 0), changeVal=(newVal - oldVal)) %>% 
        group_by(newIdx) %>% 
        summarize(nHands=n(), nChg=sum(deltaVal), totChg=sum(changeVal), 
                  maxChg=max(changeVal), minChg=min(changeVal), meanChg=mean(changeVal)
                  )
print(as.data.frame(temp))

```

The results are as expected, including:  
  
* Some hands that previously had an optimal play other than draw 2 now fall under draw 2  
* All hands that now optimize as draw-2 have a positively changed EV, averaging a gain of ~3%  
  
Next, the combined draw-1 and draw-2 universe is assessed, leaving the more common (draw-3, draw-4, and draw-5) hands still to be optimized:  
```{r}
# Assess the best option by row (adding the changed 2-card and 1-card draws)
newBestIdx <- apply(cbind(cmbDraw[, 1, drop=FALSE], newDraw1, newDraw2, cmbDraw[, 17:32]), 
                    1, FUN=which.max
                    )
hist(newBestIdx, breaks=0:33, col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
                                     rep("lightgreen", 10), rep("red", 5), rep("black", 1) ) )

# Assess the best value by row (adding in only the changed 2-card draws)
newBestVal <- apply(cbind(cmbDraw[, 1, drop=FALSE], newDraw1, newDraw2, cmbDraw[, 17:32]),
                    1, FUN=max
                    )
summary(newBestVal)

# Summarize the changes in index
sum(newBestIdx != cmbBestIdx)
data.frame(oldIdx=cmbBestIdx, newIdx=newBestIdx) %>% 
    group_by(oldIdx, newIdx) %>% summarize(ct=n()) %>% 
    ggplot(aes(x=oldIdx, y=newIdx)) + geom_point(aes(size=ct), col="blue")

# Summarize the changes in value
sum(newBestVal != cmbBestVal)
sum(newBestVal > cmbBestVal)
sum(newBestVal < cmbBestVal)

hist((newBestVal - cmbBestVal)[newBestVal != cmbBestVal], col="lightblue")
temp <- data.frame(newIdx=newBestIdx, newVal=newBestVal, oldVal=cmbBestVal) %>%
        mutate(deltaVal = ((newVal - oldVal) != 0), changeVal=(newVal - oldVal)) %>% 
        group_by(newIdx) %>% 
        summarize(nHands=n(), nChg=sum(deltaVal), totChg=sum(changeVal), 
                  maxChg=max(changeVal), minChg=min(changeVal), meanChg=mean(changeVal)
                  )
print(as.data.frame(temp))

# Assess changes from/to group
newCutIdx <- cut(newBestIdx, breaks=c(0.5, 1.5, 6.5, 16.5, 26.5, 31.5, 32.5))
cmbCutIdx <- cut(cmbBestIdx, breaks=c(0.5, 1.5, 6.5, 16.5, 26.5, 31.5, 32.5))
data.frame(oldType=cmbCutIdx, newType=newCutIdx) %>% 
    group_by(oldType, newType) %>% summarize(ct=n())

chkType <- which(newBestIdx %in% c(7:16) & cmbBestIdx %in% c(2:6))
set.seed(1609040727)
chkHands <- sort(sample(chkType, 20, replace=FALSE))
jbHands[chkHands, ]
cbind(1 + (jbHands[chkHands, ] - 1) %% 13, 
      1 + (jbHands[chkHands, ] - 1) %/% 13
      )
cbind(cmbBestIdx[chkHands], newBestIdx[chkHands], cmbBestVal[chkHands], newBestVal[chkHands])
```
  
The changes from draw-4 to draw-3 appear to be close calls between a specific sub-type of 3-RF (A, K/Q/J, T) and 4-FL, with 3-RF being helped by not seeing the flush card reappear on the river.  
  
Next, the draw-3 (keep-2) scenarios are assessed assuming no replacement:  
```{r}
keyData <- integer(0)
for (intCtr in 1:4) {
    for (intCtr2 in (intCtr+1):5) {
            
        basEV <- expVal3[idxCard2( c1=jbSmall[, intCtr], c2=jbSmall[, intCtr2] ), 1, drop=TRUE]
            
        keyA <- (1:5)[-c(intCtr, intCtr2)][1]
        keyB <- (1:5)[-c(intCtr, intCtr2)][2]
        keyC <- (1:5)[-c(intCtr, intCtr2)][3]
        keyAB <- (1:5)[-c(intCtr, intCtr2)][c(1, 2)]
        keyAC <- (1:5)[-c(intCtr, intCtr2)][c(1, 3)]
        keyBC <- (1:5)[-c(intCtr, intCtr2)][c(2, 3)]
            
        sortA <- sort(c(intCtr, intCtr2, keyA))
        sortB <- sort(c(intCtr, intCtr2, keyB))
        sortC <- sort(c(intCtr, intCtr2, keyC))
        sortAB <- sort(c(intCtr, intCtr2, keyAB))
        sortAC <- sort(c(intCtr, intCtr2, keyAC))
        sortBC <- sort(c(intCtr, intCtr2, keyBC))
        
        # Manage the 4-carders
        expAB <- expVal1[idxCard4( c1=jbSmall[, sortAB[1]], c2=jbSmall[, sortAB[2]], 
                                   c3=jbSmall[, sortAB[3]], c4=jbSmall[, sortAB[4]]
                                  ), 1, drop=TRUE]
            
        expAC <- expVal1[idxCard4( c1=jbSmall[, sortAC[1]], c2=jbSmall[, sortAC[2]], 
                                   c3=jbSmall[, sortAC[3]], c4=jbSmall[, sortAC[4]]
                                  ), 1, drop=TRUE]
        
        expBC <- expVal1[idxCard4( c1=jbSmall[, sortBC[1]], c2=jbSmall[, sortBC[2]], 
                                   c3=jbSmall[, sortBC[3]], c4=jbSmall[, sortBC[4]]
                                  ), 1, drop=TRUE]
        
        # Manage the 3-carders
        expA <- expVal2[idxCard3( c1=jbSmall[, sortA[1]], c2=jbSmall[, sortA[2]], 
                                  c3=jbSmall[, sortA[3]]
                                 ), 1, drop=TRUE]
        
        expB <- expVal2[idxCard3( c1=jbSmall[, sortB[1]], c2=jbSmall[, sortB[2]], 
                                  c3=jbSmall[, sortB[3]]
                                 ), 1, drop=TRUE]
        
        expC <- expVal2[idxCard3( c1=jbSmall[, sortC[1]], c2=jbSmall[, sortC[2]], 
                                  c3=jbSmall[, sortC[3]]
                                 ), 1, drop=TRUE]
        
        # Original minus relevant 3-cards plus relevant 4-cards minus relevant 5-card
        newEV <- (choose(50, 3) * basEV - 
                      choose(49, 2) * (expA + expB + expC) +
                      choose(48, 1) * (expAB + expAC + expBC) - 
                      expVal0[, 1, drop=TRUE]
                  ) / choose(47, 3)
        str(newEV)
            
        keyData <- c(keyData, newEV)

    }
}
newDraw3 <- matrix(data=keyData, ncol=10, byrow=FALSE)

# Assess the best option by row (adding in only the changed 3-card draws, not the 1/2-card from above)
newBestIdx <- apply(cbind(cmbDraw[, 1:16, drop=FALSE], newDraw3, cmbDraw[, 27:32]), 1, FUN=which.max)
hist(newBestIdx, breaks=0:33, col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
                                     rep("lightgreen", 10), rep("red", 5), rep("black", 1) ) )

# Assess the best value by row (adding in only the changed 3-card draws)
newBestVal <- apply(cbind(cmbDraw[, 1:16, drop=FALSE], newDraw3, cmbDraw[, 27:32]), 1, FUN=max)
summary(newBestVal)

# Summarize the changes in index
sum(newBestIdx != cmbBestIdx)
data.frame(oldIdx=cmbBestIdx, newIdx=newBestIdx) %>% 
    group_by(oldIdx, newIdx) %>% summarize(ct=n()) %>% 
    ggplot(aes(x=oldIdx, y=newIdx)) + geom_point(aes(size=ct), col="blue")

# Summarize the changes in value
sum(newBestVal != cmbBestVal)
sum(newBestVal > cmbBestVal)
sum(newBestVal < cmbBestVal)

hist((newBestVal - cmbBestVal)[newBestVal != cmbBestVal], col="lightblue")
temp <- data.frame(newIdx=newBestIdx, newVal=newBestVal, oldVal=cmbBestVal) %>%
        mutate(deltaVal = ((newVal - oldVal) != 0), changeVal=(newVal - oldVal)) %>% 
        group_by(newIdx) %>% 
        summarize(nHands=n(), nChg=sum(deltaVal), totChg=sum(changeVal), 
                  maxChg=max(changeVal), minChg=min(changeVal), meanChg=mean(changeVal)
                  )
print(as.data.frame(temp))

```
  
The big EV change takes place here, as pairs becomes much more valuable (more chances to convert to trips/quads when not getting back the discards).  Pairs are common in a random 5-card hand.  The average 2-card hold improves by 2%-3% with the "no replacement" methodology, and many hands are now optimally a 2-card hold.
  
Next, the combined draw-1, draw-2, and draw-3 universe is assessed, leaving the somewhat rarer (draw-4, and draw-5) hands still to be optimized:  
```{r}
# Assess the best option by row (adding the changed 3-card and 2-card and 1-card draws)
newBestIdx <- apply(cbind(cmbDraw[, 1, drop=FALSE], newDraw1, newDraw2, 
                          newDraw3, cmbDraw[, 27:32]
                          ), 1, FUN=which.max
                    )
hist(newBestIdx, breaks=0:33, col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
                                     rep("lightgreen", 10), rep("red", 5), rep("black", 1) ) )

# Assess the best value by row (adding the changed 3-card and 2-card and 1-card draws)
newBestVal <- apply(cbind(cmbDraw[, 1, drop=FALSE], newDraw1, newDraw2, 
                          newDraw3, cmbDraw[, 27:32]
                          ), 1, FUN=max
                    )
summary(newBestVal)

# Summarize the changes in index
sum(newBestIdx != cmbBestIdx)
data.frame(oldIdx=cmbBestIdx, newIdx=newBestIdx) %>% 
    group_by(oldIdx, newIdx) %>% summarize(ct=n()) %>% 
    ggplot(aes(x=oldIdx, y=newIdx)) + geom_point(aes(size=ct), col="blue")

# Summarize the changes in value
sum(newBestVal != cmbBestVal)
sum(newBestVal > cmbBestVal)
sum(newBestVal < cmbBestVal)

hist((newBestVal - cmbBestVal)[newBestVal != cmbBestVal], col="lightblue")
temp <- data.frame(newIdx=newBestIdx, newVal=newBestVal, oldVal=cmbBestVal) %>%
        mutate(deltaVal = ((newVal - oldVal) != 0), changeVal=(newVal - oldVal)) %>% 
        group_by(newIdx) %>% 
        summarize(nHands=n(), nChg=sum(deltaVal), totChg=sum(changeVal), 
                  maxChg=max(changeVal), minChg=min(changeVal), meanChg=mean(changeVal)
                  )
print(as.data.frame(temp))

# Assess changes from/to group
newCutIdx <- cut(newBestIdx, breaks=c(0.5, 1.5, 6.5, 16.5, 26.5, 31.5, 32.5))
cmbCutIdx <- cut(cmbBestIdx, breaks=c(0.5, 1.5, 6.5, 16.5, 26.5, 31.5, 32.5))
data.frame(oldType=cmbCutIdx, newType=newCutIdx) %>% 
    group_by(oldType, newType) %>% summarize(ct=n())

# Assess sampling of hands
chkType <- which(newBestIdx %in% c(17:26) & cmbBestIdx %in% c(2:6))
set.seed(1609060714)
chkHands <- sort(sample(chkType, 20, replace=FALSE))
jbHands[chkHands, ]
cbind(1 + (jbHands[chkHands, ] - 1) %% 13, 
      1 + (jbHands[chkHands, ] - 1) %/% 13
      )
cbind(cmbBestIdx[chkHands], newBestIdx[chkHands], cmbBestVal[chkHands], newBestVal[chkHands])
```

The game now shows an EV approaching ~99%, close to the known EV of just over ~99.5%.  Time will tell if there are bugs to fix or if forcing "no replacement" on the draw-4 and draw-5 hands will drive convergence.  Of some interest, any hand that was draw-2 or draw-3 with replacement remains that way without replacement.  But, a handful of draw-1 hands become draw-2 hands or even draw-3 hands, as follows:  
  
* The 2,400 hands (samples taken previously) change from a 4-FL draw to a 3-RF draw based on the no replacement rule.  These include the following subsets:  
    * Hands that contain suited A (always), K/Q/J (one of), T (always), and 2-9 (one of), with a non-suited case card of rank 2-9.  There are 4 suits * 3 K/Q/J * 8 options of same-suit 2-9 * 24 options for a low card in another suit.  This creates 2,304 hand types.  
    * Hands that contain 3-SF that also includes enough high cards to go for a 1-gap straight draw (need to verify)  
* The 756 hands that change from an AKQJ draw to a QJs draw based on the no replacement rule.  
  
Next, the draw-4 hands are recalculated using the "no replacement" rule:  
```{r}
keyData <- integer(0)
for (intCtr in 1:5) {
            
    basEV <- expVal4[jbSmall[, intCtr], 1, drop=TRUE]
            
    keyA <- (1:5)[-c(intCtr)][1]
    keyB <- (1:5)[-c(intCtr)][2]
    keyC <- (1:5)[-c(intCtr)][3]
    keyD <- (1:5)[-c(intCtr)][4]
    keyAB <- (1:5)[-c(intCtr)][c(1, 2)]
    keyAC <- (1:5)[-c(intCtr)][c(1, 3)]
    keyAD <- (1:5)[-c(intCtr)][c(1, 4)]
    keyBC <- (1:5)[-c(intCtr)][c(2, 3)]
    keyBD <- (1:5)[-c(intCtr)][c(2, 4)]
    keyCD <- (1:5)[-c(intCtr)][c(3, 4)]
    keyABC <- (1:5)[-c(intCtr)][c(1, 2, 3)]
    keyABD <- (1:5)[-c(intCtr)][c(1, 2, 4)]
    keyACD <- (1:5)[-c(intCtr)][c(1, 3, 4)]
    keyBCD <- (1:5)[-c(intCtr)][c(2, 3, 4)]
        
    sortA <- sort(c(intCtr, keyA))
    sortB <- sort(c(intCtr, keyB))
    sortC <- sort(c(intCtr, keyC))
    sortD <- sort(c(intCtr, keyD))
    sortAB <- sort(c(intCtr, keyAB))
    sortAC <- sort(c(intCtr, keyAC))
    sortAD <- sort(c(intCtr, keyAD))
    sortBC <- sort(c(intCtr, keyBC))
    sortBD <- sort(c(intCtr, keyBD))
    sortCD <- sort(c(intCtr, keyCD))
    sortABC <- sort(c(intCtr, keyABC))
    sortABD <- sort(c(intCtr, keyABD))
    sortACD <- sort(c(intCtr, keyACD))
    sortBCD <- sort(c(intCtr, keyBCD))
    
    # Manage the 4-carders
    expABC <- expVal1[idxCard4( c1=jbSmall[, sortABC[1]], c2=jbSmall[, sortABC[2]], 
                                c3=jbSmall[, sortABC[3]], c4=jbSmall[, sortABC[4]]
                                ), 1, drop=TRUE]
    
    expABD <- expVal1[idxCard4( c1=jbSmall[, sortABD[1]], c2=jbSmall[, sortABD[2]], 
                                c3=jbSmall[, sortABD[3]], c4=jbSmall[, sortABD[4]]
                                ), 1, drop=TRUE]
    
    expACD <- expVal1[idxCard4( c1=jbSmall[, sortACD[1]], c2=jbSmall[, sortACD[2]], 
                                c3=jbSmall[, sortACD[3]], c4=jbSmall[, sortACD[4]]
                                ), 1, drop=TRUE]
    
    expBCD <- expVal1[idxCard4( c1=jbSmall[, sortBCD[1]], c2=jbSmall[, sortBCD[2]], 
                                c3=jbSmall[, sortBCD[3]], c4=jbSmall[, sortBCD[4]]
                                ), 1, drop=TRUE]
    
    # Manage the 3-carders
    expAB <- expVal2[idxCard3( c1=jbSmall[, sortAB[1]], c2=jbSmall[, sortAB[2]], 
                               c3=jbSmall[, sortAB[3]]
                              ), 1, drop=TRUE]
    
    expAC <- expVal2[idxCard3( c1=jbSmall[, sortAC[1]], c2=jbSmall[, sortAC[2]], 
                               c3=jbSmall[, sortAC[3]]
                              ), 1, drop=TRUE]
    
    expAD <- expVal2[idxCard3( c1=jbSmall[, sortAD[1]], c2=jbSmall[, sortAD[2]], 
                               c3=jbSmall[, sortAD[3]]
                              ), 1, drop=TRUE]
    
    expBC <- expVal2[idxCard3( c1=jbSmall[, sortBC[1]], c2=jbSmall[, sortBC[2]], 
                               c3=jbSmall[, sortBC[3]]
                              ), 1, drop=TRUE]
    
    expBD <- expVal2[idxCard3( c1=jbSmall[, sortBD[1]], c2=jbSmall[, sortBD[2]], 
                               c3=jbSmall[, sortBD[3]]
                              ), 1, drop=TRUE]
    
    expCD <- expVal2[idxCard3( c1=jbSmall[, sortCD[1]], c2=jbSmall[, sortCD[2]], 
                               c3=jbSmall[, sortCD[3]]
                              ), 1, drop=TRUE]
        
    # Manage the 2-carders
    expA <- expVal3[idxCard2( c1=jbSmall[, sortA[1]], c2=jbSmall[, sortA[2]]
                             ), 1, drop=TRUE]
    
    expB <- expVal3[idxCard2( c1=jbSmall[, sortB[1]], c2=jbSmall[, sortB[2]]
                             ), 1, drop=TRUE]
    
    expC <- expVal3[idxCard2( c1=jbSmall[, sortC[1]], c2=jbSmall[, sortC[2]]
                             ), 1, drop=TRUE]
    
    expD <- expVal3[idxCard2( c1=jbSmall[, sortD[1]], c2=jbSmall[, sortD[2]]
                             ), 1, drop=TRUE]
    
    # Original minus relevant 2-cards plus relevant 3-cards minus relevant 4-cards plus 5-card
    newEV <- (choose(51, 4) * basEV - 
                  choose(50, 3) * (expA + expB + expC + expD) +
                  choose(49, 2) * (expAB + expAC + expAD + expBC + expBD + expCD) - 
                  choose(48, 1) * (expABC + expABD + expACD + expBCD) +
                  expVal0[, 1, drop=TRUE]
              ) / choose(47, 4)
    str(newEV)
            
    keyData <- c(keyData, newEV)

}
newDraw4 <- matrix(data=keyData, ncol=5, byrow=FALSE)

# Assess the best option by row (adding in only the changed 4-card draws, not the 1/2/3-card from above)
newBestIdx <- apply(cbind(cmbDraw[, 1:26, drop=FALSE], newDraw4, cmbDraw[, 32, drop=FALSE]), 
                    1, FUN=which.max
                    )
hist(newBestIdx, breaks=0:33, col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
                                     rep("lightgreen", 10), rep("red", 5), rep("black", 1) ) )

# Assess the best value by row (adding in only the changed 4-card draws)
newBestVal <- apply(cbind(cmbDraw[, 1:26, drop=FALSE], newDraw4, cmbDraw[, 32, drop=FALSE]), 
                    1, FUN=max
                    )
summary(newBestVal)

# Summarize the changes in index
sum(newBestIdx != cmbBestIdx)
data.frame(oldIdx=cmbBestIdx, newIdx=newBestIdx) %>% 
    group_by(oldIdx, newIdx) %>% summarize(ct=n()) %>% 
    ggplot(aes(x=oldIdx, y=newIdx)) + geom_point(aes(size=ct), col="blue")

# Summarize the changes in value
sum(newBestVal != cmbBestVal)
sum(newBestVal > cmbBestVal)
sum(newBestVal < cmbBestVal)

hist((newBestVal - cmbBestVal)[newBestVal != cmbBestVal], col="lightblue")
temp <- data.frame(newIdx=newBestIdx, newVal=newBestVal, oldVal=cmbBestVal) %>%
        mutate(deltaVal = ((newVal - oldVal) != 0), changeVal=(newVal - oldVal)) %>% 
        group_by(newIdx) %>% 
        summarize(nHands=n(), nChg=sum(deltaVal), totChg=sum(changeVal), 
                  maxChg=max(changeVal), minChg=min(changeVal), meanChg=mean(changeVal)
                  )
print(as.data.frame(temp))

```

The average 1-card hold improves by ~2.5% with the "no replacement" methodology, and more hands are now optimally a 1-card hold.  
  
Next, the combined draw-1, draw-2, draw-3, and draw-4 universe is assessed, leaving the relatively rare draw-5 hands still to be optimized:  
```{r}
# Assess the best option by row (adding the changed 1-4 card draws)
newBestIdx <- apply(cbind(cmbDraw[, 1, drop=FALSE], newDraw1, newDraw2, 
                          newDraw3, newDraw4, cmbDraw[, 32, drop=FALSE]
                          ), 1, FUN=which.max
                    )
hist(newBestIdx, breaks=0:33, col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
                                     rep("lightgreen", 10), rep("red", 5), rep("black", 1) ) )

# Assess the best value by row (adding the changed 1-4 card draws)
newBestVal <- apply(cbind(cmbDraw[, 1, drop=FALSE], newDraw1, newDraw2, 
                          newDraw3, newDraw4, cmbDraw[, 32, drop=FALSE]
                          ), 1, FUN=max
                    )
summary(newBestVal)

# Summarize the changes in index
sum(newBestIdx != cmbBestIdx)
data.frame(oldIdx=cmbBestIdx, newIdx=newBestIdx) %>% 
    group_by(oldIdx, newIdx) %>% summarize(ct=n()) %>% 
    ggplot(aes(x=oldIdx, y=newIdx)) + geom_point(aes(size=ct), col="blue")

# Summarize the changes in value
sum(newBestVal != cmbBestVal)
sum(newBestVal > cmbBestVal)
sum(newBestVal < cmbBestVal)

hist((newBestVal - cmbBestVal)[newBestVal != cmbBestVal], col="lightblue")
temp <- data.frame(newIdx=newBestIdx, newVal=newBestVal, oldVal=cmbBestVal) %>%
        mutate(deltaVal = ((newVal - oldVal) != 0), changeVal=(newVal - oldVal)) %>% 
        group_by(newIdx) %>% 
        summarize(nHands=n(), nChg=sum(deltaVal), totChg=sum(changeVal), 
                  maxChg=max(changeVal), minChg=min(changeVal), meanChg=mean(changeVal)
                  )
print(as.data.frame(temp))

# Assess changes from/to group
newCutIdx <- cut(newBestIdx, breaks=c(0.5, 1.5, 6.5, 16.5, 26.5, 31.5, 32.5))
cmbCutIdx <- cut(cmbBestIdx, breaks=c(0.5, 1.5, 6.5, 16.5, 26.5, 31.5, 32.5))
data.frame(oldType=cmbCutIdx, newType=newCutIdx) %>% 
    group_by(oldType, newType) %>% summarize(ct=n())

```

The game now shows an EV approaching ~99.5%, close to the known EV of just ~99.54%.  Time will tell if there are bugs to fix or if forcing "no replacement" on the draw-5 hands will drive convergence.  
  
Finally, the draw-5 hands are re-optimized to the "no replacement" standard:  
```{r}
keyData <- integer(0)
            
basEV <- expVal5[1, 1, drop=TRUE]
            
keyA <- (1:5)[1]
keyB <- (1:5)[2]
keyC <- (1:5)[3]
keyD <- (1:5)[4]
keyE <- (1:5)[5]
keyAB <- (1:5)[c(1, 2)]
keyAC <- (1:5)[c(1, 3)]
keyAD <- (1:5)[c(1, 4)]
keyAE <- (1:5)[c(1, 5)]
keyBC <- (1:5)[c(2, 3)]
keyBD <- (1:5)[c(2, 4)]
keyBE <- (1:5)[c(2, 5)]
keyCD <- (1:5)[c(3, 4)]
keyCE <- (1:5)[c(3, 5)]
keyDE <- (1:5)[c(4, 5)]
keyABC <- (1:5)[c(1, 2, 3)]
keyABD <- (1:5)[c(1, 2, 4)]
keyABE <- (1:5)[c(1, 2, 5)]
keyACD <- (1:5)[c(1, 3, 4)]
keyACE <- (1:5)[c(1, 3, 5)]
keyADE <- (1:5)[c(1, 4, 5)]
keyBCD <- (1:5)[c(2, 3, 4)]
keyBCE <- (1:5)[c(2, 3, 5)]
keyBDE <- (1:5)[c(2, 4, 5)]
keyCDE <- (1:5)[c(3, 4, 5)]
keyABCD <- (1:5)[c(1, 2, 3, 4)]
keyABCE <- (1:5)[c(1, 2, 3, 5)]
keyABDE <- (1:5)[c(1, 2, 4, 5)]
keyACDE <- (1:5)[c(1, 3, 4, 5)]
keyBCDE <- (1:5)[c(2, 3, 4, 5)]
        
sortA <- sort(c(keyA))
sortB <- sort(c(keyB))
sortC <- sort(c(keyC))
sortD <- sort(c(keyD))
sortE <- sort(c(keyE))
sortAB <- sort(c(keyAB))
sortAC <- sort(c(keyAC))
sortAD <- sort(c(keyAD))
sortAE <- sort(c(keyAE))
sortBC <- sort(c(keyBC))
sortBD <- sort(c(keyBD))
sortBE <- sort(c(keyBE))
sortCD <- sort(c(keyCD))
sortCE <- sort(c(keyCE))
sortDE <- sort(c(keyDE))
sortABC <- sort(c(keyABC))
sortABD <- sort(c(keyABD))
sortABE <- sort(c(keyABE))
sortACD <- sort(c(keyACD))
sortACE <- sort(c(keyACE))
sortADE <- sort(c(keyADE))
sortBCD <- sort(c(keyBCD))
sortBCE <- sort(c(keyBCE))
sortBDE <- sort(c(keyBDE))    
sortCDE <- sort(c(keyCDE))
sortABCD <- sort(c(keyABCD))
sortABCE <- sort(c(keyABCE))
sortABDE <- sort(c(keyABDE))
sortACDE <- sort(c(keyACDE))
sortBCDE <- sort(c(keyBCDE))

# Manage the 4-carders
expABCD <- expVal1[idxCard4( c1=jbSmall[, sortABCD[1]], c2=jbSmall[, sortABCD[2]], 
                             c3=jbSmall[, sortABCD[3]], c4=jbSmall[, sortABCD[4]]
                            ), 1, drop=TRUE]

expABCE <- expVal1[idxCard4( c1=jbSmall[, sortABCE[1]], c2=jbSmall[, sortABCE[2]], 
                             c3=jbSmall[, sortABCE[3]], c4=jbSmall[, sortABCE[4]]
                            ), 1, drop=TRUE]

expABDE <- expVal1[idxCard4( c1=jbSmall[, sortABDE[1]], c2=jbSmall[, sortABDE[2]], 
                             c3=jbSmall[, sortABDE[3]], c4=jbSmall[, sortABDE[4]]
                            ), 1, drop=TRUE]

expACDE <- expVal1[idxCard4( c1=jbSmall[, sortACDE[1]], c2=jbSmall[, sortACDE[2]], 
                             c3=jbSmall[, sortACDE[3]], c4=jbSmall[, sortACDE[4]]
                            ), 1, drop=TRUE]

expBCDE <- expVal1[idxCard4( c1=jbSmall[, sortBCDE[1]], c2=jbSmall[, sortBCDE[2]], 
                             c3=jbSmall[, sortBCDE[3]], c4=jbSmall[, sortBCDE[4]]
                            ), 1, drop=TRUE]

# Manage the 3-carders
expABC <- expVal2[idxCard3( c1=jbSmall[, sortABC[1]], c2=jbSmall[, sortABC[2]], 
                            c3=jbSmall[, sortABC[3]]
                            ), 1, drop=TRUE]
    
expABD <- expVal2[idxCard3( c1=jbSmall[, sortABD[1]], c2=jbSmall[, sortABD[2]], 
                            c3=jbSmall[, sortABD[3]]
                            ), 1, drop=TRUE]

expABE <- expVal2[idxCard3( c1=jbSmall[, sortABE[1]], c2=jbSmall[, sortABE[2]], 
                            c3=jbSmall[, sortABE[3]]
                            ), 1, drop=TRUE]

expACD <- expVal2[idxCard3( c1=jbSmall[, sortACD[1]], c2=jbSmall[, sortACD[2]], 
                            c3=jbSmall[, sortACD[3]]
                            ), 1, drop=TRUE]

expACE <- expVal2[idxCard3( c1=jbSmall[, sortACE[1]], c2=jbSmall[, sortACE[2]], 
                            c3=jbSmall[, sortACE[3]]
                            ), 1, drop=TRUE]

expADE <- expVal2[idxCard3( c1=jbSmall[, sortADE[1]], c2=jbSmall[, sortADE[2]], 
                            c3=jbSmall[, sortADE[3]]
                            ), 1, drop=TRUE]

expBCD <- expVal2[idxCard3( c1=jbSmall[, sortBCD[1]], c2=jbSmall[, sortBCD[2]], 
                            c3=jbSmall[, sortBCD[3]]
                            ), 1, drop=TRUE]

expBCE <- expVal2[idxCard3( c1=jbSmall[, sortBCE[1]], c2=jbSmall[, sortBCE[2]], 
                            c3=jbSmall[, sortBCE[3]]
                            ), 1, drop=TRUE]

expBDE <- expVal2[idxCard3( c1=jbSmall[, sortBDE[1]], c2=jbSmall[, sortBDE[2]], 
                            c3=jbSmall[, sortBDE[3]]
                            ), 1, drop=TRUE]

expCDE <- expVal2[idxCard3( c1=jbSmall[, sortCDE[1]], c2=jbSmall[, sortCDE[2]], 
                            c3=jbSmall[, sortCDE[3]]
                            ), 1, drop=TRUE]

# Manage the 2-carders
expAB <- expVal3[idxCard2( c1=jbSmall[, sortAB[1]], c2=jbSmall[, sortAB[2]]
                          ), 1, drop=TRUE]

expAC <- expVal3[idxCard2( c1=jbSmall[, sortAC[1]], c2=jbSmall[, sortAC[2]]
                          ), 1, drop=TRUE]

expAD <- expVal3[idxCard2( c1=jbSmall[, sortAD[1]], c2=jbSmall[, sortAD[2]]
                          ), 1, drop=TRUE]

expAE <- expVal3[idxCard2( c1=jbSmall[, sortAE[1]], c2=jbSmall[, sortAE[2]]
                          ), 1, drop=TRUE]

expBC <- expVal3[idxCard2( c1=jbSmall[, sortBC[1]], c2=jbSmall[, sortBC[2]]
                          ), 1, drop=TRUE]

expBD <- expVal3[idxCard2( c1=jbSmall[, sortBD[1]], c2=jbSmall[, sortBD[2]]
                          ), 1, drop=TRUE]

expBE <- expVal3[idxCard2( c1=jbSmall[, sortBE[1]], c2=jbSmall[, sortBE[2]]
                          ), 1, drop=TRUE]

expCD <- expVal3[idxCard2( c1=jbSmall[, sortCD[1]], c2=jbSmall[, sortCD[2]]
                          ), 1, drop=TRUE]

expCE <- expVal3[idxCard2( c1=jbSmall[, sortCE[1]], c2=jbSmall[, sortCE[2]]
                          ), 1, drop=TRUE]

expDE <- expVal3[idxCard2( c1=jbSmall[, sortDE[1]], c2=jbSmall[, sortDE[2]]
                          ), 1, drop=TRUE]

# Manage the 1-carders
expA <- expVal4[jbSmall[, sortA], 1, drop=TRUE]
expB <- expVal4[jbSmall[, sortB], 1, drop=TRUE]
expC <- expVal4[jbSmall[, sortC], 1, drop=TRUE]
expD <- expVal4[jbSmall[, sortD], 1, drop=TRUE]
expE <- expVal4[jbSmall[, sortE], 1, drop=TRUE]

# Original minus relevant 1-cards plus relevant 2-cards 
# minus relevant 3-cards plus relevant 4-cards minus relevant 5-card
newEV <- (choose(52, 5) * basEV - 
              choose(51, 4) * (expA + expB + expC + expD + expE) +
              choose(50, 3) * (expAB + expAC + expAD + expAE + expBC + 
                                   expBD + expBE + expCD + expCE + expDE
                               ) - 
              choose(49, 2) * (expABC + expABD + expABE + expACD + expACE + 
                                   expADE + expBCD + expBCE + expBDE + expCDE
                               ) +
              choose(48, 1) * (expABCD + expABCE + expABDE + expACDE + expBCDE) -
              expVal0[, 1, drop=TRUE]
          ) / choose(47, 5)
str(newEV)
            
keyData <- c(keyData, newEV)

newDraw5 <- matrix(data=keyData, ncol=1, byrow=FALSE)

# Assess the best option by row (adding in only the changed 5-card draws, not the 1/2/3/4-card from above)
newBestIdx <- apply(cbind(cmbDraw[, 1:31, drop=FALSE], newDraw5), 1, FUN=which.max)
hist(newBestIdx, breaks=0:33, col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
                                     rep("lightgreen", 10), rep("red", 5), rep("black", 1) ) )

# Assess the best value by row (adding in only the changed 5-card draws)
newBestVal <- apply(cbind(cmbDraw[, 1:31, drop=FALSE], newDraw5), 1, FUN=max)
summary(newBestVal)

# Summarize the changes in index
sum(newBestIdx != cmbBestIdx)
data.frame(oldIdx=cmbBestIdx, newIdx=newBestIdx) %>% 
    group_by(oldIdx, newIdx) %>% summarize(ct=n()) %>% 
    ggplot(aes(x=oldIdx, y=newIdx)) + geom_point(aes(size=ct), col="blue")

# Summarize the changes in value
sum(newBestVal != cmbBestVal)
sum(newBestVal > cmbBestVal)
sum(newBestVal < cmbBestVal)

hist((newBestVal - cmbBestVal)[newBestVal != cmbBestVal], col="lightblue")
temp <- data.frame(newIdx=newBestIdx, newVal=newBestVal, oldVal=cmbBestVal) %>%
        mutate(deltaVal = ((newVal - oldVal) != 0), changeVal=(newVal - oldVal)) %>% 
        group_by(newIdx) %>% 
        summarize(nHands=n(), nChg=sum(deltaVal), totChg=sum(changeVal), 
                  maxChg=max(changeVal), minChg=min(changeVal), meanChg=mean(changeVal)
                  )
print(as.data.frame(temp))

```

The average 0-card hold improves by ~2.5% with the "no replacement" methodology, and more hands are now optimally a 0-card hold.  
