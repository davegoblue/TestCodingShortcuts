---
title: "Coronavirus US - USA Facts"
author: "davegoblue"
date: "6/6/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
This module builds on code contained in Coronavirus_Statistics_USAF_v004.Rmd.  This file includes the latest code for analyzing data from [USA Facts](https://usafacts.org/visualizations/coronavirus-covid-19-spread-map/).  USA Facts maintains data on cases and deaths by county for coronavirus in the US.  Downloaded data are unique by county with date as a column and a separate file for each of cases, deaths, and population.

The intent of this code is to source updated functions that allow for readRunUSAFacts() to be run to obtain, read, process, and analyze data from USA Facts.

## Sourcing Functions  
The tidyverse library is loaded, and the functions used for CDC daily processing are sourced.  Additionally, specific functions for USA Facts are also sourced:  
```{r}

library(tidyverse)

# Functions are available in source file
source("./Generic_Added_Utility_Functions_202105_v001.R")
source("./Coronavirus_CDC_Daily_Functions_v001.R")
source("./Coronavirus_USAF_Functions_v001.R")

```
  
Further, the mapping file specific to USA Facts is sourced:  
```{r}

source("./Coronavirus_USAF_Default_Mappings_v001.R")

```
  
A few functions should be added back to Generic_Added_..._v001.R and Coronavirus_CDC_Daily_..._v001.R after they have been more thoroughly checked for compatibility with the state-based clustering.  For now, they are included below so as to over-write the function obtained from source(...):  
```{r}

# Updated function for handling county-level clusters
createSummary <- function(df, 
                          stateClusterDF=NULL,
                          brewPalette=NA, 
                          dataType="state"
                          ) {
    
    # FUNCTION ARGUMENTS:
    # df: an integrated data frame by cluster-date
    # stateClusterDF: a data frame containing state-cluster (NULL means it can be found in df)
    # brewPalette: character string for a palette from RColorBrewer to be used (NA means default colors)
    # dataType: the type of maps being produced ("state" or "county")
    
    # Create plots that can be relevant for a dashboard, including:
    # 1. Map of segments
    # 2. Bar plot of counts by segment
    # 3. Facetted bar plot of segment descriptors (e.g., population, burden per million)
    # 4. Facetted trend-line plot of burden by segments
    
    # Create a map of the clusters
    p1 <- helperSummaryMap(if(is.null(stateClusterDF)) df else stateClusterDF, 
                           mapLevel=if(dataType=="state") "states" else "counties",
                           keyCol=if(dataType=="state") "state" else "countyFIPS",
                           discreteValues=TRUE, 
                           labelScale=is.na(brewPalette), 
                           textLabel=if(dataType=="state") c("RI", "CT", "DE", "MD", "DC") else c(),
                           extraArgs=if(is.na(brewPalette)) list() else 
                               list("arg1"=scale_fill_brewer("Cluster", palette=brewPalette))
                           )
    
    # Create a bar plot of counts by segment
    p2 <- helperSummaryMap(if(is.null(stateClusterDF)) df else stateClusterDF, 
                           mapLevel=if(dataType=="state") "states" else "counties",
                           keyCol=if(dataType=="state") "state" else "countyFIPS",
                           discreteValues=TRUE, 
                           labelScale=is.na(brewPalette), 
                           countOnly=TRUE,
                           extraArgs=if(is.na(brewPalette)) list() else 
                               list("arg1"=scale_fill_brewer("Cluster", palette=brewPalette))
                           )
    
    # Create plot for population and burden by cluster
    p3 <- df %>%
        helperAggTotal(aggVars=c("pop", "wm_tcpm7", "wm_tdpm7"), 
                       mapper=c("pop"="Population (millions)", 
                                "wm_tcpm7"="Cases per thousand", 
                                "wm_tdpm7"="Deaths per million"
                                ), 
                       xLab=NULL, 
                       yLab=NULL, 
                       title=NULL,
                       divideBy=c("pop"=1000000, "wm_tcpm7"=1000), 
                       extraArgs=if(is.na(brewPalette)) list() else 
                           list("arg1"=scale_fill_brewer("Cluster", palette=brewPalette))
                       )
    
    # Create plot for cumulative burden per million over time
    p4xtra <- list(arg1=scale_x_date(date_breaks="2 months", date_labels="%b-%y"), 
                   arg2=theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
                   )
    if(!is.na(brewPalette)) p4xtra$arg3 <- scale_color_brewer("Cluster", palette=brewPalette)
    p4 <- df %>%
        helperAggTrend(aggVars=append(c("wm_tcpm7", "wm_tdpm7"), if(dataType=="state") "wm_hpm7" else NULL), 
                       mapper=c("wm_tcpm7"="Cases per thousand\n(cumulative)", 
                                "wm_tdpm7"="Deaths per million\n(cumulative)", 
                                "wm_hpm7"="Hospitalized per million\n(current)"
                                ),
                       yLab=NULL,
                       title=NULL, 
                       divideBy=c("wm_tcpm7"=1000), 
                       linesize=0.75,
                       extraArgs=p4xtra
                       )
    
    list(p1=p1, p2=p2, p3=p3, p4=p4)
    
}



# Helper function to make a summary map
helperSummaryMap <- function(df, 
                             mapLevel="states", 
                             keyCol="state",
                             values="cluster",
                             discreteValues=NULL,
                             legend.position="right",
                             labelScale=TRUE,
                             extraArgs=list(),
                             countOnly=FALSE,
                             textLabel=c(),
                             ...
                             ) {
    
    # FUNCTION ARGUMENTS:
    # df: a data frame containing a level of geography and an associated cluster
    # mapLevel: a parameter for whether the map is "states" or "counties"
    # keyCol: the key column for plotting (usmap::plot_usmap is particular, and this must be 'state' or 'fips')
    # values: the character name of the field containing the data to be plotted
    # discreteValues: boolean for whether the values are discrete (if not, use continuous)
    #                 NULL means infer from data
    # legend.position: character for the location of the legend in the plot
    # labelScale: boolean, should an scale_fill_ be created?  Use FALSE if contained in extraArgs
    # extraArgs: list of other arguments that will be appended as '+' to the end of the usmap::plot_usmap call
    # countOnly: should a bar plot of counts only be produced?
    # textLabel: a list of elements that should be labelled as text on the plot (too small to see)
    # ...: other parameters to be passed to usmap::plot_usmap (e.g., labels, include, exclude, etc.)
    
    # Modify the data frame to contain only the relevant data
    df <- df %>%
        select(all_of(c(keyCol, values))) %>%
        distinct()
    
    # Determine the type of data being plotted
    if (is.null(discreteValues)) discreteValues <- !is.numeric(df[[values]])
    
    # Convert data type if needed
    if (isTRUE(discreteValues) & is.numeric(df[[values]])) 
        df[[values]] <- factor(df[[values]])
    
    # If count only is needed, create a count map; otherwise create a map
    if (isTRUE(countOnly)) { 
        gg <- df %>%
            ggplot(aes(x=fct_rev(get(values)))) + 
            geom_bar(aes_string(fill=values)) + 
            stat_count(aes(label=..count.., y=..count../2), 
                       geom="text", 
                       position="identity", 
                       fontface="bold"
                       ) +
            coord_flip() + 
            labs(y="Number of members", x="")
    } else {
        if(keyCol=="countyFIPS") {
            df <- df %>% colRenamer(vecRename=c("countyFIPS"="fips"))
            keyCol <- "fips"
        }
        gg <- usmap::plot_usmap(regions=mapLevel, data=df, values=values, ...)
        if (length(textLabel) > 0) {
            labDF <- df %>% 
                filter(get(keyCol) %in% textLabel) %>%
                mutate(rk=match(get(keyCol), textLabel)) %>%
                arrange(rk) %>%
                mutate(lon=-70.1-seq(0, 0.8*length(textLabel)-0.8, by=0.8), 
                       lat=40.1-seq(0, 1.5*length(textLabel)-1.5, by=1.5)
                       ) %>%
                select(lon, lat, everything()) %>%
                usmap::usmap_transform()
            gg <- gg + geom_text(data=labDF, 
                                 aes(x=lon.1, y=lat.1, label=paste(get(keyCol), get(values))), 
                                 size=3.25
                                 )
        }
    }
    
    # Position the legend as requested
    gg <- gg + theme(legend.position=legend.position)
    
    # Create the scale if appropriate
    if (isTRUE(labelScale)) gg <- gg + 
        if(isTRUE(discreteValues)) scale_fill_discrete(values) else scale_fill_continuous(values)
    
    # Apply extra arguments
    for (ctr in seq_along(extraArgs)) gg <- gg + extraArgs[[ctr]]
    
    # Return the map object
    gg
    
}



# Function to pivot the data file longer
pivotData <- function(df, 
                      pivotKeys, 
                      nameVar="name", 
                      valVar="value",
                      toLonger=TRUE, 
                      ...
                      ) {
    
    # FUNCTION ARGUMENTS:
    # df: the data frame
    # pivotKeys: the keys (everything but cols for pivot_longer, id_cols for pivot_wider)
    # nameVar: variable name for names_to or names_from
    # valVar: variable name for values_to or values_from
    # toLonger: boolean, should pivot_longer() be used rather than pivot_wider()?
    # ...: other arguments to be passed to pivot_*()

    if (isTRUE(toLonger)) pivot_longer(df, -all_of(pivotKeys), names_to=nameVar, values_to=valVar, ...)
    else pivot_wider(df, all_of(pivotKeys), names_from=all_of(nameVar), values_from=all_of(valVar), ...)
    
}

```

An existing processed USA Facts list is loaded for use as the comparison set:  
```{r}

cty_newformat_20201026 <- readFromRDS("cty_newformat_20201026")

```
  
A function is added to create a county-level cluster map with state borders:  
```{r}

sparseCountyClusterMap <- function(vec, 
                                   clustRemap=c("999"=NA), 
                                   caption=NULL, 
                                   brewPalette=NULL, 
                                   naFill="white"
                                   ) {
    
    # FUNCTION ARGUMENTS:
    # vec: a named vector where the names are countyFIPS and the values are the clusters
    # clustRemap: remapping vector for clusters
    # caption: caption to be included (NULL means no caption)
    # brewPalette: name of a palette for scale_fill_brewer()
    #              NULL means use scale_fill_discrete() instead
    # naFill: fill to use for NA counties
    
    # Convert to a tibble for use with usmap
    df <- clustersToFrame(vec, colNameName="fips", convFactor=FALSE) %>%
        mutate(cluster=as.character(cluster), 
               cluster=ifelse(cluster %in% names(clustRemap), clustRemap[cluster], cluster)
               )
    
    # Create a blank state map with black lines
    blankStates <- usmap::plot_usmap("states")
    
    # Create a county cluster map with NA values excluded
    dataCounties <- df %>% 
        filter(!is.na(cluster)) %>% 
        usmap::plot_usmap(regions="counties", data=., values="cluster")
    
    # Integrate as a ggplot object
    p1 <- ggplot() + 
        geom_polygon(data=dataCounties[[1]], 
                     aes(x=x, y=y, group=group, fill=dataCounties[[1]]$cluster), 
                     color = NA,
                     size = 0.1
                     ) +  
        geom_polygon(data=blankStates[[1]], 
                     aes(x=x, y=y, group=group), 
                     color = "black", 
                     lwd=1.25,
                     fill = alpha(0.001)
                     ) + 
        coord_equal() + 
        ggthemes::theme_map()
    
    # Add the appropriate fill
    if (is.null(brewPalette)) p1 <- p1 + scale_fill_discrete("Cluster", na.value=naFill)
    else p1 <- p1 + scale_fill_brewer("Cluster", palette=brewPalette, na.value=naFill)
    
    # Add caption if requested
    if (!is.null(caption)) p1 <- p1 + labs(caption=caption)
    
    # Return the plotting object
    p1
    
}

```
  
The function is then run using previously created segments:  
```{r, fig.height=9, fig.width=9}

sparseCountyClusterMap(cty_newformat_20201026$useClusters, 
                       brewPalette="Paired", 
                       caption="Counties with population under 25k are blank"
                       )

```

Next steps are to load new data and compare against previous, while using existing segments:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

readList <- list("usafCase"="./RInputFiles/Coronavirus/covid_confirmed_usafacts_downloaded_20210608.csv", 
                 "usafDeath"="./RInputFiles/Coronavirus/covid_deaths_usafacts_downloaded_20210608.csv"
                 )
compareList <- list("usafCase"=cty_newformat_20201026$dfRaw$usafCase, 
                    "usafDeath"=cty_newformat_20201026$dfRaw$usafDeath
                    )

# Create new clusters
cty_newdata_20210608 <- readRunUSAFacts(maxDate="2021-06-06", 
                                        downloadTo=lapply(readList, 
                                                          FUN=function(x) if(file.exists(x)) NA else x
                                                          ),
                                        readFrom=readList, 
                                        compareFile=compareList, 
                                        writeLog="./RInputFiles/Coronavirus/USAF_NewData_20210608_v005.log", 
                                        ovrwriteLog=TRUE,
                                        useClusters=cty_newformat_20201026$useClusters,
                                        skipAssessmentPlots=FALSE,
                                        brewPalette="Paired"
                                        )

sparseCountyClusterMap(cty_newdata_20210608$useClusters, 
                       brewPalette="Paired", 
                       caption="Counties with population under 25k are blank"
                       )

```

There has been significant convergence among segments in average deaths per million and cases per million.  This is suggestive of several possibilities, such as that growth in burden may be inversely proportional to previous burden.  Next steps are to create segments using the most recent data, seeking to identify differences in 1) cumulative burden, primarily defined by deaths, and 2) shape of the curve in getting to cumulative burden.

New segments are created, with assessments:  
```{r, fig.height=9, fig.width=9}

readList <- list("usafCase"="./RInputFiles/Coronavirus/covid_confirmed_usafacts_downloaded_20210608.csv", 
                 "usafDeath"="./RInputFiles/Coronavirus/covid_deaths_usafacts_downloaded_20210608.csv"
                 )

# Create new clusters
cty_newsegs_20210608 <- readRunUSAFacts(maxDate="2021-06-06", 
                                        writeLog="./RInputFiles/Coronavirus/USAF_NewSegs_20210608_v005.log", 
                                        ovrwriteLog=TRUE,
                                        dfPerCapita=cty_newdata_20210608$dfPerCapita,
                                        useClusters=NULL,
                                        skipAssessmentPlots=FALSE,
                                        brewPalette="Paired", 
                                        defaultCluster="999",
                                        minPopCluster=40000, 
                                        hierarchical=NA,
                                        minShape="2020-04",
                                        maxShape="2021-05",
                                        ratioDeathvsCase = 5,
                                        ratioTotalvsShape = 0.5,
                                        minDeath=100,
                                        minCase=5000, 
                                        hmlSegs=3, 
                                        eslSegs=3, 
                                        seed=2106091243
                                        )

sparseCountyClusterMap(cty_newsegs_20210608$useClusters, 
                       brewPalette="Paired", 
                       caption="Counties with population under 40k are blank"
                       )

```

