---
title: 'Additional Coding - Update #3'
author: "davegoblue"
date: "September 10, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
This document explores video poker hands, using <http://wizardofodds.com/games/video-poker/methodology/> as a template, and applying DataCamp_Insights_v001 materials where applicable.  This document builds on the more salient components of the analysis in AdditionalCoding_v002.Rmd.  Specifically, while _v002 appears to get to a 100% solution, the objectives of _v003 will include 1) improved speed, and 2) improved readability.  
  
## Simulations  
### Potential Hand Types  
The card deck will be considered to be 1-52, where 1-13, 14-26, 27-39, and 40-52 shall each be the suits.  Further, the lowest number of each suit shall be considered the Ace, and the highest shall be considered the King.  There are 52c5 (2,598,960) hands applicable to a typical poker game with a 52-card deck.  All of the possible combinations are created and assessed, with caching due to moderate run times:  
```{r, cache=TRUE}
jbHands <- matrix(data=0L, nrow=choose(52, 5), ncol=5)
jbFlush <- vector("logical", length=choose(52, 5))
jbUniques <- vector("integer", length=choose(52, 5))

startTime <- proc.time()
intCtr <- 1
for (i in 1:48) {
    for (j in (i+1):49) {
        for (k in (j+1):50) {
            for (m in (k+1):51) {
                for (n in (m+1):52) {
                    jbHands[intCtr, ] <- c(i, j, k, m, n)
                               
                    # Increment the process
                    intCtr <- intCtr + 1
                }
            }
        }
    }
}
proc.time() - startTime

# Declare flushes
testA <- (jbHands - 1) %/% 13
jbFlush <- testA[, 1] == testA[, 5]

# Get the totals by card rank
cRank <- matrix(data=0L, nrow=choose(52, 5), ncol=13)
for (intCtr in 1:13) {
    cRank[, intCtr] <- as.integer( rowSums( (jbHands %% 13) == (intCtr %% 13) ) )
}

# Get the number of unique cards
jbUniques <- rowSums(cRank > 0)

# Check for straights
exStraights <- matrix(data=0L, nrow=13, ncol=10)
for (intCtr in 1:9) { exStraights[intCtr:(intCtr+4), intCtr] <- 1L }
exStraights[c(1, 10:13), 10] <- 1L
strCheck <- rowSums( ( (cRank > 0) %*% exStraights ) == 5 )

# Is the maximum number of cards equal to 3
jbMax3 <- rowSums(cRank == 3) == 1

proc.time() - startTime
```
  
Hand types are then declared, with this portion not cached since 1) it will need further refinement, and 2) it runs quickly (with the exception of the table function, later updated with dplyr/tidyr for speed):  
```{r}
jbType <- rep(-1L, nrow(jbHands))  # Default value is -1

# Manage the pairs - only convert if pair is 1 (Ace) or 11-13 (J, Q, K)
hiPair <- cRank[, 1] == 2 | cRank[, 11] == 2 | cRank[, 12] == 2 | cRank[, 13] == 2
jbType[jbUniques == 4 & hiPair] <- 0

# Manage the straights and flushes, including SF and RF
jbType[jbFlush == FALSE & jbUniques == 5 & strCheck] <- 3  # Straights as 3
jbType[jbFlush == TRUE & !strCheck] <- 5  # Flushes as 5

# Declare the straight flush and royal flush
rfVector <- c(1L, 10L, 11L, 12L, 0L)
foo <- function(x) {
    if (sum( x %% 13 == rfVector ) ==5 ) { return(799) }
    else { return(49) }
}
jbType[jbFlush == TRUE & strCheck] <- apply(jbHands[jbFlush == TRUE & strCheck, ], 1, FUN=foo)

# Look at the subset that composes Two Pair, Trips, Full House, and Quads
jbType[jbUniques == 3 & !jbMax3] <- 1  # Two Pair
jbType[jbUniques == 3 & jbMax3] <- 2  # Trips
jbType[jbUniques == 2 & jbMax3] <- 8  # Full House
jbType[jbUniques == 2 & !jbMax3] <- 24  # Quads


library(dplyr)
library(tidyr)
library(ggplot2)

# Use dplyr and tidyr since they are MUCH faster than table() for the cross-tabs
data.frame(jbType=jbType) %>% group_by(jbType) %>% summarize(count=n())
data.frame(jbType=jbType, jbUniques=jbUniques) %>% 
    group_by(jbType, jbUniques) %>% 
    summarize(count=n()) %>%
    spread(jbUniques, count, fill=0)

```
  
Potential refinements will include allowing rank and kickers to impact value of quads (e.g., Bonus or Double Double Bonus).  
  
Sample plots are created using ggplot2 (cached, since they take a while to plot off the large frame):  
```{r, cache=TRUE}
# Practice with ggplot2
# Create jbRange purely for graphing purposes
startTime <- proc.time()


jbRange1 <- apply( (jbHands - 1) %% 13 , 1 , FUN=function(x) { max(x) - min(x) } )
jbRange2 <- apply( (jbHands - 2) %% 13 , 1 , FUN=function(x) { max(x) - min(x) } )
jbRange <- pmin(jbRange1, jbRange2)


proc.time() - startTime


graphFrame <- data.frame(jbFlush=as.integer(jbFlush), jbRange=jbRange, 
                         jbType=jbType, jbUniques=jbUniques
                         )


proc.time() - startTime


# Use dplyr to speed up some later ggplots
a <- graphFrame %>% group_by(jbRange, jbUniques, jbType) %>% summarize(count=n())

# Bar chart for jbRange x jbUniques
# OLD: ggplot(graphFrame, aes(x=as.factor(jbRange))) + 
#          geom_bar(aes(fill=as.factor(jbUniques)))
# NEW: Run time is almost immediate
ggplot(a, aes(x=as.factor(jbRange), y=count)) + 
    geom_bar(aes(fill=as.factor(jbUniques)), stat="identity")

# Stacked bar chart for jbRange x jbUniques
# OLD: ggplot(graphFrame, aes(x=as.factor(jbRange))) + 
#          geom_bar(aes(fill=as.factor(jbUniques)), position="fill")
# NEW: Run time is almost immediate
ggplot(a, aes(x=as.factor(jbRange), y=count)) + 
    geom_bar(aes(fill=as.factor(jbUniques)), stat="identity", position="fill")

# Bar chart for jbRange x jbUniques, faceted by jbType
# OLD: ggplot(graphFrame, aes(x=as.factor(jbRange))) + 
#          geom_bar(aes(fill=as.factor(jbUniques))) + 
#          facet_wrap(~ jbType, ncol=5)
# NEW: Run time is almost immediate
ggplot(a, aes(x=as.factor(jbRange), y=count)) + 
    geom_bar(aes(fill=as.factor(jbUniques)), stat="identity") + 
    facet_wrap(~ jbType, ncol=5)

# Stacked bar chart for jbRange x jbUniques, faceted by jbType
# OLD: ggplot(graphFrame, aes(x=as.factor(jbRange))) + 
#          geom_bar(aes(fill=as.factor(jbUniques)), position="fill") + 
#          facet_wrap(~ jbType, ncol=5)
# NEW: Run time is almost immediate
ggplot(a, aes(x=as.factor(jbRange), y=count)) + 
    geom_bar(aes(fill=as.factor(jbUniques)), stat="identity", position="fill") +
    facet_wrap(~ jbType, ncol=5)

proc.time() - startTime

```
  
As per the tables, the graphs line up with expectations.  
  
Next, the program takes a stab at implementing the algorithm described by the Wizard of Odds at <http://wizardofodds.com/games/video-poker/methodology/> for vastly reducing run times for a program of this type.  The Wizard recommends an 11-step process:  
  
First, the 16-hand condition is tested, and the relevant arrays are initialized:
```{r}

nrowArray0 <- data.frame(jbType=jbType) %>% 
    group_by(jbType) %>% 
    summarize(ct=n()) %>%
    arrange(jbType)
nrowArray0

if (nrow(nrowArray0) > 16) { 
    stop(paste0("There are too many hand types, cap is 16, this will have: ", nrow(nrowArray0)))
}
print("OK")

# Initialize array1-array5
array1 <- matrix(data=0L, nrow=choose(52, 4), ncol=16)
array2 <- matrix(data=0L, nrow=choose(52, 3), ncol=16)
array3 <- matrix(data=0L, nrow=choose(52, 2), ncol=16)
array4 <- matrix(data=0L, nrow=choose(52, 1), ncol=16)
array5 <- matrix(data=0L, nrow=choose(52, 0), ncol=16)

# Create array0 which will have an index number corresponding to the associated jbType
array0 <- match(jbType, nrowArray0[[1]])

data.frame(array0=array0) %>% 
    group_by(array0) %>%
    summarize(ct=n()) %>%
    arrange(array0)

```
  
One area for exploration is to associate indices to each combination of cards, start with an nCm array as per <http://wizardofvegas.com/forum/questions-and-answers/math/13687-my-methodology-for-video-poker-analysis-article-question/>.  
```{r}
mtxCombin <- matrix(data=0L, nrow=52, ncol=5)
for (intCtr in 1:52) {
    for (intCtr2 in 1:5) {
        # Note that choose() is a guarded function where choose(n, k) returns 0 for k > n
        mtxCombin[intCtr, intCtr2] <- choose(intCtr, intCtr2)
    }
}
```
  
The array can then be used to convert any 2 cards to an index, as follows:  
```{r}
idxCard2 <- function(c1, c2) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    1 + mtxCombin[52, 2] - mtxCombin[53-c1, 2] +
        mtxCombin[52-c1, 1] - mtxCombin[53-c2, 1]
}

# Test the index creation process
mtxA <- matrix(data=0L, nrow=choose(52, 2), ncol=3)
curRow <- 1
for (intCtr in 1:51) {
    for (intCtr2 in (intCtr+1):52) {
        mtxA[curRow, 1:3] <- c(intCtr, intCtr2, idxCard2(c1=intCtr, c2=intCtr2))
        curRow <- curRow + 1
    }
}

# Make sure it worked OK!
head(mtxA)
tail(mtxA)
length(mtxA[, 3]) == length(unique(mtxA[, 3]))
range(mtxA[, 3]) == c(1, choose(52, 2))
```
  
The array can also be used to convert any 3 cards to an index, as follows:  
```{r}
idxCard3 <- function(c1, c2, c3) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    1 + mtxCombin[52, 3] - mtxCombin[53-c1, 3] +
        mtxCombin[52-c1, 2] - mtxCombin[53-c2, 2] +
        mtxCombin[52-c2, 1] - mtxCombin[53-c3, 1]
}

# Test the index creation process
mtxA <- matrix(data=0L, nrow=choose(52, 3), ncol=4)
curRow <- 1
for (intCtr in 1:50) {
    for (intCtr2 in (intCtr+1):51) {
        for (intCtr3 in (intCtr2+1):52) {
            mtxA[curRow, 1:4] <- c(intCtr, intCtr2, intCtr3, 
                                   idxCard3(c1=intCtr, c2=intCtr2, c3=intCtr3)
                                   )
            curRow <- curRow + 1
        }
    }
}

# Make sure it worked OK!
head(mtxA)
tail(mtxA)
length(mtxA[, 4]) == length(unique(mtxA[, 4]))
range(mtxA[, 4]) == c(1, choose(52, 3))
```
  
And, the same algorithm can be used for 4 cards, an area which should save substantial time:  
```{r}
idxCard4 <- function(c1, c2, c3, c4) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    1 + mtxCombin[52, 4] - mtxCombin[53-c1, 4] +
        mtxCombin[52-c1, 3] - mtxCombin[53-c2, 3] +
        mtxCombin[52-c2, 2] - mtxCombin[53-c3, 2] + 
        mtxCombin[52-c3, 1] - mtxCombin[53-c4, 1]
}

# Test the index creation process
mtxA <- matrix(data=0L, nrow=choose(52, 4), ncol=5)
curRow <- 1
for (intCtr in 1:49) {
    for (intCtr2 in (intCtr+1):50) {
        for (intCtr3 in (intCtr2+1):51) {
            for (intCtr4 in (intCtr3+1):52) {
                mtxA[curRow, 1:5] <- c(intCtr, intCtr2, intCtr3, intCtr4, 
                                       idxCard4(c1=intCtr, c2=intCtr2, c3=intCtr3, c4=intCtr4)
                                       )
                curRow <- curRow + 1
            }
        }
    }
}

# Make sure it worked OK!
head(mtxA)
tail(mtxA)
length(mtxA[, 5]) == length(unique(mtxA[, 5]))
range(mtxA[, 5]) == c(1, choose(52, 4))
```
  
These functions should simplify and speed-up the conversion of any given 5-card hand to a score if it is instead held as a 0-4 card hand.  

The algorithms are then tested against jbHands (the 2,598,960 x 5 data frame representing all possible hands) and its associated array0 (the 2,598,960 x 1 integer vector representing the hand value as a 1-10).  
```{r}

# The array for keeping everything (jbHands as 2,598,960 x 5 for the cards, 
# and array0 as 2,598,960 x 1 for the outcomes) is already populated
startTime <- proc.time()

dim(jbHands)
length(array0)
data.frame(array0=array0) %>% 
    group_by(array0) %>% 
    summarize(ct=n()) %>% 
    arrange(-array0)

proc.time() - startTime


# Fill the array (array5 as 1 x 16) for keeping nothing
startTime <- proc.time()

a <- data.frame(val=array0) %>% group_by(val) %>% 
    summarize(ct=n()) %>% arrange(val)

for ( intCtr in seq_along(unique(a$val)) ) {
    array5[1, intCtr] <- a$ct[a$val == intCtr]
}

proc.time() - startTime


# Test keeping a single card, and fill the array (array4 as 52 x 16) for keeping 1
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
for (c1 in 1:5) {
    temp <- data.frame(card1=jbHands[, c1], val=array0) %>% 
        group_by(card1, val) %>%
        summarize(ct=n()) %>%
        arrange(card1, val)
    
    temp$idx <- temp$card1
    
    idx <- c(idx, temp$idx)
    val <- c(val, temp$val)
    ct <- c(ct, temp$ct)
    
}

a <- data.frame(idx=idx, val=val, ct=ct) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct))

for ( intCtr in seq_along(unique(a$val)) ) {
    array4[a$idx[a$val == intCtr], intCtr] <- a$ct[a$val == intCtr]
}

proc.time() - startTime


# Test keeping two cards, and fill the array (array3 as 1,326 x 16) for keeping two cards
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
for (c1 in 1:4) {
    for (c2 in (c1+1):5) {
        temp <- data.frame(card1=jbHands[, c1], card2=jbHands[, c2], val=array0) %>% 
            group_by(card1, card2, val) %>%
            summarize(ct=n()) %>%
            arrange(card1, card2, val)
    
        temp$idx <- idxCard2(c1=temp$card1, c2=temp$card2)
    
        idx <- c(idx, temp$idx)
        val <- c(val, temp$val)
        ct <- c(ct, temp$ct)
    
    }
}

a <- data.frame(idx=idx, val=val, ct=ct) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct))

for ( intCtr in seq_along(unique(a$val)) ) {
    array3[a$idx[a$val == intCtr], intCtr] <- a$ct[a$val == intCtr]
}

proc.time() - startTime


# Test keeping three cards, and fill the array (array2 as 22,100 x 16) for keeping three cards
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
for (c1 in 1:3) {
    for (c2 in (c1+1):4) {
        for (c3 in (c2+1):5) {
            temp <- data.frame(card1=jbHands[, c1], card2=jbHands[, c2], 
                               card3=jbHands[, c3], val=array0
                               ) %>% 
                group_by(card1, card2, card3, val) %>%
                summarize(ct=n()) %>%
                arrange(card1, card2, card3, val)
    
            temp$idx <- idxCard3(c1=temp$card1, c2=temp$card2, c3=temp$card3)
    
            idx <- c(idx, temp$idx)
            val <- c(val, temp$val)
            ct <- c(ct, temp$ct)
    
        }
    }
}

a <- data.frame(idx=idx, val=val, ct=ct) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct))

for ( intCtr in seq_along(unique(a$val)) ) {
    array2[a$idx[a$val == intCtr], intCtr] <- a$ct[a$val == intCtr]
}

proc.time() - startTime


# Test keeping four cards, and fill the array (array1 as 270,725 x 16) for keeping four cards
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
for (c1 in 1:2) {
    for (c2 in (c1+1):3) {
        for (c3 in (c2+1):4) {
            for (c4 in (c3+1):5) {
                temp <- data.frame(card1=jbHands[, c1], card2=jbHands[, c2], 
                                   card3=jbHands[, c3], card4=jbHands[, c4], 
                                   val=array0
                                   ) %>% 
                    group_by(card1, card2, card3, card4, val) %>%
                    summarize(ct=n()) %>%
                    arrange(card1, card2, card3, card4, val)
    
                temp$idx <- idxCard4(c1=temp$card1, c2=temp$card2, 
                                     c3=temp$card3, c4=temp$card4
                                     )
    
                idx <- c(idx, temp$idx)
                val <- c(val, temp$val)
                ct <- c(ct, temp$ct)
            
            }
        }
    }
}

a <- data.frame(idx=idx, val=val, ct=ct) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct))

for ( intCtr in seq_along(unique(a$val)) ) {
    array1[a$idx[a$val == intCtr], intCtr] <- a$ct[a$val == intCtr]
}

proc.time() - startTime

```
  
While this is still running an order of magnitude slower than the Wizard of Odds methodology, it is encouraging that the "order of magnitude" is 30 seconds vs. 3 seconds.  There may be room for further streamlining, but the code appears to be functional and with a reasonable run-time for next steps.  
  
The dimensions and counts of the various arrays are then confirmed:  
```{r}
# The actual arrays (array1-array5)
sapply(list(array5=array5, array4=array4, array3=array3, array2=array2, array1=array1), 
       FUN=function(x) {c(sum(x)/choose(52, 5), sum(rowSums(x) > 0), sum(colSums(x) > 0)) } 
       )

# The original array
length(array0)/choose(52, 5)
nrow(jbHands)
length(unique(array0))
```
  
The arrays are all of the proper dimensions and counts.  Next, a process is built to look at a subset of hands and to evaluate each of the potential options assuming cards CAN be replaced (the next step will be to reverse this assumption):  
```{r}

startTime <- proc.time()

# Convert each of the arrays to a value
mapArray <- matrix(data=c(-1, 0, 1, 2, 3, 5, 8, 24, 49, 799, 0, 0, 0, 0, 0, 0), ncol=1)
dim(mapArray)

expVal5 <- (array5 %*% mapArray) / choose(52, 5)
expVal4 <- (array4 %*% mapArray) / choose(51, 4)
expVal3 <- (array3 %*% mapArray) / choose(50, 3)
expVal2 <- (array2 %*% mapArray) / choose(49, 2)
expVal1 <- (array1 %*% mapArray) / choose(48, 1)
expVal0 <- matrix(data=mapArray[array0, 1], ncol=1)

# Evaluate all the draw-0 options
draw0 <- matrix(data=expVal0, ncol=1)

# Evaluate all the draw-5 options
draw5 <- matrix(data=expVal5, nrow=nrow(jbHands), ncol=1)

# Evaluate all the draw-4 options
keyData <- integer(0)
for (intCtr in 1:5) {
    keyData <- c(keyData, expVal4[jbHands[, intCtr], 1, drop=TRUE])
}
draw4 <- matrix(data=keyData, ncol=5, byrow=FALSE)

# Evaluate all the draw-3 options
keyData <- integer(0)
for (intCtr in 1:4) {
    for (intCtr2 in (intCtr+1):5) {
        keyData <- c(keyData, 
                     expVal3[idxCard2( c1=jbHands[ , intCtr], c2=jbHands[ , intCtr2] ), 
                             1, drop=TRUE]
                     )
    }
}
draw3 <- matrix(data=keyData, ncol=10, byrow=FALSE)

# Evaluate all the draw-2 options
keyData <- integer(0)
for (intCtr in 1:3) {
    for (intCtr2 in (intCtr+1):4) {
        for (intCtr3 in (intCtr2+1):5) {
            keyData <- c(keyData, 
                         expVal2[idxCard3( c1=jbHands[, intCtr], c2=jbHands[, intCtr2] ,
                                           c3=jbHands[, intCtr3]
                                          ), 1, drop=TRUE]
                         )
        }
    }
}
draw2 <- matrix(data=keyData, ncol=10, byrow=FALSE)

# Evaluate all the draw-1 options
keyData <- integer(0)
for (intCtr in 1:2) {
    for (intCtr2 in (intCtr+1):3) {
        for (intCtr3 in (intCtr2+1):4) {
            for (intCtr4 in (intCtr3+1):5) {
                keyData <- c(keyData, 
                             expVal1[idxCard4( c1=jbHands[, intCtr], c2=jbHands[, intCtr2] ,
                                               c3=jbHands[, intCtr3], c4=jbHands[, intCtr4]
                                              ), 1, drop=TRUE]
                            )
            }
        }
    }
}
draw1 <- matrix(data=keyData, ncol=5, byrow=FALSE)

# Integrate the drawing summaries and find the best option by row
cmbDraw <- cbind(draw0, draw1, draw2, draw3, draw4, draw5)

# Assess the best option by row
cmbBest <- apply(cmbDraw, 1, FUN=function(x) { c( which.max(x), max(x) ) } )
hist(cmbBest[1, ], breaks=0:33, col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
                                       rep("lightgreen", 10), rep("red", 5), rep("black", 1) ) )
summary(cmbBest[2, ])


proc.time() - startTime

```
  
While still an order of magnitude slower than the reference code, this runs through all the options in ~20 seconds.  
  
Next, an attempt is made to create a smaller database that combines and weights all the "identical" hands (e.g., As Ts 9h 8h 4c is mathematically identical to Ad Td 9c 8c 4h) so there is a lower processing time.  This is adapted heavily from the clever thinking documented at <http://wizardofodds.com/games/video-poker/methodology/>, using in order:  
  
* Four of a Kind (all that matters is what is the rank of the quad/kicker)  
* Full House (need to know ranks for A full of B, as well as whether B contains the fourth suit or not)  
* Trips (singletons can be all of fourth suit, one match and one fourth suit, no fourth suit/same, or no fourth suit/different)  
* Two Pair (suits matter for how much is in common between the two pairs, as well as the singleton)  
* Pair (many combinations for suits of the singletons)  
* Nothing (suits matter a great deal!)  
  
```{r}
# Quads are simple - there are 13 possible quads and 12 possible kickers
# Each hand can be captured once with a weight of 4 since the kicker will always match one suit
quadSmall <- matrix(data=0L, nrow=13*12, ncol=5)
quadWeight <- rep(4L, times=13*12)
curIdx <- 1

for (intCtr in 1:13) {
    for (intCtr2 in (1:13)[-intCtr]) {
        quadSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr+39, intCtr2))
        curIdx <- curIdx + 1
    }
}


# Full Houses are not too much more complex, though there are two suit pairing options for each
fhSmall <- matrix(data=0L, nrow=13*12*2, ncol=5)
fhWeight <- rep(12L, times=13*12*2)
curIdx <- 1

for (intCtr in 1:13) {
    for (intCtr2 in (1:13)[-intCtr]) {
        # First option has both pairs matching the suits of the trips
        fhSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr2+13))
        # Second option has one pair not matching the suits of the trips
        fhSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr2+39))
        curIdx <- curIdx + 2
    }
}


# Trips become a touch more complicated
# There is weight 24 for both singletons match different trips suits
# There is weight 12 for one singleton matches and the other does not
# There is weight 12 for both singletons match the same trips suit
# There is weight 4 for both singletons match each other but not any of the trips suits
tripSmall <- matrix(data=0L, nrow=13*choose(12, 2)*5, ncol=5)
tripWeight <- rep(c(24, 12, 12, 12, 4), times=13*choose(12,2))
curIdx <- 1

for (intCtr in 1:13) {
    intAvail <- (1:13)[-intCtr]
    for (intCtr2 in intAvail[-length(intAvail)]) {
        for (intCtr3 in intAvail[intAvail > intCtr2]) {
            # First option has both singletons matching a different trips suit
            tripSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr3+13))
            # Second option has singleton one matching a trips suit and singleton two not
            tripSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr3+39))
            # Third option has singleton two matching a trips suit and singleton one not
            tripSmall[curIdx+2, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2+39, intCtr3))
            # Fourth option has both singletons matching the same trips suit
            tripSmall[curIdx+3, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr3))
            # Fifth option has both singletons failing to match a trips suit
            tripSmall[curIdx+4, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2+39, intCtr3+39))
            # Increment the index by 5
            curIdx <- curIdx + 5
        }
    }
}


# Two Pair becomes even more complicated
# There is weight 12 for four suits across the two pair -- singleton matches pair #1 or pair #2
# There is weight 24 for each of one suit match across the two pair; singleton can be four suits
# There is weight 12 for the two pair having identical suits; once for the singleton matching, once for not
twoSmall <- matrix(data=0L, nrow=choose(13, 2)*11*8, ncol=5)
twoWeight <- rep(c(12, 12, 24, 24, 24, 24, 12, 12), times=choose(13, 2)*11)
curIdx <- 1

for (intCtr in 1:12) {
    for (intCtr2 in (intCtr+1):13) {
        for (intCtr3 in (1:13)[-c(intCtr, intCtr2)]) {
            
            # First option has all two pair cards being different suits
            twoSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr2+39, intCtr3))
            twoSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr2+39, intCtr3+26))
            
            # Second option has one matched suits in the two pair
            twoSmall[curIdx+2, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3))
            twoSmall[curIdx+3, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3+13))
            twoSmall[curIdx+4, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3+26))
            twoSmall[curIdx+5, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3+39))
            
            # Third option has fully matched suits across the two pair
            twoSmall[curIdx+6, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+13, intCtr3))
            twoSmall[curIdx+7, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+13, intCtr3+26))
            
            # Increment the index by 8
            curIdx <- curIdx + 8
        }
    }
}




```

