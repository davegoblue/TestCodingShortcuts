---
title: 'Additional Coding - Update #3'
author: "davegoblue"
date: "September 10, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown
This document explores video poker hands, using <http://wizardofodds.com/games/video-poker/methodology/> as a template, and applying DataCamp_Insights_v001 materials where applicable.  This document builds on the more salient components of the analysis in AdditionalCoding_v002.Rmd.  Specifically, while _v002 appears to get to a 100% solution, the objectives of _v003 will include 1) improved speed, and 2) improved readability.  
  
## Simulations  
### Potential Hand Types  
The card deck will be considered to be 1-52, where 1-13, 14-26, 27-39, and 40-52 shall each be the suits.  Further, the lowest number of each suit shall be considered the Ace, and the highest shall be considered the King.  There are 52c5 (2,598,960) hands applicable to a typical poker game with a 52-card deck.  All of the possible combinations are created and assessed, with caching due to moderate run times:  
```{r, cache=TRUE}
jbHands <- matrix(data=0L, nrow=choose(52, 5), ncol=5)
jbFlush <- vector("logical", length=choose(52, 5))
jbUniques <- vector("integer", length=choose(52, 5))

startTime <- proc.time()
intCtr <- 1
for (i in 1:48) {
    for (j in (i+1):49) {
        for (k in (j+1):50) {
            for (m in (k+1):51) {
                for (n in (m+1):52) {
                    jbHands[intCtr, ] <- c(i, j, k, m, n)
                               
                    # Increment the process
                    intCtr <- intCtr + 1
                }
            }
        }
    }
}
proc.time() - startTime

# Declare flushes
testA <- (jbHands - 1) %/% 13
jbFlush <- testA[, 1] == testA[, 5]

# Get the totals by card rank
cRank <- matrix(data=0L, nrow=choose(52, 5), ncol=13)
for (intCtr in 1:13) {
    cRank[, intCtr] <- as.integer( rowSums( (jbHands %% 13) == (intCtr %% 13) ) )
}

# Get the number of unique cards
jbUniques <- rowSums(cRank > 0)

# Check for straights
exStraights <- matrix(data=0L, nrow=13, ncol=10)
for (intCtr in 1:9) { exStraights[intCtr:(intCtr+4), intCtr] <- 1L }
exStraights[c(1, 10:13), 10] <- 1L
strCheck <- rowSums( ( (cRank > 0) %*% exStraights ) == 5 )

# Is the maximum number of cards equal to 3
jbMax3 <- rowSums(cRank == 3) == 1

proc.time() - startTime
```
  
Hand types are then declared, with this portion not cached since 1) it will need further refinement, and 2) it runs quickly (with the exception of the table function, later updated with dplyr/tidyr for speed):  
```{r}
jbType <- rep(-1L, nrow(jbHands))  # Default value is -1

# Manage the pairs - only convert if pair is 1 (Ace) or 11-13 (J, Q, K)
hiPair <- cRank[, 1] == 2 | cRank[, 11] == 2 | cRank[, 12] == 2 | cRank[, 13] == 2
jbType[jbUniques == 4 & hiPair] <- 0

# Manage the straights and flushes, including SF and RF
jbType[jbFlush == FALSE & jbUniques == 5 & strCheck] <- 3  # Straights as 3
jbType[jbFlush == TRUE & !strCheck] <- 5  # Flushes as 5

# Declare the straight flush and royal flush
rfVector <- c(1L, 10L, 11L, 12L, 0L)
foo <- function(x) {
    if (sum( x %% 13 == rfVector ) ==5 ) { return(799) }
    else { return(49) }
}
jbType[jbFlush == TRUE & strCheck] <- apply(jbHands[jbFlush == TRUE & strCheck, ], 1, FUN=foo)

# Look at the subset that composes Two Pair, Trips, Full House, and Quads
jbType[jbUniques == 3 & !jbMax3] <- 1  # Two Pair
jbType[jbUniques == 3 & jbMax3] <- 2  # Trips
jbType[jbUniques == 2 & jbMax3] <- 8  # Full House
jbType[jbUniques == 2 & !jbMax3] <- 24  # Quads


library(dplyr)
library(tidyr)
library(ggplot2)

# Use dplyr and tidyr since they are MUCH faster than table() for the cross-tabs
data.frame(jbType=jbType) %>% group_by(jbType) %>% summarize(count=n())
data.frame(jbType=jbType, jbUniques=jbUniques) %>% 
    group_by(jbType, jbUniques) %>% 
    summarize(count=n()) %>%
    spread(jbUniques, count, fill=0)

```
  
Potential refinements will include allowing rank and kickers to impact value of quads (e.g., Bonus or Double Double Bonus).  
  
Sample plots are created using ggplot2 (cached, since they take a while to plot off the large frame):  
```{r, cache=TRUE}
# Practice with ggplot2
# Create jbRange purely for graphing purposes
startTime <- proc.time()


jbRange1 <- apply( (jbHands - 1) %% 13 , 1 , FUN=function(x) { max(x) - min(x) } )
jbRange2 <- apply( (jbHands - 2) %% 13 , 1 , FUN=function(x) { max(x) - min(x) } )
jbRange <- pmin(jbRange1, jbRange2)


proc.time() - startTime


graphFrame <- data.frame(jbFlush=as.integer(jbFlush), jbRange=jbRange, 
                         jbType=jbType, jbUniques=jbUniques
                         )


proc.time() - startTime


# Use dplyr to speed up some later ggplots
a <- graphFrame %>% group_by(jbRange, jbUniques, jbType) %>% summarize(count=n())

# Bar chart for jbRange x jbUniques
# OLD: ggplot(graphFrame, aes(x=as.factor(jbRange))) + 
#          geom_bar(aes(fill=as.factor(jbUniques)))
# NEW: Run time is almost immediate
ggplot(a, aes(x=as.factor(jbRange), y=count)) + 
    geom_bar(aes(fill=as.factor(jbUniques)), stat="identity")

# Stacked bar chart for jbRange x jbUniques
# OLD: ggplot(graphFrame, aes(x=as.factor(jbRange))) + 
#          geom_bar(aes(fill=as.factor(jbUniques)), position="fill")
# NEW: Run time is almost immediate
ggplot(a, aes(x=as.factor(jbRange), y=count)) + 
    geom_bar(aes(fill=as.factor(jbUniques)), stat="identity", position="fill")

# Bar chart for jbRange x jbUniques, faceted by jbType
# OLD: ggplot(graphFrame, aes(x=as.factor(jbRange))) + 
#          geom_bar(aes(fill=as.factor(jbUniques))) + 
#          facet_wrap(~ jbType, ncol=5)
# NEW: Run time is almost immediate
ggplot(a, aes(x=as.factor(jbRange), y=count)) + 
    geom_bar(aes(fill=as.factor(jbUniques)), stat="identity") + 
    facet_wrap(~ jbType, ncol=5)

# Stacked bar chart for jbRange x jbUniques, faceted by jbType
# OLD: ggplot(graphFrame, aes(x=as.factor(jbRange))) + 
#          geom_bar(aes(fill=as.factor(jbUniques)), position="fill") + 
#          facet_wrap(~ jbType, ncol=5)
# NEW: Run time is almost immediate
ggplot(a, aes(x=as.factor(jbRange), y=count)) + 
    geom_bar(aes(fill=as.factor(jbUniques)), stat="identity", position="fill") +
    facet_wrap(~ jbType, ncol=5)

proc.time() - startTime

```
  
As per the tables, the graphs line up with expectations.  
  
Next, the program takes a stab at implementing the algorithm described by the Wizard of Odds at <http://wizardofodds.com/games/video-poker/methodology/> for vastly reducing run times for a program of this type.  The Wizard recommends an 11-step process:  
  
First, the 16-hand condition is tested, and the relevant arrays are initialized:
```{r}

nrowArray0 <- data.frame(jbType=jbType) %>% 
    group_by(jbType) %>% 
    summarize(ct=n()) %>%
    arrange(jbType)
nrowArray0

if (nrow(nrowArray0) > 16) { 
    stop(paste0("There are too many hand types, cap is 16, this will have: ", nrow(nrowArray0)))
}
print("OK")

# Initialize array1-array5
array1 <- matrix(data=0L, nrow=choose(52, 4), ncol=16)
array2 <- matrix(data=0L, nrow=choose(52, 3), ncol=16)
array3 <- matrix(data=0L, nrow=choose(52, 2), ncol=16)
array4 <- matrix(data=0L, nrow=choose(52, 1), ncol=16)
array5 <- matrix(data=0L, nrow=choose(52, 0), ncol=16)

# Create array0 which will have an index number corresponding to the associated jbType
array0 <- match(jbType, nrowArray0[[1]])

data.frame(array0=array0) %>% 
    group_by(array0) %>%
    summarize(ct=n()) %>%
    arrange(array0)

```
  
One area for exploration is to associate indices to each combination of cards, start with an nCm array as per <http://wizardofvegas.com/forum/questions-and-answers/math/13687-my-methodology-for-video-poker-analysis-article-question/>.  
```{r}
mtxCombin <- matrix(data=0L, nrow=52, ncol=5)
for (intCtr in 1:52) {
    for (intCtr2 in 1:5) {
        # Note that choose() is a guarded function where choose(n, k) returns 0 for k > n
        mtxCombin[intCtr, intCtr2] <- choose(intCtr, intCtr2)
    }
}
```
  
The array can then be used to convert any 2 cards to an index, as follows:  
```{r}
idxCard2 <- function(c1, c2) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    1 + mtxCombin[52, 2] - mtxCombin[53-c1, 2] +
        mtxCombin[52-c1, 1] - mtxCombin[53-c2, 1]
}

# Test the index creation process
mtxA <- matrix(data=0L, nrow=choose(52, 2), ncol=3)
curRow <- 1
for (intCtr in 1:51) {
    for (intCtr2 in (intCtr+1):52) {
        mtxA[curRow, 1:3] <- c(intCtr, intCtr2, idxCard2(c1=intCtr, c2=intCtr2))
        curRow <- curRow + 1
    }
}

# Make sure it worked OK!
head(mtxA)
tail(mtxA)
length(mtxA[, 3]) == length(unique(mtxA[, 3]))
range(mtxA[, 3]) == c(1, choose(52, 2))
```
  
The array can also be used to convert any 3 cards to an index, as follows:  
```{r}
idxCard3 <- function(c1, c2, c3) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    1 + mtxCombin[52, 3] - mtxCombin[53-c1, 3] +
        mtxCombin[52-c1, 2] - mtxCombin[53-c2, 2] +
        mtxCombin[52-c2, 1] - mtxCombin[53-c3, 1]
}

# Test the index creation process
mtxA <- matrix(data=0L, nrow=choose(52, 3), ncol=4)
curRow <- 1
for (intCtr in 1:50) {
    for (intCtr2 in (intCtr+1):51) {
        for (intCtr3 in (intCtr2+1):52) {
            mtxA[curRow, 1:4] <- c(intCtr, intCtr2, intCtr3, 
                                   idxCard3(c1=intCtr, c2=intCtr2, c3=intCtr3)
                                   )
            curRow <- curRow + 1
        }
    }
}

# Make sure it worked OK!
head(mtxA)
tail(mtxA)
length(mtxA[, 4]) == length(unique(mtxA[, 4]))
range(mtxA[, 4]) == c(1, choose(52, 3))
```
  
And, the same algorithm can be used for 4 cards, an area which should save substantial time:  
```{r}
idxCard4 <- function(c1, c2, c3, c4) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    1 + mtxCombin[52, 4] - mtxCombin[53-c1, 4] +
        mtxCombin[52-c1, 3] - mtxCombin[53-c2, 3] +
        mtxCombin[52-c2, 2] - mtxCombin[53-c3, 2] + 
        mtxCombin[52-c3, 1] - mtxCombin[53-c4, 1]
}

# Test the index creation process
mtxA <- matrix(data=0L, nrow=choose(52, 4), ncol=5)
curRow <- 1
for (intCtr in 1:49) {
    for (intCtr2 in (intCtr+1):50) {
        for (intCtr3 in (intCtr2+1):51) {
            for (intCtr4 in (intCtr3+1):52) {
                mtxA[curRow, 1:5] <- c(intCtr, intCtr2, intCtr3, intCtr4, 
                                       idxCard4(c1=intCtr, c2=intCtr2, c3=intCtr3, c4=intCtr4)
                                       )
                curRow <- curRow + 1
            }
        }
    }
}

# Make sure it worked OK!
head(mtxA)
tail(mtxA)
length(mtxA[, 5]) == length(unique(mtxA[, 5]))
range(mtxA[, 5]) == c(1, choose(52, 4))
```
  
These functions should simplify and speed-up the conversion of any given 5-card hand to a score if it is instead held as a 0-4 card hand.  

The algorithms are then tested against jbHands (the 2,598,960 x 5 data frame representing all possible hands) and its associated array0 (the 2,598,960 x 1 integer vector representing the hand value as a 1-10).  
```{r}

# The array for keeping everything (jbHands as 2,598,960 x 5 for the cards, 
# and array0 as 2,598,960 x 1 for the outcomes) is already populated
startTime <- proc.time()

dim(jbHands)
length(array0)
data.frame(array0=array0) %>% 
    group_by(array0) %>% 
    summarize(ct=n()) %>% 
    arrange(-array0)

proc.time() - startTime


# Fill the array (array5 as 1 x 16) for keeping nothing
startTime <- proc.time()

a <- data.frame(val=array0) %>% group_by(val) %>% 
    summarize(ct=n()) %>% arrange(val)

for ( intCtr in seq_along(unique(a$val)) ) {
    array5[1, intCtr] <- a$ct[a$val == intCtr]
}

proc.time() - startTime


# Test keeping a single card, and fill the array (array4 as 52 x 16) for keeping 1
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
for (c1 in 1:5) {
    temp <- data.frame(card1=jbHands[, c1], val=array0) %>% 
        group_by(card1, val) %>%
        summarize(ct=n()) %>%
        arrange(card1, val)
    
    temp$idx <- temp$card1
    
    idx <- c(idx, temp$idx)
    val <- c(val, temp$val)
    ct <- c(ct, temp$ct)
    
}

a <- data.frame(idx=idx, val=val, ct=ct) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct))

for ( intCtr in seq_along(unique(a$val)) ) {
    array4[a$idx[a$val == intCtr], intCtr] <- a$ct[a$val == intCtr]
}

proc.time() - startTime


# Test keeping two cards, and fill the array (array3 as 1,326 x 16) for keeping two cards
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
for (c1 in 1:4) {
    for (c2 in (c1+1):5) {
        temp <- data.frame(card1=jbHands[, c1], card2=jbHands[, c2], val=array0) %>% 
            group_by(card1, card2, val) %>%
            summarize(ct=n()) %>%
            arrange(card1, card2, val)
    
        temp$idx <- idxCard2(c1=temp$card1, c2=temp$card2)
    
        idx <- c(idx, temp$idx)
        val <- c(val, temp$val)
        ct <- c(ct, temp$ct)
    
    }
}

a <- data.frame(idx=idx, val=val, ct=ct) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct))

for ( intCtr in seq_along(unique(a$val)) ) {
    array3[a$idx[a$val == intCtr], intCtr] <- a$ct[a$val == intCtr]
}

proc.time() - startTime


# Test keeping three cards, and fill the array (array2 as 22,100 x 16) for keeping three cards
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
for (c1 in 1:3) {
    for (c2 in (c1+1):4) {
        for (c3 in (c2+1):5) {
            temp <- data.frame(card1=jbHands[, c1], card2=jbHands[, c2], 
                               card3=jbHands[, c3], val=array0
                               ) %>% 
                group_by(card1, card2, card3, val) %>%
                summarize(ct=n()) %>%
                arrange(card1, card2, card3, val)
    
            temp$idx <- idxCard3(c1=temp$card1, c2=temp$card2, c3=temp$card3)
    
            idx <- c(idx, temp$idx)
            val <- c(val, temp$val)
            ct <- c(ct, temp$ct)
    
        }
    }
}

a <- data.frame(idx=idx, val=val, ct=ct) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct))

for ( intCtr in seq_along(unique(a$val)) ) {
    array2[a$idx[a$val == intCtr], intCtr] <- a$ct[a$val == intCtr]
}

proc.time() - startTime


# Test keeping four cards, and fill the array (array1 as 270,725 x 16) for keeping four cards
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
for (c1 in 1:2) {
    for (c2 in (c1+1):3) {
        for (c3 in (c2+1):4) {
            for (c4 in (c3+1):5) {
                temp <- data.frame(card1=jbHands[, c1], card2=jbHands[, c2], 
                                   card3=jbHands[, c3], card4=jbHands[, c4], 
                                   val=array0
                                   ) %>% 
                    group_by(card1, card2, card3, card4, val) %>%
                    summarize(ct=n()) %>%
                    arrange(card1, card2, card3, card4, val)
    
                temp$idx <- idxCard4(c1=temp$card1, c2=temp$card2, 
                                     c3=temp$card3, c4=temp$card4
                                     )
    
                idx <- c(idx, temp$idx)
                val <- c(val, temp$val)
                ct <- c(ct, temp$ct)
            
            }
        }
    }
}

a <- data.frame(idx=idx, val=val, ct=ct) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct))

for ( intCtr in seq_along(unique(a$val)) ) {
    array1[a$idx[a$val == intCtr], intCtr] <- a$ct[a$val == intCtr]
}

proc.time() - startTime

```
  
While this is still running an order of magnitude slower than the Wizard of Odds methodology, it is encouraging that the "order of magnitude" is 30 seconds vs. 3 seconds.  There may be room for further streamlining, but the code appears to be functional and with a reasonable run-time for next steps.  
  
The dimensions and counts of the various arrays are then confirmed:  
```{r}
# The actual arrays (array1-array5)
sapply(list(array5=array5, array4=array4, array3=array3, array2=array2, array1=array1), 
       FUN=function(x) {c(sum(x)/choose(52, 5), sum(rowSums(x) > 0), sum(colSums(x) > 0)) } 
       )

# The original array
length(array0)/choose(52, 5)
nrow(jbHands)
length(unique(array0))
```
  
The arrays are all of the proper dimensions and counts.  Next, a process is built to look at a subset of hands and to evaluate each of the potential options assuming cards CAN be replaced (the next step will be to reverse this assumption):  
```{r}

startTime <- proc.time()

# Convert each of the arrays to a value
mapArray <- matrix(data=c(-1, 0, 1, 2, 3, 5, 8, 24, 49, 799, 0, 0, 0, 0, 0, 0), ncol=1)
dim(mapArray)

expVal5 <- (array5 %*% mapArray) / choose(52, 5)
expVal4 <- (array4 %*% mapArray) / choose(51, 4)
expVal3 <- (array3 %*% mapArray) / choose(50, 3)
expVal2 <- (array2 %*% mapArray) / choose(49, 2)
expVal1 <- (array1 %*% mapArray) / choose(48, 1)
expVal0 <- matrix(data=mapArray[array0, 1], ncol=1)

# Evaluate all the draw-0 options
draw0 <- matrix(data=expVal0, ncol=1)

# Evaluate all the draw-5 options
draw5 <- matrix(data=expVal5, nrow=nrow(jbHands), ncol=1)

# Evaluate all the draw-4 options
keyData <- integer(0)
for (intCtr in 1:5) {
    keyData <- c(keyData, expVal4[jbHands[, intCtr], 1, drop=TRUE])
}
draw4 <- matrix(data=keyData, ncol=5, byrow=FALSE)

# Evaluate all the draw-3 options
keyData <- integer(0)
for (intCtr in 1:4) {
    for (intCtr2 in (intCtr+1):5) {
        keyData <- c(keyData, 
                     expVal3[idxCard2( c1=jbHands[ , intCtr], c2=jbHands[ , intCtr2] ), 
                             1, drop=TRUE]
                     )
    }
}
draw3 <- matrix(data=keyData, ncol=10, byrow=FALSE)

# Evaluate all the draw-2 options
keyData <- integer(0)
for (intCtr in 1:3) {
    for (intCtr2 in (intCtr+1):4) {
        for (intCtr3 in (intCtr2+1):5) {
            keyData <- c(keyData, 
                         expVal2[idxCard3( c1=jbHands[, intCtr], c2=jbHands[, intCtr2] ,
                                           c3=jbHands[, intCtr3]
                                          ), 1, drop=TRUE]
                         )
        }
    }
}
draw2 <- matrix(data=keyData, ncol=10, byrow=FALSE)

# Evaluate all the draw-1 options
keyData <- integer(0)
for (intCtr in 1:2) {
    for (intCtr2 in (intCtr+1):3) {
        for (intCtr3 in (intCtr2+1):4) {
            for (intCtr4 in (intCtr3+1):5) {
                keyData <- c(keyData, 
                             expVal1[idxCard4( c1=jbHands[, intCtr], c2=jbHands[, intCtr2] ,
                                               c3=jbHands[, intCtr3], c4=jbHands[, intCtr4]
                                              ), 1, drop=TRUE]
                            )
            }
        }
    }
}
draw1 <- matrix(data=keyData, ncol=5, byrow=FALSE)

# Integrate the drawing summaries and find the best option by row
cmbDraw <- cbind(draw0, draw1, draw2, draw3, draw4, draw5)

# Assess the best option by row
cmbBest <- apply(cmbDraw, 1, FUN=function(x) { c( which.max(x), max(x) ) } )
hist(cmbBest[1, ], breaks=0:33, col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
                                       rep("lightgreen", 10), rep("red", 5), rep("black", 1) ) )
summary(cmbBest[2, ])


proc.time() - startTime

```
  
While still an order of magnitude slower than the reference code, this runs through all the options in ~20 seconds.  
  
Next, an attempt is made to create a smaller database that combines and weights all the "identical" hands (e.g., As Ts 9h 8h 4c is mathematically identical to Ad Td 9c 8c 4h) so there is a lower processing time.  This is adapted heavily from the clever thinking documented at <http://wizardofodds.com/games/video-poker/methodology/>, using in order:  
  
* Four of a Kind (all that matters is what is the rank of the quad/kicker)  
* Full House (need to know ranks for A full of B, as well as whether B contains the fourth suit or not)  
* Trips (singletons can be all of fourth suit, one match and one fourth suit, no fourth suit/same, or no fourth suit/different)  
* Two Pair (suits matter for how much is in common between the two pairs, as well as the singleton)  
* Pair (many combinations for suits of the singletons)  
* Nothing (suits matter a great deal!)  
  
```{r}
# Quads are simple - there are 13 possible quads and 12 possible kickers
# Each hand can be captured once with a weight of 4 since the kicker will always match one suit
quadSmall <- matrix(data=0L, nrow=13*12, ncol=5)
quadWeight <- rep(4L, times=13*12)
curIdx <- 1

for (intCtr in 1:13) {
    for (intCtr2 in (1:13)[-intCtr]) {
        quadSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr+39, intCtr2))
        curIdx <- curIdx + 1
    }
}


# Full Houses are not too much more complex, though there are two suit pairing options for each
fhSmall <- matrix(data=0L, nrow=13*12*2, ncol=5)
fhWeight <- rep(12L, times=13*12*2)
curIdx <- 1

for (intCtr in 1:13) {
    for (intCtr2 in (1:13)[-intCtr]) {
        # First option has both pairs matching the suits of the trips
        fhSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr2+13))
        # Second option has one pair not matching the suits of the trips
        fhSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr2+39))
        curIdx <- curIdx + 2
    }
}


# Trips become a touch more complicated
# There is weight 24 for both singletons match different trips suits
# There is weight 12 for one singleton matches and the other does not
# There is weight 12 for both singletons match the same trips suit
# There is weight 4 for both singletons match each other but not any of the trips suits
tripSmall <- matrix(data=0L, nrow=13*choose(12, 2)*5, ncol=5)
tripWeight <- rep(c(24, 12, 12, 12, 4), times=13*choose(12,2))
curIdx <- 1

for (intCtr in 1:13) {
    intAvail <- (1:13)[-intCtr]
    for (intCtr2 in intAvail[-length(intAvail)]) {
        for (intCtr3 in intAvail[intAvail > intCtr2]) {
            # First option has both singletons matching a different trips suit
            tripSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr3+13))
            # Second option has singleton one matching a trips suit and singleton two not
            tripSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr3+39))
            # Third option has singleton two matching a trips suit and singleton one not
            tripSmall[curIdx+2, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2+39, intCtr3))
            # Fourth option has both singletons matching the same trips suit
            tripSmall[curIdx+3, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr3))
            # Fifth option has both singletons failing to match a trips suit
            tripSmall[curIdx+4, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2+39, intCtr3+39))
            # Increment the index by 5
            curIdx <- curIdx + 5
        }
    }
}


# Two Pair becomes even more complicated
# There is weight 12 for four suits across the two pair -- singleton matches pair #1 or pair #2
# There is weight 24 for each of one suit match across the two pair; singleton can be four suits
# There is weight 12 for the two pair having identical suits; once for the singleton matching, once for not
twoSmall <- matrix(data=0L, nrow=choose(13, 2)*11*8, ncol=5)
twoWeight <- rep(c(12, 12, 24, 24, 24, 24, 12, 12), times=choose(13, 2)*11)
curIdx <- 1

for (intCtr in 1:12) {
    for (intCtr2 in (intCtr+1):13) {
        for (intCtr3 in (1:13)[-c(intCtr, intCtr2)]) {
            
            # First option has all two pair cards being different suits
            twoSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr2+39, intCtr3))
            twoSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr2+39, intCtr3+26))
            
            # Second option has one matched suits in the two pair
            twoSmall[curIdx+2, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3))
            twoSmall[curIdx+3, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3+13))
            twoSmall[curIdx+4, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3+26))
            twoSmall[curIdx+5, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3+39))
            
            # Third option has fully matched suits across the two pair
            twoSmall[curIdx+6, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+13, intCtr3))
            twoSmall[curIdx+7, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+13, intCtr3+26))
            
            # Increment the index by 8
            curIdx <- curIdx + 8
        }
    }
}


# One Pair becomes even more complicated
# The pair is (obviously) two-suited; consider them to be 1 and 2; the game is in the singletons
# Weight 12 (2): Singletons all same suit, once matching to a pair suit, and once not
# Weight 12 (3): Singletons are suited 2-1, all matching to the pairs - 112, 121, 211
# Weight 24 (3): Singletons are suited 2-1, two matching to the pairs - 113, 131, 311
# Weight 24 (3): Singletons are suited 2-1, one matching to the pairs - 133, 313, 331 
# Weight 12 (3): Singletons are suited 2-1, none matching to the pairs - 344, 434, 443
# Weight 24 (3): Singletons are suited 1-1-1, two matching to the pairs - 123, 132, 312
# Weight 24 (3): Singletons are suited 1-1-1, one matching to the pairs - 134, 314, 341
pairSmall <- matrix(data=0L, nrow=13*choose(12, 3)*20, ncol=5)
pairWeight <- rep(c(12, 12, 12, 12, 12, 24, 24, 24, 24, 24, 24, 
                    12, 12, 12, 24, 24, 24, 24, 24, 24), 
                  times=13*choose(12, 3)
                  )
curIdx <- 1

for (intCtr in 1:13) {
    intAvail <- (1:13)[-intCtr]
    for (intCtr2 in intAvail[-c(11, 12)]) {
        nextAvail <- (intCtr2+1):13
        nextAvail <- nextAvail[!(nextAvail %in% c(intCtr))]
        for (intCtr3 in nextAvail[-length(nextAvail)]) {
            lastAvail <- (intCtr3+1):13
            lastAvail <- lastAvail[!(lastAvail %in% c(intCtr))]
            for (intCtr4 in lastAvail) {
                # Weight 12 (2): Singletons all same suit, once matching to a pair suit, and once not
                pairSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3, intCtr4))
                pairSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+26, intCtr4+26))
            
                # Weight 12 (3): Singletons are suited 2-1, all matching to the pairs - 112, 121, 211
                pairSmall[curIdx+2, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3, intCtr4+13))
                pairSmall[curIdx+3, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+13, intCtr4))
                pairSmall[curIdx+4, ] <- sort(c(intCtr, intCtr+13, intCtr2+13, intCtr3, intCtr4))
                
                # Weight 24 (3): Singletons are suited 2-1, two matching to the pairs - 113, 131, 311
                pairSmall[curIdx+5, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3, intCtr4+26))
                pairSmall[curIdx+6, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4))
                pairSmall[curIdx+7, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4))
                
                # Weight 24 (3): Singletons are suited 2-1, one matching to the pairs - 133, 313, 331 
                pairSmall[curIdx+8, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4+26))
                pairSmall[curIdx+9, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4+26))
                pairSmall[curIdx+10, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+26, intCtr4))
                
                # Weight 12 (3): Singletons are suited 2-1, none matching to the pairs - 344, 434, 443
                pairSmall[curIdx+11, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+39, intCtr4+39))
                pairSmall[curIdx+12, ] <- sort(c(intCtr, intCtr+13, intCtr2+39, intCtr3+26, intCtr4+39))
                pairSmall[curIdx+13, ] <- sort(c(intCtr, intCtr+13, intCtr2+39, intCtr3+39, intCtr4+26))
                
                # Weight 24 (3): Singletons are suited 1-1-1, two matching to the pairs - 123, 132, 312
                pairSmall[curIdx+14, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+13, intCtr4+26))
                pairSmall[curIdx+15, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4+13))
                pairSmall[curIdx+16, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4+13))
                
                # Weight 24 (3): Singletons are suited 1-1-1, one matching to the pairs - 134, 314, 341
                pairSmall[curIdx+17, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4+39))
                pairSmall[curIdx+18, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4+39))
                pairSmall[curIdx+19, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+39, intCtr4))

                # Increment the index by 20
                curIdx <- curIdx + 20
            }
        }
    }
}


# No Pair becomes even more complicated
# The entire game is in the suits for the singletons
# Weight 4 (1): Singletons all same suit - 11111
# Weight 12 (5): Singletons are suited 4-1 - 11112, 11121, 11211, 12111, 21111
# Weight 12 (10): Singletons are suited 3-2 - 11122, 11212, 11221, 12112, 12121, 
#                                             12211, 21112, 21121, 21211, 22111
# Weight 24 (10): Singletons are suited 3-1-1 - 11123, 11213, 11231, 12113, 12131,
#                                               12311, 21113, 21131, 21311, 23111
# Weight 24 (15): Singletons are suited 2-2-1 - 11223, 12123, 12213, 11232, 12132, 
#                                               12231, 11322, 12312, 12321, 13122, 
#                                               13212, 13221, 31122, 31212, 31221
# Weight 24 (10): Singletons are suited 2-1-1-1 - 11234, 12134, 12314, 12341, 21134, 
#                                                 21314, 21341, 23114, 23141, 23411
noneSmall <- matrix(data=0L, nrow=choose(13, 5)*51, ncol=5)
noneWeight <- rep(c(4, 12, 12, 12, 12, 12, 
                    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 
                    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
                    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
                    24, 24, 24, 24, 24, 24, 24, 24, 24, 24
                    ), times=choose(13, 5)
                  )

mtxAdd <- matrix(data=c(0, 0, 0, 0, 0, 
                        0, 0, 0, 0, 1,
                        0, 0, 0, 1, 0, 
                        0, 0, 1, 0, 0, 
                        0, 1, 0, 0, 0, 
                        1, 0, 0, 0, 0, 
                        0, 0, 0, 1, 1,
                        0, 0, 1, 0, 1,
                        0, 1, 0, 0, 1,
                        1, 0, 0, 0, 1,
                        0, 0, 1, 1, 0,
                        0, 1, 0, 1, 0,
                        1, 0, 0, 1, 0,
                        0, 1, 1, 0, 0,
                        1, 0, 1, 0, 0,
                        1, 1, 0, 0, 0,
                        0, 0, 0, 1, 2,
                        0, 0, 1, 0, 2,
                        0, 1, 0, 0, 2,
                        1, 0, 0, 0, 2,
                        0, 0, 1, 2, 0,
                        0, 1, 0, 2, 0,
                        1, 0, 0, 2, 0,
                        0, 1, 2, 0, 0,
                        1, 0, 2, 0, 0,
                        1, 2, 0, 0, 0,
                        0, 0, 1, 1, 2,
                        0, 1, 0, 1, 2,
                        1, 0, 0, 1, 2,
                        0, 0, 1, 2, 1,
                        0, 1, 0, 2, 1,
                        1, 0, 0, 2, 1,
                        0, 0, 2, 1, 1,
                        0, 1, 2, 0, 1,
                        1, 0, 2, 0, 1,
                        0, 2, 0, 1, 1,
                        0, 2, 1, 0, 1,
                        1, 2, 0, 0, 1,
                        2, 0, 0, 1, 1,
                        2, 0, 1, 0, 1,
                        2, 1, 0, 0, 1,
                        0, 0, 1, 2, 3,
                        0, 1, 0, 2, 3,
                        0, 1, 2, 0, 3,
                        0, 1, 2, 3, 0,
                        1, 0, 0, 2, 3,
                        1, 0, 2, 0, 3,
                        1, 0, 2, 3, 0,
                        1, 2, 0, 0, 3,
                        1, 2, 0, 3, 0,
                        1, 2, 3, 0, 0
                        ) * 13, ncol=5, byrow=TRUE)

curIdx <- 1

for (intCtr in 1:9) {
    for (intCtr2 in (intCtr+1):10) {
        for (intCtr3 in (intCtr2+1):11) {
            for (intCtr4 in (intCtr3+1):12) {
                for (intCtr5 in (intCtr4+1):13) {
                    vecNone <- c(intCtr, intCtr2, intCtr3, intCtr4, intCtr5)
                    mtxNone <- matrix(data=rep(vecNone, times=51), ncol=5, byrow=TRUE)
                    # IMPORTANT - future classification relies on low-high sorting in each row
                    noneSmall[curIdx:(curIdx+50), ] <- 
                        t(apply(mtxNone + mtxAdd, 1, FUN=sort))
                    curIdx <- curIdx + 51
                }
            }
        }
    }
}


```

Next, the hands and weights are integrated to a single hand matrix and a single weighting vector:  
```{r}
jbSmall <- rbind(quadSmall, fhSmall, tripSmall, twoSmall, pairSmall, noneSmall)
jbWeight <- c(quadWeight, fhWeight, tripWeight, twoWeight, pairWeight, noneWeight)

str(jbSmall)
str(jbWeight)

# Confirm that there are sill 52c5 hands after weighting
all.equal(sum(jbWeight), choose(52, 5))

# Confirm that dimensions of hands and weight match up
all.equal(nrow(jbSmall), length(jbWeight))
all.equal(ncol(jbSmall), 5)

# Report the degree of space savings due to the weighting
summary(jbWeight)
```
  
The weighting allows for ~19x reduction in duplication which should speed up the processing time by roughly ~19x.  This is a strong improvement in efficiency.  
  
Next, the jbSmall database is assessed for hand types, using the same approach as with the full database:  
```{r}
 
startTime <- proc.time()


# Declare flushes
smallA <- (jbSmall - 1) %/% 13
smallFlush <- smallA[, 1] == smallA[, 5]

# Get the totals by card rank
smallRank <- matrix(data=0L, nrow=nrow(jbSmall), ncol=13)
for (intCtr in 1:13) {
    smallRank[, intCtr] <- as.integer( rowSums( (jbSmall %% 13) == (intCtr %% 13) ) )
}

# Get the number of unique cards
smallUniques <- rowSums(smallRank > 0)

# Check for straights
smallStraights <- matrix(data=0L, nrow=13, ncol=10)
for (intCtr in 1:9) { smallStraights[intCtr:(intCtr+4), intCtr] <- 1L }
smallStraights[c(1, 10:13), 10] <- 1L
smallCheck <- rowSums( ( (smallRank > 0) %*% smallStraights ) == 5 )

# Is the maximum number of cards equal to 3
smallMax3 <- rowSums(smallRank == 3) == 1


# The basic work has been finished
proc.time() - startTime


# The hand types are declared
smallType <- rep(-1L, nrow(jbSmall))  # Default value is -1

# Manage the pairs - only convert if pair is 1 (Ace) or 11-13 (J, Q, K)
smallHiPair <- smallRank[, 1] == 2 | smallRank[, 11] == 2 | smallRank[, 12] == 2 | smallRank[, 13] == 2
smallType[smallUniques == 4 & smallHiPair] <- 0

# Manage the straights and flushes, including SF and RF
smallType[smallFlush == FALSE & smallUniques == 5 & smallCheck] <- 3  # Straights as 3
smallType[smallFlush == TRUE & !smallCheck] <- 5  # Flushes as 5

# Declare the straight flush and royal flush
rfVector <- c(1L, 10L, 11L, 12L, 0L)
foo <- function(x) {
    if (sum( x %% 13 == rfVector ) ==5 ) { return(799) }
    else { return(49) }
}
smallType[smallFlush == TRUE & smallCheck] <- 
    apply(jbSmall[smallFlush == TRUE & smallCheck, ], 1, FUN=foo)

# Look at the subset that composes Two Pair, Trips, Full House, and Quads
smallType[smallUniques == 3 & !smallMax3] <- 1  # Two Pair
smallType[smallUniques == 3 & smallMax3] <- 2  # Trips
smallType[smallUniques == 2 & smallMax3] <- 8  # Full House
smallType[smallUniques == 2 & !smallMax3] <- 24  # Quads


# The hand declarations have been finished
proc.time() - startTime


library(dplyr)
library(tidyr)
library(ggplot2)

# Need to integrate in the weights!
# Use dplyr and tidyr since they are MUCH faster than table() for the cross-tabs
data.frame(jbType=smallType, wt=jbWeight) %>% group_by(jbType) %>% summarize(count=sum(wt))
data.frame(jbType=smallType, jbUniques=smallUniques, wt=jbWeight) %>% 
    group_by(jbType, jbUniques) %>% 
    summarize(count=sum(wt)) %>%
    spread(jbUniques, count, fill=0)

```
  
With the sorting issue for the 5-singleton hands resolved, the weighted hands are now giving the same counts by initial hand types as the calculations based on the full database.  Processing time has been reduced to ~1 second.  
  
Next, the combinations of holds are assessed with the assumption that cards CAN be replaced, using the same methodology as above:  
```{r}

smallNrowArray0 <- data.frame(jbType=smallType) %>% 
    group_by(jbType) %>% 
    summarize(ct=n()) %>%
    arrange(jbType)
smallNrowArray0

if (nrow(smallNrowArray0) > 16) { 
    stop(paste0("There are too many hand types, cap is 16, this will have: ", nrow(smallNrowArray0)))
}
print("OK")

# Initialize smallArray1-smallArray5
smallArray1 <- matrix(data=0L, nrow=choose(52, 4), ncol=16)
smallArray2 <- matrix(data=0L, nrow=choose(52, 3), ncol=16)
smallArray3 <- matrix(data=0L, nrow=choose(52, 2), ncol=16)
smallArray4 <- matrix(data=0L, nrow=choose(52, 1), ncol=16)
smallArray5 <- matrix(data=0L, nrow=choose(52, 0), ncol=16)

# Create smallArray0 which will have an index number corresponding to the associated smallType
smallArray0 <- match(smallType, smallNrowArray0[[1]])


startTime <- proc.time()

dim(jbSmall)
length(smallArray0)
data.frame(array0=smallArray0, wt=jbWeight) %>% 
    group_by(array0) %>% 
    summarize(ct=n(), hands=sum(wt), dup=round(hands/ct, 1)) %>% 
    arrange(-array0)

proc.time() - startTime


# Fill the array (smallArray5 as 1 x 16) for keeping nothing
startTime <- proc.time()

a <- data.frame(val=smallArray0, wt=jbWeight) %>% group_by(val) %>% 
    summarize(ct=n(), hands=sum(wt)) %>% arrange(val)

# Want the weighted counts
for ( intCtr in seq_along(unique(a$val)) ) {
    smallArray5[1, intCtr] <- a$hands[a$val == intCtr]
}

proc.time() - startTime


# Test keeping a single card, and fill the array (smallArray4 as 52 x 16) for keeping 1
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
hands <- integer(0)
for (c1 in 1:5) {
    temp <- data.frame(card1=jbSmall[, c1], val=smallArray0, wt=jbWeight) %>% 
        group_by(card1, val) %>%
        summarize(ct=n(), hands=sum(wt)) %>%
        arrange(card1, val)
    
    temp$idx <- temp$card1
    
    idx <- c(idx, temp$idx)
    val <- c(val, temp$val)
    ct <- c(ct, temp$ct)
    hands <- c(hands, temp$hands)
    
}

a <- data.frame(idx=idx, val=val, ct=ct, hands=hands) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct), hands=sum(hands))

for ( intCtr in seq_along(unique(a$val)) ) {
    smallArray4[a$idx[a$val == intCtr], intCtr] <- a$hands[a$val == intCtr]
}

proc.time() - startTime


# Test keeping two cards, and fill the array (smallArray3 as 1,326 x 16) for keeping two cards
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
hands <- integer(0)
for (c1 in 1:4) {
    for (c2 in (c1+1):5) {
        temp <- data.frame(card1=jbSmall[, c1], card2=jbSmall[, c2], val=smallArray0, wt=jbWeight) %>% 
            group_by(card1, card2, val) %>%
            summarize(ct=n(), hands=sum(wt)) %>%
            arrange(card1, card2, val)
    
        temp$idx <- idxCard2(c1=temp$card1, c2=temp$card2)
    
        idx <- c(idx, temp$idx)
        val <- c(val, temp$val)
        ct <- c(ct, temp$ct)
        hands <- c(hands, temp$hands)
    
    }
}

a <- data.frame(idx=idx, val=val, ct=ct, hands=hands) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct), hands=sum(hands))

for ( intCtr in seq_along(unique(a$val)) ) {
    smallArray3[a$idx[a$val == intCtr], intCtr] <- a$hands[a$val == intCtr]
}

proc.time() - startTime


# Test keeping three cards, and fill the array (smallArray2 as 22,100 x 16) for keeping three cards
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
hands <- integer(0)
for (c1 in 1:3) {
    for (c2 in (c1+1):4) {
        for (c3 in (c2+1):5) {
            temp <- data.frame(card1=jbSmall[, c1], card2=jbSmall[, c2], 
                               card3=jbSmall[, c3], val=smallArray0, wt=jbWeight
                               ) %>% 
                group_by(card1, card2, card3, val) %>%
                summarize(ct=n(), hands=sum(wt)) %>%
                arrange(card1, card2, card3, val)
    
            temp$idx <- idxCard3(c1=temp$card1, c2=temp$card2, c3=temp$card3)
    
            idx <- c(idx, temp$idx)
            val <- c(val, temp$val)
            ct <- c(ct, temp$ct)
            hands <- c(hands, temp$hands)
    
        }
    }
}

a <- data.frame(idx=idx, val=val, ct=ct, hands=hands) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct), hands=sum(hands))

for ( intCtr in seq_along(unique(a$val)) ) {
    smallArray2[a$idx[a$val == intCtr], intCtr] <- a$hands[a$val == intCtr]
}

proc.time() - startTime


# Test keeping four cards, and fill the array (smallArray1 as 270,725 x 16) for keeping four cards
startTime <- proc.time()

idx <- integer(0)
val <- integer(0)
ct <- integer(0)
hands <- integer(0)
for (c1 in 1:2) {
    for (c2 in (c1+1):3) {
        for (c3 in (c2+1):4) {
            for (c4 in (c3+1):5) {
                temp <- data.frame(card1=jbSmall[, c1], card2=jbSmall[, c2], 
                                   card3=jbSmall[, c3], card4=jbSmall[, c4], 
                                   val=smallArray0, wt=jbWeight
                                   ) %>% 
                    group_by(card1, card2, card3, card4, val) %>%
                    summarize(ct=n(), hands=sum(wt)) %>%
                    arrange(card1, card2, card3, card4, val)
    
                temp$idx <- idxCard4(c1=temp$card1, c2=temp$card2, 
                                     c3=temp$card3, c4=temp$card4
                                     )
    
                idx <- c(idx, temp$idx)
                val <- c(val, temp$val)
                ct <- c(ct, temp$ct)
                hands <- c(hands, temp$hands)
            
            }
        }
    }
}

a <- data.frame(idx=idx, val=val, ct=ct, hands=hands) %>%
    group_by(idx, val) %>% summarize(ct=sum(ct), hands=sum(hands))

for ( intCtr in seq_along(unique(a$val)) ) {
    smallArray1[a$idx[a$val == intCtr], intCtr] <- a$hands[a$val == intCtr]
}

proc.time() - startTime

```
  
This process takes ~2 seconds, a significant improvement in processing time.  Next, optimal holds are declared and assessed:  
```{r}
startTime <- proc.time()

# Convert each of the arrays to a value
mapArray <- matrix(data=c(-1, 0, 1, 2, 3, 5, 8, 24, 49, 799, 0, 0, 0, 0, 0, 0), ncol=1)
dim(mapArray)

smallEV5 <- (smallArray5 %*% mapArray) / rowSums(smallArray5)
smallEV4 <- (smallArray4 %*% mapArray) / rowSums(smallArray4)
smallEV3 <- (smallArray3 %*% mapArray) / rowSums(smallArray3)
smallEV2 <- (smallArray2 %*% mapArray) / rowSums(smallArray2)
smallEV1 <- (smallArray1 %*% mapArray) / rowSums(smallArray1)
smallEV0 <- matrix(data=mapArray[smallArray0, 1], ncol=1)

# Some indexing combinations do not exist due to the de-dups; make these a straight -2 EV
smallEV2[is.na(smallEV2)] <- -2
smallEV1[is.na(smallEV1)] <- -2

# Evaluate all the draw-0 options
smallDraw0 <- matrix(data=smallEV0, ncol=1)

# Evaluate all the draw-5 options
smallDraw5 <- matrix(data=smallEV5, nrow=nrow(jbSmall), ncol=1)

# Evaluate all the draw-4 options
keyData <- integer(0)
for (intCtr in 1:5) {
    keyData <- c(keyData, smallEV4[jbSmall[, intCtr], 1, drop=TRUE])
}
smallDraw4 <- matrix(data=keyData, ncol=5, byrow=FALSE)

# Evaluate all the draw-3 options
keyData <- integer(0)
for (intCtr in 1:4) {
    for (intCtr2 in (intCtr+1):5) {
        keyData <- c(keyData, 
                     smallEV3[idxCard2( c1=jbSmall[ , intCtr], c2=jbSmall[ , intCtr2] ), 
                             1, drop=TRUE]
                     )
    }
}
smallDraw3 <- matrix(data=keyData, ncol=10, byrow=FALSE)

# Evaluate all the draw-2 options
keyData <- integer(0)
for (intCtr in 1:3) {
    for (intCtr2 in (intCtr+1):4) {
        for (intCtr3 in (intCtr2+1):5) {
            keyData <- c(keyData, 
                         smallEV2[idxCard3( c1=jbSmall[, intCtr], c2=jbSmall[, intCtr2] ,
                                           c3=jbSmall[, intCtr3]
                                          ), 1, drop=TRUE]
                         )
        }
    }
}
smallDraw2 <- matrix(data=keyData, ncol=10, byrow=FALSE)

# Evaluate all the draw-1 options
keyData <- integer(0)
for (intCtr in 1:2) {
    for (intCtr2 in (intCtr+1):3) {
        for (intCtr3 in (intCtr2+1):4) {
            for (intCtr4 in (intCtr3+1):5) {
                keyData <- c(keyData, 
                             smallEV1[idxCard4( c1=jbSmall[, intCtr], c2=jbSmall[, intCtr2] ,
                                               c3=jbSmall[, intCtr3], c4=jbSmall[, intCtr4]
                                              ), 1, drop=TRUE]
                            )
            }
        }
    }
}
smallDraw1 <- matrix(data=keyData, ncol=5, byrow=FALSE)

# Integrate the drawing summaries and find the best option by row
cmbSmallDraw <- cbind(smallDraw0, smallDraw1, smallDraw2, 
                      smallDraw3, smallDraw4, smallDraw5
                      )

# Assess the best option by row
cmbSmallBest <- apply(cmbSmallDraw, 1, FUN=function(x) { c( which.max(x), max(x) ) } )

# Need the weighted versions for later!
cmbWeightIndex <- rep(cmbSmallBest[1, ], times=jbWeight)
cmbWeightEV <- rep(cmbSmallBest[2, ], times=jbWeight)

hist(cmbWeightIndex, breaks=0:33, col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
                                         rep("lightgreen", 10), rep("red", 5), rep("black", 1) ) )
summary(cmbWeightEV)


proc.time() - startTime

```
  
This runs reasonably quickly, though there is still a need to work on the weightings.

The next edit will be to create the full grid of hand values, then to only run these specific subset of hands through the algorithm.

An attempt is made using combinatorics to speed up the creation of the initial jbUniques database:  
```{r}

startTime <- proc.time()


# # Create the first column by repeating c1 (53-c1)c4 - (52-c1)c3 times
# jbHandsCol1 <- rep(1:48, choose(53 - (1:48), 4) - choose(52 - (1:48), 3))
# 
# # Loop through by each combination of first card - second card has (53-c2)c3 - (52-c2)c2 times
# jbHandsCol2 <- integer(0)
# for (intCtr in 2:49) {
#     jbHandsCol2 <- c(jbHandsCol2, 
#                      rep(intCtr:49, 
#                          choose(53 - (intCtr:49), 3) - choose(52 - (intCtr:49), 2)
#                          )
#                      )
# }
# 
# # Loop through by each combination of second card - third card has (53-c3)c2 - (52-c3)c1 times
# jbHandsCol3 <- vector("integer", length=length(jbHandsCol2))
# for (intCtr in 3:50) {
#     baseRep <- choose(53 - (intCtr:50), 2) - choose(52 - (intCtr:50), 1)
#     baseInt <- rep(intCtr:50, baseRep)
#     jbHandsCol3[jbHandsCol2 == (intCtr-1)] <- rep(baseInt, intCtr-2)
# }
# 
# # Loop through by each combination of third card - fourth card has (53-c3)c1 - (52-c3)c0 times
# jbHandsCol4 <- vector("integer", length=length(jbHandsCol3))
# for (intCtr in 4:51) {
#     baseRep <- choose(53 - (intCtr:51), 1) - choose(52 - (intCtr:51), 0)
#     baseInt <- rep(intCtr:51, baseRep)
#     jbHandsCol4[jbHandsCol3 == (intCtr-1)] <- rep(baseInt, (intCtr - 3) * (intCtr - 2) / 2)
# }
# 
# # Loop through each combination of fourth card and install (c4+1):52
# jbHandsCol5 <- vector("integer", length=length(jbHandsCol4))
# for (intCtr in 5:52) {
#     jbHandsCol5[jbHandsCol4 == (intCtr-1)] <- 
#         rep(intCtr:52, sum(jbHandsCol4 == (intCtr-1)) / (53-intCtr))
# }

a <- t(combn(1:52, 5))
str(a)


proc.time() - startTime


# Verify they are the same
sum(a != jbHands)

# Find the ranks and suits
aRanks <- 1 + (a-1) %% 13
aSuits <- (a-1) %/% 13
    
# Find the flushes
aFlush <- aSuits[, 1] == aSuits[, 5]

# Find the straights
strMatrix <- matrix(data=0L, nrow=13, ncol=10)
strMatrix[c(1, 10, 11, 12, 13), 1] <- 1L
for (intCtr in 1:9) { strMatrix[intCtr:(intCtr+4), intCtr+1] <- 1L }

aRankCount <- matrix(data=-1L, nrow=choose(52, 5), ncol=13)
for (intCtr in 1:13) { aRankCount[, intCtr] <- rowSums(aRanks == intCtr) }

# Find max and count of ranks (sufficient to determine quds, full houses, trips, two pair, and pair)
aQuads <- rowSums(aRankCount == 4)
aTrips <- rowSums(aRankCount == 3)
aPairs <- rowSums(aRankCount == 2)
aHiPair <- rowSums(aRankCount[, c(1, 11, 12, 13)] == 2)
aStraight <- rowSums( ((aRankCount == 1) %*% strMatrix) == 5)

aType <- rep(-1L, choose(52, 5))

# Declare types
aType[aFlush == 1 & aStraight == 1 & aRankCount[, 1] == 1 & 
          aRankCount[, 13] == 1] <- 799  # Royal Flush
aType[aFlush == 1 & aStraight == 1 & 
          (aRankCount[, 1] == 0 | aRankCount[, 13] == 0)] <- 49  # Straight Flush
aType[aQuads == 1] <- 24  # Quads
aType[aTrips == 1 & aPairs == 1] <- 8  # Full House
aType[aFlush == 1 & aStraight == 0] <- 5  # Flush
aType[aFlush == 0 & aStraight == 1] <- 3  # Straight
aType[aTrips == 1 & aPairs == 0] <- 2  # Trips
aType[aPairs == 2] <- 1  # Two Pair
aType[aTrips == 0 & aPairs == 1 & aHiPair == 1] <- 0  # High Pair


# sum(jbHandsCol1 != jbHands[, 1])
# sum(jbHandsCol2 != jbHands[, 2])
# sum(jbHandsCol3 != jbHands[, 3])
# sum(jbHandsCol4 != jbHands[, 4])
# sum(jbHandsCol5 != jbHands[, 5])


proc.time() - startTime


data.frame(aType=aType, jbType=jbType) %>% 
    group_by(aType, jbType) %>% 
    arrange(-aType) %>% 
    summarize(ct=n())

```
  
The simple use of combn() cuts the run time by half!  The more straightforward use of == further helps to cut the run time.  The results are the same.