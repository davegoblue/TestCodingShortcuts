---
title: "Weather Modeling"
author: "davegoblue"
date: "6/18/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
The file 'WeatherEDA_202005_v002.Rmd' contains exploratory data analysis for historical weather data as contained in METAR archives hosted by Iowa State University.

Data have been dowloaded, processed, cleaned, and integrated for several stations (airports) and years, with .rds files saved in "./RInputFiles/ProcessedMETAR".

This module will perform initial modeling on the processed weather files.  It builds on the previous 'WeatherModeling_202006_v001.Rmd' and leverages functions in 'WeatherModelingFunctions_v001.R'.

#### _Data Availability_  
There are three main processed files available for further exploration:  
  
_metar_postEDA_20200617.rds and metar_postEDA_extra_20200627.rds_  
  
* source (chr) - the reporting station and time  
* locale (chr) - the descriptive name for source  
* dtime (dttm) - the date-time for the observation  
* origMETAR (chr) - the original METAR associated with the observation at that source and date-time  
* year (dbl) - the year, extracted from dtime  
* monthint (dbl) - the month, extracted from dtime, as an integer  
* month (fct) - the month, extracted from dtime, as a three-character abbreviation (factor)  
* day (int) - the day of the month, extracted from dtime  
* WindDir (chr) - previaling wind direction in degrees, stored as a character since 'VRB' means variable  
* WindSpeed (int) - the prevailing wind speed in knots  
* WindGust (dbl) - the wind gust speed in knots (NA if there is no recorded wind gust at that hour)  
* predomDir (chr) - the predominant wind direction as NE-E-SE-S-SW-W-NW-N-VRB-000-Error  
* Visibility (dbl) - surface visibility in statute miles  
* Altimeter (dbl) - altimeter in inches of mercury  
* TempF (dbl) - the Fahrenheit temperature  
* DewF (dbl) - the Fahrenheit dew point  
* modSLP (dbl) - Sea-Level Pressure (SLP), adjusted to reflect that SLP is recorded as 0-1000 but reflects data that are 950-1050  
* cTypen (chr) - the cloud type of the nth cloud layer (FEW, BKN, SCT, OVC, or VV)  
* cLeveln (dbl) - the cloud height in feet of the nth cloud layer  
* isRain (lgl) - was rain occurring at the moment the METAR was captured?  
* isSnow (lgl) - was snow occurring at the moment the METAR was captured?  
* isThunder (lgl) - was thunder occurring at the moment the METAR was captured?  
* p1Inches (dbl) - how many inches of rain occurred in the past hour?  
* p36Inches (dbl) - how many inches of rain occurred in the past 3/6 hours (3-hour summaries at 3Z-9Z-15Z-21Z and 6-hour summaries at 6Z-12Z-18Z-24Z and NA at any other Z times)?  
* p24Inches (dbl) - how many inches of rain occurred in the past 24 hours (at 12Z, NA at all other times)  
* tempFHi (dbl) - the high temperature in the past 24 hours, in Fahrenheit (reported once per day)  
* tempFLo (dbl) - the low temperature in the past 24 hours, in Fahrenheit (reported once per day)  
* minHeight (dbl) - the minimum cloud height in feet (-100 means 'no clouds')  
* minType (fct) - amount of obscuration at the minimum cloud height (VV > OVC > BKN > SCT > FEW > CLR)  
* ceilingHeight (dbl) - the minimum cloud ceiling in feet (-100 means 'no ceiling')  
* ceilingType (fct) - amount of obscuration at the minimum ceiling height (VV > OVC > BKN)  
  
_metar_modifiedClouds_20200617.rds and metar_modifiedclouds_extra_20200627.rds_  
  
* source (chr) - the reporting station and time  
* sourceName (chr) - the descriptive name for source  
* dtime (dttm) - the date-time for the observation  
* level (dbl) - cloud level (level 0 is inserted for every source-dtime as a base layer of clear)  
* height (dbl) - level height (height -100 is inserted for every source-dtime as a base layer of clear)  
* type (dbl) - level type (type CLR is inserted for every source-dtime as a base layer of clear)  
  
_metar_precipLists_20200617.rds and metar_precipLists_extra_20200627.rds_  
  
* Contains elements for each of rain/snow/thunder for each of 2015/2016/2017  
* Each element contains a list and a tibble  
* The tibble is precipLength and contains precipitation by month as source-locale-month-hours-events  
* The list is precipList and contains data on each precipitation interval  
  
Several mapping files are defined for use in plotting; tidyverse, lubridate, and caret are loaded; and the relevant functions are sourced:  
```{r}

# The process frequently uses tidyverse, lubridate, caret, and randomForest
library(tidyverse)
library(lubridate)
library(caret)
library(randomForest)


# The main path for the files
filePath <- "./RInputFiles/ProcessedMETAR/"


# Sourcing functions
source("./WeatherModelingFunctions_v001.R")


# Descriptive names for key variables
varMapper <- c(source="Original source file name", 
               locale="Descriptive name",
               dtime="Date-Time (UTC)",
               origMETAR="Original METAR",
               year="Year",
               monthint="Month",
               month="Month", 
               day="Day of Month",
               WindDir="Wind Direction (degrees)", 
               WindSpeed="Wind Speed (kts)",
               WindGust="Wind Gust (kts)",
               predomDir="General Prevailing Wind Direction",
               Visibility="Visibility (SM)", 
               Altimeter="Altimeter (inches Hg)",
               TempF="Temperature (F)",
               DewF="Dew Point (F)", 
               modSLP="Sea-Level Pressure (hPa)", 
               cType1="First Cloud Layer Type", 
               cLevel1="First Cloud Layer Height (ft)",
               isRain="Rain at Observation Time",
               isSnow="Snow at Observation Time",
               isThunder="Thunder at Obsevation Time",
               tempFHi="24-hour High Temperature (F)",
               tempFLo="24-hour Low Temperature (F)",
               minHeight="Minimum Cloud Height (ft)",
               minType="Obscuration Level at Minimum Cloud Height",
               ceilingHeight="Minimum Ceiling Height (ft)",
               ceilingType="Obscuration Level at Minimum Ceiling Height", 
               hr="Hour of Day (Zulu time)",
               hrfct="Hour of Day (Zulu time)",
               hrBucket="Hour of Day (Zulu time) - rounded to nearest 3",
               locNamefct="Locale Name"
               )


# File name to city name mapper
cityNameMapper <- c(katl_2016="Atlanta, GA (2016)",
                    kbos_2016="Boston, MA (2016)", 
                    kdca_2016="Washington, DC (2016)", 
                    kden_2016="Denver, CO (2016)", 
                    kdfw_2016="Dallas, TX (2016)", 
                    kdtw_2016="Detroit, MI (2016)", 
                    kewr_2016="Newark, NJ (2016)",
                    kgrb_2016="Green Bay, WI (2016)",
                    kgrr_2016="Grand Rapids, MI (2016)",
                    kiah_2016="Houston, TX (2016)",
                    kind_2016="Indianapolis, IN (2016)",
                    klas_2014="Las Vegas, NV (2014)",
                    klas_2015="Las Vegas, NV (2015)",
                    klas_2016="Las Vegas, NV (2016)", 
                    klas_2017="Las Vegas, NV (2017)", 
                    klas_2018="Las Vegas, NV (2018)",
                    klas_2019="Las Vegas, NV (2019)",
                    klax_2016="Los Angeles, CA (2016)", 
                    klnk_2016="Lincoln, NE (2016)",
                    kmia_2016="Miami, FL (2016)", 
                    kmke_2016="Milwaukee, WI (2016)",
                    kmsn_2016="Madison, WI (2016)",
                    kmsp_2016="Minneapolis, MN (2016)",
                    kmsy_2014="New Orleans, LA (2014)",
                    kmsy_2015="New Orleans, LA (2015)",
                    kmsy_2016="New Orleans, LA (2016)", 
                    kmsy_2017="New Orleans, LA (2017)", 
                    kmsy_2018="New Orleans, LA (2018)",
                    kmsy_2019="New Orleans, LA (2019)",
                    kord_2014="Chicago, IL (2014)",
                    kord_2015="Chicago, IL (2015)",
                    kord_2016="Chicago, IL (2016)", 
                    kord_2017="Chicago, IL (2017)", 
                    kord_2018="Chicago, IL (2018)",
                    kord_2019="Chicago, IL (2019)",
                    kphl_2016="Philadelphia, PA (2016)", 
                    kphx_2016="Phoenix, AZ (2016)", 
                    ksan_2014="San Diego, CA (2014)",
                    ksan_2015="San Diego, CA (2015)",
                    ksan_2016="San Diego, CA (2016)",
                    ksan_2017="San Diego, CA (2017)",
                    ksan_2018="San Diego, CA (2018)",
                    ksan_2019="San Diego, CA (2019)",
                    ksat_2016="San Antonio, TX (2016)", 
                    ksea_2016="Seattle, WA (2016)", 
                    ksfo_2016="San Francisco, CA (2016)", 
                    ksjc_2016="San Jose, CA (2016)",
                    kstl_2016="Saint Louis, MO (2016)", 
                    ktpa_2016="Tampa Bay, FL (2016)", 
                    ktvc_2016="Traverse City, MI (2016)"
                    )

# File names in 2016, based on cityNameMapper
names_2016 <- grep(names(cityNameMapper), pattern="[a-z]{3}_2016", value=TRUE)

```
  
The main data will be from the metar_postEDA files.  They are integrated below, and cloud and ceiling heights are converted to factors:  
```{r}

# Main weather data
metarData <- readRDS("./RInputFiles/ProcessedMETAR/metar_postEDA_20200617.rds") %>%
    bind_rows(readRDS("./RInputFiles/ProcessedMETAR/metar_postEDA_extra_20200627.rds")) %>%
    mutate(orig_minHeight=minHeight, 
           orig_ceilingHeight=ceilingHeight, 
           minHeight=mapCloudHeight(minHeight), 
           ceilingHeight=mapCloudHeight(ceilingHeight)
           )
glimpse(metarData)

```

#### _Initial Exploration_  
An initial exploration of the data can use hierarchical clustering based on several numerical features of the data (temperature, dew point, sea-level pressure, wind speed) by month.

Example code includes:  
```{r}

# Create hierarchical clustering for 2016 data
# Distance is calculated only where month is the same
distData <- metarData %>% 
    filter(year==2016) %>%
    select(locale, month, TempF, DewF, modSLP, WindSpeed) %>%
    group_by(locale, month) %>% 
    summarize_if(is.numeric, mean, na.rm=TRUE) %>% 
    ungroup() %>% 
    mutate(rowname=paste0(locale, "_", month)) %>% 
    column_to_rownames() %>% 
    select(-locale, -month) %>% 
    as.matrix() %>% 
    scale() %>% 
    dist() %>% 
    as.matrix() %>% 
    as.data.frame() %>%
    rownames_to_column(var="locale1") %>% 
    pivot_longer(-locale1, names_to="locale2", values_to="dist") %>% 
    mutate(city1=str_replace(locale1, "_\\w{3}", ""), 
           city2=str_replace(locale2, "_\\w{3}", ""), 
           month1=str_sub(locale1, -3), 
           month2=str_sub(locale2, -3)) %>%
    filter(month1==month2) %>% 
    group_by(city1, city2) %>% 
    summarize(meandist=mean(dist), sddist=sd(dist)) %>% 
    ungroup() %>% 
    select(-sddist) %>% 
    pivot_wider(city1, names_from="city2", values_from="meandist") %>%
    column_to_rownames(var="city1") %>%
    as.matrix() %>%
    as.dist(diag=FALSE)

distData %>%
    hclust(method="complete") %>%
    plot()

distData %>%
    hclust(method="single") %>%
    plot()

```
  
At a glance, there are several sensible findings from the clustering:  
  
* Two combinations of cities in close geographic proximity (Newark and Philadelphia; Chicago and Milaukee) show the greatest similarity in the clustering  
* A cluster of coastal California cities (San Diego, Los Angeles, San Jose) show strong similarities  
* A cluster of hot-humid cities (Houston-New Orleans and then soon Miami-Tampa) show strong similarities  
* Several clusters of cold-weather cities emerge  
* Two desert cities (Las Vega, Phoenix) show similarities  
  
There are a handful of cities that do not seem to cluster with anything else:  
  
* Denver, Boston, Seattle, San Francisco  
  
#### _Temperature and Dew Point_  
Suppose that the only information available about two cities were their temperatures and dew points, with month also included.  How well would a basic random forest, with mtry=3, classify the cities?

The function is then run for every combination of locales from 2016 in cityNameMapper.  A common random seed is applied to every run of the process:  
```{r cache=TRUE}

# Create a container list to hold the output
list_2016_TempF_DewF_month <- vector("list", 0.5*length(names_2016)*(length(names_2016)-1))

set.seed(2006281443)

n <- 1
for (ctr in 1:(length(names_2016)-1)) {
    for (ctr2 in (ctr+1):length(names_2016)) {
        list_2016_TempF_DewF_month[[n]] <- rfTwoLocales(metarData, 
                                                        loc1=names_2016[ctr], 
                                                        loc2=names_2016[ctr2], 
                                                        vrbls=c("TempF", "DewF", "month"),
                                                        ntree=25
                                                        )
        n <- n + 1
        if ((n %% 50) == 0) { cat("Through number:", n, "\n")}
    }
}

```
  
Accuracy can then be assessed:  
```{r}

# Create a tibble from the underlying accuracy data
acc_TempF_DewF_month <- map_dfr(list_2016_TempF_DewF_month, .f=helperAccuracyLocale)

# Assess the top 10 classification accuracies
acc_TempF_DewF_month %>%
    arrange(-accOverall) %>%
    head(10)

# Assess the bottom 10 classification accuracies
acc_TempF_DewF_month %>%
    arrange(accOverall) %>%
    head(10)


allAccuracy_month <- select(acc_TempF_DewF_month, 
                            locale=locale1, 
                            other=locale2, 
                            accOverall, 
                            accLocale=accLocale1
                            ) %>%
    bind_rows(select(acc_TempF_DewF_month, 
                     locale=locale2, 
                     other=locale1, 
                     accOverall, 
                     accLocale=accLocale2
                     )
              )

# Overall accuracy by location plot
allAccuracy_month %>%
    group_by(locale) %>%
    summarize_if(is.numeric, mean) %>%
    ggplot(aes(x=fct_reorder(locale, accOverall), y=accOverall)) + 
    geom_point(size=2) + 
    geom_text(aes(y=accOverall+0.02, label=paste0(round(100*accOverall), "%"))) +
    coord_flip() + 
    labs(x="", 
         y="Average Accuracy", 
         title="Average Accuracy Predicting Locale",
         subtitle="Predictions made 1:1 to each other locale (average accuracy reported)",
         caption="Temperature, Dew Point, Month as predictors\n(50% is baseline coinflip accuracy)"
         ) + 
    ylim(c(0.5, 1))

# Overall accuracy heatmap (FIX for better ordering of locales)
# allAccuracy_month %>% 
#     ggplot(aes(x=locale, y=other)) + 
#     geom_tile(aes(fill=accOverall)) + 
#     theme(axis.text.x=element_text(angle=90)) + 
#     scale_fill_continuous("Accuracy", high="darkblue", low="white") + 
#     labs(title="Accuracy Predicting Locale vs. Locale", 
#          caption="Temperature, Dew Point, and Month as predictors\n(50% is baseline coinflip accuracy)",
#          x="",
#          y=""
#          )

```
  
Accuracy is best for cities with significantly different locales.  The model is especially successful at pulling apart the desert cities (Las Vegas, Phoenix) from everything else, and the humid Florida cities (Miami, Tampa Bay) from everything else.
  
Next, the simple model is run to classify locale across the full 2016 dataset:  
```{r cache=TRUE}

# Run random forest for all 2016 locales
rf_all_2016_TDm <- rfMultiLocale(metarData, 
                                 vrbls=c("TempF", "DewF", "month"),
                                 locs=names_2016, 
                                 ntree=50, 
                                 seed=2006281508
                                 )

```
  
Summaries can then be created for the accuracy in predicting each locale:  
```{r}

evalPredictions(rf_all_2016_TDm, plotCaption = "Temp, Dew Point, Month, Cloud/Ceiling Height")

```
  
Accuracy is meaningfully increased compared to the null accuracy, though there is still under 50% accuracy in classifying any locale.  This is suggestive that the goal will be to define some archetype climates, and to use those for predicting (e.g., humid, cold, desert, etc.).
  
Clouds (minimum levels and ceiling heights) can potentially help further differentiate the cold weather cities on the downwind side of the lake, as well as helping to further pull apart various marine and mid-continental climates.

An updated random forest model is then run:  
```{r cache=TRUE}

# Run random forest for all 2016 locales
rf_all_2016_TDmc <- rfMultiLocale(metarData, 
                                  vrbls=c("TempF", "DewF", "month", "minHeight", "ceilingHeight"),
                                  locs=names_2016, 
                                  ntree=50, 
                                  seed=2006281509
                                  )

```
  
The evaluation process is converted to a function:  
```{r}

evalPredictions(rf_all_2016_TDmc, plotCaption = "Temp, Dew Point, Month, Cloud/Ceiling Height")

# Get the comparison to previous accuracy
deltaAccuracy(prevObject=rf_all_2016_TDm, currObject=rf_all_2016_TDmc)

```
  
Accuracy increases meaningfully, though still well under 50% in most cases.
  
The model can also be built out to consider wind speed and wind direction.  No attempt yet is made to control for over-fitting:  
```{r cache=TRUE}

# Run random forest for all 2016 locales
rf_all_2016_TDmcw <- rfMultiLocale(metarData, 
                                   vrbls=c("TempF", "DewF", 
                                           "month", 
                                           "minHeight", "ceilingHeight", 
                                           "WindSpeed", "predomDir"
                                           ),
                                   locs=names_2016, 
                                   ntree=50, 
                                   seed=2006281934
                                   )

```
  
The evaluation process can again be run:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_all_2016_TDmcw, 
                plotCaption = "Temp, Dew Point, Month, Cloud/Ceiling Height, Wind Speed/Direction"
                )

# Get the comparison to previous accuracy
deltaAccuracy(prevObject=rf_all_2016_TDmc, currObject=rf_all_2016_TDmcw)

```
  
Including wind significantly improves model accuracy for many locales.  Even the cold weather cities are now being predicted with around 30%-40% accucacy.
  
The model can also be built out to consider hour of day and sea-level pressure.  No attempt yet is made to control for over-fitting, with the exception that mtry is held at 4:  
```{r cache=TRUE}

# Run random forest for all 2016 locales
rf_all_2016_TDmcwa <- rfMultiLocale(metarData, 
                                    vrbls=c("TempF", "DewF", 
                                            "month",
                                            "minHeight", "ceilingHeight", 
                                            "WindSpeed", "predomDir",
                                            "modSLP"
                                            ),
                                    locs=names_2016, 
                                    ntree=50, 
                                    mtry=4,
                                    seed=2006282103
                                    )

```
  
The evaluation process can again be run:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_all_2016_TDmcwa, 
                plotCaption = "Temp, Dew Point, Month, Cloud/Ceiling Height, Wind Speed/Direction, SLP"
                )

# Get the comparison to previous accuracy
deltaAccuracy(prevObject=rf_all_2016_TDmcw, currObject=rf_all_2016_TDmcwa)

```
  
Adding sea-level pressure again significantly improves prediction ability.  The cold weather cities are in the roughly 40%-60% accuracy range, and the other cities are in the roughly 60%-80% accuracy range.

Based on the hierarchical clustering and results of the initial random forest models, a few archetype cities are defined in an attempt to pull out distinctions:  
  
* Miami (likely to match with Tampa, New Orleans, and Houston)  
* Las Vegas (likely to match with Phoenix)  
* Los Angeles (likely to match with San Diego and San Jose)  
* Denver (seems potentially isolated)  
* Seattle (seems potentially isolated)  
* Dallas (likely to match to San Antonio)  
* Minneapolis (surrogate for the cold side of cold weather cities)  
* Atlanta (possible to match with DC, St Louis, Indianapolis, but may be too similar to Cold/Miami)  
  
A data subset is created, with "hr" added for the Zulu hour of the observation (as integer rather than as factor):  
```{r}

archeCities <- c("kmia_2016", "klas_2016", "klax_2016", "kden_2016", 
                 "ksea_2016", "kdfw_2016", "kmsp_2016", "katl_2016"
                 )

archeData <- metarData %>%
    filter(source %in% archeCities) %>%
    mutate(hr=lubridate::hour(dtime))

```
  
A random forest, with mtry=4, is then run using all variables from previous, as well as hour:  
```{r cache=TRUE}

# Run random forest for all 2016 locales
rf_arche_2016_TDmcwa <- rfMultiLocale(archeData, 
                                      vrbls=c("TempF", "DewF", 
                                              "month", "hr",
                                              "minHeight", "ceilingHeight", 
                                              "WindSpeed", "predomDir",
                                              "modSLP"
                                              ),
                                      locs=NULL, # defaults to running for all locales
                                      ntree=100, 
                                      mtry=4,
                                      seed=2006291353
                                      )

```
  
The evaluation process can again be run:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_arche_2016_TDmcwa, 
                plotCaption = "Temp, Dew Point, Month/Hour, Cloud/Ceiling Height, Wind Speed/Direction, SLP"
                )

```
  
The model is reasonably successful in pulling apart the archetypes.  Denver and Dallas seem potentially less distinct, though all archetypes cities are predicted at 80%+ accuracy.

The remaining cities can be classified against the archetype data, to explore any patterns that emerge:  
```{r}

localeByArchetype(rf_arche_2016_TDmcwa, 
                  fullData=metarData, 
                  archeCities=archeCities, 
                  sortDescMatch=TRUE
                  )

```
  
There appear to be several issues:  
  
* Atlanta and Dallas are not particularly distinct and do not make for good archetypes (potentially, Miami, Atlanta, and Dallas can all be replaced by Houston); Denver and Seattle are shaky but may be OK  
* Minneapolis may be too cold, driving the midwestern cities to instead classify partially as Denver  
* The model is potentially learning too much about the specific city rather than about archetypes  
  
The first issue is addressed by collapsing Atlanta, Dallas, and Miami and instead using Houston as the archetype; and replacing Minneapolis with Chicago:  
```{r}

archeCities_v02 <- c("kiah_2016", "klas_2016", "klax_2016", 
                     "kden_2016", "ksea_2016", "kord_2016"
                     )

archeData_v02 <- metarData %>%
    filter(source %in% archeCities_v02) %>%
    mutate(hr=lubridate::hour(dtime))

```

A random forest, with mtry=4, is then run using all variables from previous, as well as hour:  
```{r cache=TRUE}

# Run random forest for all 2016 locales in archeData_v02
rf_arche_2016_TDmcwa_v02 <- rfMultiLocale(archeData_v02, 
                                          vrbls=c("TempF", "DewF", 
                                                  "month", "hr",
                                                  "minHeight", "ceilingHeight", 
                                                  "WindSpeed", "predomDir",
                                                  "modSLP"
                                                  ),
                                          locs=NULL, # defaults to running for all locales
                                          ntree=100, 
                                          mtry=4,
                                          seed=2006291448
                                          )

```
  
The evaluation process can again be run:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_arche_2016_TDmcwa_v02, 
                plotCaption = "Temp, Dew Point, Month/Hour, Cloud/Ceiling Height, Wind Speed/Direction, SLP"
                )

```
  
The model is reasonably successful in pulling apart the archetypes.  Houston appears the most distinct (as had Miami previously), and there is less overlap going to/from Denver or Seattle.

The remaining cities can be classified against the archetype data, to explore any patterns that emerge:  
```{r}

localeByArchetype(rf_arche_2016_TDmcwa_v02, 
                  fullData=metarData, 
                  archeCities=archeCities_v02, 
                  sortDescMatch = TRUE
                  )

```
  
At a glance, the archetypes are more sensible.  There is a bit of Denver and a bit of Seattle in most of the cold weather cities, and a bit of Houston in some of the warmer cold weather cities.  This is suggestive that there are either more then one type of cold-weather cities, or that cold-weather cities tend to be like other archetypes are certain times.

The model is run again, deleting Denver and Seattle, and converting Los Angeles to San Diego:  
```{r}

archeCities_v03 <- c("kiah_2016", "klas_2016", "ksan_2016", "kord_2016")

archeData_v03 <- metarData %>%
    filter(source %in% archeCities_v03) %>%
    mutate(hr=lubridate::hour(dtime))

```

A random forest, with mtry=4, is then run using all variables from previous, as well as hour:  
```{r cache=TRUE}

# Run random forest for all 2016 locales in archeData_v03
rf_arche_2016_TDmcwa_v03 <- rfMultiLocale(archeData_v03, 
                                          vrbls=c("TempF", "DewF", 
                                                  "month", "hr",
                                                  "minHeight", "ceilingHeight", 
                                                  "WindSpeed", "predomDir",
                                                  "modSLP"
                                                  ),
                                          locs=NULL, # defaults to running for all locales
                                          ntree=100, 
                                          mtry=4,
                                          seed=2006291459
                                          )

```
  
The evaluation process can again be run:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_arche_2016_TDmcwa_v03, 
                plotCaption = "Temp, Dew Point, Month/Hour, Cloud/Ceiling Height, Wind Speed/Direction, SLP"
                )

```
  
These archetypes are distinct, with accuracies all in the 95% range.  The remaining cities can be classified against the archetype data, to explore any patterns that emerge:  
```{r}

localeByArchetype(rf_arche_2016_TDmcwa_v03,
                  fullData=metarData,
                  archeCities=archeCities_v03,
                  sortDescMatch=TRUE
                  )

```
  
Quite a few cities show as blends of the archetype cities, which is likely correct if archetypes are considered to be Cold, Humid, Marine, Desert.  An open question is whether to expand that list with another 1-2 archetypes that attempt to better capture Atlanta, Dallas, Denver, St Louis, and DC.  

The Marine archetype may need to be converted to Pacific and to better identify the California entities.  

A decision about Seattle is needed, as it is a little like everything and everything is a little like it.
  
To address the issue of the model learning from specific cities rather than archetypes, user-defined clusters will be created, and data from these clusters will be used in modeling:  
  
* Marine - San Diego, Los Angeles in an attempt to train the model to recognize that Marine cities differ meaningfully from Cold cities and Humid cities (San Jose, San Francicso and Seattle are somewhat different climates)  
* Desert - Las Vegas, Phoenix in an attempt to train the model on differences in Desert and Marine  
* Humid - Houston, Miami, New Orleans, Tampa, reflecting that the model is already largely pulling out the humid cities correctly  
* Cold - Chicago, Milwaukee, Grand Rapids, Green Bay, Traverse City, Madison, Detroit, Minneapolis to reflect that the model is largely already pulling out cold cities correctly (Boston excluded for now)  
* South - Atlanta, Dallas, San Antonio in an attempt to pull out southern cities that are not as humid as those along the Gulf Coast  
* Mixed - Indianapolis, Lincoln, St Louis, to reflect cities that have milder winters than Cold but colder winters than South  
* Excluded for now - Denver, Seattle, Boston/Newark/Phialdelphia/DC, San Francisco/San Jose  
  
Further, a variable will be created for "hr", the Zulu hour of the observation:  
```{r}

# Create the locale mapper
locMapperTibble <- tibble::tribble(
    ~source, ~locType,
    'katl_2016', 'South',
    'kbos_2016', 'Exclude',
    'kdca_2016', 'Exclude',
    'kden_2016', 'Exclude',
    'kdfw_2016', 'South',
    'kdtw_2016', 'Cold',
    'kewr_2016', 'Exclude',
    'kgrb_2016', 'Cold',
    'kgrr_2016', 'Cold',
    'kiah_2016', 'Humid',
    'kind_2016', 'Mixed',
    'klas_2016', 'Desert',
    'klax_2016', 'Marine',
    'klnk_2016', 'Mixed',
    'kmia_2016', 'Humid',
    'kmke_2016', 'Cold',
    'kmsn_2016', 'Cold',
    'kmsp_2016', 'Cold',
    'kmsy_2016', 'Humid',
    'kord_2016', 'Cold',
    'kphl_2016', 'Exclude',
    'kphx_2016', 'Desert',
    'ksan_2016', 'Marine',
    'ksat_2016', 'South',
    'ksea_2016', 'Exclude',
    'ksfo_2016', 'Exclude',
    'ksjc_2016', 'Exclude',
    'kstl_2016', 'Mixed',
    'ktpa_2016', 'Humid',
    'ktvc_2016', 'Cold'
)

# Create locMapper
locMapper <- locMapperTibble %>% pull(locType)
names(locMapper) <- locMapperTibble %>% pull(source)
locMapper

# Create the data file with locType
locData_v04 <- metarData %>% 
    mutate(locType=locMapper[source], hr=lubridate::hour(dtime)) %>% 
    filter(year==2016, locType !="Exclude")

# Counts by locType
locData_v04 %>%
    count(locType)

```
  
There is a risk that the model will predict neutral cities as 'Cold' given the 4:1 ratio of Cold cities to Marine/Desert cities.  The random forest model is first run on the data 'as is':    
```{r cache=TRUE}

rf_arche_small_TDmcwa_v04 <- rfMultiLocale(locData_v04, 
                                           vrbls=c("TempF", "DewF", 
                                                   "month", "hr",
                                                   "minHeight", "ceilingHeight", 
                                                   "WindSpeed", "predomDir",
                                                   "modSLP"
                                                   ),
                                           locs=NULL, # defaults to running for all locales
                                           ntree=100, 
                                           locVar="locType", 
                                           pred="locType",
                                           mtry=4, 
                                           otherVar=c("dtime", "source", "locale"),
                                           seed=2006301313
                                           )

```
  
Prediction accuracy is then assessed:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_arche_small_TDmcwa_v04,
                plotCaption = "Temp, Dew Point, Month/Hour, Cloud/Ceiling Height, Wind Speed/Direction, SLP",
                keyVar="locType"
                )

```
  
The designation of Cold, Desert, Humid, and Marine seems successful.  The attempt to split South from Humid resulted in good, if incomplete, separation.  The attempt to separate a group of 'warmer' cold-weather cities from 'colder' cold-weather cities was not particularly successful.  This could partially be an artifact of 'Cold' having double the data volume as 'Mixed'.

Classifications by city can also be examined:  
```{r}

archeCities_v04 <- locMapperTibble %>%
    filter(locType != "Exclude") %>%
    pull(source)

localeByArchetype(rf_arche_small_TDmcwa_v04, 
                  fullData=mutate(metarData, locType=locMapper[source]), 
                  archeCities=archeCities_v04, 
                  sortDescMatch=TRUE
                  )

```
  
Many of the cities are nicely classified in to their assigned archetypes, as desired.  Among the cities used in the classifications, concerns include:  
  
* The cities pre-assigned as South do not seem to cluster so strongly together.  This may not be a good archetype  
* The cities pre-assigned as Mixed do not clutser well, possibly driven by a data volume discrepancy where Cold has more than double the data  
* Remaining cities frequently assign to 2+ archetypes, as expected since weather in the mid-latitudes would not necessarily follow any archetypal pattern on a year-long basis  
  
Classifications are changed somewhat, and data are then filtered so that an equal number of observations from each locale type are applied in the modeling:  
  
* Mixed - deleted, entries will be moved to 'Exclude' to see how they map  
* South - deleted, entries will be moved to 'Exclude' to see how they map  
  
```{r}

# Create the locale mapper
locMapperTibble_v05 <- tibble::tribble(
    ~source, ~locType,
    'katl_2016', 'Exclude',
    'kbos_2016', 'Exclude',
    'kdca_2016', 'Exclude',
    'kden_2016', 'Exclude',
    'kdfw_2016', 'Exclude',
    'kdtw_2016', 'Cold',
    'kewr_2016', 'Exclude',
    'kgrb_2016', 'Cold',
    'kgrr_2016', 'Cold',
    'kiah_2016', 'Humid',
    'kind_2016', 'Exclude',
    'klas_2016', 'Desert',
    'klax_2016', 'Marine',
    'klnk_2016', 'Exclude',
    'kmia_2016', 'Humid',
    'kmke_2016', 'Cold',
    'kmsn_2016', 'Cold',
    'kmsp_2016', 'Cold',
    'kmsy_2016', 'Humid',
    'kord_2016', 'Cold',
    'kphl_2016', 'Exclude',
    'kphx_2016', 'Desert',
    'ksan_2016', 'Marine',
    'ksat_2016', 'Exclude',
    'ksea_2016', 'Exclude',
    'ksfo_2016', 'Exclude',
    'ksjc_2016', 'Exclude',
    'kstl_2016', 'Exclude',
    'ktpa_2016', 'Humid',
    'ktvc_2016', 'Cold'
)

# Create locMapper
locMapper_v05 <- locMapperTibble_v05 %>% pull(locType)
names(locMapper_v05) <- locMapperTibble_v05 %>% pull(source)
locMapper_v05

# Create the data file with locType
locData_v05 <- metarData %>% 
    mutate(locType=locMapper_v05[source], hr=lubridate::hour(dtime)) %>% 
    filter(year==2016, locType !="Exclude")

# Counts by locType
locData_v05 %>%
    count(locType)

```

The data are the filtered so that there are an equal number of observations from each locale type.  The model can later be predicted against the remaining items:  
```{r}

# Set a seed for reporducibility
set.seed(2006301356)

# Find the smallest locale type
nSmall <- locData_v05 %>%
    filter(!is.na(locType)) %>%
    count(locType) %>%
    pull(n) %>%
    min()

# Create the relevant data subset
subData_v05 <- locData_v05 %>%
    filter(!is.na(locType)) %>%
    group_by(locType) %>%
    sample_n(size=nSmall, replace=FALSE) %>%
    ungroup()

# Sumarize the data subset
subData_v05 %>% 
    count(locType, locale) %>% 
    arrange(-n)

```
  
The previous model can then be run on the data subset:  
```{r cache=TRUE}

rf_arche_small_TDmcwa_v05 <- rfMultiLocale(subData_v05, 
                                           vrbls=c("TempF", "DewF", 
                                                   "month", "hr",
                                                   "minHeight", "ceilingHeight", 
                                                   "WindSpeed", "predomDir",
                                                   "modSLP"
                                                   ),
                                           locs=NULL, # defaults to running for all locales
                                           ntree=100, 
                                           locVar="locType", 
                                           pred="locType",
                                           mtry=4, 
                                           otherVar=c("dtime", "source", "locale"),
                                           seed=2006301358
                                           )

```
  
The evaluation process can again be run:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_arche_small_TDmcwa_v05,
                plotCaption = "Temp, Dew Point, Month/Hour, Cloud/Ceiling Height, Wind Speed/Direction, SLP",
                keyVar="locType"
                )

```
  
The archetypes are well-separated, with roughly 95% accuracy in every case.  Predictions can then also be made for all cities, including those not in the modeling:  
```{r}

archeCities_v05 <- locMapperTibble_v05 %>%
    filter(locType != "Exclude") %>%
    pull(source)

localeByArchetype(rf_arche_small_TDmcwa_v05, 
                  fullData=mutate(metarData, locType=locMapper_v05[source]), 
                  archeCities=archeCities_v05, 
                  sortDescMatch=TRUE
                  )

```
  
Broadly speaking, cities used in modeling appear to classify in to the appropriate archetypes.  For the cities not included in the modeling:  
  
* Boston, Lincoln, Indianapolis, Newark, Philadelphia, and Seattle are most closely matched to 'Cold'  
* San Antonio is most closely matched to 'Humid'  
* Denver is a split of Cold/Desert  
* DC and St Louis are a split of Cold/Humid  
* San Francisco and San Jose are most closely matched to 'Marine' with meaningful 'Cold' and 'Humid' also  
* Atlanta and Dallas are roughly split between 'Humid' and 'Cold', with a bit of 'Desert' also  
  
The model can be applied to data from years other than 2016, to see how the classifications are impacted by use in out-of-sample years:  
```{r}

# Predictions on non-2016 data
helperPredictPlot(rf_arche_small_TDmcwa_v05$rfModel, 
                  df=filter(mutate(metarData, hr=lubridate::hour(dtime)), year!=2016), 
                  predOrder=c("Marine", "Humid", "Desert", "Cold"), 
                  locMapper=locMapper_v05
                  )

```
  
Model performance on non-2016 data is not as strong, with roughly a 10%-20% loss of accuracy.  Predictions are still much better than null accuracy, and the model (mostly) continues to separate the archetypes.

Suppose that models are run on all 2015-2018 data for Chicago, Las Vegas, New Orleans, and San Diego:  
```{r}

# Create the subset for Chicago, Las Vegas, New Orleans, San Diego
sub_2015_2018_data <- metarData %>%
    filter(str_sub(source, 1, 4) %in% c("kord", "klas", "kmsy", "ksan"), 
           year %in% c(2015, 2016, 2017, 2018)
           ) %>%
    mutate(city=str_replace(locale, pattern=" .\\d{4}.", replacement=""), 
           hr=lubridate::hour(dtime)
           )

# Check that proper locales are included
sub_2015_2018_data %>% 
    count(city, locale)

```
  
The random forest model is run and cached:  
```{r cache=TRUE}

# Run random forest for 2015-2018 data
rf_types_2015_2018_TDmcwha <- rfMultiLocale(sub_2015_2018_data, 
                                            vrbls=c("TempF", "DewF", 
                                                    "month", "hr",
                                                    "minHeight", "ceilingHeight", 
                                                    "WindSpeed", "predomDir", 
                                                    "modSLP"
                                                    ),
                                            locs=NULL, 
                                            locVar="city",
                                            pred="city",
                                            ntree=50, 
                                            seed=2006301420, 
                                            mtry=4
                                            )

```
  
```{r}

evalPredictions(rf_types_2015_2018_TDmcwha, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, SLP", 
                keyVar="city"
                )

```
  
Even with a small forest (50 trees), the model is almost always separating Las Vegas, Chicago, San Diego, and New Orleans.  While the climates are very different in these cities, it is striking that the model has so few misclassifications.

How do other cities map against these classifications?  
```{r}

# Predictions on 2015/2018 data
helperPredictPlot(rf_types_2015_2018_TDmcwha$rfModel, 
                  df=filter(mutate(metarData, hr=lubridate::hour(dtime)), 
                            !(str_sub(source, 1, 4) %in% c("kord", "klas", "kmsy", "ksan"))
                            ), 
                  predOrder=c("Chicago, IL", "San Diego, CA", "New Orleans, LA", "Las Vegas, NV")
                  )

```
  
Classifications are broadly as expected based on the previous archetype analysis.  Variable importances are plotted:  
```{r}

helperPlotVarImp(rf_types_2015_2018_TDmcwha$rfModel)

```
  
Dew point and temperature by month continue to be strong factors for separating the four cities in this analysis.  SLP, minimum cloud height, and prevailing wind direction are also meaningful.
  
An assessment can be run for the 2015-2018 model:  
```{r}

# Run for the full model including SLP
probs_2015_2018_TDmcwha <- 
    assessPredictionCertainty(rf_types_2015_2018_TDmcwha, 
                              keyVar="city", 
                              plotCaption="Temp, Dew Point, Month/Hour, Clouds, Wind, SLP", 
                              showAcc=TRUE
                              )

```
  
* Predictions with 80%+ of the votes are made ~75% of the time, and these predictions are ~99% accurate  
* Predictions with <80% of the votes are made ~25% of the times, and these predictions are ~80% accurate  
* The percentage of votes received appears to be a reasonable proxy for the confidence of the prediction  
  
A similar process can be run for assessing the classification of the other cities against the 2015-2017 data for Chicago, Las Vegas, New Orleans, and San Diego:  
```{r}

useData <- metarData %>%
    filter(!(str_sub(source, 1, 4) %in% c("kord", "klas", "kmsy", "ksan"))) %>%
    mutate(hr=lubridate::hour(dtime))
    
# Run for the model excluding SLP
probs_allcities_2015_2018_TDmcwh <- 
    assessPredictionCertainty(rf_types_2015_2018_TDmcwha, 
                              testData=useData,
                              keyVar="locale", 
                              plotCaption="Temp, Dew Point, Month/Hour, Clouds, Wind, modSLP", 
                              showHists=TRUE
                              )

```
  
The model is frequently not so confident in assigning an archetype to related cities, though it frequently gets the most sensible assignment.

An assessment is run to look at the evolution of the model as it take in the 'next best' variable for building out the random forest:  
```{r cache=TRUE}

# Define the variables to be considered
possVars <- c("TempF", "DewF", "month", "hr", "minHeight", 
              "ceilingHeight", "WindSpeed", "predomDir", "modSLP"
              )

# Create a container for storing the best random forest and variable added from each run
rfContainer <- vector("list", length=length(possVars))
rfVarAdds <- vector("character", length=length(possVars))

# Run the functions using a for loop over the length of possVars
for (ctr in 1:length(possVars)) {
    
    # Pull in the results of the previous run
    if (ctr==1) {
        prevVars <- c()
    } else {
        prevVars <- rfVarAdds[1:(ctr-1)]
    }
    
    # Run each of them through the combinations
    tmpList <- helperRFCombinations(possVars, df=sub_2015_2018_data, prevVars=prevVars)

    # Assess the performance
    tmpAccuracy <- helperVariableAccuracy(tmpList, possVars=possVars, prevVars=prevVars)
    
    # Prepare to repeat the process
    bestRow <- tmpAccuracy %>%
        filter(locale=="OOB") %>%
        filter(accuracy==max(accuracy))
    bestRow
    
    # Update the rfContainer and rfVarAdds elements
    rfContainer[[ctr]] <- tmpList[[as.integer(pull(bestRow, vrblNum))]]
    rfVarAdds[ctr] <- pull(bestRow, vrblName)
    cat("\nVariable Added:", rfVarAdds[ctr], "\n")

}

```
  
The evolution of accuracy can then be plotted:  
```{r}

# Pull the accuracy data from the variables selected
tblAccuracy <- map_dfr(rfContainer, .f=helperExtractAccuracy, .id="vrblNum") %>%
    mutate(vrblName=rfVarAdds[as.integer(vrblNum)], 
           locale=factor(locale, levels=c("OOB", unique(locale)[unique(locale) != "OOB"])), 
           plotLabel=ifelse(as.integer(vrblNum)==1, vrblName, paste0("add ", vrblName))
           )

# Plot the gains in accuracy, facetted by 'locale'
ggplot(tblAccuracy, aes(x=fct_reorder(plotLabel, -as.integer(vrblNum)))) + 
    geom_text(aes(y=accuracy, label=paste0(round(100*accuracy), "%"))) + 
    facet_wrap(~locale, nrow=1) + 
    ylim(c(0, 1)) +
    geom_hline(yintercept=0.25, lty=2) +
    labs(x="", 
         y="", 
         title="Evolution of accuracy as next-best variables are added",
         caption="Null accuracy is 25%"
         ) +
    coord_flip()

```
  
As seen previously, dew point, temperature, and month are significant differentiating variables, driving roughly 75% accuracy in classifying the archetypes.

Adding altimeter (SLP) bumps the accuracy by another ~10%, while adding minimum cloud height and prevailing wind direction bump the accuracy by another ~5%.

This shows some of the power of the random forest algorithm as it is given additional variables to explore.  Evolution of error can be plotted to see the impact:  
```{r}

oobError <- c()
for (ctr in 1:9) {
    oobError <- c(oobError, rfContainer[[ctr]]$rfModel$err.rate[, "OOB"])
}

tibble::tibble(nVars=rep(1:9, each=25), 
               ntrees=rep(1:25, times=9), 
               accuracy=1-oobError
               ) %>%
    ggplot(aes(x=ntrees, y=accuracy)) + 
    geom_line(aes(group=nVars, color=factor(nVars))) +
    labs(x="Number of Trees", 
         y="OOB Accuracy", 
         title="Accuracy improves with more trees and more variables"
         ) + 
    scale_color_discrete("# Variables")

```
  
With a greater number of variables, there is a greater lift in accuracy as the forest grows larger.

Suppose that an attempt is made to classify the year for a single city.  Example code includes:  
```{r cache=TRUE}

# Create a subset of the data for only Chicago (2014-2019)
sub_kord_data <- metarData %>%
    mutate(hr=lubridate::hour(dtime)) %>%
    filter(str_sub(source, 1 ,4) %in% "kord")

# Run random forest for Chicago 2014-2019 data
rf_kord_TDmcwha <- rfMultiLocale(sub_kord_data, 
                                 vrbls=c("TempF", "DewF", 
                                         "month", "hr",
                                         "minHeight", "ceilingHeight", 
                                         "WindSpeed", "predomDir", 
                                         "modSLP"
                                         ),
                                 locs=NULL, 
                                 locVar="year",
                                 pred="year",
                                 ntree=200, 
                                 seed=2007011309, 
                                 mtry=4
                                 )

```
  
Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_kord_TDmcwha, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, SLP", 
                keyVar="year", 
                locOrder=TRUE
                )

# Evaluate variable importance
helperPlotVarImp(rf_kord_TDmcwha$rfModel)

# Evaluate error evolution
errorEvolution(rf_kord_TDmcwha, useCategory="OOB", subT="Chicago (2014-2019)")

```
  
Interestingly, the model predicts the year with 75%-80% accuracy (null accuracy 17%), suggesting there is significant annual variation in Chicago climate.  Sea-level-pressure has the largest variable importance (SLP is a mix of altitude, temperature, dew point, and high/low pressure systems).  The first 50 trees significantly reduce the OOB error, with more modest, but still continuing, error reduction afterwards.
  
The process is run for Las Vegas:  
```{r cache=TRUE}

# Create a subset of the data for only Las Vegas (2014-2019)
sub_klas_data <- metarData %>%
    mutate(hr=lubridate::hour(dtime)) %>%
    filter(str_sub(source, 1 ,4) %in% "klas")

# Run random forest for Las Vegas 2014-2019 data
rf_klas_TDmcwha <- rfMultiLocale(sub_klas_data, 
                                 vrbls=c("TempF", "DewF", 
                                         "month", "hr",
                                         "minHeight", "ceilingHeight", 
                                         "WindSpeed", "predomDir", 
                                         "modSLP"
                                         ),
                                 locs=NULL, 
                                 locVar="year",
                                 pred="year",
                                 ntree=200, 
                                 seed=2007011405, 
                                 mtry=4
                                 )

```
  
Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_klas_TDmcwha, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, SLP", 
                keyVar="year", 
                locOrder=TRUE
                )

# Evaluate variable importance
helperPlotVarImp(rf_klas_TDmcwha$rfModel)

# Evaluate error evolution
errorEvolution(rf_klas_TDmcwha, useCategory="OOB", subT="Las Vegas (2014-2019)")

```
  
Prediction accuracies are lower for Las Vegas, averaging 60%-75% (2014 appears to be much more differentiated than the other years).  This is suggestive that there is less annual variation in the Las Vegas climate than there is in the Chicago climate, though still enough to meaningfully pull apart the years.

Modified seal-level pressure is the top predictor, and the majority of the OOB error reduction occurs in the first 50 trees.

Suppose that modSLP is eliminated as a predictor variable, and the process is scaled down to 50 trees and repeated for Chicago:  
```{r cache=TRUE}

# Run random forest for Chicago 2014-2019 data
rf_kord_TDmcwh_50 <- rfMultiLocale(sub_kord_data, 
                                   vrbls=c("TempF", "DewF", 
                                           "month", "hr",
                                           "minHeight", "ceilingHeight", 
                                           "WindSpeed", "predomDir"
                                           ),
                                   locs=NULL, 
                                   locVar="year",
                                   pred="year",
                                   ntree=50, 
                                   seed=2007011410, 
                                   mtry=4
                                   )

```
  
Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_kord_TDmcwh_50, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind", 
                keyVar="year", 
                locOrder=TRUE
                )

# Evaluate variable importance
helperPlotVarImp(rf_kord_TDmcwh_50$rfModel)

# Compare error evolution through the first 50 trees
tibble::tibble(ntree=1:50, 
               withSLP=rf_kord_TDmcwha$rfModel$err.rate[1:50, "OOB"], 
               noSLP=rf_kord_TDmcwh_50$rfModel$err.rate[1:50, "OOB"]
               ) %>%
    pivot_longer(-ntree, names_to="Model", values_to="Error") %>%
    ggplot(aes(x=ntree, y=Error, color=Model)) + 
    geom_line() + 
    geom_text(data=~filter(., ntree %in% c(1, 50)), 
              aes(y=Error+0.02, label=paste0(round(100*Error, 1), "%"))
              ) +
    labs(x="# Trees", 
         y="OOB Error Rate", 
         title="OOB Error Evolution for SLP Included/Excluded"
         ) + 
    ylim(c(0, NA))

```
  
Modified sea-level pressure is revealed to be a significant driver of prediction accuracy for Chicago, confirming findings of the previous variable importance analysis.  This suggests different patterns of high and low pressure being in control by year may meaningfully improve the ability to predict Chicago by year.
  
The process can also be run for Las Vegas:  
```{r cache=TRUE}

# Run random forest for Las Vegas 2014-2019 data
rf_klas_TDmcwh_50 <- rfMultiLocale(sub_klas_data, 
                                   vrbls=c("TempF", "DewF", 
                                           "month", "hr",
                                           "minHeight", "ceilingHeight", 
                                           "WindSpeed", "predomDir"
                                           ),
                                   locs=NULL, 
                                   locVar="year",
                                   pred="year",
                                   ntree=50, 
                                   seed=2007011420, 
                                   mtry=4
                                   )

```
  
Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_klas_TDmcwh_50, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind", 
                keyVar="year", 
                locOrder=TRUE
                )

# Evaluate variable importance
helperPlotVarImp(rf_klas_TDmcwh_50$rfModel)

# Compare error evolution through the first 50 trees
tibble::tibble(ntree=1:50, 
               withSLP=rf_klas_TDmcwha$rfModel$err.rate[1:50, "OOB"], 
               noSLP=rf_klas_TDmcwh_50$rfModel$err.rate[1:50, "OOB"]
               ) %>%
    pivot_longer(-ntree, names_to="Model", values_to="Error") %>%
    ggplot(aes(x=ntree, y=Error, color=Model)) + 
    geom_line() + 
    geom_text(data=~filter(., ntree %in% c(1, 50)), 
              aes(y=Error+0.02, label=paste0(round(100*Error, 1), "%"))
              ) +
    labs(x="# Trees", 
         y="OOB Error Rate", 
         title="OOB Error Evolution for SLP Included/Excluded"
         ) + 
    ylim(c(0, NA))

```
  
Modified sea-level pressure is revealed as a meaningful driver of prediction accuracy for Las Vegas also, though with a lesser effect than seen in Chicago.  This potentially suggests less variability by year in SLP for Las Vegas.  
  
Since SLP is so meaningful, are there any patterns by year?  
```{r}

sub_kord_data %>%
    bind_rows(sub_klas_data, .id="cityFile") %>%
    select(cityFile, year, month, modSLP) %>%
    mutate(city=case_when(cityFile==1 ~ "Chicago", cityFile==2 ~ "Las Vegas", TRUE ~ "Error")) %>%
    filter(!is.na(modSLP)) %>%
    ggplot(aes(x=factor(year), y=modSLP)) + 
    geom_boxplot(fill="lightblue") + 
    facet_wrap(~city) +
    labs(x="", y="modSLP", title="Modified Sea-Level Pressure by Year (Chicago and Las Vegas)")

```
  
Chicago has a higher sea-level pressure than Las Vegas (as expected), though neither city shows much variation on average from year to year.  The Chicago data are explored further by month:  
```{r}

sub_kord_data %>%
    select(year, month, modSLP) %>%
    filter(!is.na(modSLP)) %>%
    ggplot(aes(x=month, y=modSLP)) + 
    geom_boxplot(fill="lightblue") + 
    facet_wrap(~year) +
    labs(x="", y="modSLP", title="Modified Sea-Level Pressure by Month and Year (Chicago)")

sub_kord_data %>%
    select(year, month, modSLP) %>%
    filter(!is.na(modSLP)) %>%
    group_by(year, month) %>%
    summarize(medSLP=median(modSLP)) %>%
    ggplot(aes(x=month, y=medSLP, color=factor(year), group=year)) + 
    geom_line(lwd=1) + 
    labs(x="", y="Median modSLP", title="Median modified Sea-Level Pressure by Month and Year (Chicago)")

sub_kord_data %>%
    select(year, month, modSLP) %>%
    filter(!is.na(modSLP)) %>%
    group_by(year, month) %>%
    summarize(medSLP=median(modSLP)) %>%
    group_by(month) %>%
    summarize(sdSLP=sd(medSLP)) %>%
    ggplot(aes(x=month, y=sdSLP)) + 
    geom_point() + 
    labs(x="", 
         y="Standard Deviation of Median modSLP by Year", 
         title="Variability by year of modified Sea-Level Pressure by Month (Chicago)"
         )

```
  
There are meaningful differences in median modified sea-level pressure by month by year.  This is suggestive that several year of data are needed to define an archetype, as there is risk that otherwise the archetype will be an anomalous "high pressure was in contol in June" when that is not generally applicable.  And, since high vs. low pressure are often related to temperature, dew point, coludiness, wind speed, and the like, the need for multiple years of data to define an archetype likely extends to all the other variables as well.

With greater variability in SLP by year in the cold-weather months, predictive ability in the cold-weather months is expected to be higher:  
```{r}

rf_kord_TDmcwha$testData %>% 
    group_by(month) %>% 
    summarize(pctError=1-mean(correct)) %>%
    ggplot(aes(x=month, y=pctError)) + 
    geom_col(fill="lightblue") + 
    geom_text(aes(y=pctError/2, label=paste0(round(100*pctError, 1), "%"))) +
    labs(x="", y="Error Rate", title="Prediction Error Rate by Month (Chicago)")

```
  
As expected, the model takes advantage of greater annual variation in modSLP during the cold season to make better prediction of which year it is during the cold season.
  
Next an attempt is made to predict the month given the data:  
```{r cache=TRUE}

# Run random forest for Las Vegas 2014-2019 data
rf_klas_TDycwha_month_50 <- rfMultiLocale(sub_klas_data, 
                                          vrbls=c("TempF", "DewF", 
                                                  "year", "hr",
                                                  "minHeight", "ceilingHeight", 
                                                  "WindSpeed", "predomDir", 
                                                  "modSLP"
                                                  ),
                                          locs=NULL, 
                                          locVar="month",
                                          pred="month",
                                          ntree=50, 
                                          seed=2007021356, 
                                          mtry=4
                                          )

```

Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_klas_TDycwha_month_50, 
                plotCaption = "Temp, Dew Point, Year, Hour of Day, Cloud Height, Wind, Altimeter", 
                keyVar="month", 
                locOrder=TRUE
                )

# Evaluate variable importance
helperPlotVarImp(rf_klas_TDycwha_month_50$rfModel)

# Evaluate error evolution
errorEvolution(rf_klas_TDycwha_month_50, useCategory="OOB", subT="Las Vegas (2014-2019)")

```
  
There is meaningful seasonality to the Las Vegas data such that the predicted month is frequently either the same season or (for spring/fall) the mirror season.

Suppose that year is not available as a predictor:  
```{r cache=TRUE}

# Run random forest for Las Vegas 2014-2019 data
rf_klas_TDcwha_month_50 <- rfMultiLocale(sub_klas_data, 
                                         vrbls=c("TempF", "DewF", 
                                                 "hr",
                                                 "minHeight", "ceilingHeight", 
                                                 "WindSpeed", "predomDir", 
                                                 "modSLP"
                                                 ),
                                         locs=NULL, 
                                         locVar="month",
                                         pred="month",
                                         ntree=50, 
                                         seed=2007021402, 
                                         mtry=4
                                         )

```
  
Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_klas_TDcwha_month_50, 
                plotCaption = "Temp, Dew Point, Hour of Day, Cloud Height, Wind, Altimeter", 
                keyVar="month", 
                locOrder=TRUE
                )

# Evaluate variable importance
helperPlotVarImp(rf_klas_TDcwha_month_50$rfModel)

# Evaluate error evolution
errorEvolution(rf_klas_TDcwha_month_50, useCategory="OOB", subT="Las Vegas (2014-2019)")

```
  
The same seasonal pattern is observed, though prediction accuracy falls be ~15%.  This is suggestive that it is not uncommon for Las Vegas climate to run a month-ahead or a month-behind where it ran in a previous year.

The model appears to still be learning at 50 trees, so it is expanded to 150 trees:  
```{r cache=TRUE}

# Run random forest for Las Vegas 2014-2019 data
rf_klas_TDcwha_month_150 <- rfMultiLocale(sub_klas_data, 
                                          vrbls=c("TempF", "DewF", 
                                                  "hr",
                                                  "minHeight", "ceilingHeight", 
                                                  "WindSpeed", "predomDir", 
                                                  "modSLP"
                                                  ),
                                          locs=NULL, 
                                          locVar="month",
                                          pred="month",
                                          ntree=150, 
                                          seed=2007021402, 
                                          mtry=4
                                          )

```
  
Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_klas_TDcwha_month_150, 
                plotCaption = "Temp, Dew Point, Hour of Day, Cloud Height, Wind, Altimeter", 
                keyVar="month", 
                locOrder=TRUE
                )

# Evaluate variable importance
helperPlotVarImp(rf_klas_TDcwha_month_150$rfModel)

# Evaluate error evolution
errorEvolution(rf_klas_TDcwha_month_150, useCategory="OOB", subT="Las Vegas (2014-2019)")

```
  
Another topic of interest is the use of sea-level pressure or altimeter in modeling.  The altimeter setting in a METAR is captured in two ways:  
  
* Altimeter - the atmospheric pressure in inches of mercury, corrected for height above sea-level  
* Sea-Level Pressure (SLP) - the atmospheric pressure in millibars, with a theroertical hole drilled from the meauring station striaght down to sea-level  
  
In theory, both metrics report almost the same thing but in different units.  There is a small difference in that SLP makes an adjustment for average 12-hour temperature (since temperature is a driver of air pressure) while altimeter is purely an adjustment for altitude.

How does the model perform with neither/either/both or Altimeter and modSLP included?  An example will be used for trying to classify a handful of cities from 2016:  
  
* Chicago  
* Milwaukee  
* New Orleans  
* Las Vegas  
* San Diego  
* Denver  
* Boston  
* Seattle  
  
```{r}

sub_mini_2016_data <- metarData %>%
    mutate(hr=lubridate::hour(dtime)) %>%
    filter(year==2016, 
           str_sub(source, 1 ,4) %in% c("kord", "kmke", "kmsy", "klas", "ksan", "kden", "kbos", "ksea")
           )
    
```
  
First, a model is run with neither Altimeter nor SLP:  
```{r cache=TRUE}

# Run random forest for subset data (2016)
rf_mini_TDmcwh <- rfMultiLocale(sub_mini_2016_data, 
                                vrbls=c("TempF", "DewF", 
                                        "month", "hr",
                                        "minHeight", "ceilingHeight", 
                                        "WindSpeed", "predomDir"
                                        ),
                                locs=NULL, 
                                locVar="locale",
                                pred="locale",
                                ntree=100, 
                                seed=2007021422, 
                                mtry=4
                                )

```
  
Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_mini_TDmcwh, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind", 
                keyVar="locale", 
                locOrder=NULL
                )

# Evaluate variable importance
helperPlotVarImp(rf_mini_TDmcwh$rfModel)

# Evaluate error evolution
errorEvolution(rf_mini_TDmcwh, useCategory="OOB", subT="No Altimeter, No SLP")

```
  
Overall accuracy is roughly 75%, with the greatest challenge being separating Chicago and Milwaukee, with Boston also showing some similarities to these cities.
  
The process is then run with both Altimeter and SLP:  
```{r cache=TRUE}

# Run random forest for subset data (2016)
rf_mini_TDmcwhas <- rfMultiLocale(sub_mini_2016_data, 
                                  vrbls=c("TempF", "DewF", 
                                          "month", "hr",
                                          "minHeight", "ceilingHeight", 
                                          "WindSpeed", "predomDir",
                                          "modSLP", "Altimeter"
                                          ),
                                  locs=NULL, 
                                  locVar="locale",
                                  pred="locale",
                                  ntree=100, 
                                  seed=2007021429, 
                                  mtry=4
                                  )

```
  
Prediction accuracy and variable importance can again be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_mini_TDmcwhas, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, Altimeter, and SLP", 
                keyVar="locale", 
                locOrder=NULL
                )

# Evaluate variable importance
helperPlotVarImp(rf_mini_TDmcwhas$rfModel)

# Evaluate error evolution
errorEvolution(rf_mini_TDmcwhas, useCategory="OOB", subT="Both Altimeter and SLP")

```
  
Overall accuracy increases to about 85%.  Except for Chicago/Milwaukee, every city is overwhelmingly classified as itself.
  
Smaller runs with just SLP and just Altimeter are conducted, to verify that the learning rate is roughly the same in these cases.  As well SLP plus a dummy variable (SLP + rnorm()) is run:  
```{r cache=TRUE}

# Run random forest for subset data (2016)
rf_mini_TDmcwhs <- rfMultiLocale(sub_mini_2016_data, 
                                 vrbls=c("TempF", "DewF", 
                                         "month", "hr",
                                         "minHeight", "ceilingHeight", 
                                         "WindSpeed", "predomDir",
                                         "modSLP"
                                         ),
                                 locs=NULL, 
                                 locVar="locale",
                                 pred="locale",
                                 ntree=50, 
                                 seed=2007021435, 
                                 mtry=4
                                 )

```
  
```{r cache=TRUE}

# Run random forest for subset data (2016)
rf_mini_TDmcwha <- rfMultiLocale(sub_mini_2016_data, 
                                 vrbls=c("TempF", "DewF", 
                                         "month", "hr",
                                         "minHeight", "ceilingHeight", 
                                         "WindSpeed", "predomDir",
                                         "Altimeter"
                                         ),
                                 locs=NULL, 
                                 locVar="locale",
                                 pred="locale",
                                 ntree=50, 
                                 seed=2007021440, 
                                 mtry=4
                                 )

```
  
```{r cache=TRUE}

set.seed(2007021444)
subUseData <- sub_mini_2016_data %>%
    mutate(dummy=modSLP + rnorm(n=nrow(sub_mini_2016_data)))

# Run random forest for subset data (2016)
rf_mini_TDmcwhsd <- rfMultiLocale(subUseData, 
                                  vrbls=c("TempF", "DewF", 
                                          "month", "hr",
                                          "minHeight", "ceilingHeight", 
                                          "WindSpeed", "predomDir",
                                          "modSLP", "dummy"
                                          ),
                                  locs=NULL, 
                                  locVar="locale",
                                  pred="locale",
                                  ntree=50, 
                                  seed=2007021445, 
                                  mtry=4
                                  )

```
  
OOB error evolution through the first 50 trees can be compared:  
```{r}

# Compare error evolution through the first 50 trees
tibble::tibble(ntree=1:50, 
               neither=rf_mini_TDmcwh$rfModel$err.rate[1:50, "OOB"], 
               altimeter=rf_mini_TDmcwha$rfModel$err.rate[1:50, "OOB"], 
               modslp=rf_mini_TDmcwhs$rfModel$err.rate[1:50, "OOB"],
               slp_dummy=rf_mini_TDmcwhsd$rfModel$err.rate[1:50, "OOB"], 
               both=rf_mini_TDmcwhas$rfModel$err.rate[1:50, "OOB"]
               ) %>%
    pivot_longer(-ntree, names_to="Model", values_to="Error") %>%
    ggplot(aes(x=ntree, y=Error, color=Model)) + 
    geom_line() + 
    geom_text(data=~filter(., ntree %in% c(1, 50)), 
              aes(y=Error+0.02, label=paste0(round(100*Error, 1), "%"))
              ) +
    labs(x="# Trees", 
         y="OOB Error Rate", 
         title="OOB Error Evolution for SLP Included/Excluded"
         ) + 
    ylim(c(0, NA))

```
  
Interestingly, the inclusion of both Altimeter and modSLP appears to drive a 2%-3% decrease in classification error.  The main difference between the variables is that modSLP contains a hint about the previous 12-hour temperature.

Importantly, including a dummy variable with modSLP has either no impact or a slight negative impact on model performance.  So, the addition of Altimeter to modSLP is likely a real impact, not merely the inclusion of two highly correlated variables that are both valuable to driving model performance.
  
Next, an attempt is made to compare every grouping of two cities, using all variables, mtry of 4, and a very small forest of 15 trees:  
```{r cache=TRUE}

# Create a container list to hold the output
list_varimp_2016 <- vector("list", 0.5*length(names_2016)*(length(names_2016)-1))

# Set a random seed
set.seed(2007031342)

# Loop through all possible combinations
n <- 1
for (ctr in 1:(length(names_2016)-1)) {
    for (ctr2 in (ctr+1):length(names_2016)) {
        list_varimp_2016[[n]] <- rfTwoLocales(mutate(metarData, hr=lubridate::hour(dtime)), 
                                              loc1=names_2016[ctr], 
                                              loc2=names_2016[ctr2], 
                                              vrbls=c("TempF", "DewF", 
                                                      "month", "hr",
                                                      "minHeight", "ceilingHeight", 
                                                      "WindSpeed", "predomDir", 
                                                      "modSLP", "Altimeter"
                                                      ),
                                              ntree=15, 
                                              mtry=4
                                              )
        n <- n + 1
        if ((n %% 40) == 0) { cat("Through number:", n, "\n")}
    }
}

```
  
```{r}

# Create a tibble from the underlying accuracy data
acc_varimp_2016 <- map_dfr(list_varimp_2016, .f=helperAccuracyLocale)

# Assess the top 20 classification accuracies
acc_varimp_2016 %>%
    arrange(-accOverall) %>%
    head(20)

# Assess the bottom 20 classification accuracies
acc_varimp_2016 %>%
    arrange(accOverall) %>%
    head(20)

```
  
As pre previous, the best accuracies are obtained when comparing cities in very different climates (e.g., Denver vs. Humid/Marine or Miami vs. Desert/Cold), while the worst accuracies are obtained when comparing very similar cities (e.g., Chicago and Milwaukee or Newar and Philadelphia).

Variable importance can then be assessed across all 1:1 classifications:  
```{r cache=TRUE}

# Create a tibble of all the variable importance data
val_varimp_2016 <- map_dfr(list_varimp_2016, 
                           .f=function(x) { x$rfModel %>% 
                                   caret::varImp() %>% 
                                   t() %>% 
                                   as.data.frame()
                               }
                           ) %>% 
    tibble::as_tibble()

```
  
```{r}

# Create boxplot of overall variable importance
val_varimp_2016 %>% 
    mutate(num=1:nrow(val_varimp_2016)) %>% 
    pivot_longer(-num, names_to="variable", values_to="varImp") %>% 
    ggplot(aes(x=fct_reorder(variable, varImp), y=varImp)) + 
    geom_boxplot(fill="lightblue") + 
    labs(x="", 
         y="Variable Importance", 
         title="Variable Importance for 1:1 Random Forest Classifications"
         )

# Attach the city names and OOB error rate
tbl_varimp_2016 <- sapply(list_varimp_2016, 
                          FUN=function(x) { c(names(x$errorRate[2:3]), x$errorRate["OOB"]) }
                          ) %>%
    t() %>% 
    as.data.frame() %>% 
    bind_cols(val_varimp_2016) %>% 
    tibble::as_tibble() %>% 
    mutate(OOB=as.numeric(as.character(OOB))) %>%
    rename(locale1=V1, 
           locale2=V2
           )

# Plot accuracy vs. spikiness of variable importance
tbl_varimp_2016 %>%
    pivot_longer(-c(locale1, locale2, OOB), names_to="var", values_to="varImp") %>% 
    group_by(locale1, locale2, OOB) %>% 
    summarize(mean=mean(varImp), max=max(varImp)) %>% 
    mutate(maxMean=max/mean) %>%
    ggplot(aes(x=maxMean, y=1-OOB)) + 
    geom_point() + 
    geom_smooth(method="loess") +
    labs(x="Ratio of Maximum Variable Importance to Mean Variable Importance", 
         y="OOB Accuracy", 
         title="Accuracy vs. Spikiness of Variable Importance"
         )

```
  
Broadly speaking, the same variables that drive overall classification are important in driving 1:1 classifications.  There is meaningful spikiness, suggesting that different 1:1 classifications rely on different variables.

There is a strong trend where the best accuracies are obtained where there is a single spiky dimension that drives the classifications.  This suggests that while the model can take advantage of all 10 variables, it has the easiest tome when there is a single, well-differentiated variable.  No surprise.

An attempt is made to define archetype cities as cities that are either 1) very different from other cities, or 2) very similar to other cities.  An archetype should always meet criteria for some meaningful examples, and criteria 2 allows for an archetype to be similar to several other cities of the same archetype:  
```{r}

oobData <- tibble::tibble(City=character(0), OOBLow=numeric(0), OOBHigh=numeric(0))

for (city in cityNameMapper[names_2016]) {
    
    cityData <- tbl_varimp_2016 %>%
        filter(locale1 == city | locale2 == city)
    
    lowOOB <- cityData %>%
        top_n(n=10, wt=-OOB) %>%
        pull(OOB) %>%
        mean()
    
    highOOB <- cityData %>%
        top_n(n=5, wt=OOB) %>%
        pull(OOB) %>%
        mean()
    
    cat("\nCity:", city, 
        "\tOOB (Low 10 Average):", round(lowOOB, 4), 
        "\tOOB (High 5 Average):", round(highOOB, 4)
        )
    
    oobData <- bind_rows(oobData, tibble::tibble(City=city, OOBLow=lowOOB, OOBHigh=highOOB))
    
}

# Plot OOB data summary
oobData %>%
    ggplot(aes(x=OOBLow, y=OOBHigh)) + 
    geom_text(aes(label=City)) + 
    labs(x="Average OOB Error of Best 10 1:1 Predictions", 
         y="Average OOB Error of Worst 5 1:1 Predictions"
         )

```
  
At a glance, Miami, Denver and Phoenix/Las Vegas make for great archetypes in this data.  They are broadly dissimilar from a large number of cities and not all that similar to many other cities.  New Orleans or Tampa may also make for good archetypes (somewhat surprisingly in that these should be similar to Miami).
  
Suppose that hierarchical clustering is attempted, using 1-OOB as the main 'distance' variable:  
```{r}

# Create both halves of what will become the distance matric
upperHalf <- tbl_varimp_2016 %>%
    mutate(locale1=as.character(locale1), locale2=as.character(locale2))

lowerHalf <- upperHalf %>%
    rename(locale2=locale1, locale1=locale2) %>%
    select(locale1, locale2, everything())

bothHalf <- upperHalf %>%
    bind_rows(lowerHalf)

# Select only locale1, locale2, OOB and create a record for each locale to itself
mtxData <- bothHalf %>%
    select(locale1, locale2, OOB) %>%
    bind_rows(tibble::tibble(locale1=unique(bothHalf$locale1), locale2=locale1, OOB=NA)) %>%
    arrange(locale1, locale2) %>%
    mutate(accuracy=1-OOB)

# Create the matrix and add row/column names
mtxOOB <- matrix(data=mtxData$accuracy, nrow=sqrt(nrow(mtxData)), ncol=sqrt(nrow(mtxData)), byrow=TRUE)
dimnames(mtxOOB) <- list(unique(mtxData$locale1), unique(mtxData$locale1))

# Convert to distance matrix
distOOB <- as.dist(mtxOOB)

# Run hierarchical clustering
distOOB %>%
    hclust(method="complete") %>%
    plot()

```
  
Seattle and Denver appear to be good stand-alone cities.  They are not particularly close to any other cities.

Suppose that an attempt is made to classify cities as Seattle, Denver, or Other:  
```{r}

# Create data for Denver/Seattle/Other
sub_densea_data <- metarData %>%
    mutate(place=case_when(source=="kden_2016" ~ "Denver", 
                           source=="ksea_2016" ~ "Seattle", 
                           TRUE ~ "Other"
                           )
           ) %>%
    filter(year==2016)

# Down-sample all to smallest 'place'
nSmallPlace <- sub_densea_data %>%
    count(place) %>%
    pull(n) %>%
    min()

# Group the data and sample to only this minimum size
set.seed(2007031504)

sub_densea_data <- sub_densea_data %>%
    group_by(place) %>%
    sample_n(size=nSmallPlace) %>%
    ungroup() %>%
    mutate(hr=lubridate::hour(dtime))

# Run random forest for subset data
rf_densea_TDmcwhsa <- rfMultiLocale(sub_densea_data, 
                                    vrbls=c("TempF", "DewF", 
                                            "month", "hr",
                                            "minHeight", "ceilingHeight", 
                                            "WindSpeed", "predomDir",
                                            "modSLP", "Altimeter"
                                            ),
                                    locs=NULL, 
                                    locVar="place",
                                    pred="place",
                                    ntree=100, 
                                    seed=2007031510, 
                                    mtry=4
                                    )

# Evaluate prediction accuracy
evalPredictions(rf_densea_TDmcwhsa, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, Altimeter, and SLP", 
                keyVar="place", 
                locOrder=NULL
                )

# Evaluate variable importance
helperPlotVarImp(rf_densea_TDmcwhsa$rfModel)

# Evaluate error evolution
errorEvolution(rf_densea_TDmcwhsa, subT="Denver, Seattle, Other")

```
  
The model is very good at picking out Seattle and Denver, but not so good at picking out that Other is not Seattle or Denver.  A different approach may be needed to find stand-alone cities and archetypes.
  
An initial attempt is made to classify all of the 2016 cities, using a small forest of 25 trees, with the objective of finding cities that are frequently classified as each other:  
```{r cache=TRUE}

# Run random forest for subset data
rf_all_nt25_TDmcwhsa <- rfMultiLocale(filter(mutate(metarData, hr=lubridate::hour(dtime)), year==2016), 
                                      vrbls=c("TempF", "DewF", 
                                              "month", "hr",
                                              "minHeight", "ceilingHeight", 
                                              "WindSpeed", "predomDir",
                                              "modSLP", "Altimeter"
                                              ),
                                      locs=NULL, 
                                      locVar="locale",
                                      pred="locale",
                                      ntree=25, 
                                      seed=2007041352, 
                                      mtry=4
                                      )

```
  
Accuracy can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_all_nt25_TDmcwhsa, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, Altimeter, and SLP", 
                keyVar="locale", 
                locOrder=NULL
                )

# Evaluate variable importance
helperPlotVarImp(rf_all_nt25_TDmcwhsa$rfModel)

# Evaluate error evolution
errorEvolution(rf_all_nt25_TDmcwhsa, useCategory="OOB", subT="All 30 cities individually")

```
  
There are frequently misclassified cities that might benefit from being grouped and classified as such:  
  
* Las Vegas and Phoenix  
* Miami and Tampa  
* San Diego and Los Angeles  
* San Francisco and San Jose  
* New Orleans and Houston (may also match well with Miami and Tampa)  
* DC, Philadelphia, and Newark  
* Chicago and Milwaukee  
* Detroit and Grand Rapids  
  
Encouragingly, this is broadly the same as the findings from the hierarchical clustering.  The model is still learning at a decent rate, so the 25-tree forest is, as expected, too small.
  
A mapping file is created to map relevant cities together:  
```{r}

# Create the locale mapper
locMapperTibble_ss01 <- tibble::tribble(
    ~source, ~locType,
    'katl_2016', 'Same',
    'kbos_2016', 'Same',
    'kdca_2016', 'DC-PHL-EWR (2016)',
    'kden_2016', 'Same',
    'kdfw_2016', 'Same',
    'kdtw_2016', 'Detroit-Grand Rapids (2016)',
    'kewr_2016', 'DC-PHL-EWR (2016)',
    'kgrb_2016', 'Same',
    'kgrr_2016', 'Detroit-Grand Rapids (2016)',
    'kiah_2016', 'Houston-New Orleans (2016)',
    'kind_2016', 'Same',
    'klas_2016', 'Las Vegas-Phoenix (2016)',
    'klax_2016', 'Los Angeles-San Diego (2016)',
    'klnk_2016', 'Same',
    'kmia_2016', 'Miami-Tampa Bay (2016)',
    'kmke_2016', 'Chicago-Milwaukee (2016)',
    'kmsn_2016', 'Same',
    'kmsp_2016', 'Same',
    'kmsy_2016', 'Houston-New Orleans (2016)',
    'kord_2016', 'Chicago-Milwaukee (2016)',
    'kphl_2016', 'DC-PHL-EWR (2016)',
    'kphx_2016', 'Las Vegas-Phoenix (2016)',
    'ksan_2016', 'Los Angeles-San Diego (2016)',
    'ksat_2016', 'Same',
    'ksea_2016', 'Same',
    'ksfo_2016', 'Bay Area (2016)',
    'ksjc_2016', 'Bay Area (2016)',
    'kstl_2016', 'Same',
    'ktpa_2016', 'Miami-Tampa Bay (2016)',
    'ktvc_2016', 'Same'
)

# Create locMapper
locMapper_ss01 <- locMapperTibble_ss01 %>% pull(locType)
names(locMapper_ss01) <- locMapperTibble_ss01 %>% pull(source)
locMapper_ss01

# Create the data file with locType
locData_ss01 <- metarData %>% 
    mutate(locType=ifelse(locMapper_ss01[source]=="Same", locale, locMapper_ss01[source]), 
           hr=lubridate::hour(dtime)) %>% 
    filter(year==2016, locType !="Exclude")

# Counts by locType
locData_ss01 %>%
    count(locType) %>%
    arrange(-n) %>%
    as.data.frame()

```
  
The data are then sampled such that each locType is equally prevalent:  
```{r}

# Set a seed for reporducibility
set.seed(2007041419)

# Find the smallest locale type
nSmall <- locData_ss01 %>%
    filter(!is.na(locType)) %>%
    count(locType) %>%
    pull(n) %>%
    min()

# Create the relevant data subset
ss01_data <- locData_ss01 %>%
    filter(!is.na(locType)) %>%
    group_by(locType) %>%
    sample_n(size=nSmall, replace=FALSE) %>%
    ungroup()

# Sumarize the data subset
ss01_data %>% 
    count(locale) %>% 
    arrange(-n) %>%
    as.data.frame()

```
  
A random forest can then be run to predict locType (using a slightly bigger forest of 50 trees:  
```{r cache=TRUE}

# Run random forest for subset data
rf_s01_nt50_TDmcwhsa <- rfMultiLocale(ss01_data, 
                                      vrbls=c("TempF", "DewF", 
                                              "month", "hr",
                                              "minHeight", "ceilingHeight", 
                                              "WindSpeed", "predomDir",
                                              "modSLP", "Altimeter"
                                              ),
                                      locs=NULL, 
                                      locVar="locType",
                                      pred="locType",
                                      otherVar=c("dtime", "locale", "source"),
                                      ntree=50, 
                                      seed=2007041423, 
                                      mtry=4
                                      )

```
  
Accuracy can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_s01_nt50_TDmcwhsa, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, Altimeter, and SLP", 
                keyVar="locType", 
                locOrder=NULL
                )

# Evaluate variable importance
helperPlotVarImp(rf_s01_nt50_TDmcwhsa$rfModel)

# Evaluate error evolution
errorEvolution(rf_s01_nt50_TDmcwhsa, useCategory="OOB", subT="Subset 01: 21 Groups of 1-3 Locales")

```
  
A few other consolidations appear merited:  
  
* Miami-Tampa and Houston-New Orleans  
* Boston with DC-PHL-EWR  
* Chicago-Milwaukee and Detroit-Grand Rapids with Madison and Green Bay  
* Saint Louis and Indianapolis  
* Dallas and San Antonio  
  
Example code includes:  
```{r}

# Create the locale mapper
locMapperTibble_ss02 <- tibble::tribble(
    ~source, ~locType,
    'katl_2016', 'Same',
    'kbos_2016', 'DC-PHL-EWR-BOS (2016)',
    'kdca_2016', 'DC-PHL-EWR-BOS (2016)',
    'kden_2016', 'Same',
    'kdfw_2016', 'Dallas-San Antonio (2016)',
    'kdtw_2016', 'Cold Midwest (2016)',
    'kewr_2016', 'DC-PHL-EWR-BOS (2016)',
    'kgrb_2016', 'Cold Midwest (2016)',
    'kgrr_2016', 'Cold Midwest (2016)',
    'kiah_2016', 'Gulf Coast (2016)',
    'kind_2016', 'St Louis-Indianapolis (2016)',
    'klas_2016', 'Las Vegas-Phoenix (2016)',
    'klax_2016', 'Los Angeles-San Diego (2016)',
    'klnk_2016', 'Same',
    'kmia_2016', 'Gulf Coast (2016)',
    'kmke_2016', 'Cold Midwest (2016)',
    'kmsn_2016', 'Cold Midwest (2016)',
    'kmsp_2016', 'Same',
    'kmsy_2016', 'Gulf Coast (2016)',
    'kord_2016', 'Cold Midwest (2016)',
    'kphl_2016', 'DC-PHL-EWR-BOS (2016)',
    'kphx_2016', 'Las Vegas-Phoenix (2016)',
    'ksan_2016', 'Los Angeles-San Diego (2016)',
    'ksat_2016', 'Dallas-San Antonio (2016)',
    'ksea_2016', 'Same',
    'ksfo_2016', 'Bay Area (2016)',
    'ksjc_2016', 'Bay Area (2016)',
    'kstl_2016', 'St Louis-Indianapolis (2016)',
    'ktpa_2016', 'Gulf Coast (2016)',
    'ktvc_2016', 'Same'
)

# Create locMapper
locMapper_ss02 <- locMapperTibble_ss02 %>% pull(locType)
names(locMapper_ss02) <- locMapperTibble_ss02 %>% pull(source)
locMapper_ss02

# Create the data file with locType
locData_ss02 <- metarData %>% 
    mutate(locType=ifelse(locMapper_ss02[source]=="Same", locale, locMapper_ss02[source]), 
           hr=lubridate::hour(dtime)) %>% 
    filter(year==2016, locType !="Exclude")

# Counts by locType
locData_ss02 %>%
    count(locType) %>%
    arrange(-n) %>%
    as.data.frame()

```
  
The data are then sampled such that each locType is equally prevalent:  
```{r}

# Set a seed for reporducibility
set.seed(2007041447)

# Find the smallest locale type
nSmall <- locData_ss02 %>%
    filter(!is.na(locType)) %>%
    count(locType) %>%
    pull(n) %>%
    min()

# Create the relevant data subset
ss02_data <- locData_ss02 %>%
    filter(!is.na(locType)) %>%
    group_by(locType) %>%
    sample_n(size=nSmall, replace=FALSE) %>%
    ungroup()

# Sumarize the data subset
ss02_data %>% 
    count(locale) %>% 
    arrange(-n) %>%
    as.data.frame()

```
  
A random forest can then be run to predict locType (using a forest of 50 trees):  
```{r cache=TRUE}

# Run random forest for subset data
rf_s02_nt50_TDmcwhsa <- rfMultiLocale(ss02_data, 
                                      vrbls=c("TempF", "DewF", 
                                              "month", "hr",
                                              "minHeight", "ceilingHeight", 
                                              "WindSpeed", "predomDir",
                                              "modSLP", "Altimeter"
                                              ),
                                      locs=NULL, 
                                      locVar="locType",
                                      pred="locType",
                                      otherVar=c("dtime", "locale", "source"),
                                      ntree=50, 
                                      seed=2007041449, 
                                      mtry=4
                                      )

```
  
Accuracy can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_s02_nt50_TDmcwhsa, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, Altimeter, and SLP", 
                keyVar="locType", 
                locOrder=NULL
                )

# Evaluate variable importance
helperPlotVarImp(rf_s02_nt50_TDmcwhsa$rfModel)

# Evaluate error evolution
errorEvolution(rf_s02_nt50_TDmcwhsa, useCategory="OOB", subT="Subset 02: 14 Groups of 1-6 Locales")

```
  
Overall accuracy continues to improve.  Further exploration may allow for continued evolution of the archetypes, particularly as related to the colder cities where accuracy is not improving with consolidation to archetypes.

Data are limited to only locales that do not meaningfully overlap with 'Cold Midwest'.  Functions are written to create the mapper, associated dataset, and associated data sample:  
```{r}

# Create the locale mapper
locMapperTibble_ss03 <- tibble::tribble(
    ~source, ~locType,
    'katl_2016', 'Same',
    'kbos_2016', 'Exclude',
    'kdca_2016', 'Exclude',
    'kden_2016', 'Same',
    'kdfw_2016', 'Dallas-San Antonio (2016)',
    'kdtw_2016', 'Exclude',
    'kewr_2016', 'Exclude',
    'kgrb_2016', 'Exclude',
    'kgrr_2016', 'Exclude',
    'kiah_2016', 'Gulf Coast (2016)',
    'kind_2016', 'Exclude',
    'klas_2016', 'Las Vegas-Phoenix (2016)',
    'klax_2016', 'Los Angeles-San Diego (2016)',
    'klnk_2016', 'Exclude',
    'kmia_2016', 'Gulf Coast (2016)',
    'kmke_2016', 'Exclude',
    'kmsn_2016', 'Exclude',
    'kmsp_2016', 'Exclude',
    'kmsy_2016', 'Gulf Coast (2016)',
    'kord_2016', 'Exclude',
    'kphl_2016', 'Exclude',
    'kphx_2016', 'Las Vegas-Phoenix (2016)',
    'ksan_2016', 'Los Angeles-San Diego (2016)',
    'ksat_2016', 'Dallas-San Antonio (2016)',
    'ksea_2016', 'Same',
    'ksfo_2016', 'Bay Area (2016)',
    'ksjc_2016', 'Bay Area (2016)',
    'kstl_2016', 'Exclude',
    'ktpa_2016', 'Gulf Coast (2016)',
    'ktvc_2016', 'Exclude'
)


# Create the locale mapper
locMapper_ss03 <- createLocMapper(locMapperTibble_ss03)

# Create the data file with locType
locData_ss03 <- applyLocMapper(metarData, mapper=locMapper_ss03, yearsUse=c(2016))

# Create the smaller data file that is balanced by locType
ss03_data <- createBalancedSample(locData_ss03, seed=2007051311)

```
  
A random forest can then be run on both the individual locales (locData_ss03) and the balanced sample of locale types (ss03_data):  
```{r cache=TRUE}

# Run random forest for subset data
rf_s03_nt100_TDmcwhsa <- rfMultiLocale(ss03_data, 
                                      vrbls=c("TempF", "DewF", 
                                              "month", "hr",
                                              "minHeight", "ceilingHeight", 
                                              "WindSpeed", "predomDir",
                                              "modSLP", "Altimeter"
                                              ),
                                      locs=NULL, 
                                      locVar="locType",
                                      pred="locType",
                                      otherVar=c("dtime", "locale", "source"),
                                      ntree=100, 
                                      seed=2007051315, 
                                      mtry=4
                                      )

```
  
Accuracy can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_s03_nt100_TDmcwhsa, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, Altimeter, and SLP", 
                keyVar="locType", 
                locOrder=NULL
                )

# Evaluate variable importance
helperPlotVarImp(rf_s03_nt100_TDmcwhsa$rfModel)

# Evaluate error evolution
errorEvolution(rf_s03_nt100_TDmcwhsa, 
               useCategory="OOB", 
               subT="Exclude Locales with High Overlap to Cold Midwest"
               )

```
  
Predictions continue to be highly accurate for Denver, Seattle, and Las Vegas-Phoenix.  There is some mixing of the Pacific coastal cities - Bay Area sometimes as Seattle or LA/San Diego, and LA/San Diego sometimes as Bay Area.  There is also some meaningful overlap among Dallas-San Antonio, Gulf Coast, and Atlanta.
  
The process can then be repeated for the individual cities:  
```{r cache=TRUE}

# Run random forest for subset data
rf_l03_nt100_TDmcwhsa <- rfMultiLocale(locData_ss03, 
                                      vrbls=c("TempF", "DewF", 
                                              "month", "hr",
                                              "minHeight", "ceilingHeight", 
                                              "WindSpeed", "predomDir",
                                              "modSLP", "Altimeter"
                                              ),
                                      locs=NULL, 
                                      locVar="locale",
                                      pred="locale",
                                      otherVar=c("dtime", "locale", "source"),
                                      ntree=100, 
                                      seed=2007051325, 
                                      mtry=4
                                      )

```
  
Accuracy can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_l03_nt100_TDmcwhsa, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, Altimeter, and SLP", 
                keyVar="locale", 
                locOrder=NULL
                )

# Evaluate variable importance
helperPlotVarImp(rf_l03_nt100_TDmcwhsa$rfModel)

# Evaluate error evolution
errorEvolution(rf_l03_nt100_TDmcwhsa, 
               useCategory="OOB", 
               subT="Exclude Locales with High Overlap to Cold Midwest"
               )

```
  
At a glance, the combinations chosen from the individual cities seem sensible given how the individual cities tend to (mis)classify.

Random forests can also be used to run regressions, such as on variables like temperature or dew point.  Suppose that a few data elements are available, and the goal is to predict the temmperature based on those:  
```{r}

# Build a regression dataset with factored variables for locale and source
regrData <- metarData %>%
    mutate(hr=lubridate::hour(lubridate::round_date(dtime, unit="1 hour")),
           hrfct=factor(hr), 
           localefct=factor(locale), 
           locName=str_replace(locale, pattern=" \\(\\d{4}\\)", replacement=""), 
           locNamefct=factor(locName)
           )

# Define a dependent variable and predictor variables and filtering criteria
depVar <- "TempF"
predVars <- c("DewF", "month", "hrfct", "locNamefct")
critFilter <- list("year"=c(2016), 
                   "locNamefct"=c("Chicago, IL", "Las Vegas, NV", "San Diego, CA", "New Orleans, LA")
                   )

# Filter such that only non-NA data across all of depVar and predVars are included
subRegData <- regrData %>%
    filter_at(vars(all_of(c(depVar, predVars, names(critFilter)))), all_vars(!is.na(.)))

# Filter such that only matches to critFilter are included
for (xNum in seq_len(length(critFilter))) {
    subRegData <- subRegData %>%
        filter_at(vars(all_of(names(critFilter)[xNum])), ~. %in% critFilter[[xNum]])
}

# Split in to a test set and a train set
testSize <- 0.3
set.seed(2007151232)
idxTrain <- sample(1:nrow(subRegData), size=round((1-testSize)*nrow(subRegData)), replace=FALSE)
trainRegData <- subRegData[idxTrain, ]  # will be in random order
testRegData <- subRegData[-idxTrain, ]  # will be in sorted order

# Run random forest regression
rfRegrData <- randomForest::randomForest(x=trainRegData[, predVars, drop=FALSE], 
                                         y=trainRegData[, depVar, drop=TRUE], 
                                         ntree=25, 
                                         mtry=2
                                         )

# Assess variable importance
rfRegrData %>% 
    caret::varImp()

# Assess evolution of OOB r-squared and RMSE
tibble::tibble(ntree=1:25, rmse=rfRegrData$mse**0.5) %>%
    ggplot(aes(x=ntree, y=rmse)) + 
    geom_point() + 
    ylim(c(0, NA)) + 
    labs(x="# Trees", y="RMSE", title="Evolution of RMSE")
tibble::tibble(ntree=1:25, rmse=rfRegrData$rsq) %>%
    ggplot(aes(x=ntree, y=rmse)) + 
    geom_point() + 
    ylim(c(NA, 1)) + 
    labs(x="# Trees", y="R-squared", title="Evolution of R-squared")

# Apply to test-set data and report metrics
rfPreds <- testRegData %>%
    mutate(pred=predict(rfRegrData, newdata=testRegData[, predVars, drop=FALSE]), 
           globMean=mean(get(depVar))
           ) %>%
    group_by(locale) %>%
    mutate(locMean=mean(get(depVar))) %>%
    ungroup() %>%
    mutate(errActualGlob=(get(depVar)-globMean)**2,
           errActualLoc=(get(depVar)-locMean)**2, 
           errPredict=(get(depVar)-pred)**2
           )

# Calculate the errors by locale
rfError <- rfPreds %>%
    select(locale, starts_with("err")) %>%
    group_by(locale) %>%
    summarize_all(~mean(.)**0.5)

# Plot errors by locale
rfError %>%
    pivot_longer(-locale, names_to="errorType", values_to="rmse") %>%
    ggplot(aes(x=locale, y=rmse, fill=errorType)) + 
        geom_col(position="dodge") + 
    labs(x="", y="Average Error", title="Prediction Accuracy by Locale") + 
    scale_fill_discrete("Actual vs.", 
                        c("errActualGlob", "errActualLoc", "errPredict"), 
                        c("Global Mean", "Locale Mean", "Predicted")
                        )

# Print errors by locale, including percentage changes
rfError %>%
    mutate(pctLocGlob=errActualLoc/errActualGlob, 
           pctPredLoc=errPredict/errActualLoc, 
           pctPredGlob=errPredict/errActualGlob
           )

```
  
A simple random forest significantly reduces null error in predicting temperatures, particularly for Chicago, Las Vegas, and New Orleans.  This suggests knowing the dew point and the month enhance predictions for seasonal locales, while being of less use in a marine climate with modest seasonal variation.

Note that San Diego has more accurate predictions than any other locale, it is just that San Diego does not need much more than locale to be accurate.  In contrast, Chicago averages ~25 degree error if using global mean, ~20 degrees error if using local mean, and ~5 degrees error if using dew point, month, and hour.
  
Notably, it appears that running with just a single tree explains nearly 90% of the variance and drives average prediction errors down to under 6 degrees.  While there is evolution with additional trees, it appears modest.  Potentially, large forests may not be less necessary for this regression analysis phase.
  
The above process is converted to functional form, with the main function running the filtering, then calling a modified rfTwoLocale() that is adapted to handle classification or regression.  The function reRegression() is available in WeatherModelingFunctions_v001.R.

The regression is run again using the same arguments with the new function, and results are cached:  
```{r cache=TRUE}

rfRegrData2 <- rfRegression(regrData, 
                            depVar=depVar, 
                            predVars=predVars, 
                            critFilter=critFilter, 
                            seed=2007151232, 
                            ntree=25, 
                            mtry=2, 
                            testSize=0.3
                            )

```
  
The general outcomes are nearly identical:  
```{r}

# Assess variable importance
rfRegrData2$rfModel %>% 
    caret::varImp()

# Assess evolution of OOB r-squared and RMSE
tibble::tibble(ntree=1:25, rmse=rfRegrData2$mse**0.5) %>%
    ggplot(aes(x=ntree, y=rmse)) + 
    geom_point() + 
    ylim(c(0, NA)) + 
    labs(x="# Trees", y="RMSE", title="Evolution of RMSE")
tibble::tibble(ntree=1:25, rmse=rfRegrData2$rsq) %>%
    ggplot(aes(x=ntree, y=rmse)) + 
    geom_point() + 
    ylim(c(NA, 1)) + 
    labs(x="# Trees", y="R-squared", title="Evolution of R-squared")

```
  
An evaluation function suitable for regresion is written, to cover the following metrics:  
  
1.  Variable importance  
2.  Evolution of RMSE and r-squared with number of trees  
3.  RMSE and r-squared in the test dataset plotted by key variable (locale)  
4.  Actual vs. predicted, optionally filtered and facetted, with an lm smooth and y=x abline  
  
Each sub-section is written as its own function, with a wrapper function that calls then all together.  The below functions are available in WeatherModelingFunctions_v001.R:  
  
* plotVariableImportance - plot of caret::varImp()  
* plotMSERSQ - plot of RMSE and R-squared evolution with number of trees  
* plotErrorByVar - plot of RMSE and R-squared by a user-defined key variable  
* plotActualVsPredicted - plot of actual vs, predicted, optionally facetted and filtered  
* evalRFRegression - calls the four functions above  
  
Example code for running the functions alone and together includes:  
```{r}

# Run function #1
plotVariableImportance(rfRegrData, 
                       returnData=TRUE, 
                       caption="temperature ~ f(locale, month, hour, dew point)", 
                       titleAdd=": Predicting Temperature"
                       )

# Run function #2
plotMSERSQ(rfRegrData, returnData=TRUE)

# Run function #3
plotErrorByVar(rfRegrData2, depVar="TempF", keyVar="locNamefct", returnData=TRUE)

# Run function #4
plotActualVsPredicted(rfRegrData2, depVar="TempF", facetVar="locNamefct", returnData=TRUE)

# Run combined function
rfOut_002 <- evalRFRegression(rfRegrData2, 
                              depVar="TempF", 
                              keyVar="locNamefct", 
                              facetVar="locNamefct", 
                              caption="Temp ~ f(locale, month, dew point, hour)",
                              returnData=TRUE
                              )

```

The random forest is then run for an expanded list of locales in 2016, with results cached:  
```{r cache=TRUE}

keyLocs3 <- c("Chicago, IL", "Las Vegas, NV", "San Diego, CA", "New Orleans, LA", "Atlanta, GA", "Denver, CO", "Dallas, TX", "Miami, FL", "Phoenix, AZ", "Seattle, WA", "Boston, MA", "San Francisco, CA")

# Run for select 2016 data
rfRegrData3 <- rfRegression(regrData, 
                            depVar="TempF", 
                            predVars=c("DewF", "month", "hrfct", "locNamefct"), 
                            critFilter=list(year=2016, locNamefct=keyLocs3), 
                            seed=2007171405, 
                            ntree=20, 
                            mtry=2, 
                            testSize=0.3
                            )

```
  
The results can then be evaluated:  
```{r}

rfOut_003 <- evalRFRegression(rfRegrData3, 
                              depVar="TempF", 
                              keyVar="locNamefct", 
                              facetVar="locNamefct", 
                              caption="Temp ~ f(locale, month, dew point, hour)",
                              returnData=TRUE
                              )

```
  
Month, locale, and dewpoint are all relatively high in variable importance, while hour is low.  This is somewhat surprising given that there are usually diurnal temperature changes, though the results suggest that month and dew point have greater impact on temperatures.  Denver is the hardest locale for the model to predict.

The process is run again with hour excluded to see how that impacts the results:  
```{r cache=TRUE}

keyLocs3a <- c("Chicago, IL", "Las Vegas, NV", "San Diego, CA", "New Orleans, LA", "Atlanta, GA", "Denver, CO", "Dallas, TX", "Miami, FL", "Phoenix, AZ", "Seattle, WA", "Boston, MA", "San Francisco, CA")

# Run for select 2016 data
rfRegrData3a <- rfRegression(regrData, 
                             depVar="TempF", 
                             predVars=c("DewF", "month", "locNamefct"), 
                             otherVar=c("source", "dtime", "hrfct"),
                             critFilter=list(year=2016, locNamefct=keyLocs3a), 
                             seed=2007171405, 
                             ntree=20, 
                             mtry=2, 
                             testSize=0.3
                             )

```
  
And, the results are again evaluated:  
```{r}

rfOut_003a <- evalRFRegression(rfRegrData3a, 
                               depVar="TempF", 
                               keyVar="locNamefct", 
                               facetVar="locNamefct", 
                               caption="Temp ~ f(locale, month, dew point)",
                               returnData=TRUE
                               )

```
  
Run time is significantly faster with the elimination of the 24-category factor, hour.  Interestingly, there is no longer mush change in RMSE or R-squared with more trees, suggestive that the main work being done in the previous model is to incorporate the impact of hour.  Removing hour meaningfullky degrades both RMSE (~1.5 degrees more delta) and R-squared (~5% less variance explained).  Several locales no longer have prediction smooths that follow the 45-degree line, suggesting that hour may be especially helpful in specific locales.  Next steps are to explore this further.
  
Single-variable regressions are run to assess performance, using 1) only dew point, 2) only month, 3) only locale, 4) only hour, 5) only sea-level pressure, and 6) only altimeter:  
```{r}

# Set up the eplanatory variables and other variables to keep from 'testData
varSingles <- c("DewF", "month", "locNamefct", "hrfct", "modSLP", "Altimeter")
otherVars <- c("source", "dtime", "DewF", "month", "locNamefct", "hrfct", "modSLP", "Altimeter")

# Set up listContainerRFReg to hold results
listContainerRFReg <- vector("list", 6)
names(listContainerRFReg) <- varSingles

n <- 1
for (thisVar in varSingles) {
    
    # Run a single-variable regression for TempF vs. thisVar (should not evolve with number of trees)
    listContainerRFReg[[n]] <- rfRegression(regrData, 
                                            depVar="TempF", 
                                            predVars=thisVar, 
                                            otherVar=otherVars,
                                            critFilter=list(year=2016, locNamefct=keyLocs3a), 
                                            seed=2007181302+n, 
                                            ntree=5, 
                                            mtry=1, 
                                            testSize=0.3
                                            )
    
    # Increment n
    n <- n + 1
    
}

# R-squared of overall model by model type
rsq <- sapply(listContainerRFReg, FUN=function(x) x$rsq) %>%
    tibble::as_tibble() %>%
    mutate(ntree=row_number())

# Plot of final R-squared
rsq %>%
    filter(ntree==max(ntree)) %>%
    pivot_longer(-ntree, names_to="var", values_to="rsq") %>%
    ggplot(aes(x=fct_reorder(paste0(var, "\n", varMapper[var]), rsq), y=rsq)) +
    geom_col(fill="lightblue") + 
    geom_text(aes(y=rsq/2, label=round(rsq, 3))) + 
    coord_flip() +
    labs(x="", 
         y="Overall R-squared", 
         title="Predicting temperature using only a single variable"
         )

```
  
At an overall level, month and dew point are the most helpful in differentiating temperatures, followed by locale.  Hour is the least helpful, and appears to add value only when other variables have already been included.

How is accuracy in the varying locales impacted by the variable used?
```{r}

# Impact for just using month
plotErrorByVar(listContainerRFReg$month, 
               depVar="TempF", 
               keyVar="locNamefct", 
               caption="Temperature ~ f(month)"
               )

# Impact for just using dew point
plotErrorByVar(listContainerRFReg$DewF, 
               depVar="TempF", 
               keyVar="locNamefct", 
               caption="Temperature ~ f(dewpoint)"
               )

# Impact for just using locale
plotErrorByVar(listContainerRFReg$locNamefct, 
               depVar="TempF", 
               keyVar="month", 
               caption="Temperature ~ f(locale)"
               )

```
  
The issues with using a single predictor are obvious, as many of R-squared by dimension become negative.  Specifically:  
  
* Using month-only as a predictor works best for Atlanta, Dallas, and Las Vegas, while driving worse than null performance for Miami, San Francisco, and San Diego  
* Using dewpoint-only as a predictor works best for New Orleans, Atlanta, and Dallas, while driving worse than null performance for the desert and marine locales  
* Using locale-only as a predictor works best in March-May and October-November, while driving worse than null performance for summer and winter months  
  
The month-only result is explored in more detail:  
```{r}

# Predictions based solely on month
listContainerRFReg$month$testData %>%
    group_by(locNamefct, month) %>%
    summarize(meanTemp=mean(TempF)) %>%
    group_by(month) %>%
    mutate(meanMonth=mean(meanTemp)) %>%
    ungroup() %>%
    filter(locNamefct %in% c("Atlanta, GA", "Dallas, TX", "Las Vegas, NV", 
                             "Miami, FL", "San Francisco, CA", "San Diego, CA"
                             )
           ) %>%
    ggplot(aes(x=month, y=meanTemp)) + 
    geom_line(aes(group=locNamefct, color=locNamefct)) + 
    geom_line(data=~filter(., locNamefct=="Atlanta, GA"), aes(y=meanMonth, group=1, lwd=2)) + 
    labs(x="", 
         y="Average Temperature", 
         title="Average Temperature by Month", 
         subtitle="Overall and by locale"
         ) + 
    scale_color_discrete("Locale") + 
    scale_size_continuous("Overall Average", labels=NULL)

```
  
The findings are as expected.  Atlanta, Dallas, and Las Vegas have seasonal variations that broadly follow the overall average.  In contrast, San Francisco and San Diego tend to be warmer than overall average in winter and colder than overall average in summer.  Miami tends to be warmer than overall average in all months, and with not much montly variation.
  
Clearly, at least two variables are needed.  Suppose that for simplification, only the two best factor variable predictors are used:  
```{r}

# Run a regression for TempF vs. month and locale
rfTempvMonthLocale <- rfRegression(regrData, 
                                   depVar="TempF", 
                                   predVars=c("month", "locNamefct"), 
                                   otherVar=otherVars,
                                   critFilter=list(year=2016, locNamefct=keyLocs3a), 
                                   seed=2007181357, 
                                   ntree=5, 
                                   mtry=2, 
                                   testSize=0.3
                                   )

# Evaluate simple regression using only locale and month
rfOut_tvml <- evalRFRegression(rfTempvMonthLocale, 
                               depVar="TempF", 
                               keyVar="locNamefct", 
                               facetVar="locNamefct", 
                               caption="Temp ~ f(locale, month)",
                               returnData=TRUE
                               )

# Impact on predictions by month
plotErrorByVar(rfTempvMonthLocale, 
               depVar="TempF", 
               keyVar="month", 
               caption="Temp ~ f(locale, month)"
               )

# Impact on predictions by hour
plotErrorByVar(rfTempvMonthLocale, 
               depVar="TempF", 
               keyVar="hrfct", 
               caption="Temp ~ f(locale, month)"
               )

```
  
As expected, R-squared is now positive for all elements on the locale and month dimensions.  Predictions appear to be less accurate for the 19-24Z range, reflecting roughly the afternoon in the US, and to be most accurate in the 2-8 (early nighttime) and 14-17 (morning) hours.  There is no evolution in RMSE or R-squared with number of trees since the model is (essentially) just finding the average temperature by locale and month.

Hour is added to the model for an additional attempt to improve accuracy:  
```{r cache=TRUE}

# Run a regression for TempF vs. month and locale and hour
rfTempvMonthLocaleHour <- rfRegression(regrData, 
                                       depVar="TempF", 
                                       predVars=c("month", "locNamefct", "hrfct"), 
                                       otherVar=otherVars,
                                       critFilter=list(year=2016, locNamefct=keyLocs3a), 
                                       seed=2007181421, 
                                       ntree=5, 
                                       mtry=3, 
                                       testSize=0.3
                                       )

```
  
Evaluations are then performed:  
```{r}

# Evaluate simple regression using only locale and month and hour
rfOut_tvmlh <- evalRFRegression(rfTempvMonthLocaleHour, 
                                depVar="TempF", 
                                keyVar="locNamefct", 
                                facetVar="locNamefct", 
                                caption="Temp ~ f(locale, month, hour)",
                                returnData=TRUE
                                )

# Impact on predictions by month
plotErrorByVar(rfTempvMonthLocaleHour, 
               depVar="TempF", 
               keyVar="month", 
               caption="Temp ~ f(locale, month, hour)"
               )

# Impact on predictions by hour
plotErrorByVar(rfTempvMonthLocaleHour, 
               depVar="TempF", 
               keyVar="hrfct", 
               caption="Temp ~ f(locale, month, hour)"
               )

```
  
Accuracy by hour is more uniform, and the overall predictive power has increased.

Run times show the drawback of using random forest regression on such a simple problem:  
```{r}

# Extract the key data
lmData <- regrData %>%
    filter(year==2016, locNamefct %in% keyLocs3a)

# Extract the relevant testData
testData <- rfTempvMonthLocaleHour$testData

# Create trainData as lmData anti-joined to testData
trainData <- lmData %>%
    anti_join(select(testData, source, dtime))

# Get the averages from train data
trainAvg <- 
    trainData %>%
    group_by(locNamefct, month, hrfct) %>%
    summarize(predMean=mean(TempF, na.rm=TRUE))

# Merge back to testData
testData <- testData %>%
    left_join(trainAvg)

# Report on RMSE and R-squared
testData %>%
    summarize(varTot=var(TempF), varPred=var(predMean-TempF, na.rm=TRUE), 
              rsq=1-varPred/varTot, rmse=varPred**0.5
              )

```
  
The identical RMSE and R-squared are obtained in under a second.  Note that running lm(TempF ~ locNamefct * month * hrfct, ...) takes much longer than the random forest regression due to complexities related to using solve() and storing diagnostic statistics.  Model selection should be driven by many factors.  In this specific example, they all converge to predicting temperature as the mean for each grouping of factors.
  
A run of the random forest regression is then made using only a few numeric variables - dew point, sea-level pressure, and altimeter:  
```{r cache=TRUE}

# Run a regression for TempF vs. dewpoint and sea-lvele pressure and altimeter
rfTempvDewSLPAltimeter <- rfRegression(regrData, 
                                       depVar="TempF", 
                                       predVars=c("DewF", "modSLP", "Altimeter"), 
                                       otherVar=otherVars,
                                       critFilter=list(year=2016, locNamefct=keyLocs3a), 
                                       seed=2007191311, 
                                       ntree=5, 
                                       mtry=3, 
                                       testSize=0.3
                                       )

```
  
```{r}

# Evaluate simple regression using only dewpoint and sea-lvele pressure and altimeter
rfOut_tvdsa <- evalRFRegression(rfTempvDewSLPAltimeter, 
                                depVar="TempF", 
                                keyVar="locNamefct", 
                                facetVar="locNamefct", 
                                caption="Temp ~ f(dew point, SLP, altimeter)",
                                returnData=TRUE
                                )

# Impact on predictions by month
plotErrorByVar(rfTempvDewSLPAltimeter, 
               depVar="TempF", 
               keyVar="month", 
               caption="Temp ~ f(dew point, SLP, altimeter)"
               )

# Impact on predictions by hour
plotErrorByVar(rfTempvDewSLPAltimeter, 
               depVar="TempF", 
               keyVar="hrfct", 
               caption="Temp ~ f(dew point, SLP, altimeter)"
               )

```
  
Dew point and sea-level pressure stand out as more important then altimeter.  Notably, unlike the categorical regression, the model continues to learn with more trees suggesting that 5 is too few.  Additionally, predictions are "worse than null" for San Diego and San Francsico, suggesting that the locale variable is vital for establishing differing relationships of temperature to dew point in different locales.

An additional version of the model is run taking the two highest importance variables from each of the previous regressions - locale, month, dew point, and sea-level pressure:  
```{r cache=TRUE}

# Run a regression for TempF vs. month, locale, dew point, sea-level pressure
rfTempvDewSLPMonthLocale <- rfRegression(regrData, 
                                         depVar="TempF", 
                                         predVars=c("DewF", "modSLP", "month", "locNamefct"), 
                                         otherVar=otherVars,
                                         critFilter=list(year=2016, locNamefct=keyLocs3a), 
                                         seed=2007191321, 
                                         ntree=20, 
                                         mtry=2, 
                                         testSize=0.3
                                         )

```
  
```{r}

# Evaluate regression using dew point, sea-level pressure, month, locale
rfOut_tvdsml <- evalRFRegression(rfTempvDewSLPMonthLocale, 
                                 depVar="TempF", 
                                 keyVar="locNamefct", 
                                 facetVar="locNamefct", 
                                 caption="Temp ~ f(dew point, SLP, month, locale)",
                                 returnData=TRUE
                                 )

# Impact on predictions by month
plotErrorByVar(rfTempvDewSLPMonthLocale, 
               depVar="TempF", 
               keyVar="month", 
               caption="Temp ~ f(dew point, SLP, month, locale)"
               )

# Impact on predictions by hour
plotErrorByVar(rfTempvDewSLPMonthLocale, 
               depVar="TempF", 
               keyVar="hrfct", 
               caption="Temp ~ f(dew point, SLP, month, locale)"
               )

```
  
Month is the most important variable, followed by locale and dew point.  Sea-level pressure appears to have less influence.  RMSE is down slightly and R-squared is up slightly, with predictions continuing to be hardest in Denver (high RMSE) and San Diego/San Francisco (low r-squared).

There continues to be a pattern where times in 18Z-24Z (roughly late afternoon) are predicted much worse then times in 2-8Z (roughly the first half of nighttime), potentially suggesting that including hour as an explanatory variable could help.

A version of the random forest regression is then run that adds hour and altimeter to the mix.  The mtry variable is held at 2:  
```{r cache=TRUE}

# Run a regression for TempF vs. six key variables
rfTempvBig6 <- rfRegression(regrData, 
                            depVar="TempF", 
                            predVars=c("DewF", "modSLP", "Altimeter", "month", "locNamefct", "hrfct"), 
                            otherVar=otherVars,
                            critFilter=list(year=2016, locNamefct=keyLocs3a), 
                            seed=2007191338, 
                            ntree=20, 
                            mtry=2, 
                            testSize=0.3
                            )

```
  
```{r}

# Evaluate regression using six key variables
rfOut_tvbig6 <- evalRFRegression(rfTempvBig6, 
                                 depVar="TempF", 
                                 keyVar="locNamefct", 
                                 facetVar="locNamefct", 
                                 caption="Temp ~ f(dew point, SLP, altimeter, month, locale, hour)",
                                 returnData=TRUE
                                 )

# Impact on predictions by month
plotErrorByVar(rfTempvBig6, 
               depVar="TempF", 
               keyVar="month", 
               caption="Temp ~ f(dew point, SLP, altimeter, month, locale, hour)"
               )

# Impact on predictions by hour
plotErrorByVar(rfTempvBig6, 
               depVar="TempF", 
               keyVar="hrfct", 
               caption="Temp ~ f(dew point, SLP, altimeter, month, locale, hour)"
               )

```
  
While hour and altimeter show as lower on variable importance, overall model performance is significantly improved.  Specifically, RMSE is down to ~4.5 and still falling with more trees, while r-squared is up to ~0.93 and still rising with more trees.  Notably, many of the locales are now at 90%+ r-squared, with even San Diego and San Francisco now being accurately classified.
  
Next steps are to focus specifically on some of the tougher locales (Denver, San Francisco, San Diego) and times (20Z for example) to explore what is driving those challenges.
  
Since locale and month are both known to be important, do the forests run more quickly if they are run for subsets of the data?  
```{r}

regrSubData <- regrData %>%
    filter(year==2016, locNamefct %in% keyLocs3a)

locsRegSub <- regrSubData %>%
    pull(locNamefct) %>%
    as.character() %>%
    unique() %>%
    sort()

```
  
Forests are then run for each locale:  
```{r cache=TRUE}

startTime <- Sys.time()

# Create a container to hold the output
lstRegSub <- vector("list", length(locsRegSub))
names(lstRegSub) <- locsRegSub

n <- 1
for (loc in locsRegSub) {

    # Run a regression for TempF vs. month, hour, dew point, sea-level pressure, altitude
    lstRegSub[[n]] <- rfRegression(regrSubData, 
                                   depVar="TempF", 
                                   predVars=c("DewF", "modSLP", "Altimeter", "month", "hrfct"), 
                                   otherVar=otherVars,
                                   critFilter=list(year=2016, locNamefct=loc), 
                                   seed=2007201355+n, 
                                   ntree=20, 
                                   mtry=2, 
                                   testSize=0.3
                                   )
    
    # Incerement counter
    n <- n + 1
    
    # Update progress
    cat("\nFinished processing:", loc)
    
}

endTime <- Sys.time()
cat("\nTotal run time:", round(endTime - startTime, 1), "seconds\n")

```
  
This process runs in around 20 seconds, roughly 100x faster than running the random forest with all the data together.  In this case, locale is known to be strongly predictive, so splitting it out may make sense.  Does the timing change if month is also split out?  
```{r cache=TRUE}

startTime <- Sys.time()

# Create a container to hold the output
lstRegSub_002 <- vector("list", length(locsRegSub)*length(month.abb))

n <- 1
for (loc in locsRegSub) {
    for (mon in month.abb) {
        # Run a regression for TempF vs. hour, dew point, sea-level pressure, altitude
        lstRegSub_002[[n]] <- rfRegression(regrSubData, 
                                           depVar="TempF", 
                                           predVars=c("DewF", "modSLP", "Altimeter", "hrfct"), 
                                           otherVar=otherVars,
                                           critFilter=list(year=2016, locNamefct=loc, month=mon), 
                                           seed=2007201405+n, 
                                           ntree=20, 
                                           mtry=2, 
                                           testSize=0.3
                                           )
    
        # Incerement counter
        n <- n + 1
    }
    
    # Update progress
    cat("\nFinished processing:", loc)
    
}

endTime <- Sys.time()
cat("\nTotal run time:", round(endTime - startTime, 1), "seconds\n")

```
  
There is no obvious improvement in run time, suggesting that the increased overhead of the for loops may be offsetting any efficiency gains from growing much simpler trees on smaller datasets.

The data from the locale regressions is combined, for purposes of running diagnostics:  
```{r}

# Integrate the test data
subTestData <- map_dfr(lstRegSub, .f=function(x) { x$testData} )

# Integrate the r-squared data
subRSQ <- map_dfr(lstRegSub, 
                  .f=function(x) { tibble::tibble(ntree=1:length(x$rsq), rsq=x$rsq) }, 
                  .id="source"
                  )

# Integrate the RMSE data
subRMSE <- map_dfr(lstRegSub, 
                   .f=function(x) { tibble::tibble(ntree=1:length(x$mse), rmse=x$mse**0.5) }, 
                   .id="source"
                   )

# Plot integrated evolution of RSQ
helperPlotEvolution <- function(df, plotVar) {
    
    p1 <- df %>%
        ggplot(aes_string(x="ntree", y=plotVar)) + 
        geom_line(aes(group=source, color=source)) + 
        labs(x="Number of trees", 
             title=paste0("Evolution of ", str_to_upper(plotVar), " by locale")
             )
    if (plotVar=="rsq") { p1 <- p1 + ylim(c(NA, 1)) }
    if (plotVar=="rmse") { p1 <- p1 + ylim(c(0, NA)) }
    print(p1)
    
}

# Plot final R-squared and RMSE by locale
ebvRFSub_loc <- plotErrorByVar(list(testData=subTestData), 
                               depVar="TempF", 
                               keyVar="locNamefct", 
                               returnData=TRUE
                               )

# Plot final R-squared and RMSE by month
ebvRFSub_mon <- plotErrorByVar(list(testData=subTestData), 
                               depVar="TempF", 
                               keyVar="month", 
                               returnData=TRUE
                               )

# Plot final R-squared and RMSE by hour
ebvRFSub_hr <- plotErrorByVar(list(testData=subTestData), 
                              depVar="TempF", 
                              keyVar="hrfct", 
                              returnData=TRUE
                              )

# Show differences by model run
ebvData <- bind_rows(ebvRFSub_loc, rfOut_tvbig6$f3, .id="source") %>%
    mutate(source=ifelse(source==1, "Run by locale", "Run overall"))

# Plot differences in R-squared
ebvData %>%
    ggplot(aes(x=fct_reorder(locNamefct, rsq), y=rsq)) + 
    geom_point(aes(color=source)) + 
    coord_flip() + 
    ylim(c(NA, 1)) + 
    labs(x="", y="R-squared", title="R-squared by modeling approach") + 
    scale_color_discrete("Model")

# Plot differences in RMSE
ebvData %>%
    ggplot(aes(x=fct_reorder(locNamefct, rmse), y=rmse)) + 
    geom_point(aes(color=source)) + 
    coord_flip() + 
    ylim(c(0, NA)) + 
    labs(x="", y="RMSE", title="RMSE by modeling approach") + 
    scale_color_discrete("Model")

```
  
If anything, the models run by locale appear to be slightly more accurate than the models run overall.  The differences in variable importance can also be assessed:  
```{r}

# Grab the variable importance for each locale
impLstRegSub <- map_dfr(lstRegSub, 
                        .f=function(x) { x$rfModel$importance %>% t() %>% tibble::as_tibble() }, 
                        .id="locNamefct"
                        )

# Get the percentage by variable, then plot
impLstRegSub %>%
    pivot_longer(-locNamefct, names_to="variable", values_to="importance") %>%
    group_by(locNamefct) %>%
    mutate(pct=importance/sum(importance)) %>%
    ungroup() %>%
    ggplot(aes(x=locNamefct, y=variable)) + 
    geom_tile(aes(fill=pct)) + 
    geom_text(aes(label=round(pct, 3))) + 
    coord_flip() + 
    labs(x="", y="", title="Variable importance by locale (scaled to add to 100% in each locale)") + 
    scale_fill_continuous("Percent", low="white", high="green")

```
  
There are some interesting differences in variable importance by locale:  
  
* Las Vegas and Phoenix make very little use of dewpoint, while Denver, San Diego, and San Francisco also show far less importance for this attribute  
* Las Vegas, Phoenix, and Denver use primarily month with some weight on sea-level pressure, and hour  
* San Diego and San Francisco use a rather balanced weighting of month, hour, and dew point  
  
Portions of the difference are driven by seasonal extremes.  For example, Chicago has four distinct seasons with dew point correlated to temperature in each.  Thus, there is a lot of variance in Chicago temperature data, and much of that variance can be explained by dewpoint.  In contrast, Las Vegas tends to have low dew points all year and the marine locales tend to have moderate dew points all year.  As such, there is little explanatory power of dew point in these locales.

Another area to examine is the explanatory power for random forest regressions by a mix of two factor variables.  A helper function is written to explore this - helperAccuracyByFactors() is available in file WeatherModelingFunctions_v001.R:  
```{r}

helperAccuracyByFactors(subTestData, xVar="locNamefct", yVar="month", depVar="TempF", metric="rsq")
helperAccuracyByFactors(subTestData, xVar="locNamefct", yVar="month", depVar="TempF", metric="rmse")

```
  
There are some rather low explanatory powers for some of these intersections.  A chunk of the model's overall explanatory power by locale is in finding differences in average temperature by month, and a few of the R-squared suggest there is not much more being learned about the within month differences.  Boston in July stands out - what does the explanatory power by hour look like?  Hours are grouped by three to minimize buckets with very small data:  
```{r}

subJuly <- subTestData %>%
    filter(month=="Jul") %>%
    mutate(hrBucket=factor(3 * (((as.integer(hrfct)-1) %% 24) %/% 3) + 1))

helperAccuracyByFactors(subJuly, xVar="locNamefct", yVar="hrBucket", depVar="TempF", metric="rsq")

```
  
There is clearly significant room for improvement, as several of the R-squared values are negative.  Suppose that random forest regressions are run for each locale, using only July data:  
```{r cache=TRUE}

startTime <- Sys.time()

# Create a container to hold the output
lstRegSub_jul <- vector("list", length(locsRegSub))

n <- 1
for (loc in locsRegSub) {
    for (mon in month.abb[7]) {
        # Run a regression for TempF vs. hour, dew point, sea-level pressure, altitude
        lstRegSub_jul[[n]] <- rfRegression(regrSubData, 
                                           depVar="TempF", 
                                           predVars=c("DewF", "modSLP", "Altimeter", "hrfct"), 
                                           otherVar=otherVars,
                                           critFilter=list(year=2016, locNamefct=loc, month=mon), 
                                           seed=2007211342+n, 
                                           ntree=100, 
                                           mtry=3, 
                                           testSize=0.3
                                           )
    
        # Incerement counter
        n <- n + 1
    }
    
    # Update progress
    cat("\nFinished processing:", loc)
    
}

endTime <- Sys.time()
cat("\nTotal run time:", round(endTime - startTime, 1), "seconds\n")

```
  
The evaluation process can then be run again:  
```{r}

# Integrate the test data
subTestData_jul <- map_dfr(lstRegSub_jul, .f=function(x) { x$testData} )

# Plot final R-squared and RMSE by locale
ebvRFSub_loc_jul <- plotErrorByVar(list(testData=subTestData_jul), 
                                   depVar="TempF", 
                                   keyVar="locNamefct", 
                                   returnData=TRUE
                                   )

# Plot final R-squared and RMSE by hour
ebvRFSub_hr_jul <- plotErrorByVar(list(testData=subTestData_jul), 
                                  depVar="TempF", 
                                  keyVar="hrfct", 
                                  returnData=TRUE
                                  )

subJuly_002 <- subTestData_jul %>%
    filter(month=="Jul") %>%
    mutate(hrBucket=factor(3 * (((as.integer(hrfct)-1) %% 24) %/% 3) + 1))

helperAccuracyByFactors(subJuly_002, xVar="locNamefct", yVar="hrBucket", depVar="TempF", metric="rsq")

```
  
Boston remains the hardest to predict in July, and there has been only a little imporvement in RMSE or R-squared.  Why is the Dallas data still showing negative R-squared?  
```{r}

subPlotJuly <- subJuly_002 %>%
    filter(locNamefct=="Dallas, TX", hrBucket==7)

subPlotJuly

subPlotJuly %>%
    ggplot(aes(x=TempF, y=predicted)) + 
    geom_point() + 
    geom_abline(lty=2, color="red") + 
    labs(x="Actual Temperature", y="Predicted Temperature") + 
    geom_text(data=~filter(., TempF < 78), aes(x=TempF+0.25, label=dtime), hjust=0, color="red") +
    coord_equal()

```
  
The model appears to be reasonable in this case.  There is an anomalously low temperature of 75 degrees at 6Z on July 10.  The model is predicts a value that is roughly in-line with what would typically be expected for Dallas in July at midnight.  A plot of Dallas Temperatures and Dew Points in July suggests that while low temperatures in the mid-70s are rare, they occur several times:  
```{r}

regrData %>% 
    filter(source=="kdfw_2016", month=="Jul", !is.na(TempF), !is.na(DewF)) %>% 
    ggplot(aes(x=dtime, y=TempF)) + 
    geom_line(color="red") + 
    geom_line(aes(y=DewF), color="blue") + 
    labs(x="", y="Temp/Dew (F)", title="Dallas, TX in July 2016")

```
  
The dew point does not help predict these low temperature evenings.  Suppose 76 degrees is used as the cutoff for a "cold" July occurrence in Dallas.  Does anything stand out about these times?  
```{r}

dfw_jul <- regrData %>% 
    filter(source=="kdfw_2016", month=="Jul", !is.na(TempF), !is.na(DewF)) %>% 
    mutate(isCold=TempF <= 76.5) 

dfw_jul%>% 
    select(-year, -monthint, -day, -starts_with("cL"), -starts_with("orig"), -hr) %>%
    group_by(isCold) %>%
    summarize_if(is.numeric, .funs=mean, na.rm=TRUE)

dfw_jul%>% 
    select(-year, -monthint, -day, -starts_with("cL"), -starts_with("orig"), -hr) %>%
    group_by(isCold) %>%
    summarize_if(is.logical, .funs=mean, na.rm=TRUE)

dfw_jul%>% 
    count(isCold, predomDir) %>%
    group_by(isCold) %>%
    mutate(pct=n/sum(n)) %>%
    pivot_wider(predomDir, names_from="isCold", values_from="pct")

dfw_jul%>% 
    count(isCold, minHeight) %>%
    group_by(isCold) %>%
    mutate(pct=n/sum(n)) %>%
    pivot_wider(minHeight, names_from="isCold", values_from="pct")

dfw_jul%>% 
    count(isCold, ceilingHeight) %>%
    group_by(isCold) %>%
    mutate(pct=n/sum(n)) %>%
    pivot_wider(ceilingHeight, names_from="isCold", values_from="pct")

```
  
It appears that a "cold" July evening in Dallas is associated with precipitation, clouds, and winds from the east.  Does this match up with data from July 10?
```{r}

metarData %>%
    filter(source=="kdfw_2016", month=="Jul", lubridate::day(dtime)==10, lubridate::hour(dtime) < 12) %>%
    pull(origMETAR)

```
  
To a degree, yes.  There were clouds and rain earlier in the evening, though these had cleared out by the time of the anomaly.  Potentially, an area for further exploration.
  
Next, the evolution of RMSE as variables are added is plotted.  The main categorical variables - locale, month, and hour - are added first, as these are largely just the average for the intersection of variables:  
```{r}

# Sample test/train dataset
set.seed(2007221340)
nullData <- regrData %>%
    filter(!is.na(TempF), year==2016, TempF <= 120, DewF <= 100, TempF >= DewF) %>%
    mutate(isTest=runif(nrow(.))<=0.3)

# Null estimates for temperature based on locale; locale-month; and locale-month-hour
nullMeans <- nullData %>%
    filter(!isTest) %>%
    group_by(locNamefct) %>%
    mutate(meanLoc=mean(TempF)) %>%
    group_by(locNamefct, month) %>%
    mutate(meanLocMonth=mean(TempF)) %>%
    group_by(locNamefct, month, hrfct) %>%
    summarize(meanLoc=mean(meanLoc), meanLocMonth=mean(meanLocMonth), meanLocMonthHour=mean(TempF), n=n()) %>%
    ungroup()

# Assessment of accuracies for temperature by locale
nullTest <- nullData %>%
    filter(isTest) %>%
    right_join(nullMeans, by=c("locNamefct", "month", "hrfct")) %>%
    mutate(eLoc=meanLoc-TempF, 
           eLocMonth=meanLocMonth-TempF, 
           eLocMonthHour=meanLocMonthHour-TempF
           )

# Create overall metrics
nullOverall <- nullTest %>%
    mutate(locNamefct="Overall") %>%
    group_by(locNamefct) %>%
    summarize(varTot=var(TempF), 
              eLoc2=mean(eLoc**2), 
              eLocMonth=mean(eLocMonth**2), 
              eLocMonthHour=mean(eLocMonthHour**2)
              )

# Create locale metrics, and bind overall metrics
nullByLocale <- nullTest %>%
    mutate(locNamefct=as.character(locNamefct)) %>%
    group_by(locNamefct) %>%
    summarize(varTot=var(TempF), 
              eLoc2=mean(eLoc**2), 
              eLocMonth=mean(eLocMonth**2), 
              eLocMonthHour=mean(eLocMonthHour**2)
              ) %>%
    bind_rows(nullOverall)

# Create plot for RMSE
nullByLocale %>%
    pivot_longer(-locNamefct, names_to="byNull", values_to="MSE") %>%
    mutate(RMSE=MSE**0.5, 
           byNull=factor(byNull, levels=c("varTot", "eLoc2", "eLocMonth", "eLocMonthHour"))
           )%>%
    group_by(locNamefct) %>% 
    mutate(dRMSE=ifelse(row_number()==n(), RMSE, RMSE-lead(RMSE))) %>%
    ungroup() %>%
    ggplot(aes(x=fct_reorder(locNamefct, RMSE), y=dRMSE, fill=byNull)) + 
    geom_col(position="stack") + 
    coord_flip() + 
    scale_fill_discrete("Technique", 
                        breaks=c("varTot", "eLoc2", "eLocMonth", "eLocMonthHour"), 
                        labels=c("Overall", "Locale", "Locale-Month", "Locale-Month-Hour"), 
                        guide=guide_legend(reverse=TRUE)
                        ) + 
    labs(x="", y="RMSE", title="RMSE by Locale by Technique (averages only)") + 
    theme(legend.position="bottom")

```
  
For predicting overall accuracy, improvements in RMSE are most rapid when moving from locale-only to a combination of locale-month.  This pattern appears to be generally repeated for most locales.

How much expalantory power do dewpoint and sea-level pressure have after controlling for locale-month-hour?  
```{r}

# Addition of dew point to training data
nullTrain <- nullData %>%
    filter(!isTest) %>%
    right_join(nullMeans, by=c("locNamefct", "month", "hrfct")) %>%
    mutate(err=meanLocMonthHour-TempF)

# Simple linear regression for dew point vs. error
lm(err ~ DewF, data=nullTrain) %>% 
    summary()

# Simple linear regression for modSLP vs. error
lm(err ~ modSLP, data=nullTrain) %>% 
    summary()

# Simple linear regression for dew point and modSLP vs. error
lm(err ~ DewF + modSLP, data=nullTrain) %>% 
    summary()

```
  
At a glance, dew point and sea-level pressure both have meaningful explanatory power.  In combination, they explain 17% of the variance in error when predictions are made solely based on locale-month-hour.

Does this change when regressions are run on smaller slices of the data (locale-month)?
```{r}

nullLM <- nullTrain %>%
    nest(data=-c(locNamefct, month)) %>%
    mutate(lmResult=map(data, ~lm(err ~ DewF + modSLP, data=.x)), 
           tidied=map(lmResult, broom::glance)
           ) %>%
    unnest(tidied)

nullLM %>%
    ggplot(aes(x=r.squared)) +
    geom_histogram(bins=10) + 
    labs(x="R-squared", 
         y="# Combinations of Locale-Month", 
         title="R-squared for error ~ dewpoint + sea-level pressure", 
         subtitle="Error based on null model of temperature ~ locale + month + hour"
         )

nullLM %>%
    ggplot(aes(x=fct_reorder(locNamefct, r.squared), y=r.squared)) + 
    geom_boxplot(fill="lightblue") + 
    coord_flip() + 
    labs(x="", 
         y="R-squared", 
         title="R-squared for error ~ dewpoint + sea-level pressure (by locale/month)", 
         subtitle="Error based on null model of temperature ~ locale + month + hour"
         )

nullLM %>%
    ggplot(aes(x=month, y=r.squared)) + 
    geom_boxplot(fill="lightblue") + 
    coord_flip() + 
    labs(x="", 
         y="R-squared", 
         title="R-squared for error ~ dewpoint + sea-level pressure (by locale/month)", 
         subtitle="Error based on null model of temperature ~ locale + month + hour"
         )

```
  
Addiing dewpoint and sea-level pressure appears to have better explanatory power in cold-weather locales and in cold-weather months.  Explanatory power appears to be lowest in marine and desert locales, and in warm-weather months.  In part, this is because there is less overall variation of temperature in these locales, and thus knowing the locale, month, and hour will already drive a very low RMSE.  In contrast, RMSE tended to be higher for the cold-weather locales.

The results of the linear regression can then be used to make a new prediction for temperature as follows:  
  
* There is an original, true temperature, To  
* There is a predicted temperature, Tp, based on locale-month-hour  
* There is a prediction error, Ep, calculated as Tp-To  
* There is an lm model calculating Ep ~ DewF + modSLP  
* Use the lm model to predict a new error, En, for each data element  
* Predict a new temperature, Tn, as Tn=Tp-En  
  
```{r}

# Merge the lm column to the testing data
nullTestLM <- nullTest %>%
    group_by(locNamefct, month) %>%
    nest(data=-c(locNamefct, month)) %>%
    ungroup() %>%
    left_join(select(nullLM, month, locNamefct, lmResult), by=c("month", "locNamefct"))

# Create new predictions in the nested frame
nullTestLM <- nullTestLM %>%
    mutate(data=map2(.x=data, 
                     .y=lmResult, 
                     ~mutate(.x, errPred=predict(.y, newdata=.x), tempPred=meanLocMonthHour-errPred)
                     )
           )

# Unnest for the actual data
lmNullDewSLP <- nullTestLM %>%
    unnest(data)

```
  
Calculate and plot the improvements in RMSE:  
```{r}

newOverall <- lmNullDewSLP %>% 
    mutate(locNamefct="Overall") %>% 
    group_by(locNamefct) %>% 
    summarize(eDewSLP=mean((TempF-tempPred)**2))

newByLocale <- lmNullDewSLP %>% 
    mutate(locNamefct=as.character(locNamefct)) %>% 
    group_by(locNamefct) %>% 
    summarize(eDewSLP=mean((TempF-tempPred)**2)) %>%
    bind_rows(newOverall) %>%
    right_join(nullByLocale, by=c("locNamefct"))

# Create plot for RMSE
newByLocale %>%
    select(-eDewSLP, eDewSLP) %>%
    pivot_longer(-locNamefct, names_to="byNull", values_to="MSE") %>%
    mutate(RMSE=MSE**0.5, 
           byNull=factor(byNull, levels=c("varTot", "eLoc2", "eLocMonth", "eLocMonthHour", "eDewSLP"))
           ) %>%
    group_by(locNamefct) %>% 
    mutate(dRMSE=ifelse(row_number()==n(), RMSE, RMSE-lead(RMSE))) %>%
    ungroup() %>%
    ggplot(aes(x=fct_reorder(locNamefct, RMSE, .fun=max), 
               y=dRMSE, 
               fill=byNull
               )
           ) + 
    geom_col(position="stack") + 
    coord_flip() + 
    scale_fill_discrete("Technique", 
                        breaks=c("varTot", "eLoc2", "eLocMonth", "eLocMonthHour", "eDewSLP"), 
                        labels=c("Impact of Locale", "Impact of Month", "Impact of Hour", 
                                 "Impact of Dew and SLP", "Final"
                                 ), 
                        guide=guide_legend(reverse=TRUE)
                        ) + 
    labs(x="", y="RMSE", title="RMSE by Locale by Technique (averages, then lm for Dew/SLP)") + 
    theme(legend.position="bottom")

```
  
The final RMSE by locale are much more even than the original RMSE by locale, driven by the significant impact of (especially) month and dewpoint/SLP in many of the more tricky locales.  Is there a similar finding when running random forests by locale?  
```{r cache=TRUE}

startTime <- Sys.time()

# Create a container to hold the output
locsFull2016 <- newByLocale %>% 
    filter(locNamefct != "Overall") %>%
    pull(locNamefct)
lstFull2016mhxx <- vector("list", length(locsFull2016))
names(lstFull2016mhxx) <- locsFull2016

# Filter so that TempF exists and that bizarre outliers cannot occur
regrUse2016 <- regrData %>%
    filter(!is.na(TempF), year==2016, TempF <= 120, DewF <= 100, TempF >= DewF)

n <- 1
for (loc in locsFull2016) {

    # Run a regression for TempF vs. month, hour
    lstFull2016mhxx[[n]] <- rfRegression(regrUse2016, 
                                         depVar="TempF", 
                                         predVars=c("month", "hrfct"), 
                                         otherVar=otherVars,
                                         critFilter=list(year=2016, locNamefct=loc), 
                                         seed=2007231345+n, 
                                         ntree=20, 
                                         mtry=2, 
                                         testSize=0.3
                                         )
    
    # Incerement counter
    n <- n + 1
    
    # Update progress
    cat("\nFinished processing:", loc)
    
}

endTime <- Sys.time()
cat("\nTotal run time:", round(as.numeric(difftime(endTime, startTime, units="secs")), 1), "seconds\n")

```
  
The MSE can then be calculated off each of the testData files, with comparisons made to the null data:  
```{r}

mseFull2016mhxx <- tibble::tibble(locNamefct=names(lstFull2016mhxx), 
                                  mse=sapply(lstFull2016mhxx, 
                                             FUN=function(x) {
                                                 mean((x$testData$TempF-x$testData$predicted)**2)
                                                 }
                                             )
                                  )

newByLocale %>% 
    inner_join(mseFull2016mhxx, by="locNamefct") %>% 
    mutate(delta=mse**0.5-eLocMonthHour**0.5) %>% 
    ggplot(aes(x=fct_reorder(locNamefct, -delta), y=delta)) +
    geom_col(fill="lightblue") + 
    coord_flip() + 
    labs(x="", 
         y="Change in RMSE (random forest RMSE minus null RMSE)", 
         title="Impact on RMSE of random forest vs. null model"
         )

```
  
Broadly speaking, then random forest regression and the null regression achieve very similar RMSE.  Some locales are predicted ~0.25 degrees better while others are predicted ~0.25 degrees worse.  Does this pattern hold when adding dewpoint and sea-level-pressure to the random forest regression?  
```{r cache=TRUE}

startTime <- Sys.time()

# Create a container to hold the output
locsFull2016 <- newByLocale %>% 
    filter(locNamefct != "Overall") %>%
    pull(locNamefct)
lstFull2016mhds <- vector("list", length(locsFull2016))
names(lstFull2016mhds) <- locsFull2016

# Filter so that TempF exists and that bizarre outliers cannot occur
regrUse2016 <- regrData %>%
    filter(!is.na(TempF), year==2016, TempF <= 120, DewF <= 100, TempF >= DewF)

n <- 1
for (loc in locsFull2016) {

    # Run a regression for TempF vs. month, hour
    lstFull2016mhds[[n]] <- rfRegression(regrUse2016, 
                                         depVar="TempF", 
                                         predVars=c("month", "hrfct", "DewF", "modSLP"), 
                                         otherVar=otherVars,
                                         critFilter=list(year=2016, locNamefct=loc), 
                                         seed=2007231345+n, 
                                         ntree=20, 
                                         mtry=3, 
                                         testSize=0.3
                                         )
    
    # Incerement counter
    n <- n + 1
    
    # Update progress
    cat("\nFinished processing:", loc)
    
}

endTime <- Sys.time()
cat("\nTotal run time:", round(as.numeric(difftime(endTime, startTime, units="secs")), 1), "seconds\n")

```

The MSE can then be calculated off each of the testData files, with comparisons made to the original data that combined null means with a linear model of dewpoint and SLP on the residuals:  
```{r}

mseFull2016mhds <- tibble::tibble(locNamefct=names(lstFull2016mhds), 
                                  mse=sapply(lstFull2016mhds, 
                                             FUN=function(x) {
                                                 mean((x$testData$TempF-x$testData$predicted)**2)
                                                 }
                                             )
                                  )

newByLocale %>% 
    inner_join(mseFull2016mhds, by="locNamefct") %>% 
    mutate(delta=mse**0.5-eDewSLP**0.5) %>% 
    ggplot(aes(x=fct_reorder(locNamefct, -delta), y=delta)) +
    geom_col(fill="lightblue") + 
    coord_flip() + 
    labs(x="", 
         y="Change in RMSE (random forest RMSE minus null+linear RMSE)", 
         title="Impact on RMSE of random forest vs. null+linear model"
         )

sapply(lstFull2016mhds, FUN=function(x) { x$rsq }) %>% 
    as.data.frame() %>% 
    mutate(ntree=1:n()) %>% 
    tibble::as_tibble() %>% 
    pivot_longer(-ntree, names_to="locale", values_to="rsq") %>%
    group_by(ntree) %>%
    summarize(meanrsq=mean(rsq)) %>%
    ggplot(aes(x=ntree, y=meanrsq)) + 
    geom_point() + 
    geom_text(aes(y=meanrsq+0.005, label=round(meanrsq, 3))) +
    ylim(c(NA, 1)) + 
    labs(x="# Trees", y="Mean R-squared by locale", title="Impact on R-squared of forest size")

```
  
The power of the random forest begins to appear, as RMSE is consistently lower by roughly ~0.5 degrees using the random forest regressions rather than the null means with a basic linear model.  Importantly, the random forest regression is able to consider hour, dewpoint, and SLP together for a given locale-month, while the null model used a constant impact of dewpoint and SLP for every hour in the locale-month.  Further, the random forest regression can potentially tease out non-linear patterns in the data.  

Further, the random forest regression model, while already performing better, is continuing to learn slightly even at around 20 trees.  This suggests that a larger forest might potentially drive slightly more prediction improvements.

The progression of RMSE by locale is plotted again:  
```{r}

mseFull2016Overall <- map_dfr(lstFull2016mhds, .f=function(x) { x$testData }) %>%
    summarize(err2=mean((TempF-predicted)**2)) %>%
    pull(err2)

mseFull2016mhds <- mseFull2016mhds %>%
    bind_rows(tibble::tibble(locNamefct="Overall", mse=mseFull2016Overall))

mseByLocale <- newByLocale %>% 
    inner_join(mseFull2016mhds, by=c("locNamefct")) %>%
    rename(rf=mse)

# Create plot for RMSE
mseByLocale %>%
    select(-eDewSLP, -rf, eDewSLP, rf) %>%
    pivot_longer(-locNamefct, names_to="byNull", values_to="MSE") %>%
    mutate(RMSE=MSE**0.5, 
           byNull=factor(byNull, levels=c("varTot", "eLoc2", "eLocMonth", "eLocMonthHour", "eDewSLP", "rf"))
           ) %>%
    group_by(locNamefct) %>% 
    mutate(dRMSE=ifelse(row_number()==n(), RMSE, RMSE-lead(RMSE))) %>%
    ungroup() %>%
    ggplot(aes(x=fct_reorder(locNamefct, RMSE, .fun=max), 
               y=dRMSE, 
               fill=byNull
               )
           ) + 
    geom_col(position="stack") + 
    coord_flip() + 
    scale_fill_discrete("Technique", 
                        breaks=c("varTot", "eLoc2", "eLocMonth", "eLocMonthHour", "eDewSLP", "rf"), 
                        labels=c("Impact of Locale", "Impact of Month", "Impact of Hour", 
                                 "Impact of Dew and SLP", "Impact of Forest", "Final"
                                 ), 
                        guide=guide_legend(reverse=TRUE)
                        ) + 
    labs(x="", y="RMSE", title="RMSE by Locale by Technique (averages, then lm for Dew/SLP, then forest)") + 
    theme(legend.position="bottom")

```
  
The modest but meaningful impact of moving to the random forest regression is apparent.
