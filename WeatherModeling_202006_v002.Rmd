---
title: "Weather Modeling"
author: "davegoblue"
date: "6/18/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
The file 'WeatherEDA_202005_v002.Rmd' contains exploratory data analysis for historical weather data as contained in METAR archives hosted by Iowa State University.

Data have been dowloaded, processed, cleaned, and integrated for several stations (airports) and years, with .rds files saved in "./RInputFiles/ProcessedMETAR".

This module will perform initial modeling on the processed weather files.  It builds on the previous 'WeatherModeling_202006_v001.Rmd' and leverages functions in 'WeatherModelingFunctions_v001.R'.

#### _Data Availability_  
There are three main processed files available for further exploration:  
  
_metar_postEDA_20200617.rds and metar_postEDA_extra_20200627.rds_  
  
* source (chr) - the reporting station and time  
* locale (chr) - the descriptive name for source  
* dtime (dttm) - the date-time for the observation  
* origMETAR (chr) - the original METAR associated with the observation at that source and date-time  
* year (dbl) - the year, extracted from dtime  
* monthint (dbl) - the month, extracted from dtime, as an integer  
* month (fct) - the month, extracted from dtime, as a three-character abbreviation (factor)  
* day (int) - the day of the month, extracted from dtime  
* WindDir (chr) - previaling wind direction in degrees, stored as a character since 'VRB' means variable  
* WindSpeed (int) - the prevailing wind speed in knots  
* WindGust (dbl) - the wind gust speed in knots (NA if there is no recorded wind gust at that hour)  
* predomDir (chr) - the predominant wind direction as NE-E-SE-S-SW-W-NW-N-VRB-000-Error  
* Visibility (dbl) - surface visibility in statute miles  
* Altimeter (dbl) - altimeter in inches of mercury  
* TempF (dbl) - the Fahrenheit temperature  
* DewF (dbl) - the Fahrenheit dew point  
* modSLP (dbl) - Sea-Level Pressure (SLP), adjusted to reflect that SLP is recorded as 0-1000 but reflects data that are 950-1050  
* cTypen (chr) - the cloud type of the nth cloud layer (FEW, BKN, SCT, OVC, or VV)  
* cLeveln (dbl) - the cloud height in feet of the nth cloud layer  
* isRain (lgl) - was rain occurring at the moment the METAR was captured?  
* isSnow (lgl) - was snow occurring at the moment the METAR was captured?  
* isThunder (lgl) - was thunder occurring at the moment the METAR was captured?  
* p1Inches (dbl) - how many inches of rain occurred in the past hour?  
* p36Inches (dbl) - how many inches of rain occurred in the past 3/6 hours (3-hour summaries at 3Z-9Z-15Z-21Z and 6-hour summaries at 6Z-12Z-18Z-24Z and NA at any other Z times)?  
* p24Inches (dbl) - how many inches of rain occurred in the past 24 hours (at 12Z, NA at all other times)  
* tempFHi (dbl) - the high temperature in the past 24 hours, in Fahrenheit (reported once per day)  
* tempFLo (dbl) - the low temperature in the past 24 hours, in Fahrenheit (reported once per day)  
* minHeight (dbl) - the minimum cloud height in feet (-100 means 'no clouds')  
* minType (fct) - amount of obscuration at the minimum cloud height (VV > OVC > BKN > SCT > FEW > CLR)  
* ceilingHeight (dbl) - the minimum cloud ceiling in feet (-100 means 'no ceiling')  
* ceilingType (fct) - amount of obscuration at the minimum ceiling height (VV > OVC > BKN)  
  
_metar_modifiedClouds_20200617.rds and metar_modifiedclouds_extra_20200627.rds_  
  
* source (chr) - the reporting station and time  
* sourceName (chr) - the descriptive name for source  
* dtime (dttm) - the date-time for the observation  
* level (dbl) - cloud level (level 0 is inserted for every source-dtime as a base layer of clear)  
* height (dbl) - level height (height -100 is inserted for every source-dtime as a base layer of clear)  
* type (dbl) - level type (type CLR is inserted for every source-dtime as a base layer of clear)  
  
_metar_precipLists_20200617.rds and metar_precipLists_extra_20200627.rds_  
  
* Contains elements for each of rain/snow/thunder for each of 2015/2016/2017  
* Each element contains a list and a tibble  
* The tibble is precipLength and contains precipitation by month as source-locale-month-hours-events  
* The list is precipList and contains data on each precipitation interval  
  
Several mapping files are defined for use in plotting; tidyverse, lubridate, and caret are loaded; and the relevant functions are sourced:  
```{r}

# The process frequently uses tidyverse, lubridate, caret, and randomForest
library(tidyverse)
library(lubridate)
library(caret)
library(randomForest)


# The main path for the files
filePath <- "./RInputFiles/ProcessedMETAR/"


# Sourcing functions
source("./WeatherModelingFunctions_v001.R")


# Descriptive names for key variables
varMapper <- c(source="Original source file name", 
               locale="Descriptive name",
               dtime="Date-Time (UTC)",
               origMETAR="Original METAR",
               year="Year",
               monthint="Month",
               month="Month", 
               day="Day of Month",
               WindDir="Wind Direction (degrees)", 
               WindSpeed="Wind Speed (kts)",
               WindGust="Wind Gust (kts)",
               predomDir="General Prevailing Wind Direction",
               Visibility="Visibility (SM)", 
               Altimeter="Altimeter (inches Hg)",
               TempF="Temperature (F)",
               DewF="Dew Point (F)", 
               modSLP="Sea-Level Pressure (hPa)", 
               cType1="First Cloud Layer Type", 
               cLevel1="First Cloud Layer Height (ft)",
               isRain="Rain at Observation Time",
               isSnow="Snow at Observation Time",
               isThunder="Thunder at Obsevation Time",
               tempFHi="24-hour High Temperature (F)",
               tempFLo="24-hour Low Temperature (F)",
               minHeight="Minimum Cloud Height (ft)",
               minType="Obscuration Level at Minimum Cloud Height",
               ceilingHeight="Minimum Ceiling Height (ft)",
               ceilingType="Obscuration Level at Minimum Ceiling Height", 
               hr="Hour of Day (Zulu time)"
               )


# File name to city name mapper
cityNameMapper <- c(katl_2016="Atlanta, GA (2016)",
                    kbos_2016="Boston, MA (2016)", 
                    kdca_2016="Washington, DC (2016)", 
                    kden_2016="Denver, CO (2016)", 
                    kdfw_2016="Dallas, TX (2016)", 
                    kdtw_2016="Detroit, MI (2016)", 
                    kewr_2016="Newark, NJ (2016)",
                    kgrb_2016="Green Bay, WI (2016)",
                    kgrr_2016="Grand Rapids, MI (2016)",
                    kiah_2016="Houston, TX (2016)",
                    kind_2016="Indianapolis, IN (2016)",
                    klas_2014="Las Vegas, NV (2014)",
                    klas_2015="Las Vegas, NV (2015)",
                    klas_2016="Las Vegas, NV (2016)", 
                    klas_2017="Las Vegas, NV (2017)", 
                    klas_2018="Las Vegas, NV (2018)",
                    klas_2019="Las Vegas, NV (2019)",
                    klax_2016="Los Angeles, CA (2016)", 
                    klnk_2016="Lincoln, NE (2016)",
                    kmia_2016="Miami, FL (2016)", 
                    kmke_2016="Milwaukee, WI (2016)",
                    kmsn_2016="Madison, WI (2016)",
                    kmsp_2016="Minneapolis, MN (2016)",
                    kmsy_2014="New Orleans, LA (2014)",
                    kmsy_2015="New Orleans, LA (2015)",
                    kmsy_2016="New Orleans, LA (2016)", 
                    kmsy_2017="New Orleans, LA (2017)", 
                    kmsy_2018="New Orleans, LA (2018)",
                    kmsy_2019="New Orleans, LA (2019)",
                    kord_2014="Chicago, IL (2014)",
                    kord_2015="Chicago, IL (2015)",
                    kord_2016="Chicago, IL (2016)", 
                    kord_2017="Chicago, IL (2017)", 
                    kord_2018="Chicago, IL (2018)",
                    kord_2019="Chicago, IL (2019)",
                    kphl_2016="Philadelphia, PA (2016)", 
                    kphx_2016="Phoenix, AZ (2016)", 
                    ksan_2014="San Diego, CA (2014)",
                    ksan_2015="San Diego, CA (2015)",
                    ksan_2016="San Diego, CA (2016)",
                    ksan_2017="San Diego, CA (2017)",
                    ksan_2018="San Diego, CA (2018)",
                    ksan_2019="San Diego, CA (2019)",
                    ksat_2016="San Antonio, TX (2016)", 
                    ksea_2016="Seattle, WA (2016)", 
                    ksfo_2016="San Francisco, CA (2016)", 
                    ksjc_2016="San Jose, CA (2016)",
                    kstl_2016="Saint Louis, MO (2016)", 
                    ktpa_2016="Tampa Bay, FL (2016)", 
                    ktvc_2016="Traverse City, MI (2016)"
                    )

# File names in 2016, based on cityNameMapper
names_2016 <- grep(names(cityNameMapper), pattern="[a-z]{3}_2016", value=TRUE)

```
  
The main data will be from the metar_postEDA files.  They are integrated below, and cloud and ceiling heights are converted to factors:  
```{r}

# Main weather data
metarData <- readRDS("./RInputFiles/ProcessedMETAR/metar_postEDA_20200617.rds") %>%
    bind_rows(readRDS("./RInputFiles/ProcessedMETAR/metar_postEDA_extra_20200627.rds")) %>%
    mutate(orig_minHeight=minHeight, 
           orig_ceilingHeight=ceilingHeight, 
           minHeight=mapCloudHeight(minHeight), 
           ceilingHeight=mapCloudHeight(ceilingHeight)
           )
glimpse(metarData)

```

#### _Initial Exploration_  
An initial exploration of the data can use hierarchical clustering based on several numerical features of the data (temperature, dew point, sea-level pressure, wind speed) by month.

Example code includes:  
```{r}

# Create hierarchical clustering for 2016 data
# Distance is calculated only where month is the same
distData <- metarData %>% 
    filter(year==2016) %>%
    select(locale, month, TempF, DewF, modSLP, WindSpeed) %>%
    group_by(locale, month) %>% 
    summarize_if(is.numeric, mean, na.rm=TRUE) %>% 
    ungroup() %>% 
    mutate(rowname=paste0(locale, "_", month)) %>% 
    column_to_rownames() %>% 
    select(-locale, -month) %>% 
    as.matrix() %>% 
    scale() %>% 
    dist() %>% 
    as.matrix() %>% 
    as.data.frame() %>%
    rownames_to_column(var="locale1") %>% 
    pivot_longer(-locale1, names_to="locale2", values_to="dist") %>% 
    mutate(city1=str_replace(locale1, "_\\w{3}", ""), 
           city2=str_replace(locale2, "_\\w{3}", ""), 
           month1=str_sub(locale1, -3), 
           month2=str_sub(locale2, -3)) %>%
    filter(month1==month2) %>% 
    group_by(city1, city2) %>% 
    summarize(meandist=mean(dist), sddist=sd(dist)) %>% 
    ungroup() %>% 
    select(-sddist) %>% 
    pivot_wider(city1, names_from="city2", values_from="meandist") %>%
    column_to_rownames(var="city1") %>%
    as.matrix() %>%
    as.dist(diag=FALSE)

distData %>%
    hclust(method="complete") %>%
    plot()

distData %>%
    hclust(method="single") %>%
    plot()

```
  
At a glance, there are several sensible findings from the clustering:  
  
* Two combinations of cities in close geographic proximity (Newark and Philadelphia; Chicago and Milaukee) show the greatest similarity in the clustering  
* A cluster of coastal California cities (San Diego, Los Angeles, San Jose) show strong similarities  
* A cluster of hot-humid cities (Houston-New Orleans and then soon Miami-Tampa) show strong similarities  
* Several clusters of cold-weather cities emerge  
* Two desert cities (Las Vega, Phoenix) show similarities  
  
There are a handful of cities that do not seem to cluster with anything else:  
  
* Denver, Boston, Seattle, San Francisco  
  
#### _Temperature and Dew Point_  
Suppose that the only information available about two cities were their temperatures and dew points, with month also included.  How well would a basic random forest, with mtry=3, classify the cities?

The function is then run for every combination of locales from 2016 in cityNameMapper.  A common random seed is applied to every run of the process:  
```{r cache=TRUE}

# Create a container list to hold the output
list_2016_TempF_DewF_month <- vector("list", 0.5*length(names_2016)*(length(names_2016)-1))

set.seed(2006281443)

n <- 1
for (ctr in 1:(length(names_2016)-1)) {
    for (ctr2 in (ctr+1):length(names_2016)) {
        list_2016_TempF_DewF_month[[n]] <- rfTwoLocales(metarData, 
                                                        loc1=names_2016[ctr], 
                                                        loc2=names_2016[ctr2], 
                                                        vrbls=c("TempF", "DewF", "month"),
                                                        ntree=25
                                                        )
        n <- n + 1
        if ((n %% 50) == 0) { cat("Through number:", n, "\n")}
    }
}

```
  
Accuracy can then be assessed:  
```{r}

# Create a tibble from the underlying accuracy data
acc_TempF_DewF_month <- map_dfr(list_2016_TempF_DewF_month, .f=helperAccuracyLocale)

# Assess the top 10 classification accuracies
acc_TempF_DewF_month %>%
    arrange(-accOverall) %>%
    head(10)

# Assess the bottom 10 classification accuracies
acc_TempF_DewF_month %>%
    arrange(accOverall) %>%
    head(10)


allAccuracy_month <- select(acc_TempF_DewF_month, 
                            locale=locale1, 
                            other=locale2, 
                            accOverall, 
                            accLocale=accLocale1
                            ) %>%
    bind_rows(select(acc_TempF_DewF_month, 
                     locale=locale2, 
                     other=locale1, 
                     accOverall, 
                     accLocale=accLocale2
                     )
              )

# Overall accuracy by location plot
allAccuracy_month %>%
    group_by(locale) %>%
    summarize_if(is.numeric, mean) %>%
    ggplot(aes(x=fct_reorder(locale, accOverall), y=accOverall)) + 
    geom_point(size=2) + 
    geom_text(aes(y=accOverall+0.02, label=paste0(round(100*accOverall), "%"))) +
    coord_flip() + 
    labs(x="", 
         y="Average Accuracy", 
         title="Average Accuracy Predicting Locale",
         subtitle="Predictions made 1:1 to each other locale (average accuracy reported)",
         caption="Temperature, Dew Point, Month as predictors\n(50% is baseline coinflip accuracy)"
         ) + 
    ylim(c(0.5, 1))

# Overall accuracy heatmap (FIX for better ordering of locales)
# allAccuracy_month %>% 
#     ggplot(aes(x=locale, y=other)) + 
#     geom_tile(aes(fill=accOverall)) + 
#     theme(axis.text.x=element_text(angle=90)) + 
#     scale_fill_continuous("Accuracy", high="darkblue", low="white") + 
#     labs(title="Accuracy Predicting Locale vs. Locale", 
#          caption="Temperature, Dew Point, and Month as predictors\n(50% is baseline coinflip accuracy)",
#          x="",
#          y=""
#          )

```
  
Accuracy is best for cities with significantly different locales.  The model is especially successful at pulling apart the desert cities (Las Vegas, Phoenix) from everything else, and the humid Florida cities (Miami, Tampa Bay) from everything else.
  
Next, the simple model is run to classify locale across the full 2016 dataset:  
```{r cache=TRUE}

# Run random forest for all 2016 locales
rf_all_2016_TDm <- rfMultiLocale(metarData, 
                                 vrbls=c("TempF", "DewF", "month"),
                                 locs=names_2016, 
                                 ntree=50, 
                                 seed=2006281508
                                 )

```
  
Summaries can then be created for the accuracy in predicting each locale:  
```{r}

evalPredictions(rf_all_2016_TDm, plotCaption = "Temp, Dew Point, Month, Cloud/Ceiling Height")

```
  
Accuracy is meaningfully increased compared to the null accuracy, though there is still under 50% accuracy in classifying any locale.  This is suggestive that the goal will be to define some archetype climates, and to use those for predicting (e.g., humid, cold, desert, etc.).
  
Clouds (minimum levels and ceiling heights) can potentially help further differentiate the cold weather cities on the downwind side of the lake, as well as helping to further pull apart various marine and mid-continental climates.

An updated random forest model is then run:  
```{r cache=TRUE}

# Run random forest for all 2016 locales
rf_all_2016_TDmc <- rfMultiLocale(metarData, 
                                  vrbls=c("TempF", "DewF", "month", "minHeight", "ceilingHeight"),
                                  locs=names_2016, 
                                  ntree=50, 
                                  seed=2006281509
                                  )

```
  
The evaluation process is converted to a function:  
```{r}

evalPredictions(rf_all_2016_TDmc, plotCaption = "Temp, Dew Point, Month, Cloud/Ceiling Height")

# Get the comparison to previous accuracy
deltaAccuracy(prevObject=rf_all_2016_TDm, currObject=rf_all_2016_TDmc)

```
  
Accuracy increases meaningfully, though still well under 50% in most cases.
  
The model can also be built out to consider wind speed and wind direction.  No attempt yet is made to control for over-fitting:  
```{r cache=TRUE}

# Run random forest for all 2016 locales
rf_all_2016_TDmcw <- rfMultiLocale(metarData, 
                                   vrbls=c("TempF", "DewF", 
                                           "month", 
                                           "minHeight", "ceilingHeight", 
                                           "WindSpeed", "predomDir"
                                           ),
                                   locs=names_2016, 
                                   ntree=50, 
                                   seed=2006281934
                                   )

```
  
The evaluation process can again be run:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_all_2016_TDmcw, 
                plotCaption = "Temp, Dew Point, Month, Cloud/Ceiling Height, Wind Speed/Direction"
                )

# Get the comparison to previous accuracy
deltaAccuracy(prevObject=rf_all_2016_TDmc, currObject=rf_all_2016_TDmcw)

```
  
Including wind significantly improves model accuracy for many locales.  Even the cold weather cities are now being predicted with around 30%-40% accucacy.
  
The model can also be built out to consider hour of day and sea-level pressure.  No attempt yet is made to control for over-fitting, with the exception that mtry is held at 4:  
```{r cache=TRUE}

# Run random forest for all 2016 locales
rf_all_2016_TDmcwa <- rfMultiLocale(metarData, 
                                    vrbls=c("TempF", "DewF", 
                                            "month",
                                            "minHeight", "ceilingHeight", 
                                            "WindSpeed", "predomDir",
                                            "modSLP"
                                            ),
                                    locs=names_2016, 
                                    ntree=50, 
                                    mtry=4,
                                    seed=2006282103
                                    )

```
  
The evaluation process can again be run:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_all_2016_TDmcwa, 
                plotCaption = "Temp, Dew Point, Month, Cloud/Ceiling Height, Wind Speed/Direction, SLP"
                )

# Get the comparison to previous accuracy
deltaAccuracy(prevObject=rf_all_2016_TDmcw, currObject=rf_all_2016_TDmcwa)

```
  
Adding sea-level pressure again significantly improves prediction ability.  The cold weather cities are in the roughly 40%-60% accuracy range, and the other cities are in the roughly 60%-80% accuracy range.

Based on the hierarchical clustering and results of the initial random forest models, a few archetype cities are defined in an attempt to pull out distinctions:  
  
* Miami (likely to match with Tampa, New Orleans, and Houston)  
* Las Vegas (likely to match with Phoenix)  
* Los Angeles (likely to match with San Diego and San Jose)  
* Denver (seems potentially isolated)  
* Seattle (seems potentially isolated)  
* Dallas (likely to match to San Antonio)  
* Minneapolis (surrogate for the cold side of cold weather cities)  
* Atlanta (possible to match with DC, St Louis, Indianapolis, but may be too similar to Cold/Miami)  
  
A data subset is created, with "hr" added for the Zulu hour of the observation (as integer rather than as factor):  
```{r}

archeCities <- c("kmia_2016", "klas_2016", "klax_2016", "kden_2016", 
                 "ksea_2016", "kdfw_2016", "kmsp_2016", "katl_2016"
                 )

archeData <- metarData %>%
    filter(source %in% archeCities) %>%
    mutate(hr=lubridate::hour(dtime))

```
  
A random forest, with mtry=4, is then run using all variables from previous, as well as hour:  
```{r cache=TRUE}

# Run random forest for all 2016 locales
rf_arche_2016_TDmcwa <- rfMultiLocale(archeData, 
                                      vrbls=c("TempF", "DewF", 
                                              "month", "hr",
                                              "minHeight", "ceilingHeight", 
                                              "WindSpeed", "predomDir",
                                              "modSLP"
                                              ),
                                      locs=NULL, # defaults to running for all locales
                                      ntree=100, 
                                      mtry=4,
                                      seed=2006291353
                                      )

```
  
The evaluation process can again be run:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_arche_2016_TDmcwa, 
                plotCaption = "Temp, Dew Point, Month/Hour, Cloud/Ceiling Height, Wind Speed/Direction, SLP"
                )

```
  
The model is reasonably successful in pulling apart the archetypes.  Denver and Dallas seem potentially less distinct, though all archetypes cities are predicted at 80%+ accuracy.

The remaining cities can be classified against the archetype data, to explore any patterns that emerge:  
```{r}

localeByArchetype(rf_arche_2016_TDmcwa, 
                  fullData=metarData, 
                  archeCities=archeCities, 
                  sortDescMatch=TRUE
                  )

```
  
There appear to be several issues:  
  
* Atlanta and Dallas are not particularly distinct and do not make for good archetypes (potentially, Miami, Atlanta, and Dallas can all be replaced by Houston); Denver and Seattle are shaky but may be OK  
* Minneapolis may be too cold, driving the midwestern cities to instead classify partially as Denver  
* The model is potentially learning too much about the specific city rather than about archetypes  
  
The first issue is addressed by collapsing Atlanta, Dallas, and Miami and instead using Houston as the archetype; and replacing Minneapolis with Chicago:  
```{r}

archeCities_v02 <- c("kiah_2016", "klas_2016", "klax_2016", 
                     "kden_2016", "ksea_2016", "kord_2016"
                     )

archeData_v02 <- metarData %>%
    filter(source %in% archeCities_v02) %>%
    mutate(hr=lubridate::hour(dtime))

```

A random forest, with mtry=4, is then run using all variables from previous, as well as hour:  
```{r cache=TRUE}

# Run random forest for all 2016 locales in archeData_v02
rf_arche_2016_TDmcwa_v02 <- rfMultiLocale(archeData_v02, 
                                          vrbls=c("TempF", "DewF", 
                                                  "month", "hr",
                                                  "minHeight", "ceilingHeight", 
                                                  "WindSpeed", "predomDir",
                                                  "modSLP"
                                                  ),
                                          locs=NULL, # defaults to running for all locales
                                          ntree=100, 
                                          mtry=4,
                                          seed=2006291448
                                          )

```
  
The evaluation process can again be run:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_arche_2016_TDmcwa_v02, 
                plotCaption = "Temp, Dew Point, Month/Hour, Cloud/Ceiling Height, Wind Speed/Direction, SLP"
                )

```
  
The model is reasonably successful in pulling apart the archetypes.  Houston appears the most distinct (as had Miami previously), and there is less overlap going to/from Denver or Seattle.

The remaining cities can be classified against the archetype data, to explore any patterns that emerge:  
```{r}

localeByArchetype(rf_arche_2016_TDmcwa_v02, 
                  fullData=metarData, 
                  archeCities=archeCities_v02, 
                  sortDescMatch = TRUE
                  )

```
  
At a glance, the archetypes are more sensible.  There is a bit of Denver and a bit of Seattle in most of the cold weather cities, and a bit of Houston in some of the warmer cold weather cities.  This is suggestive that there are either more then one type of cold-weather cities, or that cold-weather cities tend to be like other archetypes are certain times.

The model is run again, deleting Denver and Seattle, and converting Los Angeles to San Diego:  
```{r}

archeCities_v03 <- c("kiah_2016", "klas_2016", "ksan_2016", "kord_2016")

archeData_v03 <- metarData %>%
    filter(source %in% archeCities_v03) %>%
    mutate(hr=lubridate::hour(dtime))

```

A random forest, with mtry=4, is then run using all variables from previous, as well as hour:  
```{r cache=TRUE}

# Run random forest for all 2016 locales in archeData_v03
rf_arche_2016_TDmcwa_v03 <- rfMultiLocale(archeData_v03, 
                                          vrbls=c("TempF", "DewF", 
                                                  "month", "hr",
                                                  "minHeight", "ceilingHeight", 
                                                  "WindSpeed", "predomDir",
                                                  "modSLP"
                                                  ),
                                          locs=NULL, # defaults to running for all locales
                                          ntree=100, 
                                          mtry=4,
                                          seed=2006291459
                                          )

```
  
The evaluation process can again be run:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_arche_2016_TDmcwa_v03, 
                plotCaption = "Temp, Dew Point, Month/Hour, Cloud/Ceiling Height, Wind Speed/Direction, SLP"
                )

```
  
These archetypes are distinct, with accuracies all in the 95% range.  The remaining cities can be classified against the archetype data, to explore any patterns that emerge:  
```{r}

localeByArchetype(rf_arche_2016_TDmcwa_v03,
                  fullData=metarData,
                  archeCities=archeCities_v03,
                  sortDescMatch=TRUE
                  )

```
  
Quite a few cities show as blends of the archetype cities, which is likely correct if archetypes are considered to be Cold, Humid, Marine, Desert.  An open question is whether to expand that list with another 1-2 archetypes that attempt to better capture Atlanta, Dallas, Denver, St Louis, and DC.  

The Marine archetype may need to be converted to Pacific and to better identify the California entities.  

A decision about Seattle is needed, as it is a little like everything and everything is a little like it.
  
To address the issue of the model learning from specific cities rather than archetypes, user-defined clusters will be created, and data from these clusters will be used in modeling:  
  
* Marine - San Diego, Los Angeles in an attempt to train the model to recognize that Marine cities differ meaningfully from Cold cities and Humid cities (San Jose, San Francicso and Seattle are somewhat different climates)  
* Desert - Las Vegas, Phoenix in an attempt to train the model on differences in Desert and Marine  
* Humid - Houston, Miami, New Orleans, Tampa, reflecting that the model is already largely pulling out the humid cities correctly  
* Cold - Chicago, Milwaukee, Grand Rapids, Green Bay, Traverse City, Madison, Detroit, Minneapolis to reflect that the model is largely already pulling out cold cities correctly (Boston excluded for now)  
* South - Atlanta, Dallas, San Antonio in an attempt to pull out southern cities that are not as humid as those along the Gulf Coast  
* Mixed - Indianapolis, Lincoln, St Louis, to reflect cities that have milder winters than Cold but colder winters than South  
* Excluded for now - Denver, Seattle, Boston/Newark/Phialdelphia/DC, San Francisco/San Jose  
  
Further, a variable will be created for "hr", the Zulu hour of the observation:  
```{r}

# Create the locale mapper
locMapperTibble <- tibble::tribble(
    ~source, ~locType,
    'katl_2016', 'South',
    'kbos_2016', 'Exclude',
    'kdca_2016', 'Exclude',
    'kden_2016', 'Exclude',
    'kdfw_2016', 'South',
    'kdtw_2016', 'Cold',
    'kewr_2016', 'Exclude',
    'kgrb_2016', 'Cold',
    'kgrr_2016', 'Cold',
    'kiah_2016', 'Humid',
    'kind_2016', 'Mixed',
    'klas_2016', 'Desert',
    'klax_2016', 'Marine',
    'klnk_2016', 'Mixed',
    'kmia_2016', 'Humid',
    'kmke_2016', 'Cold',
    'kmsn_2016', 'Cold',
    'kmsp_2016', 'Cold',
    'kmsy_2016', 'Humid',
    'kord_2016', 'Cold',
    'kphl_2016', 'Exclude',
    'kphx_2016', 'Desert',
    'ksan_2016', 'Marine',
    'ksat_2016', 'South',
    'ksea_2016', 'Exclude',
    'ksfo_2016', 'Exclude',
    'ksjc_2016', 'Exclude',
    'kstl_2016', 'Mixed',
    'ktpa_2016', 'Humid',
    'ktvc_2016', 'Cold'
)

# Create locMapper
locMapper <- locMapperTibble %>% pull(locType)
names(locMapper) <- locMapperTibble %>% pull(source)
locMapper

# Create the data file with locType
locData_v04 <- metarData %>% 
    mutate(locType=locMapper[source], hr=lubridate::hour(dtime)) %>% 
    filter(year==2016, locType !="Exclude")

# Counts by locType
locData_v04 %>%
    count(locType)

```
  
There is a risk that the model will predict neutral cities as 'Cold' given the 4:1 ratio of Cold cities to Marine/Desert cities.  The random forest model is first run on the data 'as is':    
```{r cache=TRUE}

rf_arche_small_TDmcwa_v04 <- rfMultiLocale(locData_v04, 
                                           vrbls=c("TempF", "DewF", 
                                                   "month", "hr",
                                                   "minHeight", "ceilingHeight", 
                                                   "WindSpeed", "predomDir",
                                                   "modSLP"
                                                   ),
                                           locs=NULL, # defaults to running for all locales
                                           ntree=100, 
                                           locVar="locType", 
                                           pred="locType",
                                           mtry=4, 
                                           otherVar=c("dtime", "source", "locale"),
                                           seed=2006301313
                                           )

```
  
Prediction accuracy is then assessed:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_arche_small_TDmcwa_v04,
                plotCaption = "Temp, Dew Point, Month/Hour, Cloud/Ceiling Height, Wind Speed/Direction, SLP",
                keyVar="locType"
                )

```
  
The designation of Cold, Desert, Humid, and Marine seems successful.  The attempt to split South from Humid resulted in good, if incomplete, separation.  The attempt to separate a group of 'warmer' cold-weather cities from 'colder' cold-weather cities was not particularly successful.  This could partially be an artifact of 'Cold' having double the data volume as 'Mixed'.

Classifications by city can also be examined:  
```{r}

archeCities_v04 <- locMapperTibble %>%
    filter(locType != "Exclude") %>%
    pull(source)

localeByArchetype(rf_arche_small_TDmcwa_v04, 
                  fullData=mutate(metarData, locType=locMapper[source]), 
                  archeCities=archeCities_v04, 
                  sortDescMatch=TRUE
                  )

```
  
Many of the cities are nicely classified in to their assigned archetypes, as desired.  Among the cities used in the classifications, concerns include:  
  
* The cities pre-assigned as South do not seem to cluster so strongly together.  This may not be a good archetype  
* The cities pre-assigned as Mixed do not clutser well, possibly driven by a data volume discrepancy where Cold has more than double the data  
* Remaining cities frequently assign to 2+ archetypes, as expected since weather in the mid-latitudes would not necessarily follow any archetypal pattern on a year-long basis  
  
Classifications are changed somewhat, and data are then filtered so that an equal number of observations from each locale type are applied in the modeling:  
  
* Mixed - deleted, entries will be moved to 'Exclude' to see how they map  
* South - deleted, entries will be moved to 'Exclude' to see how they map  
  
```{r}

# Create the locale mapper
locMapperTibble_v05 <- tibble::tribble(
    ~source, ~locType,
    'katl_2016', 'Exclude',
    'kbos_2016', 'Exclude',
    'kdca_2016', 'Exclude',
    'kden_2016', 'Exclude',
    'kdfw_2016', 'Exclude',
    'kdtw_2016', 'Cold',
    'kewr_2016', 'Exclude',
    'kgrb_2016', 'Cold',
    'kgrr_2016', 'Cold',
    'kiah_2016', 'Humid',
    'kind_2016', 'Exclude',
    'klas_2016', 'Desert',
    'klax_2016', 'Marine',
    'klnk_2016', 'Exclude',
    'kmia_2016', 'Humid',
    'kmke_2016', 'Cold',
    'kmsn_2016', 'Cold',
    'kmsp_2016', 'Cold',
    'kmsy_2016', 'Humid',
    'kord_2016', 'Cold',
    'kphl_2016', 'Exclude',
    'kphx_2016', 'Desert',
    'ksan_2016', 'Marine',
    'ksat_2016', 'Exclude',
    'ksea_2016', 'Exclude',
    'ksfo_2016', 'Exclude',
    'ksjc_2016', 'Exclude',
    'kstl_2016', 'Exclude',
    'ktpa_2016', 'Humid',
    'ktvc_2016', 'Cold'
)

# Create locMapper
locMapper_v05 <- locMapperTibble_v05 %>% pull(locType)
names(locMapper_v05) <- locMapperTibble_v05 %>% pull(source)
locMapper_v05

# Create the data file with locType
locData_v05 <- metarData %>% 
    mutate(locType=locMapper_v05[source], hr=lubridate::hour(dtime)) %>% 
    filter(year==2016, locType !="Exclude")

# Counts by locType
locData_v05 %>%
    count(locType)

```

The data are the filtered so that there are an equal number of observations from each locale type.  The model can later be predicted against the remaining items:  
```{r}

# Set a seed for reporducibility
set.seed(2006301356)

# Find the smallest locale type
nSmall <- locData_v05 %>%
    filter(!is.na(locType)) %>%
    count(locType) %>%
    pull(n) %>%
    min()

# Create the relevant data subset
subData_v05 <- locData_v05 %>%
    filter(!is.na(locType)) %>%
    group_by(locType) %>%
    sample_n(size=nSmall, replace=FALSE) %>%
    ungroup()

# Sumarize the data subset
subData_v05 %>% 
    count(locType, locale) %>% 
    arrange(-n)

```
  
The previous model can then be run on the data subset:  
```{r cache=TRUE}

rf_arche_small_TDmcwa_v05 <- rfMultiLocale(subData_v05, 
                                           vrbls=c("TempF", "DewF", 
                                                   "month", "hr",
                                                   "minHeight", "ceilingHeight", 
                                                   "WindSpeed", "predomDir",
                                                   "modSLP"
                                                   ),
                                           locs=NULL, # defaults to running for all locales
                                           ntree=100, 
                                           locVar="locType", 
                                           pred="locType",
                                           mtry=4, 
                                           otherVar=c("dtime", "source", "locale"),
                                           seed=2006301358
                                           )

```
  
The evaluation process can again be run:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_arche_small_TDmcwa_v05,
                plotCaption = "Temp, Dew Point, Month/Hour, Cloud/Ceiling Height, Wind Speed/Direction, SLP",
                keyVar="locType"
                )

```
  
The archetypes are well-separated, with roughly 95% accuracy in every case.  Predictions can then also be made for all cities, including those not in the modeling:  
```{r}

archeCities_v05 <- locMapperTibble_v05 %>%
    filter(locType != "Exclude") %>%
    pull(source)

localeByArchetype(rf_arche_small_TDmcwa_v05, 
                  fullData=mutate(metarData, locType=locMapper_v05[source]), 
                  archeCities=archeCities_v05, 
                  sortDescMatch=TRUE
                  )

```
  
Broadly speaking, cities used in modeling appear to classify in to the appropriate archetypes.  For the cities not included in the modeling:  
  
* Boston, Lincoln, Indianapolis, Newark, Philadelphia, and Seattle are most closely matched to 'Cold'  
* San Antonio is most closely matched to 'Humid'  
* Denver is a split of Cold/Desert  
* DC and St Louis are a split of Cold/Humid  
* San Francisco and San Jose are most closely matched to 'Marine' with meaningful 'Cold' and 'Humid' also  
* Atlanta and Dallas are roughly split between 'Humid' and 'Cold', with a bit of 'Desert' also  
  
The model can be applied to data from years other than 2016, to see how the classifications are impacted by use in out-of-sample years:  
```{r}

# Predictions on non-2016 data
helperPredictPlot(rf_arche_small_TDmcwa_v05$rfModel, 
                  df=filter(mutate(metarData, hr=lubridate::hour(dtime)), year!=2016), 
                  predOrder=c("Marine", "Humid", "Desert", "Cold"), 
                  locMapper=locMapper_v05
                  )

```
  
Model performance on non-2016 data is not as strong, with roughly a 10%-20% loss of accuracy.  Predictions are still much better than null accuracy, and the model (mostly) continues to separate the archetypes.

Suppose that models are run on all 2015-2018 data for Chicago, Las Vegas, New Orleans, and San Diego:  
```{r}

# Create the subset for Chicago, Las Vegas, New Orleans, San Diego
sub_2015_2018_data <- metarData %>%
    filter(str_sub(source, 1, 4) %in% c("kord", "klas", "kmsy", "ksan"), 
           year %in% c(2015, 2016, 2017, 2018)
           ) %>%
    mutate(city=str_replace(locale, pattern=" .\\d{4}.", replacement=""), 
           hr=lubridate::hour(dtime)
           )

# Check that proper locales are included
sub_2015_2018_data %>% 
    count(city, locale)

```
  
The random forest model is run and cached:  
```{r cache=TRUE}

# Run random forest for 2015-2018 data
rf_types_2015_2018_TDmcwha <- rfMultiLocale(sub_2015_2018_data, 
                                            vrbls=c("TempF", "DewF", 
                                                    "month", "hr",
                                                    "minHeight", "ceilingHeight", 
                                                    "WindSpeed", "predomDir", 
                                                    "modSLP"
                                                    ),
                                            locs=NULL, 
                                            locVar="city",
                                            pred="city",
                                            ntree=50, 
                                            seed=2006301420, 
                                            mtry=4
                                            )

```
  
```{r}

evalPredictions(rf_types_2015_2018_TDmcwha, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, SLP", 
                keyVar="city"
                )

```
  
Even with a small forest (50 trees), the model is almost always separating Las Vegas, Chicago, San Diego, and New Orleans.  While the climates are very different in these cities, it is striking that the model has so few misclassifications.

How do other cities map against these classifications?  
```{r}

# Predictions on 2015/2018 data
helperPredictPlot(rf_types_2015_2018_TDmcwha$rfModel, 
                  df=filter(mutate(metarData, hr=lubridate::hour(dtime)), 
                            !(str_sub(source, 1, 4) %in% c("kord", "klas", "kmsy", "ksan"))
                            ), 
                  predOrder=c("Chicago, IL", "San Diego, CA", "New Orleans, LA", "Las Vegas, NV")
                  )

```
  
Classifications are broadly as expected based on the previous archetype analysis.  Variable importances are plotted:  
```{r}

helperPlotVarImp(rf_types_2015_2018_TDmcwha$rfModel)

```
  
Dew point and temperature by month continue to be strong factors for separating the four cities in this analysis.  SLP, minimum cloud height, and prevailing wind direction are also meaningful.
  
An assessment can be run for the 2015-2018 model:  
```{r}

# Run for the full model including SLP
probs_2015_2018_TDmcwha <- 
    assessPredictionCertainty(rf_types_2015_2018_TDmcwha, 
                              keyVar="city", 
                              plotCaption="Temp, Dew Point, Month/Hour, Clouds, Wind, SLP", 
                              showAcc=TRUE
                              )

```
  
* Predictions with 80%+ of the votes are made ~75% of the time, and these predictions are ~99% accurate  
* Predictions with <80% of the votes are made ~25% of the times, and these predictions are ~80% accurate  
* The percentage of votes received appears to be a reasonable proxy for the confidence of the prediction  
  
A similar process can be run for assessing the classification of the other cities against the 2015-2017 data for Chicago, Las Vegas, New Orleans, and San Diego:  
```{r}

useData <- metarData %>%
    filter(!(str_sub(source, 1, 4) %in% c("kord", "klas", "kmsy", "ksan"))) %>%
    mutate(hr=lubridate::hour(dtime))
    
# Run for the model excluding SLP
probs_allcities_2015_2018_TDmcwh <- 
    assessPredictionCertainty(rf_types_2015_2018_TDmcwha, 
                              testData=useData,
                              keyVar="locale", 
                              plotCaption="Temp, Dew Point, Month/Hour, Clouds, Wind, modSLP", 
                              showHists=TRUE
                              )

```
  
The model is frequently not so confident in assigning an archetype to related cities, though it frequently gets the most sensible assignment.

An assessment is run to look at the evolution of the model as it take in the 'next best' variable for building out the random forest:  
```{r cache=TRUE}

# Define the variables to be considered
possVars <- c("TempF", "DewF", "month", "hr", "minHeight", 
              "ceilingHeight", "WindSpeed", "predomDir", "modSLP"
              )

# Create a container for storing the best random forest and variable added from each run
rfContainer <- vector("list", length=length(possVars))
rfVarAdds <- vector("character", length=length(possVars))

# Run the functions using a for loop over the length of possVars
for (ctr in 1:length(possVars)) {
    
    # Pull in the results of the previous run
    if (ctr==1) {
        prevVars <- c()
    } else {
        prevVars <- rfVarAdds[1:(ctr-1)]
    }
    
    # Run each of them through the combinations
    tmpList <- helperRFCombinations(possVars, df=sub_2015_2018_data, prevVars=prevVars)

    # Assess the performance
    tmpAccuracy <- helperVariableAccuracy(tmpList, possVars=possVars, prevVars=prevVars)
    
    # Prepare to repeat the process
    bestRow <- tmpAccuracy %>%
        filter(locale=="OOB") %>%
        filter(accuracy==max(accuracy))
    bestRow
    
    # Update the rfContainer and rfVarAdds elements
    rfContainer[[ctr]] <- tmpList[[as.integer(pull(bestRow, vrblNum))]]
    rfVarAdds[ctr] <- pull(bestRow, vrblName)
    cat("\nVariable Added:", rfVarAdds[ctr], "\n")

}

```
  
The evolution of accuracy can then be plotted:  
```{r}

# Pull the accuracy data from the variables selected
tblAccuracy <- map_dfr(rfContainer, .f=helperExtractAccuracy, .id="vrblNum") %>%
    mutate(vrblName=rfVarAdds[as.integer(vrblNum)], 
           locale=factor(locale, levels=c("OOB", unique(locale)[unique(locale) != "OOB"])), 
           plotLabel=ifelse(as.integer(vrblNum)==1, vrblName, paste0("add ", vrblName))
           )

# Plot the gains in accuracy, facetted by 'locale'
ggplot(tblAccuracy, aes(x=fct_reorder(plotLabel, -as.integer(vrblNum)))) + 
    geom_text(aes(y=accuracy, label=paste0(round(100*accuracy), "%"))) + 
    facet_wrap(~locale, nrow=1) + 
    ylim(c(0, 1)) +
    geom_hline(yintercept=0.25, lty=2) +
    labs(x="", 
         y="", 
         title="Evolution of accuracy as next-best variables are added",
         caption="Null accuracy is 25%"
         ) +
    coord_flip()

```
  
As seen previously, dew point, temperature, and month are significant differentiating variables, driving roughly 75% accuracy in classifying the archetypes.

Adding altimeter (SLP) bumps the accuracy by another ~10%, while adding minimum cloud height and prevailing wind direction bump the accuracy by another ~5%.

This shows some of the power of the random forest algorithm as it is given additional variables to explore.  Evolution of error can be plotted to see the impact:  
```{r}

oobError <- c()
for (ctr in 1:9) {
    oobError <- c(oobError, rfContainer[[ctr]]$rfModel$err.rate[, "OOB"])
}

tibble::tibble(nVars=rep(1:9, each=25), 
               ntrees=rep(1:25, times=9), 
               accuracy=1-oobError
               ) %>%
    ggplot(aes(x=ntrees, y=accuracy)) + 
    geom_line(aes(group=nVars, color=factor(nVars))) +
    labs(x="Number of Trees", 
         y="OOB Accuracy", 
         title="Accuracy improves with more trees and more variables"
         ) + 
    scale_color_discrete("# Variables")

```
  
With a greater number of variables, there is a greater lift in accuracy as the forest grows larger.

Suppose that an attempt is made to classify the year for a single city.  Example code includes:  
```{r cache=TRUE}

# Create a subset of the data for only Chicago (2014-2019)
sub_kord_data <- metarData %>%
    mutate(hr=lubridate::hour(dtime)) %>%
    filter(str_sub(source, 1 ,4) %in% "kord")

# Run random forest for Chicago 2014-2019 data
rf_kord_TDmcwha <- rfMultiLocale(sub_kord_data, 
                                 vrbls=c("TempF", "DewF", 
                                         "month", "hr",
                                         "minHeight", "ceilingHeight", 
                                         "WindSpeed", "predomDir", 
                                         "modSLP"
                                         ),
                                 locs=NULL, 
                                 locVar="year",
                                 pred="year",
                                 ntree=200, 
                                 seed=2007011309, 
                                 mtry=4
                                 )

```
  
Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_kord_TDmcwha, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, SLP", 
                keyVar="year", 
                locOrder=TRUE
                )

# Evaluate variable importance
helperPlotVarImp(rf_kord_TDmcwha$rfModel)

# Evaluate error evolution
errorEvolution(rf_kord_TDmcwha, useCategory="OOB", subT="Chicago (2014-2019)")

```
  
Interestingly, the model predicts the year with 75%-80% accuracy (null accuracy 17%), suggesting there is significant annual variation in Chicago climate.  Sea-level-pressure has the largest variable importance (SLP is a mix of altitude, temperature, dew point, and high/low pressure systems).  The first 50 trees significantly reduce the OOB error, with more modest, but still continuing, error reduction afterwards.
  
The process is run for Las Vegas:  
```{r cache=TRUE}

# Create a subset of the data for only Las Vegas (2014-2019)
sub_klas_data <- metarData %>%
    mutate(hr=lubridate::hour(dtime)) %>%
    filter(str_sub(source, 1 ,4) %in% "klas")

# Run random forest for Las Vegas 2014-2019 data
rf_klas_TDmcwha <- rfMultiLocale(sub_klas_data, 
                                 vrbls=c("TempF", "DewF", 
                                         "month", "hr",
                                         "minHeight", "ceilingHeight", 
                                         "WindSpeed", "predomDir", 
                                         "modSLP"
                                         ),
                                 locs=NULL, 
                                 locVar="year",
                                 pred="year",
                                 ntree=200, 
                                 seed=2007011405, 
                                 mtry=4
                                 )

```
  
Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_klas_TDmcwha, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, SLP", 
                keyVar="year", 
                locOrder=TRUE
                )

# Evaluate variable importance
helperPlotVarImp(rf_klas_TDmcwha$rfModel)

# Evaluate error evolution
errorEvolution(rf_klas_TDmcwha, useCategory="OOB", subT="Las Vegas (2014-2019)")

```
  
Prediction accuracies are lower for Las Vegas, averaging 60%-75% (2014 appears to be much more differentiated than the other years).  This is suggestive that there is less annual variation in the Las Vegas climate than there is in the Chicago climate, though still enough to meaningfully pull apart the years.

Modified seal-level pressure is the top predictor, and the majority of the OOB error reduction occurs in the first 50 trees.

Suppose that modSLP is eliminated as a predictor variable, and the process is scaled down to 50 trees and repeated for Chicago:  
```{r cache=TRUE}

# Run random forest for Chicago 2014-2019 data
rf_kord_TDmcwh_50 <- rfMultiLocale(sub_kord_data, 
                                   vrbls=c("TempF", "DewF", 
                                           "month", "hr",
                                           "minHeight", "ceilingHeight", 
                                           "WindSpeed", "predomDir"
                                           ),
                                   locs=NULL, 
                                   locVar="year",
                                   pred="year",
                                   ntree=50, 
                                   seed=2007011410, 
                                   mtry=4
                                   )

```
  
Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_kord_TDmcwh_50, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind", 
                keyVar="year", 
                locOrder=TRUE
                )

# Evaluate variable importance
helperPlotVarImp(rf_kord_TDmcwh_50$rfModel)

# Compare error evolution through the first 50 trees
tibble::tibble(ntree=1:50, 
               withSLP=rf_kord_TDmcwha$rfModel$err.rate[1:50, "OOB"], 
               noSLP=rf_kord_TDmcwh_50$rfModel$err.rate[1:50, "OOB"]
               ) %>%
    pivot_longer(-ntree, names_to="Model", values_to="Error") %>%
    ggplot(aes(x=ntree, y=Error, color=Model)) + 
    geom_line() + 
    geom_text(data=~filter(., ntree %in% c(1, 50)), 
              aes(y=Error+0.02, label=paste0(round(100*Error, 1), "%"))
              ) +
    labs(x="# Trees", 
         y="OOB Error Rate", 
         title="OOB Error Evolution for SLP Included/Excluded"
         ) + 
    ylim(c(0, NA))

```
  
Modified sea-level pressure is revealed to be a significant driver of prediction accuracy for Chicago, confirming findings of the previous variable importance analysis.  This suggests different patterns of high and low pressure being in control by year may meaningfully improve the ability to predict Chicago by year.
  
The process can also be run for Las Vegas:  
```{r cache=TRUE}

# Run random forest for Las Vegas 2014-2019 data
rf_klas_TDmcwh_50 <- rfMultiLocale(sub_klas_data, 
                                   vrbls=c("TempF", "DewF", 
                                           "month", "hr",
                                           "minHeight", "ceilingHeight", 
                                           "WindSpeed", "predomDir"
                                           ),
                                   locs=NULL, 
                                   locVar="year",
                                   pred="year",
                                   ntree=50, 
                                   seed=2007011420, 
                                   mtry=4
                                   )

```
  
Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_klas_TDmcwh_50, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind", 
                keyVar="year", 
                locOrder=TRUE
                )

# Evaluate variable importance
helperPlotVarImp(rf_klas_TDmcwh_50$rfModel)

# Compare error evolution through the first 50 trees
tibble::tibble(ntree=1:50, 
               withSLP=rf_klas_TDmcwha$rfModel$err.rate[1:50, "OOB"], 
               noSLP=rf_klas_TDmcwh_50$rfModel$err.rate[1:50, "OOB"]
               ) %>%
    pivot_longer(-ntree, names_to="Model", values_to="Error") %>%
    ggplot(aes(x=ntree, y=Error, color=Model)) + 
    geom_line() + 
    geom_text(data=~filter(., ntree %in% c(1, 50)), 
              aes(y=Error+0.02, label=paste0(round(100*Error, 1), "%"))
              ) +
    labs(x="# Trees", 
         y="OOB Error Rate", 
         title="OOB Error Evolution for SLP Included/Excluded"
         ) + 
    ylim(c(0, NA))

```
  
Modified sea-level pressure is revealed as a meaningful driver of prediction accuracy for Las Vegas also, though with a lesser effect than seen in Chicago.  This potentially suggests less variability by year in SLP for Las Vegas.  
  
Since SLP is so meaningful, are there any patterns by year?  
```{r}

sub_kord_data %>%
    bind_rows(sub_klas_data, .id="cityFile") %>%
    select(cityFile, year, month, modSLP) %>%
    mutate(city=case_when(cityFile==1 ~ "Chicago", cityFile==2 ~ "Las Vegas", TRUE ~ "Error")) %>%
    filter(!is.na(modSLP)) %>%
    ggplot(aes(x=factor(year), y=modSLP)) + 
    geom_boxplot(fill="lightblue") + 
    facet_wrap(~city) +
    labs(x="", y="modSLP", title="Modified Sea-Level Pressure by Year (Chicago and Las Vegas)")

```
  
Chicago has a higher sea-level pressure than Las Vegas (as expected), though neither city shows much variation on average from year to year.  The Chicago data are explored further by month:  
```{r}

sub_kord_data %>%
    select(year, month, modSLP) %>%
    filter(!is.na(modSLP)) %>%
    ggplot(aes(x=month, y=modSLP)) + 
    geom_boxplot(fill="lightblue") + 
    facet_wrap(~year) +
    labs(x="", y="modSLP", title="Modified Sea-Level Pressure by Month and Year (Chicago)")

sub_kord_data %>%
    select(year, month, modSLP) %>%
    filter(!is.na(modSLP)) %>%
    group_by(year, month) %>%
    summarize(medSLP=median(modSLP)) %>%
    ggplot(aes(x=month, y=medSLP, color=factor(year), group=year)) + 
    geom_line(lwd=1) + 
    labs(x="", y="Median modSLP", title="Median modified Sea-Level Pressure by Month and Year (Chicago)")

sub_kord_data %>%
    select(year, month, modSLP) %>%
    filter(!is.na(modSLP)) %>%
    group_by(year, month) %>%
    summarize(medSLP=median(modSLP)) %>%
    group_by(month) %>%
    summarize(sdSLP=sd(medSLP)) %>%
    ggplot(aes(x=month, y=sdSLP)) + 
    geom_point() + 
    labs(x="", 
         y="Standard Deviation of Median modSLP by Year", 
         title="Variability by year of modified Sea-Level Pressure by Month (Chicago)"
         )

```
  
There are meaningful differences in median modified sea-level pressure by month by year.  This is suggestive that several year of data are needed to define an archetype, as there is risk that otherwise the archetype will be an anomalous "high pressure was in contol in June" when that is not generally applicable.  And, since high vs. low pressure are often related to temperature, dew point, coludiness, wind speed, and the like, the need for multiple years of data to define an archetype likely extends to all the other variables as well.

With greater variability in SLP by year in the cold-weather months, predictive ability in the cold-weather months is expected to be higher:  
```{r}

rf_kord_TDmcwha$testData %>% 
    group_by(month) %>% 
    summarize(pctError=1-mean(correct)) %>%
    ggplot(aes(x=month, y=pctError)) + 
    geom_col(fill="lightblue") + 
    geom_text(aes(y=pctError/2, label=paste0(round(100*pctError, 1), "%"))) +
    labs(x="", y="Error Rate", title="Prediction Error Rate by Month (Chicago)")

```
  
As expected, the model takes advantage of greater annual variation in modSLP during the cold season to make better prediction of which year it is during the cold season.
  
Next an attempt is made to predict the month given the data:  
```{r cache=TRUE}

# Run random forest for Las Vegas 2014-2019 data
rf_klas_TDycwha_month_50 <- rfMultiLocale(sub_klas_data, 
                                          vrbls=c("TempF", "DewF", 
                                                  "year", "hr",
                                                  "minHeight", "ceilingHeight", 
                                                  "WindSpeed", "predomDir", 
                                                  "modSLP"
                                                  ),
                                          locs=NULL, 
                                          locVar="month",
                                          pred="month",
                                          ntree=50, 
                                          seed=2007021356, 
                                          mtry=4
                                          )

```

Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_klas_TDycwha_month_50, 
                plotCaption = "Temp, Dew Point, Year, Hour of Day, Cloud Height, Wind, Altimeter", 
                keyVar="month", 
                locOrder=TRUE
                )

# Evaluate variable importance
helperPlotVarImp(rf_klas_TDycwha_month_50$rfModel)

# Evaluate error evolution
errorEvolution(rf_klas_TDycwha_month_50, useCategory="OOB", subT="Las Vegas (2014-2019)")

```
  
There is meaningful seasonality to the Las Vegas data such that the predicted month is frequently either the same season or (for spring/fall) the mirror season.

Suppose that year is not available as a predictor:  
```{r cache=TRUE}

# Run random forest for Las Vegas 2014-2019 data
rf_klas_TDcwha_month_50 <- rfMultiLocale(sub_klas_data, 
                                         vrbls=c("TempF", "DewF", 
                                                 "hr",
                                                 "minHeight", "ceilingHeight", 
                                                 "WindSpeed", "predomDir", 
                                                 "modSLP"
                                                 ),
                                         locs=NULL, 
                                         locVar="month",
                                         pred="month",
                                         ntree=50, 
                                         seed=2007021402, 
                                         mtry=4
                                         )

```
  
Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_klas_TDcwha_month_50, 
                plotCaption = "Temp, Dew Point, Hour of Day, Cloud Height, Wind, Altimeter", 
                keyVar="month", 
                locOrder=TRUE
                )

# Evaluate variable importance
helperPlotVarImp(rf_klas_TDcwha_month_50$rfModel)

# Evaluate error evolution
errorEvolution(rf_klas_TDcwha_month_50, useCategory="OOB", subT="Las Vegas (2014-2019)")

```
  
The same seasonal pattern is observed, though prediction accuracy falls be ~15%.  This is suggestive that it is not uncommon for Las Vegas climate to run a month-ahead or a month-behind where it ran in a previous year.

The model appears to still be learning at 50 trees, so it is expanded to 150 trees:  
```{r cache=TRUE}

# Run random forest for Las Vegas 2014-2019 data
rf_klas_TDcwha_month_150 <- rfMultiLocale(sub_klas_data, 
                                          vrbls=c("TempF", "DewF", 
                                                  "hr",
                                                  "minHeight", "ceilingHeight", 
                                                  "WindSpeed", "predomDir", 
                                                  "modSLP"
                                                  ),
                                          locs=NULL, 
                                          locVar="month",
                                          pred="month",
                                          ntree=150, 
                                          seed=2007021402, 
                                          mtry=4
                                          )

```
  
Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_klas_TDcwha_month_150, 
                plotCaption = "Temp, Dew Point, Hour of Day, Cloud Height, Wind, Altimeter", 
                keyVar="month", 
                locOrder=TRUE
                )

# Evaluate variable importance
helperPlotVarImp(rf_klas_TDcwha_month_150$rfModel)

# Evaluate error evolution
errorEvolution(rf_klas_TDcwha_month_150, useCategory="OOB", subT="Las Vegas (2014-2019)")

```
  
Another topic of interest is the use of sea-level pressure or altimeter in modeling.  The altimeter setting in a METAR is captured in two ways:  
  
* Altimeter - the atmospheric pressure in inches of mercury, corrected for height above sea-level  
* Sea-Level Pressure (SLP) - the atmospheric pressure in millibars, with a theroertical hole drilled from the meauring station striaght down to sea-level  
  
In theory, both metrics report almost the same thing but in different units.  There is a small difference in that SLP makes an adjustment for average 12-hour temperature (since temperature is a driver of air pressure) while altimeter is purely an adjustment for altitude.

How does the model perform with neither/either/both or Altimeter and modSLP included?  An example will be used for trying to classify a handful of cities from 2016:  
  
* Chicago  
* Milwaukee  
* New Orleans  
* Las Vegas  
* San Diego  
* Denver  
* Boston  
* Seattle  
  
```{r}

sub_mini_2016_data <- metarData %>%
    mutate(hr=lubridate::hour(dtime)) %>%
    filter(year==2016, 
           str_sub(source, 1 ,4) %in% c("kord", "kmke", "kmsy", "klas", "ksan", "kden", "kbos", "ksea")
           )
    
```
  
First, a model is run with neither Altimeter nor SLP:  
```{r cache=TRUE}

# Run random forest for subset data (2016)
rf_mini_TDmcwh <- rfMultiLocale(sub_mini_2016_data, 
                                vrbls=c("TempF", "DewF", 
                                        "month", "hr",
                                        "minHeight", "ceilingHeight", 
                                        "WindSpeed", "predomDir"
                                        ),
                                locs=NULL, 
                                locVar="locale",
                                pred="locale",
                                ntree=100, 
                                seed=2007021422, 
                                mtry=4
                                )

```
  
Prediction accuracy and variable importance can then be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_mini_TDmcwh, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind", 
                keyVar="locale", 
                locOrder=NULL
                )

# Evaluate variable importance
helperPlotVarImp(rf_mini_TDmcwh$rfModel)

# Evaluate error evolution
errorEvolution(rf_mini_TDmcwh, useCategory="OOB", subT="No Altimeter, No SLP")

```
  
Overall accuracy is roughly 75%, with the greatest challenge being separating Chicago and Milwaukee, with Boston also showing some similarities to these cities.
  
The process is then run with both Altimeter and SLP:  
```{r cache=TRUE}

# Run random forest for subset data (2016)
rf_mini_TDmcwhas <- rfMultiLocale(sub_mini_2016_data, 
                                  vrbls=c("TempF", "DewF", 
                                          "month", "hr",
                                          "minHeight", "ceilingHeight", 
                                          "WindSpeed", "predomDir",
                                          "modSLP", "Altimeter"
                                          ),
                                  locs=NULL, 
                                  locVar="locale",
                                  pred="locale",
                                  ntree=100, 
                                  seed=2007021429, 
                                  mtry=4
                                  )

```
  
Prediction accuracy and variable importance can again be assessed:  
```{r}

# Evaluate prediction accuracy
evalPredictions(rf_mini_TDmcwhas, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, Altimeter, and SLP", 
                keyVar="locale", 
                locOrder=NULL
                )

# Evaluate variable importance
helperPlotVarImp(rf_mini_TDmcwhas$rfModel)

# Evaluate error evolution
errorEvolution(rf_mini_TDmcwhas, useCategory="OOB", subT="Both Altimeter and SLP")

```
  
Overall accuracy increases to about 85%.  Except for Chicago/Milwaukee, every city is overwhelmingly classified as itself.
  
Smaller runs with just SLP and just Altimeter are conducted, to verify that the learning rate is roughly the same in these cases.  As well SLP plus a dummy variable (SLP + rnorm()) is run:  
```{r cache=TRUE}

# Run random forest for subset data (2016)
rf_mini_TDmcwhs <- rfMultiLocale(sub_mini_2016_data, 
                                 vrbls=c("TempF", "DewF", 
                                         "month", "hr",
                                         "minHeight", "ceilingHeight", 
                                         "WindSpeed", "predomDir",
                                         "modSLP"
                                         ),
                                 locs=NULL, 
                                 locVar="locale",
                                 pred="locale",
                                 ntree=50, 
                                 seed=2007021435, 
                                 mtry=4
                                 )

```
  
```{r cache=TRUE}

# Run random forest for subset data (2016)
rf_mini_TDmcwha <- rfMultiLocale(sub_mini_2016_data, 
                                 vrbls=c("TempF", "DewF", 
                                         "month", "hr",
                                         "minHeight", "ceilingHeight", 
                                         "WindSpeed", "predomDir",
                                         "Altimeter"
                                         ),
                                 locs=NULL, 
                                 locVar="locale",
                                 pred="locale",
                                 ntree=50, 
                                 seed=2007021440, 
                                 mtry=4
                                 )

```
  
```{r cache=TRUE}

set.seed(2007021444)
subUseData <- sub_mini_2016_data %>%
    mutate(dummy=modSLP + rnorm(n=nrow(sub_mini_2016_data)))

# Run random forest for subset data (2016)
rf_mini_TDmcwhsd <- rfMultiLocale(subUseData, 
                                  vrbls=c("TempF", "DewF", 
                                          "month", "hr",
                                          "minHeight", "ceilingHeight", 
                                          "WindSpeed", "predomDir",
                                          "modSLP", "dummy"
                                          ),
                                  locs=NULL, 
                                  locVar="locale",
                                  pred="locale",
                                  ntree=50, 
                                  seed=2007021445, 
                                  mtry=4
                                  )

```
  
OOB error evolution through the first 50 trees can be compared:  
```{r}

# Compare error evolution through the first 50 trees
tibble::tibble(ntree=1:50, 
               neither=rf_mini_TDmcwh$rfModel$err.rate[1:50, "OOB"], 
               altimeter=rf_mini_TDmcwha$rfModel$err.rate[1:50, "OOB"], 
               modslp=rf_mini_TDmcwhs$rfModel$err.rate[1:50, "OOB"],
               slp_dummy=rf_mini_TDmcwhsd$rfModel$err.rate[1:50, "OOB"], 
               both=rf_mini_TDmcwhas$rfModel$err.rate[1:50, "OOB"]
               ) %>%
    pivot_longer(-ntree, names_to="Model", values_to="Error") %>%
    ggplot(aes(x=ntree, y=Error, color=Model)) + 
    geom_line() + 
    geom_text(data=~filter(., ntree %in% c(1, 50)), 
              aes(y=Error+0.02, label=paste0(round(100*Error, 1), "%"))
              ) +
    labs(x="# Trees", 
         y="OOB Error Rate", 
         title="OOB Error Evolution for SLP Included/Excluded"
         ) + 
    ylim(c(0, NA))

```
  
Interestingly, the inclusion of both Altimeter and modSLP appears to drive a 2%-3% decrease in classification error.  The main difference between the variables is that modSLP contains a hint about the previous 12-hour temperature.

Importantly, including a dummy variable with modSLP has either no impact or a slight negative impact on model performance.  So, the addition of Altimeter to modSLP is likely a real impact, not merely the inclusion of two highly correlated variables that are both valuable to driving model performance.
  
Next, an attempt is made to compare every grouping of two cities, using all variables, mtry of 4, and a very small forest of 15 trees:  
```{r cache=TRUE}

# Create a container list to hold the output
list_varimp_2016 <- vector("list", 0.5*length(names_2016)*(length(names_2016)-1))

# Set a random seed
set.seed(2007031342)

# Loop through all possible combinations
n <- 1
for (ctr in 1:(length(names_2016)-1)) {
    for (ctr2 in (ctr+1):length(names_2016)) {
        list_varimp_2016[[n]] <- rfTwoLocales(mutate(metarData, hr=lubridate::hour(dtime)), 
                                              loc1=names_2016[ctr], 
                                              loc2=names_2016[ctr2], 
                                              vrbls=c("TempF", "DewF", 
                                                      "month", "hr",
                                                      "minHeight", "ceilingHeight", 
                                                      "WindSpeed", "predomDir", 
                                                      "modSLP", "Altimeter"
                                                      ),
                                              ntree=15, 
                                              mtry=4
                                              )
        n <- n + 1
        if ((n %% 40) == 0) { cat("Through number:", n, "\n")}
    }
}

```
  
```{r}

# Create a tibble from the underlying accuracy data
acc_varimp_2016 <- map_dfr(list_varimp_2016, .f=helperAccuracyLocale)

# Assess the top 20 classification accuracies
acc_varimp_2016 %>%
    arrange(-accOverall) %>%
    head(20)

# Assess the bottom 20 classification accuracies
acc_varimp_2016 %>%
    arrange(accOverall) %>%
    head(20)

```
  
As pre previous, the best accuracies are obtained when comparing cities in very different climates (e.g., Denver vs. Humid/Marine or Miami vs. Desert/Cold), while the worst accuracies are obtained when comparing very similar cities (e.g., Chicago and Milwaukee or Newar and Philadelphia).

Variable importance can then be assessed across all 1:1 classifications:  
```{r cache=TRUE}

# Create a tibble of all the variable importance data
val_varimp_2016 <- map_dfr(list_varimp_2016, 
                           .f=function(x) { x$rfModel %>% 
                                   caret::varImp() %>% 
                                   t() %>% 
                                   as.data.frame()
                               }
                           ) %>% 
    tibble::as_tibble()

```
  
```{r}

# Create boxplot of overall variable importance
val_varimp_2016 %>% 
    mutate(num=1:nrow(val_varimp_2016)) %>% 
    pivot_longer(-num, names_to="variable", values_to="varImp") %>% 
    ggplot(aes(x=fct_reorder(variable, varImp), y=varImp)) + 
    geom_boxplot(fill="lightblue") + 
    labs(x="", 
         y="Variable Importance", 
         title="Variable Importance for 1:1 Random Forest Classifications"
         )

# Attach the city names and OOB error rate
tbl_varimp_2016 <- sapply(list_varimp_2016, 
                          FUN=function(x) { c(names(x$errorRate[2:3]), x$errorRate["OOB"]) }
                          ) %>%
    t() %>% 
    as.data.frame() %>% 
    bind_cols(val_varimp_2016) %>% 
    tibble::as_tibble() %>% 
    mutate(OOB=as.numeric(as.character(OOB))) %>%
    rename(locale1=V1, 
           locale2=V2
           )

# Plot accuracy vs. spikiness of variable importance
tbl_varimp_2016 %>%
    pivot_longer(-c(locale1, locale2, OOB), names_to="var", values_to="varImp") %>% 
    group_by(locale1, locale2, OOB) %>% 
    summarize(mean=mean(varImp), max=max(varImp)) %>% 
    mutate(maxMean=max/mean) %>%
    ggplot(aes(x=maxMean, y=1-OOB)) + 
    geom_point() + 
    geom_smooth(method="loess") +
    labs(x="Ratio of Maximum Variable Importance to Mean Variable Importance", 
         y="OOB Accuracy", 
         title="Accuracy vs. Spikiness of Variable Importance"
         )

```
  
Broadly speaking, the same variables that drive overall classification are important in driving 1:1 classifications.  There is meaningful spikiness, suggesting that different 1:1 classifications rely on different variables.

There is a strong trend where the best accuracies are obtained where there is a single spiky dimension that drives the classifications.  This suggests that while the model can take advantage of all 10 variables, it has the easiest tome when there is a single, well-differentiated variable.  No surprise.

An attempt is made to define archetype cities as cities that are either 1) very different from other cities, or 2) very similar to other cities.  An archetype should always meet criteria for some meaningful examples, and criteria 2 allows for an archetype to be similar to several other cities of the same archetype:  
```{r}

oobData <- tibble::tibble(City=character(0), OOBLow=numeric(0), OOBHigh=numeric(0))

for (city in cityNameMapper[names_2016]) {
    
    cityData <- tbl_varimp_2016 %>%
        filter(locale1 == city | locale2 == city)
    
    lowOOB <- cityData %>%
        top_n(n=10, wt=-OOB) %>%
        pull(OOB) %>%
        mean()
    
    highOOB <- cityData %>%
        top_n(n=5, wt=OOB) %>%
        pull(OOB) %>%
        mean()
    
    cat("\nCity:", city, 
        "\tOOB (Low 10 Average):", round(lowOOB, 4), 
        "\tOOB (High 5 Average):", round(highOOB, 4)
        )
    
    oobData <- bind_rows(oobData, tibble::tibble(City=city, OOBLow=lowOOB, OOBHigh=highOOB))
    
}

# Plot OOB data summary
oobData %>%
    ggplot(aes(x=OOBLow, y=OOBHigh)) + 
    geom_text(aes(label=City)) + 
    labs(x="Average OOB Error of Best 10 1:1 Predictions", 
         y="Average OOB Error of Worst 5 1:1 Predictions"
         )

```
  
At a glance, Miami, Denver and Phoenix/Las Vegas make for great archetypes in this data.  They are broadly dissimilar from a large number of cities and not all that similar to many other cities.  New Orleans or Tampa may also make for good archetypes (somewhat surprisingly in that these should be similar to Miami).
  
Suppose that hierarchical clustering is attempted, using 1-OOB as the main 'distance' variable:  
```{r}

# Create both halves of what will become the distance matric
upperHalf <- tbl_varimp_2016 %>%
    mutate(locale1=as.character(locale1), locale2=as.character(locale2))

lowerHalf <- upperHalf %>%
    rename(locale2=locale1, locale1=locale2) %>%
    select(locale1, locale2, everything())

bothHalf <- upperHalf %>%
    bind_rows(lowerHalf)

# Select only locale1, locale2, OOB and create a record for each locale to itself
mtxData <- bothHalf %>%
    select(locale1, locale2, OOB) %>%
    bind_rows(tibble::tibble(locale1=unique(bothHalf$locale1), locale2=locale1, OOB=NA)) %>%
    arrange(locale1, locale2) %>%
    mutate(accuracy=1-OOB)

# Create the matrix and add row/column names
mtxOOB <- matrix(data=mtxData$accuracy, nrow=sqrt(nrow(mtxData)), ncol=sqrt(nrow(mtxData)), byrow=TRUE)
dimnames(mtxOOB) <- list(unique(mtxData$locale1), unique(mtxData$locale1))

# Convert to distance matrix
distOOB <- as.dist(mtxOOB)

# Run hierarchical clustering
distOOB %>%
    hclust(method="complete") %>%
    plot()

```
  
Seattle and Denver appear to be good stand-alone cities.  They are not particularly close to any other cities.

Suppose that an attempt is made to classify cities as Seattle, Denver, or Other:  
```{r}

# Create data for Denver/Seattle/Other
sub_densea_data <- metarData %>%
    mutate(place=case_when(source=="kden_2016" ~ "Denver", 
                           source=="ksea_2016" ~ "Seattle", 
                           TRUE ~ "Other"
                           )
           ) %>%
    filter(year==2016)

# Down-sample all to smallest 'place'
nSmallPlace <- sub_densea_data %>%
    count(place) %>%
    pull(n) %>%
    min()

# Group the data and sample to only this minimum size
set.seed(2007031504)

sub_densea_data <- sub_densea_data %>%
    group_by(place) %>%
    sample_n(size=nSmallPlace) %>%
    ungroup() %>%
    mutate(hr=lubridate::hour(dtime))

# Run random forest for subset data
rf_densea_TDmcwhsa <- rfMultiLocale(sub_densea_data, 
                                    vrbls=c("TempF", "DewF", 
                                            "month", "hr",
                                            "minHeight", "ceilingHeight", 
                                            "WindSpeed", "predomDir",
                                            "modSLP", "Altimeter"
                                            ),
                                    locs=NULL, 
                                    locVar="place",
                                    pred="place",
                                    ntree=100, 
                                    seed=2007031510, 
                                    mtry=4
                                    )

# Evaluate prediction accuracy
evalPredictions(rf_densea_TDmcwhsa, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, Altimeter, and SLP", 
                keyVar="place", 
                locOrder=NULL
                )

# Evaluate variable importance
helperPlotVarImp(rf_densea_TDmcwhsa$rfModel)

# Evaluate error evolution
errorEvolution(rf_densea_TDmcwhsa, subT="Denver, Seattle, Other")

```
  
The model is very good at picking out Seattle and Denver, but not so good at picking out that Other is not Seattle or Denver.  A different approach may be needed to find stand-alone cities and archetypes.
