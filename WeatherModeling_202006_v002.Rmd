---
title: "Weather Modeling"
author: "davegoblue"
date: "6/18/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
The file 'WeatherEDA_202005_v002.Rmd' contains exploratory data analysis for historical weather data as contained in METAR archives hosted by Iowa State University.

Data have been dowloaded, processed, cleaned, and integrated for several stations (airports) and years, with .rds files saved in "./RInputFiles/ProcessedMETAR".

This module will perform initial modeling on the processed weather files.  It builds on the previous 'WeatherModeling_202006_v001.Rmd' and leverages functions in 'WeatherModelingFunctions_v001.R'.

#### _Data Availability_  
There are three main processed files available for further exploration:  
  
_metar_postEDA_20200617.rds and metar_postEDA_extra_20200627.rds_  
  
* source (chr) - the reporting station and time  
* locale (chr) - the descriptive name for source  
* dtime (dttm) - the date-time for the observation  
* origMETAR (chr) - the original METAR associated with the observation at that source and date-time  
* year (dbl) - the year, extracted from dtime  
* monthint (dbl) - the month, extracted from dtime, as an integer  
* month (fct) - the month, extracted from dtime, as a three-character abbreviation (factor)  
* day (int) - the day of the month, extracted from dtime  
* WindDir (chr) - previaling wind direction in degrees, stored as a character since 'VRB' means variable  
* WindSpeed (int) - the prevailing wind speed in knots  
* WindGust (dbl) - the wind gust speed in knots (NA if there is no recorded wind gust at that hour)  
* predomDir (chr) - the predominant wind direction as NE-E-SE-S-SW-W-NW-N-VRB-000-Error  
* Visibility (dbl) - surface visibility in statute miles  
* Altimeter (dbl) - altimeter in inches of mercury  
* TempF (dbl) - the Fahrenheit temperature  
* DewF (dbl) - the Fahrenheit dew point  
* modSLP (dbl) - Sea-Level Pressure (SLP), adjusted to reflect that SLP is recorded as 0-1000 but reflects data that are 950-1050  
* cTypen (chr) - the cloud type of the nth cloud layer (FEW, BKN, SCT, OVC, or VV)  
* cLeveln (dbl) - the cloud height in feet of the nth cloud layer  
* isRain (lgl) - was rain occurring at the moment the METAR was captured?  
* isSnow (lgl) - was snow occurring at the moment the METAR was captured?  
* isThunder (lgl) - was thunder occurring at the moment the METAR was captured?  
* p1Inches (dbl) - how many inches of rain occurred in the past hour?  
* p36Inches (dbl) - how many inches of rain occurred in the past 3/6 hours (3-hour summaries at 3Z-9Z-15Z-21Z and 6-hour summaries at 6Z-12Z-18Z-24Z and NA at any other Z times)?  
* p24Inches (dbl) - how many inches of rain occurred in the past 24 hours (at 12Z, NA at all other times)  
* tempFHi (dbl) - the high temperature in the past 24 hours, in Fahrenheit (reported once per day)  
* tempFLo (dbl) - the low temperature in the past 24 hours, in Fahrenheit (reported once per day)  
* minHeight (dbl) - the minimum cloud height in feet (-100 means 'no clouds')  
* minType (fct) - amount of obscuration at the minimum cloud height (VV > OVC > BKN > SCT > FEW > CLR)  
* ceilingHeight (dbl) - the minimum cloud ceiling in feet (-100 means 'no ceiling')  
* ceilingType (fct) - amount of obscuration at the minimum ceiling height (VV > OVC > BKN)  
  
_metar_modifiedClouds_20200617.rds and metar_modifiedclouds_extra_20200627.rds_  
  
* source (chr) - the reporting station and time  
* sourceName (chr) - the descriptive name for source  
* dtime (dttm) - the date-time for the observation  
* level (dbl) - cloud level (level 0 is inserted for every source-dtime as a base layer of clear)  
* height (dbl) - level height (height -100 is inserted for every source-dtime as a base layer of clear)  
* type (dbl) - level type (type CLR is inserted for every source-dtime as a base layer of clear)  
  
_metar_precipLists_20200617.rds and metar_precipLists_extra_20200627.rds_  
  
* Contains elements for each of rain/snow/thunder for each of 2015/2016/2017  
* Each element contains a list and a tibble  
* The tibble is precipLength and contains precipitation by month as source-locale-month-hours-events  
* The list is precipList and contains data on each precipitation interval  
  
Several mapping files are defined for use in plotting; tidyverse, lubridate, and caret are loaded; and the relevant functions are sourced:  
```{r}

# The process frequently uses tidyverse, lubridate, and caret
library(tidyverse)
library(lubridate)
library(caret)


# The main path for the files
filePath <- "./RInputFiles/ProcessedMETAR/"


# Sourcing functions
source("./WeatherModelingFunctions_v001.R")


# Descriptive names for key variables
varMapper <- c(source="Original source file name", 
               locale="Descriptive name",
               dtime="Date-Time (UTC)",
               origMETAR="Original METAR",
               year="Year",
               monthint="Month",
               month="Month", 
               day="Day of Month",
               WindDir="Wind Direction (degrees)", 
               WindSpeed="Wind Speed (kts)",
               WindGust="Wind Gust (kts)",
               predomDir="General Prevailing Wind Direction",
               Visibility="Visibility (SM)", 
               Altimeter="Altimeter (inches Hg)",
               TempF="Temperature (F)",
               DewF="Dew Point (F)", 
               modSLP="Sea-Level Pressure (hPa)", 
               cType1="First Cloud Layer Type", 
               cLevel1="First Cloud Layer Height (ft)",
               isRain="Rain at Observation Time",
               isSnow="Snow at Observation Time",
               isThunder="Thunder at Obsevation Time",
               tempFHi="24-hour High Temperature (F)",
               tempFLo="24-hour Low Temperature (F)",
               minHeight="Minimum Cloud Height (ft)",
               minType="Obscuration Level at Minimum Cloud Height",
               ceilingHeight="Minimum Ceiling Height (ft)",
               ceilingType="Obscuration Level at Minimum Ceiling Height", 
               hr="Hour of Day (Zulu time)"
               )


# File name to city name mapper
cityNameMapper <- c(katl_2016="Atlanta, GA (2016)",
                    kbos_2016="Boston, MA (2016)", 
                    kdca_2016="Washington, DC (2016)", 
                    kden_2016="Denver, CO (2016)", 
                    kdfw_2016="Dallas, TX (2016)", 
                    kdtw_2016="Detroit, MI (2016)", 
                    kewr_2016="Newark, NJ (2016)",
                    kgrb_2016="Green Bay, WI (2016)",
                    kgrr_2016="Grand Rapids, MI (2016)",
                    kiah_2016="Houston, TX (2016)",
                    kind_2016="Indianapolis, IN (2016)",
                    klas_2014="Las Vegas, NV (2014)",
                    klas_2015="Las Vegas, NV (2015)",
                    klas_2016="Las Vegas, NV (2016)", 
                    klas_2017="Las Vegas, NV (2017)", 
                    klas_2018="Las Vegas, NV (2018)",
                    klas_2019="Las Vegas, NV (2019)",
                    klax_2016="Los Angeles, CA (2016)", 
                    klnk_2016="Lincoln, NE (2016)",
                    kmia_2016="Miami, FL (2016)", 
                    kmke_2016="Milwaukee, WI (2016)",
                    kmsn_2016="Madison, WI (2016)",
                    kmsp_2016="Minneapolis, MN (2016)",
                    kmsy_2014="New Orleans, LA (2014)",
                    kmsy_2015="New Orleans, LA (2015)",
                    kmsy_2016="New Orleans, LA (2016)", 
                    kmsy_2017="New Orleans, LA (2017)", 
                    kmsy_2018="New Orleans, LA (2018)",
                    kmsy_2019="New Orleans, LA (2019)",
                    kord_2014="Chicago, IL (2014)",
                    kord_2015="Chicago, IL (2015)",
                    kord_2016="Chicago, IL (2016)", 
                    kord_2017="Chicago, IL (2017)", 
                    kord_2018="Chicago, IL (2018)",
                    kord_2019="Chicago, IL (2019)",
                    kphl_2016="Philadelphia, PA (2016)", 
                    kphx_2016="Phoenix, AZ (2016)", 
                    ksan_2014="San Diego, CA (2014)",
                    ksan_2015="San Diego, CA (2015)",
                    ksan_2016="San Diego, CA (2016)",
                    ksan_2017="San Diego, CA (2017)",
                    ksan_2018="San Diego, CA (2018)",
                    ksan_2019="San Diego, CA (2019)",
                    ksat_2016="San Antonio, TX (2016)", 
                    ksea_2016="Seattle, WA (2016)", 
                    ksfo_2016="San Francisco, CA (2016)", 
                    ksjc_2016="San Jose, CA (2016)",
                    kstl_2016="Saint Louis, MO (2016)", 
                    ktpa_2016="Tampa Bay, FL (2016)", 
                    ktvc_2016="Traverse City, MI (2016)"
                    )

# File names in 2016, based on cityNameMapper
names_2016 <- grep(names(cityNameMapper), pattern="[a-z]{3}_2016", value=TRUE)

```
  
The main data will be from the metar_postEDA files.  They are integrated below, and cloud and ceiling heights are converted to factors:  
```{r}

# Main weather data
metarData <- readRDS("./RInputFiles/ProcessedMETAR/metar_postEDA_20200617.rds") %>%
    bind_rows(readRDS("./RInputFiles/ProcessedMETAR/metar_postEDA_extra_20200627.rds")) %>%
    mutate(orig_minHeight=minHeight, 
           orig_ceilingHeight=ceilingHeight, 
           minHeight=mapCloudHeight(minHeight), 
           ceilingHeight=mapCloudHeight(ceilingHeight)
           )
glimpse(metarData)

```

#### _Initial Exploration_  
An initial exploration of the data can use hierarchical clustering based on several numerical features of the data (temperature, dew point, sea-level pressure, wind speed) by month.

Example code includes:  
```{r}

# Create hierarchical clustering for 2016 data
# Distance is calculated only where month is the same
distData <- metarData %>% 
    filter(year==2016) %>%
    select(locale, month, TempF, DewF, modSLP, WindSpeed) %>%
    group_by(locale, month) %>% 
    summarize_if(is.numeric, mean, na.rm=TRUE) %>% 
    ungroup() %>% 
    mutate(rowname=paste0(locale, "_", month)) %>% 
    column_to_rownames() %>% 
    select(-locale, -month) %>% 
    as.matrix() %>% 
    scale() %>% 
    dist() %>% 
    as.matrix() %>% 
    as.data.frame() %>%
    rownames_to_column(var="locale1") %>% 
    pivot_longer(-locale1, names_to="locale2", values_to="dist") %>% 
    mutate(city1=str_replace(locale1, "_\\w{3}", ""), 
           city2=str_replace(locale2, "_\\w{3}", ""), 
           month1=str_sub(locale1, -3), 
           month2=str_sub(locale2, -3)) %>%
    filter(month1==month2) %>% 
    group_by(city1, city2) %>% 
    summarize(meandist=mean(dist), sddist=sd(dist)) %>% 
    ungroup() %>% 
    select(-sddist) %>% 
    pivot_wider(city1, names_from="city2", values_from="meandist") %>%
    column_to_rownames(var="city1") %>%
    as.matrix() %>%
    as.dist(diag=FALSE)

distData %>%
    hclust(method="complete") %>%
    plot()

distData %>%
    hclust(method="single") %>%
    plot()

```
  
At a glance, there are several sensible findings from the clustering:  
  
* Two combinations of cities in close geographic proximity (Newark and Philadelphia; Chicago and Milaukee) show the greatest similarity in the clustering  
* A cluster of coastal California cities (San Diego, Los Angeles, San Jose) show strong similarities  
* A cluster of hot-humid cities (Houston-New Orleans and then soon Miami-Tampa) show strong similarities  
* Several clusters of cold-weather cities emerge  
* Two desert cities (Las Vega, Phoenix) show similarities  
  
There are a handful of cities that do not seem to cluster with anything else:  
  
* Denver, Boston, Seattle, San Francisco  
  
#### _Temperature and Dew Point_  
Suppose that the only information available about two cities were their temperatures and dew points, with month also included.  How well would a basic random forest, with mtry=3, classify the cities?

The function is then run for every combination of locales from 2016 in cityNameMapper.  A common random seed is applied to every run of the process:  
```{r cache=TRUE}

# Create a container list to hold the output
list_2016_TempF_DewF_month <- vector("list", 0.5*length(names_2016)*(length(names_2016)-1))

set.seed(2006281443)

n <- 1
for (ctr in 1:(length(names_2016)-1)) {
    for (ctr2 in (ctr+1):length(names_2016)) {
        list_2016_TempF_DewF_month[[n]] <- rfTwoLocales(metarData, 
                                                        loc1=names_2016[ctr], 
                                                        loc2=names_2016[ctr2], 
                                                        vrbls=c("TempF", "DewF", "month"),
                                                        ntree=25
                                                        )
        n <- n + 1
        if ((n %% 50) == 0) { cat("Through number:", n, "\n")}
    }
}

```
  
Accuracy can then be assessed:  
```{r}

# Create a tibble from the underlying accuracy data
acc_TempF_DewF_month <- map_dfr(list_2016_TempF_DewF_month, .f=helperAccuracyLocale)

# Assess the top 10 classification accuracies
acc_TempF_DewF_month %>%
    arrange(-accOverall) %>%
    head(10)

# Assess the bottom 10 classification accuracies
acc_TempF_DewF_month %>%
    arrange(accOverall) %>%
    head(10)


allAccuracy_month <- select(acc_TempF_DewF_month, 
                            locale=locale1, 
                            other=locale2, 
                            accOverall, 
                            accLocale=accLocale1
                            ) %>%
    bind_rows(select(acc_TempF_DewF_month, 
                     locale=locale2, 
                     other=locale1, 
                     accOverall, 
                     accLocale=accLocale2
                     )
              )

# Overall accuracy by location plot
allAccuracy_month %>%
    group_by(locale) %>%
    summarize_if(is.numeric, mean) %>%
    ggplot(aes(x=fct_reorder(locale, accOverall), y=accOverall)) + 
    geom_point(size=2) + 
    geom_text(aes(y=accOverall+0.02, label=paste0(round(100*accOverall), "%"))) +
    coord_flip() + 
    labs(x="", 
         y="Average Accuracy", 
         title="Average Accuracy Predicting Locale",
         subtitle="Predictions made 1:1 to each other locale (average accuracy reported)",
         caption="Temperature, Dew Point, Month as predictors\n(50% is baseline coinflip accuracy)"
         ) + 
    ylim(c(0.5, 1))

# Overall accuracy heatmap (FIX for better ordering of locales)
# allAccuracy_month %>% 
#     ggplot(aes(x=locale, y=other)) + 
#     geom_tile(aes(fill=accOverall)) + 
#     theme(axis.text.x=element_text(angle=90)) + 
#     scale_fill_continuous("Accuracy", high="darkblue", low="white") + 
#     labs(title="Accuracy Predicting Locale vs. Locale", 
#          caption="Temperature, Dew Point, and Month as predictors\n(50% is baseline coinflip accuracy)",
#          x="",
#          y=""
#          )

```
  
Accuracy is best for cities with significantly different locales.  The model is especially successful at pulling apart the desert cities (Las Vegas, Phoenix) from everything else, and the humid Florida cities (Miami, Tampa Bay) from everything else.
  
Next, the simple model is run to classify locale across the full 2016 dataset:  
```{r cache=TRUE}

# Run random forest for all 2016 locales
rf_all_2016_TDm <- rfMultiLocale(metarData, 
                                 vrbls=c("TempF", "DewF", "month"),
                                 locs=names_2016, 
                                 ntree=50, 
                                 seed=2006281508
                                 )

```
  
Summaries can then be created for the accuracy in predicting each locale:  
```{r}

evalPredictions(rf_all_2016_TDm, plotCaption = "Temp, Dew Point, Month, Cloud/Ceiling Height")

```
  
Accuracy is meaningfully increased compared to the null accuracy, though there is still under 50% accuracy in classifying any locale.  This is suggestive that the goal will be to define some archetype climates, and to use those for predicting (e.g., humid, cold, desert, etc.).
  
Clouds (minimum levels and ceiling heights) can potentially help further differentiate the cold weather cities on the downwind side of the lake, as well as helping to further pull apart various marine and mid-continental climates.

An updated random forest model is then run:  
```{r cache=TRUE}

# Run random forest for all 2016 locales
rf_all_2016_TDmc <- rfMultiLocale(metarData, 
                                  vrbls=c("TempF", "DewF", "month", "minHeight", "ceilingHeight"),
                                  locs=names_2016, 
                                  ntree=50, 
                                  seed=2006281509
                                  )

```
  
The evaluation process is converted to a function:  
```{r}

evalPredictions(rf_all_2016_TDmc, plotCaption = "Temp, Dew Point, Month, Cloud/Ceiling Height")

# Get the change in prediction accuracy
list(prev=rf_all_2016_TDm$testData, curr=rf_all_2016_TDmc$testData) %>% 
    map_dfr(.f=getAccuracy, .id="source") %>% 
    group_by(locale) %>% 
    mutate(maxPct=max(pct)) %>% 
    ungroup() %>% 
    ggplot(aes(x=fct_reorder(locale, maxPct), y=pct)) + 
    geom_point(aes(color=source)) + 
    geom_text(aes(y=pct+0.05*(2*(pct==maxPct)-1), label=paste0(round(100*pct), "%"))) +
    coord_flip() + 
    ylim(c(0, 1)) + 
    labs(x="", 
         y="Correctly Predicted", 
         title="Accuracy of Locale Predictions", 
         subtitle="(positive detection rate by locale)"
         ) + 
    scale_color_manual("Model", 
                       values=c("prev"="red", "curr"="darkgreen"), 
                       labels=c("prev"="previous", "curr"="current")
                       )

```
  
Accuracy increases meaningfully, though still well under 50% in most cases.
  
The model can also be built out to consider wind speed and wind direction.  No attempt yet is made to control for over-fitting:  
```{r cache=TRUE}

# Run random forest for all 2016 locales
rf_all_2016_TDmcw <- rfMultiLocale(metarData, 
                                   vrbls=c("TempF", "DewF", 
                                           "month", 
                                           "minHeight", "ceilingHeight", 
                                           "WindSpeed", "predomDir"
                                           ),
                                   locs=names_2016, 
                                   ntree=50, 
                                   seed=2006281934
                                   )

```
  
The evaluation process can again be run:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_all_2016_TDmcw, 
                plotCaption = "Temp, Dew Point, Month, Cloud/Ceiling Height, Wind Speed/Direction"
                )

# Get the change in prediction accuracy
list(prev=rf_all_2016_TDmc$testData, curr=rf_all_2016_TDmcw$testData) %>% 
    map_dfr(.f=getAccuracy, .id="source") %>% 
    group_by(locale) %>% 
    mutate(maxPct=max(pct)) %>% 
    ungroup() %>% 
    ggplot(aes(x=fct_reorder(locale, maxPct), y=pct)) + 
    geom_point(aes(color=source)) + 
    geom_text(aes(y=pct+0.05*(2*(pct==maxPct)-1), label=paste0(round(100*pct), "%"))) +
    coord_flip() + 
    ylim(c(0, 1)) + 
    labs(x="", 
         y="Correctly Predicted", 
         title="Accuracy of Locale Predictions", 
         subtitle="(positive detection rate by locale)"
         ) + 
    scale_color_manual("Model", 
                       values=c("prev"="red", "curr"="darkgreen"), 
                       labels=c("prev"="previous", "curr"="current")
                       )

```
  
Including wind significantly improves model accuracy for many locales.  Even the cold weather cities are now being predicted with around 30%-40% accucacy.
  
The model can also be built out to consider hour of day and sea-level pressure.  No attempt yet is made to control for over-fitting, with the exception that mtry is held at 4:  
```{r cache=TRUE}

# Run random forest for all 2016 locales
rf_all_2016_TDmcwa <- rfMultiLocale(metarData, 
                                    vrbls=c("TempF", "DewF", 
                                            "month",
                                            "minHeight", "ceilingHeight", 
                                            "WindSpeed", "predomDir",
                                            "modSLP"
                                            ),
                                    locs=names_2016, 
                                    ntree=50, 
                                    mtry=4,
                                    seed=2006282103
                                    )

```
  
The evaluation process can again be run:  
```{r}

# Get the graphs of the prediction accuracy
evalPredictions(rf_all_2016_TDmcwa, 
                plotCaption = "Temp, Dew Point, Month, Cloud/Ceiling Height, Wind Speed/Direction, SLP"
                )

# Get the change in prediction accuracy
list(prev=rf_all_2016_TDmcw$testData, curr=rf_all_2016_TDmcwa$testData) %>% 
    map_dfr(.f=getAccuracy, .id="source") %>% 
    group_by(locale) %>% 
    mutate(maxPct=max(pct)) %>% 
    ungroup() %>% 
    ggplot(aes(x=fct_reorder(locale, maxPct), y=pct)) + 
    geom_point(aes(color=source)) + 
    geom_text(aes(y=pct+0.05*(2*(pct==maxPct)-1), label=paste0(round(100*pct), "%"))) +
    coord_flip() + 
    ylim(c(0, 1)) + 
    labs(x="", 
         y="Correctly Predicted", 
         title="Accuracy of Locale Predictions", 
         subtitle="(positive detection rate by locale)"
         ) + 
    scale_color_manual("Model", 
                       values=c("prev"="red", "curr"="darkgreen"), 
                       labels=c("prev"="previous", "curr"="current")
                       )

```
  
Adding sea-level pressure again significantly improves prediction ability.  The cold weather cities are in the roughly 40%-60% accuracy range, and the other cities are in the roughly 60%-80% accuracy range.

Next, a smaller subset of the weather data is explored, with the cities grouped as:  
  
* Las Vegas  
* San Diego  
* New Orleans / Houston  
* Newark  
* Lincoln  
* Traverse City / Grand Rapids / Detroit  
* Chicago / Milwaukee / Madison / Green Bay / Minneapolis / Indianapolis  
  
Further, a variable will be created for "hr", the Zulu hour of the observation:  
```{r eval=FALSE}

locale2016Mapper <- c('Cold-MI', 'Newark', 'Cold', 'Cold-MI', 'Humid', 'Cold', 'Desert', 'Lincoln', 'Cold', 'Cold', 'Cold', 'Humid', 'Cold', 'Marine', 'Cold-MI')
names(locale2016Mapper) <- c('Detroit, MI (2016)', 'Newark, NJ (2016)', 'Green Bay, WI (2016)', 'Grand Rapids, MI (2016)', 'Houston, TX (2016)', 'Indianapolis, IN (2016)', 'Las Vegas, NV (2016)', 'Lincoln, NE (2016)', 'Milwaukee, WI (2016)', 'Madison, WI (2016)', 'Minneapolis, MN (2016)', 'New Orleans, LA (2016)', 'Chicago, IL (2016)', 'San Diego, CA (2016)', 'Traverse City, MI (2016)')

tibble::tibble(locale=names(locale2016Mapper), mapping=locale2016Mapper) %>%
    arrange(mapping, locale)

modData <- modData %>%
    mutate(hr=lubridate::hour(dtime), 
           locType=locale2016Mapper[locale]
           )

modData %>%
    count(locType, year) %>%
    pivot_wider(locType, names_from="year", values_from="n")

```
  
The data are the filtered so that there are an equal number of observations from each locale type.  The model can later be predicted against the remaining items:  
```{r eval=FALSE}

# Set a seed for reporducibility
set.seed(2006211352)

# Find the smallest locale type
nSmall <- modData %>%
    filter(!is.na(locType)) %>%
    count(locType) %>%
    pull(n) %>%
    min()

# Create the relevant data subset
subData <- modData %>%
    filter(!is.na(locType)) %>%
    group_by(locType) %>%
    sample_n(size=nSmall, replace=FALSE) %>%
    ungroup()

# Sumarize the data subset
subData %>% 
    count(locale) %>% 
    arrange(-n)

```
  
The previous model can then be run on the data subset:  
```{r eval=FALSE}

# Run random forest for all 2016 locale types
rf_types_2016_TDmcw <- rfMultiLocale(subData, 
                                     vrbls=c("TempF", "DewF", 
                                             "month", 
                                             "minHeight", "ceilingHeight", 
                                             "WindSpeed", "predomDir"
                                             ),
                                     locs=NULL, 
                                     locVar="locType",
                                     pred="locType",
                                     ntree=50, 
                                     seed=2006211401
                                     )

```
  
The evaluation process can again be run:  
```{r eval=FALSE}

evalPredictions(rf_types_2016_TDmcw, 
                plotCaption = "Temp, Dew Point, Month, Cloud/Ceiling Height, Wind Speed/Direction", 
                keyVar="locType"
                )

```
  
Predictive ability is strongest for the well-differentiated types, and weakest for the more poorly differentiated types.  The model is about 50% accurate in classifying cold climates; 25% of the time they are classified as they other type of cold climate, and 25% of the time they are classified as something else (typically Lincoln or Newark).
  
The modeling is run again using a much smaller training dataset (testSize set to 0.9) to see the implication of a much smaller data volume:  
```{r eval=FALSE}

# Run random forest for all 2016 locale types
rf_types_2016_small_TDmcw <- rfMultiLocale(subData, 
                                           vrbls=c("TempF", "DewF", 
                                                   "month", 
                                                   "minHeight", "ceilingHeight", 
                                                   "WindSpeed", "predomDir"
                                                   ),
                                           locs=NULL, 
                                           locVar="locType",
                                           pred="locType",
                                           ntree=50, 
                                           seed=2006211419,
                                           testSize=0.9
                                           )

```
  
The evaluation process can again be run:  
```{r eval=FALSE}

evalPredictions(rf_types_2016_small_TDmcw, 
                plotCaption = "Temp, Dew Point, Month, Cloud/Ceiling Height, Wind Speed/Direction", 
                keyVar="locType"
                )

```
  
As expected, predictions are less accurate with a smaller training dataset.  Overall acuuracy falls from ~70% to ~60% with the much smaller training data volumes.  This suggests the model is continuing to learn from the data, and may benefit from an expanded sample.
  
Next, the model is adapted to include the hour (as an integer, which may need to be rethought, though this will generally capture whether it is daytime or nighttime even without factoring) and the sea-level pressure variable:  
```{r eval=FALSE}

# Run random forest for all 2016 locale types - add hour and modSLP, limit mtry to 4
rf_types_2016_TDmcwha <- rfMultiLocale(subData, 
                                       vrbls=c("TempF", "DewF", 
                                               "month", "hr",
                                               "minHeight", "ceilingHeight", 
                                               "WindSpeed", "predomDir", 
                                               "modSLP"
                                               ),
                                       locs=NULL, 
                                       locVar="locType",
                                       pred="locType",
                                       ntree=50, 
                                       seed=2006211423, 
                                       mtry=4
                                       )

```
  
The evaluation process can again be run:  
```{r eval=FALSE}

evalPredictions(rf_types_2016_TDmcwha, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, SLP", 
                keyVar="locType"
                )

```
  
Accuracy increases to 75%.  In particular, the model is better able to distinguish Lincoln and Newark from the remaining locations, which has a follow-on effect of improving cold weather classifications.
  
Exploration is then run on distinguishing two locales from each other, to see the implications of parameters like data volume (controlled through testSize) and the number of trees.
  
Comparisons will be run as follows:  
  
* Desert vs. Humid (should be easiest to pull apart)  
* Cold vs. Cold-MI (should be hardest to pull apart)  
  
```{r eval=FALSE}

ntrees <- c(10, 25, 50, 100, 250, 500)
testSizes <- c(0.9, 0.7, 0.3)

desertHumid <- vector("list", length(ntrees) * length(testSizes))
n <- 1

for (ntree in ntrees) {
    for (testSize in testSizes) {

        desertHumid[[n]] <- rfTwoLocales(subData, 
                                         loc1="Desert", 
                                         loc2="Humid", 
                                         locVar="locType", 
                                         vrbls=c("TempF", "DewF", "month", "hr", 
                                                 "minHeight", "ceilingHeight", 
                                                 "WindSpeed", "predomDir", "modSLP"
                                                 ),
                                         pred="locType", 
                                         seed=2006211432,
                                         ntree=ntree, 
                                         mtry=4,
                                         testSize=testSize
                                         )
        desertHumid[[n]]$ntree <- ntree
        desertHumid[[n]]$testSize <- testSize
        
        n <- n+1
        
    }
}

```
  
An assessment of accuracy can then be performed:  
```{r eval=FALSE}

df <- sapply(desertHumid, 
             FUN=function(x) { c(x[["errorRate"]]["OOB"], ntree=x$ntree, testSize=x$testSize) }
             ) %>%
    t() %>%
    tibble::as_tibble()

df %>%
    mutate(accuracy=1-OOB, trainSize=1-testSize) %>%
    ggplot(aes(x=ntree, y=trainSize)) +
    geom_text(aes(label=paste0(round(100*accuracy), "%"))) + 
    scale_x_log10()

```
  
As expected, accuracy is very high for distinguishing Desert and Humid climates, even with small data volumes (training size 10% of the data) and a small number of trees.
  
The approach is then run for the cold weather cities:  
```{r eval=FALSE}

ntrees <- c(10, 25, 50, 100, 250, 500)
testSizes <- c(0.9, 0.7, 0.3)

coldColdMI <- vector("list", length(ntrees) * length(testSizes))
n <- 1

for (ntree in ntrees) {
    for (testSize in testSizes) {

        coldColdMI[[n]] <- rfTwoLocales(subData, 
                                        loc1="Cold", 
                                        loc2="Cold-MI", 
                                        locVar="locType", 
                                        vrbls=c("TempF", "DewF", "month", "hr", 
                                                "minHeight", "ceilingHeight", 
                                                "WindSpeed", "predomDir", "modSLP"
                                                ),
                                        pred="locType", 
                                        seed=2006211501,
                                        ntree=ntree, 
                                        mtry=4,
                                        testSize=testSize
                                        )
        coldColdMI[[n]]$ntree <- ntree
        coldColdMI[[n]]$testSize <- testSize
        
        n <- n+1
        
    }
}

```
  
An assessment of accuracy can then be performed:  
```{r eval=FALSE}

dfColdColdMI <- sapply(coldColdMI, 
                       FUN=function(x) { c(x[["errorRate"]]["OOB"], ntree=x$ntree, testSize=x$testSize) }
                       ) %>%
    t() %>%
    tibble::as_tibble()

dfColdColdMI %>%
    mutate(accuracy=1-OOB, trainSize=1-testSize) %>%
    ggplot(aes(x=ntree, y=trainSize)) +
    geom_text(aes(label=paste0(round(100*accuracy), "%"))) + 
    scale_x_log10()

```
  
Greater data volumes and greater tree depths are more helpful for distinguishing cold weather city types from each other.  The smallest forest has a 56% accuracy (null 50%) while the largest has a 68% accuracy.  This suggests some potential upside to continuing the cold weather modeling process with more cities added for greater data volumes.
  
Data from years other than 2016 can be fed in to the model, with predictions made to see whether the model is learning general differences in climate or specific features about 2016.

Data that were not included in the modeling can be predicted, with the results assessed:  
  
* 2016 data that was not chosen for modeling - serves as an additional test frame  
* 2015 and 2017 data - can show the extent to which the model is learning general climate differences as opposed to specific 2016 weather features  
  
Example code includes:  
```{r eval=FALSE}

nonUsedData <- modData %>%
    anti_join(select(subData, source, dtime))

nonUsedData %>%
    mutate(localeName=str_replace(locale, pattern=" .{1}\\d{4}.*", replacement="")) %>%
    count(localeName, year) %>%
    pivot_wider(localeName, names_from="year", values_from="n")

```
  
The function can then be applied to the 2016 data:  
```{r eval=FALSE}

# Modify the file for mapping locale to type
localeMapper <- locale2016Mapper
names(localeMapper) <- str_replace(names(localeMapper), pattern=" .\\d{4}.", replacement="")

# Predictions on 2016 data
helperPredictPlot(rf_types_2016_TDmcwha$rfModel, 
                  df=filter(nonUsedData, year==2016), 
                  predOrder=c("Cold", "Cold-MI", "Lincoln", "Newark", "Marine", "Humid", "Desert"), 
                  locMapper=localeMapper
                  )

```
  
The predictions seem in-line with the test dataset conclusions, as would be expected given that the "unused" 2016 data are randomly sampled and should be no different than that "test" 2016 dataset.  
  
The function can then be applied to the 2015 and 2017 data:  
```{r eval=FALSE}

# Predictions on 2015/2017 data
helperPredictPlot(rf_types_2016_TDmcwha$rfModel, 
                  df=filter(nonUsedData, year!=2016), 
                  predOrder=c("Cold", "Cold-MI", "Lincoln", "Newark", "Marine", "Humid", "Desert"), 
                  locMapper=localeMapper
                  )

```
  
Model performance on 2015 and 2017 data is not as strong, with roughly a 10%-20% loss of accuracy.  Predictions are still much better than null accuracy, and the model (mostly) continues to separate the three well-differentiated types (Desert, Humid, Marine).

However, the model struggles to classify Chicago, placing it roughly equally as Cold (correct), Cold-MI, Lincoln, and Newark.  This suggests cold-weather cities may be predicted on specific anomalies of 2016 (e.g., where the cold snaps hit).  More data may help the model generalize better, specifcally to separate recurring and generalizable climate features of Chicago from weather anomalies that happened to hit Chicago in 2016.
  
Suppose that models are run on all 2015-2017 data for Chicago, Las Vegas, New Orleans, and San Diego:  
```{r eval=FALSE}

# Create the subset for Chicago, Las Vegas, New Orleans, San Diego (should have 2015, 2016, 2017)
sub_2015_2017_data <- modData %>%
    filter(str_sub(source, 1, 4) %in% c("kord", "klas", "kmsy", "ksan")) %>%
    mutate(city=str_replace(locale, pattern=" .\\d{4}.", replacement=""))

# Check that proper locales are included
sub_2015_2017_data %>% 
    count(city, locale)

```
  
```{r eval=FALSE}

# Run random forest for 2015-2017 data
rf_types_2015_2017_TDmcwha <- rfMultiLocale(sub_2015_2017_data, 
                                            vrbls=c("TempF", "DewF", 
                                                    "month", "hr",
                                                    "minHeight", "ceilingHeight", 
                                                    "WindSpeed", "predomDir", 
                                                    "modSLP"
                                                    ),
                                            locs=NULL, 
                                            locVar="city",
                                            pred="city",
                                            ntree=25, 
                                            seed=2006221334, 
                                            mtry=4
                                            )

```
  
```{r eval=FALSE}

evalPredictions(rf_types_2015_2017_TDmcwha, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind, SLP", 
                keyVar="city"
                )

```
  
Even with a very small forest (25 trees), the model is almost always separating Las Vegas, Chicago, San Diego, and New Orleans.  While the climates are very different in these cities, it is striking that the model has so few misclassifications.

How do other cities map against these classifications?  
```{r eval=FALSE}

# Predictions on 2015/2017 data
helperPredictPlot(rf_types_2015_2017_TDmcwha$rfModel, 
                  df=filter(modData, !(str_sub(source, 1, 4) %in% c("kord", "klas", "kmsy", "ksan"))), 
                  predOrder=c("Chicago, IL", "San Diego, CA", "New Orleans, LA", "Las Vegas, NV")
                  )

```
  
* Houston is most similar to New Orleans as expected  
* Milwaukee, Green Bay, and Grand Rapids are all classified 90%+ as Chicago  
* Madison, Traverse City, Minneapolis, and Detroit are all classified 85%+ as Chicago  
* Lincoln, Indianapolis, and Newark are all "closest" to Chicago, but all show meaningful prediction volumes to New Orleans (these are the three "least cold" of the cold-weather cities in the modeling)  
  
The prediction process is re-run excluding the altimeter (modSLP) data:  
```{r eval=FALSE}

# Run random forest for 2015-2017 data (exclude modSLP)
rf_types_2015_2017_TDmcwh <- rfMultiLocale(sub_2015_2017_data, 
                                           vrbls=c("TempF", "DewF", 
                                                   "month", "hr",
                                                   "minHeight", "ceilingHeight", 
                                                   "WindSpeed", "predomDir"
                                                   ),
                                            locs=NULL, 
                                            locVar="city",
                                            pred="city",
                                            ntree=25, 
                                            seed=2006221334, 
                                            mtry=4
                                            )

```
  
```{r eval=FALSE}

evalPredictions(rf_types_2015_2017_TDmcwh, 
                plotCaption = "Temp, Dew Point, Month, Hour of Day, Cloud Height, Wind", 
                keyVar="city"
                )

```
  
Performance drops, since altimeters are meaningfully different in high altitude (Las Vegas) and sea-level (New Orleans and San Diego) locations.

Variable importances are plotted:  
```{r eval=FALSE}

helperPlotVarImp(rf_types_2015_2017_TDmcwha$rfModel)
helperPlotVarImp(rf_types_2015_2017_TDmcwh$rfModel, titleAdd=" (Excludes SLP)")

```
  
Dew point and temperature by month continue to be strong factors for separating the four cities in this analysis.  SLP, minimum cloud height, and prevailing wind direction are also meaningful.
  
The assessment can be run for the two main 2015-2017 models:  
```{r eval=FALSE}

# Run for the full model including SLP
probs_2015_2017_TDmcwha <- 
    assessPredictionCertainty(rf_types_2015_2017_TDmcwha, 
                              keyVar="city", 
                              plotCaption="Temp, Dew Point, Month/Hour, Clouds, Wind, SLP", 
                              showAcc=TRUE
                              )

# Run for the model excluding SLP
probs_2015_2017_TDmcwh <- 
    assessPredictionCertainty(rf_types_2015_2017_TDmcwh, 
                              keyVar="city", 
                              plotCaption="Temp, Dew Point, Month/Hour, Clouds, Wind", 
                              showAcc=TRUE
                              )

```
  
Predictions with 80%+ of the votes are made ~80% of the time, and these predictions are ~99% accurate.  Predictions with <80% of the votes are made ~20% of the times, and these predictions are ~75% accurate.  The percentage of votes received appears to be a reasonable proxy for the confidence of the prediction.
  
A similar process can be run for assessing the classification of the other cities against the 2015-2017 data for Chicago, Las Vegas, New Orleans, and San Diego:  
```{r eval=FALSE}

useData <- modData %>%
    filter(!(str_sub(source, 1, 4) %in% c("kord", "klas", "kmsy", "ksan")))
    
# Run for the model excluding SLP
probs_allcities_2015_2017_TDmcwh <- 
    assessPredictionCertainty(rf_types_2015_2017_TDmcwh, 
                              testData=useData,
                              keyVar="locale", 
                              plotCaption="Temp, Dew Point, Month/Hour, Clouds, Wind", 
                              showHists=TRUE
                              )

```
  
Patterns in the predictions stand out:  
  
* Houston is almost always classified as New Orleans when the model is confident (~65% of the time)  
* The cities that are at least as cold as Chicago are almost always classified as Chicago when the model is confident (~70% of the time)  
* Newark, Lincoln, and Indianapolis are generally not classified with confidence (~50% of predictions are to 'Too Low'), suggesting these cities may fall in between the four archetypes  
* There are a meaningful number of 'Too Low' predictions for every locale, suggesting that many locales "loo like" at least two of these archetypes at certain times of the year  
  
The actual run is cached since it takes a meaningful amount of time:  
```{r eval=FALSE}

# Define the variables to be considered
possVars <- c("TempF", "DewF", "month", "hr", "minHeight", 
              "ceilingHeight", "WindSpeed", "predomDir", "modSLP"
              )

# Create a container for storing the best random forest and variable added from each run
rfContainer <- vector("list", length=length(possVars))
rfVarAdds <- vector("character", length=length(possVars))

# Run the functions using a for loop over the length of possVars
for (ctr in 1:length(possVars)) {
    
    # Pull in the results of the previous run
    if (ctr==1) {
        prevVars <- c()
    } else {
        prevVars <- rfVarAdds[1:(ctr-1)]
    }
    
    # Run each of them through the combinations
    tmpList <- helperRFCombinations(possVars, df=sub_2015_2017_data, prevVars=prevVars)

    # Assess the performance
    tmpAccuracy <- helperVariableAccuracy(tmpList, possVars=possVars, prevVars=prevVars)
    
    # Prepare to repeat the process
    bestRow <- tmpAccuracy %>%
        filter(locale=="OOB") %>%
        filter(accuracy==max(accuracy))
    bestRow
    
    # Update the rfContainer and rfVarAdds elements
    rfContainer[[ctr]] <- tmpList[[as.integer(pull(bestRow, vrblNum))]]
    rfVarAdds[ctr] <- pull(bestRow, vrblName)
    cat("\nVariable Added:", rfVarAdds[ctr], "\n")

}

```
  
The evolution of accuracy can then be plotted:  
```{r eval=FALSE}

# Pull the accuracy data from the variables selected
tblAccuracy <- map_dfr(rfContainer, .f=helperExtractAccuracy, .id="vrblNum") %>%
    mutate(vrblName=rfVarAdds[as.integer(vrblNum)], 
           locale=factor(locale, levels=c("OOB", unique(locale)[unique(locale) != "OOB"])), 
           plotLabel=ifelse(as.integer(vrblNum)==1, vrblName, paste0("add ", vrblName))
           )

# Plot the gains in accuracy, facetted by 'locale'
ggplot(tblAccuracy, aes(x=fct_reorder(plotLabel, -as.integer(vrblNum)))) + 
    geom_text(aes(y=accuracy, label=paste0(round(100*accuracy), "%"))) + 
    facet_wrap(~locale, nrow=1) + 
    ylim(c(0, 1)) +
    geom_hline(yintercept=0.25, lty=2) +
    labs(x="", 
         y="", 
         title="Evolution of accuracy as next-best variables are added",
         caption="Null accuracy is 25%"
         ) +
    coord_flip()

```
  
As seen previously, dew point, temperature, and month are significant differentiating variables, driving roughly 75% accuracy in classifying the archetypes.

Adding altimeter (SLP) bumps the accuracy by another ~10%, while adding minimum cloud height and prevailing wind direction bump the accuracy by another ~5%.

This shows some of the power of the random forest algorithm as it is given additional variables to explore.

Further, the OOB estimates provided by the modeling are pessimistic relative to performance on the hold-out sample (which has 94%-96% accuracy rather than the estimated 89%-93% accuracy).  This is driven partly by rfTwoLocales() pulling the average error rate rather than the final error rate, an oversight that carries throughout the analysis.  The next version of this modeling should fix the approach to classifying errors.

Evolution of error can be plotted to see the impact:  
```{r eval=FALSE}

oobError <- c()
for (ctr in 1:9) {
    oobError <- c(oobError, rfContainer[[ctr]]$rfModel$err.rate[, "OOB"])
}

tibble::tibble(nVars=rep(1:9, each=25), 
               ntrees=rep(1:25, times=9), 
               accuracy=1-oobError
               ) %>%
    ggplot(aes(x=ntrees, y=accuracy)) + 
    geom_line(aes(group=nVars, color=factor(nVars))) +
    labs(x="Number of Trees", 
         y="OOB Accuracy", 
         title="Accuracy improves with more trees and more variables"
         ) + 
    scale_color_discrete("# Variables")

```
  
It will be interesting to see how the four archetypes models perform on other large US cities.  A separate routine is written to source the key download and EDA functions and to run them for these key data.
