---
title: "Coronavirus US - USA Facts"
author: "davegoblue"
date: "6/6/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
This module builds on code contained in Coronavirus_Statistics_USAF_v005.Rmd.  This file includes the latest code for analyzing data from [USA Facts](https://usafacts.org/visualizations/coronavirus-covid-19-spread-map/).  USA Facts maintains data on cases and deaths by county for coronavirus in the US.  Downloaded data are unique by county with date as a column and a separate file for each of cases, deaths, and population.

The intent of this code is to source updated functions that allow for readRunUSAFacts() to be run to obtain, read, process, and analyze data from USA Facts.

## Sourcing Functions  
The tidyverse library is loaded, and the functions used for CDC daily processing are sourced.  Additionally, specific functions for USA Facts are also sourced:  
```{r}

library(tidyverse)

# Functions are available in source file
source("./Generic_Added_Utility_Functions_202105_v001.R")
source("./Coronavirus_CDC_Daily_Functions_v001.R")
source("./Coronavirus_USAF_Functions_v001.R")

```
  
Further, the mapping file specific to USA Facts is sourced:  
```{r}

source("./Coronavirus_USAF_Default_Mappings_v001.R")

```
  
Updated functions for diagnoseClusters(), createDetailedSummaries(), createSummary(), and helperSummaryMap() are added to Coronavirus_USAF_Functions_v001.R. These functions should be checked for consistency with state-level data with just a single copy kept later.

## Example Process  
The functions are tested on previously downloaded data, with results cached:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

urlMapper[["usafCase"]] <- "https://static.usafacts.org/public/data/covid-19/covid_confirmed_usafacts.csv"
urlMapper[["usafDeath"]] <- "https://static.usafacts.org/public/data/covid-19/covid_deaths_usafacts.csv"
urlMapper[["usafPop"]] <- "https://static.usafacts.org/public/data/covid-19/covid_county_population_usafacts.csv"

readList <- list("usafCase"="./RInputFiles/Coronavirus/covid_confirmed_usafacts_downloaded_20220308.csv", 
                 "usafDeath"="./RInputFiles/Coronavirus/covid_deaths_usafacts_downloaded_20220308.csv"
                 )
compareList <- list("usafCase"=readFromRDS("cty_newdata_20220202")$dfRaw$usafCase, 
                    "usafDeath"=readFromRDS("cty_newdata_20220202")$dfRaw$usafDeath
                    )

# Use existing clusters
cty_chkdata_20220308 <- readRunUSAFacts(maxDate="2022-03-06", 
                                        downloadTo=lapply(readList, 
                                                          FUN=function(x) if(file.exists(x)) NA else x
                                                          ),
                                        readFrom=readList, 
                                        compareFile=compareList, 
                                        writeLog="./RInputFiles/Coronavirus/USAF_NewData_20220308_chk_v005.log", 
                                        ovrwriteLog=TRUE,
                                        useClusters=readFromRDS("cty_newdata_20210813")$useClusters,
                                        skipAssessmentPlots=FALSE,
                                        brewPalette="Paired"
                                        )

# Plot all counties based on closest cluster
sparseCountyClusterMap(cty_chkdata_20220308$useClusters, 
                       caption="Includes only counties with 25k+ population",
                       brewPalette="viridis"
                       )

# Save the check file
saveToRDS(cty_chkdata_20220308, ovrWriteError=FALSE)

# Confirm that it is identical to the previous process
cty_newdata_20220308 <- readFromRDS("cty_newdata_20220308")
# Same names in the list
all.equal(names(cty_chkdata_20220308), names(cty_newdata_20220308))
# Identical items in the list
sapply(names(cty_chkdata_20220308), 
       FUN=function(x) identical(cty_chkdata_20220308[[x]], cty_newdata_20220308[[x]])
       )
# ggplot2 objects are never identical due to environment; confirm they are all.equal
all.equal(cty_chkdata_20220308$plotDataList, cty_newdata_20220308$plotDataList)

```

The capability for obtaining and processing county-level vaccines data is included:  
```{r fig.height=9, fig.width=9}

# Read the relevant vaccines data
vaxPartialRaw_20220309 <- downloadCountyVaccines(loc="./RInputFiles/Coronavirus/county_vaccine_20220309.csv")
vaxPartialRaw_20220309

# Repair the data for 65+
vaxFix65_20220309 <- repairVaxPopulation(vaxPartialRaw_20220309, colsRepair=c("popgte65"))
vaxFix65_20220309

```
  
Correlations data can also be run:  
```{r fig.height=9, fig.width=9}

corrList20220309 <- corrVaxBurden(lstCD=cty_newdata_20220308,
                                  dfVax=vaxPartialRaw_20220309, 
                                  minDateCD=c("2021-11-01", "2021-09-01"),
                                  maxDateCD="2022-02-28"
                                  )
corrList20220309

```
  
Comparisons can be run between summed county and state data:  
```{r fig.height=9, fig.width=9}

statePerCapita <- readFromRDS("cdc_daily_220304")$dfPerCapita

tempStateCompareList <- compareStateSummedCounty(dfState=statePerCapita, 
                                                 dfCounty=cty_newdata_20220308$dfPerCapita, 
                                                 aggData=TRUE,
                                                 dateThru="2022-02-28", 
                                                 returnData=TRUE
                                                 )
tempStateCompareList

```

The scoring metric is converted to functional form:  
```{r, fig.height=9, fig.width=9}

# Data for score similarity process
tempStateCompareList_v2 <- compareStateSummedCounty(dfState=statePerCapita, 
                                                    dfCounty=cty_newdata_20220308$dfPerCapita, 
                                                    inclStates=c(state.abb, "DC"), 
                                                    dateThru="2022-02-28", 
                                                    makePlot=FALSE,
                                                    returnData=TRUE
                                                    )
scoreSimilarity(tempStateCompareList_v2, minDate="2020-02-15", maxDate="2022-02-15", makeFacet=FALSE)

# Example states with meaningful disconnects on 1+ metrics
compareStateSummedCounty(dfState=statePerCapita, 
                         dfCounty=cty_newdata_20220308$dfPerCapita, 
                         inclStates=c("FL", "MO", "OK", "TX", "ME", "NE", "KY", "AL", "GA"), 
                         dateThru="2022-02-28", 
                         makePlot=TRUE,
                         returnData=FALSE
)

```
  
While cumulative deaths and cumulative cases are generally well aligned between sources, rolling 7-day deaths and cases are frequently divergent by source.

An integrated vaccines dataset can be created:  
```{r, fig.height=9, fig.width=9}

allState_20220309 <- integrateStateVaccine(vaxFix65_20220309, statePerCap=statePerCapita)
allState_20220309

```

Functionality for exploring vaccine evolution is included:  
```{r fig.height=9, fig.width=9}

# Example for a single state
stateAgeVaxEvolution(allState_20220309, keyState="FL", minDate="2020-12-15", returnData=TRUE)

# Example for multiple states without plotting
stateAgeVaxEvolution(allState_20220309, keyState=c("CA", "FL", "TX", "NY", "PA", "IL"), createPlot=FALSE)

# Example for multiple states with plotting
stateAgeVaxEvolution(allState_20220309, keyState=c("CT", "AR", "AZ"), minDate="2020-12-15", returnData=TRUE)

```
  
Scores can be created for every state, reflecting differences in the vaccination data:  
```{r fig.height=9, fig.width=9}

scoreVaxSimilarity(allState_20220309)
scoreVaxSimilarity(allState_20220309, minDate="2021-12-01", maxDate="2022-02-28", returnBaseData=TRUE)

stateAgeVaxEvolution(allState_20220309, 
                     keyState=c("HI", "TX", "VA", "GA", "CO", "WV", "VT"), 
                     createPlot = TRUE
                     )

```
  
County-level burden process mapping is included:  
```{r fig.height=9, fig.width=9}

makeBurdenDatePlot <- function(df, 
                               keyVar,
                               timeLabel,
                               plotTitle=NULL,
                               varLabel=NULL,
                               varFloor=0,
                               varCeiling=+Inf,
                               varDivBy=1,
                               vecRename=c("countyFIPS"="fips")
                               ) {
    
    # FUNCTION ARGUMENTS:
    # df: a processed data frame with fips, asofDate, burden
    # keyVar: character string for variable to be plotted
    # timeLabel: character string for amount of time (e.g., "1-month" or "5-week")
    # plotTitle: title for the plot (NULL means infer from other arguments)
    # varLabel: label for the variable in plot scale (NULL means infer from other arguments)
    # varFloor: minimum value to be allowed for variable (-Inf means no floor applied)
    # varCeiling: maximum value to be allowed for variable (Inf means no ceiling applied)
    # varDivBy: variable should be divivded by this for plotting
    # vecRename: renaming vector to get desired variables in frame
    
    # Create varLabel if passed as NULL
    if(is.null(varLabel)) {
        varLabel <- stringr::str_to_upper(stringr::str_extract(keyVar, "^[A-Za-z]*"))
        if((varDivBy > 1) & isTRUE(all.equal(log10(varDivBy) %% 1, 0))) 
            varLabel <- paste0(varLabel, "(", stringr::str_replace(varDivBy, pattern="1", replacement=""), "s)")
        else if (varDivBy != 1) varLabel <- paste0(varLabel, "(units of ", varDivBy, ")")
    }
    
    # Create plotTitle if passed as NULL
    if(is.null(plotTitle)) 
        plotTitle <- paste0(timeLabel, 
                            " coronavirus ", 
                            if(str_detect(stringr::str_to_upper(keyVar), pattern="CPM")) "cases" else "deaths",
                            " by county"
                            )
    
    # Create and return plot
    df %>%
        colRenamer(vecRename=vecRename) %>%
        mutate(burden=pmax(pmin(get(all_of(keyVar)), varCeiling), varFloor)/varDivBy) %>%
        select(fips, burden, asofDate) %>%
        usmap::plot_usmap(regions="counties", data=., values="burden") + 
        labs(title=plotTitle, 
             subtitle=if(varFloor > -Inf | varCeiling < +Inf) "Floors and/or ceilings applied" else NULL, 
             caption="Source: USA Facts"
             ) +
        scale_fill_continuous(paste0(varLabel, "\n", timeLabel), low="grey", high="red") +
        facet_wrap(~asofDate) + 
        theme(legend.position="bottom")
    
}

dfRoll20220308 <- createBurdenCountyDate(cty_newdata_20220308, 
                                         maxDate="2022-02-28", 
                                         rollBy=months(c(0, -3, -6, -9)), 
                                         dateSpan=91
                                         )
dfRoll20220308

makeBurdenDatePlot(dfRoll20220308, keyVar="cpm91", timeLabel="3-month", varCeiling=100000, varDivBy=1000)
makeBurdenDatePlot(dfRoll20220308, keyVar="dpm91", timeLabel="3-month", varCeiling=1500)

```

