---
title: "Coronavirus US - USA Facts"
author: "davegoblue"
date: "6/6/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
This module builds on code contained in Coronavirus_Statistics_USAF_v005.Rmd.  This file includes the latest code for analyzing data from [USA Facts](https://usafacts.org/visualizations/coronavirus-covid-19-spread-map/).  USA Facts maintains data on cases and deaths by county for coronavirus in the US.  Downloaded data are unique by county with date as a column and a separate file for each of cases, deaths, and population.

The intent of this code is to source updated functions that allow for readRunUSAFacts() to be run to obtain, read, process, and analyze data from USA Facts.

## Sourcing Functions  
The tidyverse library is loaded, and the functions used for CDC daily processing are sourced.  Additionally, specific functions for USA Facts are also sourced:  
```{r}

library(tidyverse)

# Functions are available in source file
source("./Generic_Added_Utility_Functions_202105_v001.R")
source("./Coronavirus_CDC_Daily_Functions_v001.R")
source("./Coronavirus_USAF_Functions_v001.R")

```
  
Further, the mapping file specific to USA Facts is sourced:  
```{r}

source("./Coronavirus_USAF_Default_Mappings_v001.R")

```
  
Updated functions for diagnoseClusters(), createDetailedSummaries(), createSummary(), and helperSummaryMap() are added to Coronavirus_USAF_Functions_v001.R. These functions should be checked for consistency with state-level data with just a single copy kept later.

## Example Process  
The functions are tested on previously downloaded data, with results cached:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

urlMapper[["usafCase"]] <- "https://static.usafacts.org/public/data/covid-19/covid_confirmed_usafacts.csv"
urlMapper[["usafDeath"]] <- "https://static.usafacts.org/public/data/covid-19/covid_deaths_usafacts.csv"
urlMapper[["usafPop"]] <- "https://static.usafacts.org/public/data/covid-19/covid_county_population_usafacts.csv"

readList <- list("usafCase"="./RInputFiles/Coronavirus/covid_confirmed_usafacts_downloaded_20220308.csv", 
                 "usafDeath"="./RInputFiles/Coronavirus/covid_deaths_usafacts_downloaded_20220308.csv"
                 )
compareList <- list("usafCase"=readFromRDS("cty_newdata_20220202")$dfRaw$usafCase, 
                    "usafDeath"=readFromRDS("cty_newdata_20220202")$dfRaw$usafDeath
                    )

# Use existing clusters
cty_chkdata_20220308 <- readRunUSAFacts(maxDate="2022-03-06", 
                                        downloadTo=lapply(readList, 
                                                          FUN=function(x) if(file.exists(x)) NA else x
                                                          ),
                                        readFrom=readList, 
                                        compareFile=compareList, 
                                        writeLog="./RInputFiles/Coronavirus/USAF_NewData_20220308_chk_v005.log", 
                                        ovrwriteLog=TRUE,
                                        useClusters=readFromRDS("cty_newdata_20210813")$useClusters,
                                        skipAssessmentPlots=FALSE,
                                        brewPalette="Paired"
                                        )

# Plot all counties based on closest cluster
sparseCountyClusterMap(cty_chkdata_20220308$useClusters, 
                       caption="Includes only counties with 25k+ population",
                       brewPalette="viridis"
                       )

# Save the check file
saveToRDS(cty_chkdata_20220308, ovrWriteError=FALSE)

# Confirm that it is identical to the previous process
cty_newdata_20220308 <- readFromRDS("cty_newdata_20220308")
# Same names in the list
all.equal(names(cty_chkdata_20220308), names(cty_newdata_20220308))
# Identical items in the list
sapply(names(cty_chkdata_20220308), 
       FUN=function(x) identical(cty_chkdata_20220308[[x]], cty_newdata_20220308[[x]])
       )
# ggplot2 objects are never identical due to environment; confirm they are all.equal
all.equal(cty_chkdata_20220308$plotDataList, cty_newdata_20220308$plotDataList)

```

The capability for obtaining and processing county-level vaccines data is included:  
```{r fig.height=9, fig.width=9}

# Read the relevant vaccines data
vaxPartialRaw_20220309 <- downloadCountyVaccines(loc="./RInputFiles/Coronavirus/county_vaccine_20220309.csv")
vaxPartialRaw_20220309

# Repair the data for 65+
vaxFix65_20220309 <- repairVaxPopulation(vaxPartialRaw_20220309, colsRepair=c("popgte65"))
vaxFix65_20220309

```
  
Correlations data can also be run:  
```{r fig.height=9, fig.width=9}

corrList20220309 <- corrVaxBurden(lstCD=cty_newdata_20220308,
                                  dfVax=vaxPartialRaw_20220309, 
                                  minDateCD=c("2021-11-01", "2021-09-01"),
                                  maxDateCD="2022-02-28"
                                  )
corrList20220309

```
  
Comparisons can be run between summed county and state data:  
```{r fig.height=9, fig.width=9}

statePerCapita <- readFromRDS("cdc_daily_220304")$dfPerCapita

tempStateCompareList <- compareStateSummedCounty(dfState=statePerCapita, 
                                                 dfCounty=cty_newdata_20220308$dfPerCapita, 
                                                 aggData=TRUE,
                                                 dateThru="2022-02-28", 
                                                 returnData=TRUE
                                                 )
tempStateCompareList

```

The scoring metric is converted to functional form:  
```{r, fig.height=9, fig.width=9}

# Data for score similarity process
tempStateCompareList_v2 <- compareStateSummedCounty(dfState=statePerCapita, 
                                                    dfCounty=cty_newdata_20220308$dfPerCapita, 
                                                    inclStates=c(state.abb, "DC"), 
                                                    dateThru="2022-02-28", 
                                                    makePlot=FALSE,
                                                    returnData=TRUE
                                                    )
scoreSimilarity(tempStateCompareList_v2, minDate="2020-02-15", maxDate="2022-02-15", makeFacet=FALSE)

# Example states with meaningful disconnects on 1+ metrics
compareStateSummedCounty(dfState=statePerCapita, 
                         dfCounty=cty_newdata_20220308$dfPerCapita, 
                         inclStates=c("FL", "MO", "OK", "TX", "ME", "NE", "KY", "AL", "GA"), 
                         dateThru="2022-02-28", 
                         makePlot=TRUE,
                         returnData=FALSE
)

```
  
While cumulative deaths and cumulative cases are generally well aligned between sources, rolling 7-day deaths and cases are frequently divergent by source.

An integrated vaccines dataset can be created:  
```{r, fig.height=9, fig.width=9}

allState_20220309 <- integrateStateVaccine(vaxFix65_20220309, statePerCap=statePerCapita)
allState_20220309

```

Functionality for exploring vaccine evolution is included:  
```{r fig.height=9, fig.width=9}

# Example for a single state
stateAgeVaxEvolution(allState_20220309, keyState="FL", minDate="2020-12-15", returnData=TRUE)

# Example for multiple states without plotting
stateAgeVaxEvolution(allState_20220309, keyState=c("CA", "FL", "TX", "NY", "PA", "IL"), createPlot=FALSE)

# Example for multiple states with plotting
stateAgeVaxEvolution(allState_20220309, keyState=c("CT", "AR", "AZ"), minDate="2020-12-15", returnData=TRUE)

```
  
Scores can be created for every state, reflecting differences in the vaccination data:  
```{r fig.height=9, fig.width=9}

scoreVaxSimilarity(allState_20220309)
scoreVaxSimilarity(allState_20220309, minDate="2021-12-01", maxDate="2022-02-28", returnBaseData=TRUE)

stateAgeVaxEvolution(allState_20220309, 
                     keyState=c("HI", "TX", "VA", "GA", "CO", "WV", "VT"), 
                     createPlot = TRUE
                     )

```
  
County-level burden process mapping is included:  
```{r fig.height=9, fig.width=9}

dfRoll20220308 <- createBurdenCountyDate(cty_newdata_20220308, 
                                         maxDate="2022-02-28", 
                                         rollBy=months(c(0, -3, -6, -9)), 
                                         dateSpan=91
                                         )
dfRoll20220308

makeBurdenDatePlot(dfRoll20220308, keyVar="cpm91", timeLabel="3-month", varCeiling=100000, varDivBy=1000)
makeBurdenDatePlot(dfRoll20220308, keyVar="dpm91", timeLabel="3-month", varCeiling=1500)

```

The latest county-level burden data are downloaded:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

urlMapper[["usafCase"]] <- "https://static.usafacts.org/public/data/covid-19/covid_confirmed_usafacts.csv"
urlMapper[["usafDeath"]] <- "https://static.usafacts.org/public/data/covid-19/covid_deaths_usafacts.csv"
urlMapper[["usafPop"]] <- "https://static.usafacts.org/public/data/covid-19/covid_county_population_usafacts.csv"

readList <- list("usafCase"="./RInputFiles/Coronavirus/covid_confirmed_usafacts_downloaded_20220414.csv", 
                 "usafDeath"="./RInputFiles/Coronavirus/covid_deaths_usafacts_downloaded_20220414.csv"
                 )
compareList <- list("usafCase"=readFromRDS("cty_newdata_20220308")$dfRaw$usafCase, 
                    "usafDeath"=readFromRDS("cty_newdata_20220308")$dfRaw$usafDeath
                    )

# Use existing clusters
cty_newdata_20220414 <- readRunUSAFacts(maxDate="2022-04-12", 
                                        downloadTo=lapply(readList, 
                                                          FUN=function(x) if(file.exists(x)) NA else x
                                                          ),
                                        readFrom=readList, 
                                        compareFile=compareList, 
                                        writeLog="./RInputFiles/Coronavirus/USAF_NewData_20220414_chk_v005.log", 
                                        ovrwriteLog=TRUE,
                                        useClusters=readFromRDS("cty_newdata_20210813")$useClusters,
                                        skipAssessmentPlots=FALSE,
                                        brewPalette="Paired"
                                        )

# Plot all counties based on closest cluster
sparseCountyClusterMap(cty_newdata_20220414$useClusters, 
                       caption="Includes only counties with 25k+ population",
                       brewPalette="viridis"
                       )

# Save the check file
saveToRDS(cty_newdata_20220414, ovrWriteError=FALSE)

```

A function is included for reading and fixing vaccines data, as well as running correlations to the burden data:  
```{r fig.height=9, fig.width=9}

processCountyVaccines <- function(loc,
                                  ctyList,
                                  url="https://data.cdc.gov/api/views/8xkx-amqh/rows.csv?accessType=DOWNLOAD", 
                                  colsRepair=c("popgte65"), 
                                  ...
                                  ) {
    
    # FUNCTION ARGUMENTS:
    # loc: the location of the downloaded vaccines data
    # ctyList: processed list file of county-level burden data
    # url: the location for obtaining the vaccines data
    # colsRepair: columns in the raw vaccines data that require repairs to the population data
    # ...: arguments passed to corrVaxBurden()
    
    vaxRaw <- downloadCountyVaccines(loc=loc, url=url)
    vaxFix <- repairVaxPopulation(vaxRaw, colsRepair=colsRepair)
    corrList <- corrVaxBurden(lstCD=ctyList, dfVax=vaxRaw, ...)
    
    # Return the key items
    list(vaxRaw=vaxRaw, vaxFix=vaxFix, corrList=corrList)
    
}

cty_vaxdata_20220415 <- processCountyVaccines(loc="./RInputFiles/Coronavirus/county_vaccine_20220415.csv", 
                                              ctyList=cty_newdata_20220414, 
                                              minDateCD=c("2021-11-01", "2021-09-01"),
                                              maxDateCD="2022-03-31"
                                              )

```
  
Similarities between summed county-level data and state-level data are explored:  
```{r, fig.height=9, fig.width=9}

# Data for score similarity process
tempStateCompareList_v2 <- compareStateSummedCounty(dfState=readFromRDS("cdc_daily_220416")$dfPerCapita, 
                                                    dfCounty=cty_newdata_20220414$dfPerCapita, 
                                                    inclStates=c(state.abb, "DC"), 
                                                    dateThru="2022-04-10", 
                                                    makePlot=FALSE,
                                                    returnData=TRUE
                                                    )
scoreSimilarity(tempStateCompareList_v2, minDate="2020-02-15", maxDate="2022-04-10", makeFacet=FALSE)

# Example states with meaningful disconnects on 1+ metrics
compareStateSummedCounty(dfState=readFromRDS("cdc_daily_220416")$dfPerCapita, 
                         dfCounty=cty_newdata_20220414$dfPerCapita, 
                         inclStates=c("GA", "FL", "NE", "OK", "KY", "ME", "VT", "WY", "TN", "RI", "MO", "MA", "KS"), 
                         dateThru="2022-04-10", 
                         makePlot=TRUE,
                         returnData=FALSE
                         )

```
  
An integrated vaccines dataset is created, along with similarity scores:  
```{r, fig.height=9, fig.width=9}

allState_20220415 <- integrateStateVaccine(cty_vaxdata_20220415$vaxFix, 
                                           statePerCap=readFromRDS("cdc_daily_220416")$dfPerCapita
                                           )
allState_20220415

vaxDiff_20220415 <- scoreVaxSimilarity(allState_20220415, 
                                       minDate="2021-04-01", 
                                       maxDate="2022-03-31", 
                                       returnBaseData=TRUE
                                       )

```
  
Plots of the larger differences are included:  
```{r, fig.height=9, fig.width=9}

stateAgeVaxEvolution(allState_20220415, 
                     keyState=c("MA", "HI", "TX", "VA", "VT", "GA", "CO", "WV"), 
                     createPlot = TRUE
                     )

scoreVaxSimilarity(allState_20220415, minDate="2022-01-01", maxDate="2022-03-31")

stateAgeVaxEvolution(allState_20220415, keyState=c(state.abb, "DC"), createPlot = FALSE) %>% 
    filter(!complete.cases(.), date >= "2021-01-01") %>% 
    group_by(state, ym=customYYYYMM(date)) %>% 
    summarize(n=n()) %>% 
    pivot_wider(ym, names_from="state", values_from="n") %>% 
    arrange(desc(ym))

```
  
* HI and MA have never reported county-level data
* CA stopped reporting county-level data as of 2022-03
* TX and VA have around a week of missing county-level data in 2022-03
  
Function integrateStateVaccine() is updated to better manage sporadic NA values such as in TX and VA:  
```{r, fig.height=9, fig.width=9}

integrateStateVaccine <- function(vaxCounty, 
                                  statePerCap,
                                  keyStates=c(state.abb, "DC"),
                                  joinType=dplyr::right_join,
                                  treatNAZero=TRUE
                                  ) {
    
    # FUNCTION ARGUMENTS:
    # vaxCounty: processed county-level vaccines data
    # statePerCap: per-capita state level data frame
    # keyStates: states to be included
    # joinType: join to be made (statePerCap is 'left' and summed vaxCounty is 'right')
    # treatNAZero: boolean, should NA values in vaccines be treated as 0 rather than throwing an aggregate NA?
    
    # Create the aggregation function
    if(isTRUE(treatNAZero)) aggFunc <- specNA(sum) else aggFunc <- sum
    
    # Roll county-level data to state
    dfTemp <- vaxCounty %>%
        filter(state %in% all_of(keyStates), FIPS != "UNK") %>%
        group_by(date, state) %>%
        summarize(ctypoppct=aggFunc(vxcpoppct*pop)/sum(pop), 
                  ctygte18pct=aggFunc(vxcgte18pct*popgte18)/sum(popgte18),
                  ctygte65pct=aggFunc(vxcgte65pct*popgte65)/sum(popgte65),
                  across(starts_with("pop"), sum, na.rm=TRUE), 
                  .groups="drop"
        )
    
    # Integrate and return the data
    statePerCap %>%
        select(state, date, vxcpoppct, vxcgte18pct, vxcgte65pct) %>%
        filter(state %in% all_of(keyStates)) %>%
        joinType(dfTemp, by=c("state", "date"))
    
}

# Check that data are the same
all.equal(allState_20220415, 
          integrateStateVaccine(cty_vaxdata_20220415$vaxFix, 
                                statePerCap=readFromRDS("cdc_daily_220416")$dfPerCapita, 
                                treatNAZero=FALSE
                                )
          )

# Check differences in updated data
allState_20220415_v2 <- integrateStateVaccine(cty_vaxdata_20220415$vaxFix, 
                                              statePerCap=readFromRDS("cdc_daily_220416")$dfPerCapita, 
                                              treatNAZero=TRUE
                                              )

# Confirm equality where not NA in original data
all.equal(allState_20220415[complete.cases(allState_20220415), ], 
          allState_20220415_v2[complete.cases(allState_20220415), ]
          )

# Display updated records
allState_20220415_v2[complete.cases(allState_20220415_v2) & !complete.cases(allState_20220415), ] %>%
    mutate(ym=customYYYYMM(date)) %>%
    filter(ym >= "2021-01-01") %>%
    group_by(state, ym) %>%
    summarize(across(where(is.numeric), mean), n=n(), .groups="drop")

scoreVaxSimilarity(allState_20220415_v2, minDate="2022-01-01", maxDate="2022-03-31")

```

County-level burden process mapping is included:  
```{r fig.height=9, fig.width=9}

dfRoll20220414 <- createBurdenCountyDate(cty_newdata_20220414, 
                                         maxDate="2022-03-31", 
                                         rollBy=months(c(0, -3, -6, -9)), 
                                         dateSpan=91
                                         )
dfRoll20220414

makeBurdenDatePlot(dfRoll20220414, keyVar="cpm91", timeLabel="3-month", varCeiling=100000, varDivBy=1000)
makeBurdenDatePlot(dfRoll20220414, keyVar="dpm91", timeLabel="3-month", varCeiling=1500)

```
  
Post-processing steps are consolidated to a function, so that the process includes:  
  
1. readRunUSAFacts() and spareCountyClusterMap()  
2. processCountyVaccines()  
3. postProcessCountyData()  
4. Individual functions as needed  
  
The postProcessCountyData() includes:  
```{r fig.height=9, fig.width=9}

# Updated to include date range
scoreVaxSimilarity <- function(df, 
                               keyStates=c(state.abb, "DC"), 
                               minDate=NULL, 
                               maxDate=NULL, 
                               returnBaseData=FALSE
                               ) {
    
    # FUNCTION ARGUMENTS:
    # df: a processed file from integrateStateVaccine()
    # keyStates: states to include
    # minDate: earliest date to use for scoring (NULL means use all)
    # maxDate: latest date to use for scoring (NULL means use all)
    # returnBaseData: boolean, should dfBase be returned?
    
    # Set minDate and maxDate if NULL
    if(is.null(minDate)) minDate <- min(df$date, na.rm=TRUE)
    if(is.null(maxDate)) maxDate <- max(df$date, na.rm=TRUE)
    
    dfBase <- stateAgeVaxEvolution(df, keyState=keyStates, createPlot = FALSE) %>%
        mutate(value=ifelse(is.na(value), 0, value), src=ifelse(src=="State", "cdcState", "ctySum")) %>%
        pivotData(c("state", "date", "age"), nameVar="src", toLonger=FALSE) %>%
        filter(date >= minDate, date <= maxDate) %>%
        mutate(ym=customYYYYMM(date)) %>%
        group_by(state, ym, age) %>%
        summarize(n=n(), 
                  rmse=sqrt(mean((cdcState-ctySum)**2)), 
                  cdcState=mean(cdcState), 
                  ctySum=mean(ctySum), 
                  .groups="drop"
        )
    p1 <- dfBase %>%
        group_by(state, age) %>% 
        summarize(rmse=mean(rmse), .groups="drop") %>% 
        ggplot(aes(x=fct_reorder(state, rmse), y=rmse)) + 
        geom_col(fill="lightblue") + 
        coord_flip() + 
        facet_wrap(~age) + 
        labs(x=NULL, 
             y="RMSE (Vaccinated by State/Age difference by source)", 
             title="Difference in vaccinated by state data by source", 
             subtitle=paste0("Date range: ", minDate, " to ", maxDate)
        )
    print(p1)
    
    if(isTRUE(returnBaseData)) return(dfBase)
    
}

# Updated to handle lst passed as a perCapita file
makeBurdenSummary <- function(lst, 
                              groupVar=c("countyFIPS", "state"), 
                              numVarFinal=c("tdpm", "tcpm"), 
                              numVarSum=c("dpm", "cpm"), 
                              keyDate=NULL,
                              dateRange=28
                              ) {
    
    # FUNCTION ARGUMENTS
    # lst: list of processed county burden data (or extracted dfPerCapita file)
    # groupVar: grouping variables for the final dataset
    # numVarFinal: numeric variables to pull data from the key date
    # numVarSum: numeric variables to sum from the key date interval
    # keyDate: the key date for the summaries (NULL means use maximum in data)
    # dateRange: number of days to include in the numeric interval summaries
    
    # Extract perCapita data if passed as a list
    if("list" %in% class(lst)) lst <- lst[["dfPerCapita"]]
    
    # Find keyDate if not provided, convert to date if not already
    if(is.null(keyDate)) keyDate <- lst %>% pull(date) %>% max()
    if(!("Date" %in% class(keyDate))) keyDate <- as.Date(keyDate)
    
    # Create summary
    df <- lst %>% 
        group_by_at(all_of(groupVar)) %>%
        summarize(asofDate=keyDate, 
                  across(all_of(numVarFinal), .fns=~sum(ifelse(date==keyDate, .x, 0))),
                  across(all_of(numVarSum), 
                         .fns=~sum(ifelse(date>keyDate-dateRange & date<=keyDate, .x, 0)), 
                         .names=paste0("{.col}", as.character(dateRange))
                  ),
                  .groups="drop"
        )
    
    # Return the data frame
    df
    
}

postProcessCountyData <- function(lstCtyBurden,
                                  lstCtyVax,
                                  lstState, 
                                  maxDate=NULL, 
                                  minDateBurden="2020-02-15", 
                                  minDateVax="2021-04-01"
                                  ) {

    # FUNCTION ARGUMENTS:
    # lstCtyBurden: list of processed county-level burden data (or a dfPerCapita file from this list)
    # lstCtyVax: list of processed county-level vaccines data (or a vaxFix file from this list)
    # lstState: list of processed state-level burden data (or a dfPerCapita file from this list)
    # maxDate: maximum date to use for plotting (NULL means latest date in both lstCty and lstState)
    # minDateBurden: earliest date for scoring burden similarity across files
    # minDateVax: earliest date for scoring vaccine similarity across files
    
    # Extract the relevant perCapita and vaxFix data if needed
    if("list" %in% class(lstCtyBurden)) lstCtyBurden <- lstCtyBurden[["dfPerCapita"]]
    if("list" %in% class(lstState)) lstState <- lstState[["dfPerCapita"]]
    if("list" %in% class(lstCtyVax)) lstCtyVax <- lstCtyVax[["vaxFix"]]
    
    # Get maxDate if not provided
    if(is.null(maxDate)) maxDate <- min(max(lstCtyBurden$date, na.rm=TRUE), max(lstState$date, na.rm=TRUE))
    cat("\nParameter maxDate is:", as.character(maxDate), "\n\n")
    
    # Data for score similarity process
    dfCompare <- compareStateSummedCounty(dfState=lstState, 
                                          dfCounty=lstCtyBurden, 
                                          inclStates=c(state.abb, "DC"), 
                                          dateThru=maxDate, 
                                          makePlot=FALSE,
                                          returnData=TRUE
                                          )
    scoreSimilarity(dfCompare, minDate=minDateBurden, maxDate=maxDate, makeFacet=FALSE)

    # Check differences in data sources
    dfAllState <- integrateStateVaccine(lstCtyVax, statePerCap=lstState, treatNAZero=TRUE)
    vaxDiff <- scoreVaxSimilarity(dfAllState, minDate=minDateVax, maxDate=maxDate, returnBaseData=TRUE)

    # Create county-level burden data by quarters
    dfRoll91 <- createBurdenCountyDate(lstCtyBurden, 
                                       maxDate=maxDate, 
                                       rollBy=months(c(0, -3, -6, -9)), 
                                       dateSpan=91
                                       )
    makeBurdenDatePlot(dfRoll91, keyVar="cpm91", timeLabel="3-month", varCeiling=100000, varDivBy=1000) %>% print()
    makeBurdenDatePlot(dfRoll91, keyVar="dpm91", timeLabel="3-month", varCeiling=1500) %>% print()

    # Return the key elements
    list(dfCompare=dfCompare, dfAllState=dfAllState, vaxDiff=vaxDiff, dfRoll91=dfRoll91)
    
}

cty_postdata_20220414 <- postProcessCountyData(lstCtyBurden=cty_newdata_20220414$dfPerCapita, 
                                               lstCtyVax=cty_vaxdata_20220415$vaxFix, 
                                               lstState=readFromRDS("cdc_daily_220416")$dfPerCapita
                                               )

```

And stand-alone functions include:  
```{r fig.height=9, fig.width=9}

# 1. Plot states with meaningful disconnects on 1+ metrics
compareStateSummedCounty(dfState=readFromRDS("cdc_daily_220416")$dfPerCapita,
                         dfCounty=cty_newdata_20220414$dfPerCapita,
                         inclStates=c("GA", "FL", "NE", "OK", "KY", "ME", "VT", "WY", "TN", "RI", "MO", "MA", "KS"),
                         dateThru="2022-04-10",
                         makePlot=TRUE,
                         returnData=FALSE
                         )

# 2. Plot differences in vaccines data if needed
stateAgeVaxEvolution(cty_postdata_20220414$dfAllState,
                     keyState=c("MA", "HI", "TX", "VA", "VT", "GA", "CO", "WV"),
                     createPlot = TRUE
                     )

# 3. Check vaccine similarity scoring on a different time period
scoreVaxSimilarity(cty_postdata_20220414$dfAllState, minDate="2022-01-01", maxDate="2022-03-31")

# 4. Check for states with missing data (after adjustments, should only be HI which does not report by county)
stateAgeVaxEvolution(cty_postdata_20220414$dfAllState, keyState=c(state.abb, "DC"), createPlot = FALSE) %>%
    filter(!complete.cases(.), date >= "2021-01-01") %>%
    group_by(state, ym=customYYYYMM(date), .groups="drop") %>%
    summarize(n=n()) %>%
    pivot_wider(ym, names_from="state", values_from="n") %>%
    arrange(desc(ym))

# 5. Additional rolling data as needed
dfRoll_28 <- createBurdenCountyDate(cty_newdata_20220414,
                                    maxDate="2022-04-10",
                                    rollBy=months(c(0, -1, -2, -3)),
                                    dateSpan=28
                                    )
makeBurdenDatePlot(dfRoll_28, keyVar="cpm28", timeLabel="1-month", varCeiling=50000, varDivBy=1000)
makeBurdenDatePlot(dfRoll_28, keyVar="dpm28", timeLabel="1-month", varCeiling=500)

```
  
Function compareStateSummedCounty() is updated to accept a processed frame:  
```{r fig.height=9, fig.width=9}

pivotStateBurdenData <- function(df, 
                                 inclStates, 
                                 varKeep=c("date", "state", "tot_cases", "new_cases", "tot_deaths", "new_deaths"),
                                 varRename=c("tot_cases"="cases", "tot_deaths"="deaths"),
                                 dateThru=NULL
                                 ) {
    
    # FUNCTION ARGUMENTS:
    # df: a state-level burden data frame
    # inclStates: states to be included
    # varKeep: variables to be kept from state burden frame
    # varRename: variables to be renamed
    # dateThru: maximum date for the analysis (NULL means use max(date) from df)
    
    # Create and return pivoted state-level data
    df %>%
        colSelector(vecSelect=varKeep) %>%
        colRenamer(vecRename=varRename) %>%
        filter(state %in% all_of(inclStates), 
               date <= if(is.null(dateThru)) max(date) else as.Date(dateThru)
               ) %>%
        pivot_longer(-c(date, state)) %>%
        mutate(value=ifelse(is.na(value), 0, value)) %>%
        arrange(date, state, name) %>%
        group_by(state, name) %>%
        mutate(value7=zoo::rollmean(value, k=7, fill=NA, align="center"), src="state") %>%
        ungroup()
    
}

createSummedCountyBurdenData <- function(df, 
                                         inclStates, 
                                         varKeep=c("state", "countyFIPS", "date", 
                                                   "cases", "new_cases", "deaths", "new_deaths"
                                                   ),
                                         varRename=c(),
                                         dateThru=NULL
                                 ) {
    
    # FUNCTION ARGUMENTS:
    # df: a state-level burden data frame
    # inclStates: states to be included
    # varKeep: variables to be kept from state burden frame
    # varRename: variables to be renamed
    # dateThru: maximum date for the analysis (NULL means use max(date) from df)
    
    # Create and return summed and pivoted county-level data
    df %>%
        filter(state %in% all_of(inclStates), 
               date <= if(is.null(dateThru)) max(date) else as.Date(dateThru)
               ) %>%
        colSelector(vecSelect=varKeep) %>%
        colRenamer(vecRename=varRename) %>%
        pivot_longer(-c(state, countyFIPS, date)) %>%
        arrange(state, countyFIPS, date) %>%
        group_by(state, countyFIPS, name) %>%
        mutate(value7=zoo::rollmean(value, k=7, fill=NA, align="center")) %>%
        ungroup() %>%
        filter(state %in% all_of(inclStates)) %>%
        group_by(state, date, name) %>%
        summarize(across(c(value, value7), .fns=sum), .groups="drop") %>%
        filter(!is.na(value7)) %>%
        mutate(src="county")
    
}

compareStateSummedCounty <- function(dfState=NULL, 
                                     dfCounty=NULL,
                                     lstAll=NULL,
                                     aggData=FALSE,
                                     inclStates=if(isTRUE(aggData)) c(state.abb, "DC") else NULL, 
                                     dateThru=NULL, 
                                     makePlot=TRUE, 
                                     createData=TRUE,
                                     returnData=FALSE
                                     ) {
    
    # FUNCTION ARGUMENTS:
    # dfState: processed state-level metrics
    # dfCounty: processed county-level metrics
    # lstAll: list containing processed dfState and dfCounty
    # aggData: boolean, should data be aggregated (FALSE means one plot series per state)
    # inclStates: character vector of states to include
    # dateThru: latest date for analyzsis (NULL means use all data)
    # makePlot: boolean, should plots be created for each state?
    # createData: boolean, does dfAll need to be built from dfState and dfCounty? FALSE means use dfAll
    # returnData: boolean, should a list of processed dfState and processed dfCounty be returned?
    
    # Check that data passed matches parameters
    if(isTRUE(createData)) {
        if(is.null(dfState) | is.null(dfCounty)) stop("\nNeed to pass dfState and dfCounty when createData=TRUE\n")
        if(!is.null(lstAll)) cat("\nlstAll is ignored, to be built from dfState and dfCounty when createData=TRUE\n")
    }
    if(!isTRUE(createData)) {
        if(is.null(lstAll)) stop("\nNeed to pass lstAll when createData=FALSE\n")
        if(!is.null(dfState)) cat("\ndfState ignored; using lstAll due to createData=FALSE\n")
        if(!is.null(dfCounty)) cat("\ndfCounty ignored; using lstAll due to createData=FALSE\n")
    }
    
    # Check that at least one state has been passed
    if(is.null(inclStates) | length(inclStates)==0) {
        cat("\nNo states passed to compareStateSummedCounty, returning without running function\n")
        return()
    }
    
    # Create or extract data as directed by parameter createData
    if(isTRUE(createData)) {
        dfState <- pivotStateBurdenData(dfState, inclStates=inclStates, dateThru=dateThru)
        dfCounty <- createSummedCountyBurdenData(dfCounty, inclState=inclStates, dateThru=dateThru)
    } else {
        dfState <- lstAll[["dfState"]]
        dfCounty <- lstAll[["dfCounty"]]
    }
    
    # If data are to be aggregated, perform the aggregation
    if(isTRUE(aggData)) {
        tempAgg <- function(df) {
            df %>% 
                group_by(date, name, src) %>% 
                summarize(value=specNA(sum)(value, na.rm=TRUE), 
                          value7=specNA(sum)(value7, na.rm=TRUE), 
                          .groups="drop"
                          ) %>% 
                mutate(state="Aggregated")
        }
        dfState <- tempAgg(dfState)
        dfCounty <- tempAgg(dfCounty)
        inclStates <- "Aggregated"
    }
    
    if(isTRUE(makePlot)) {
        
        for(thisState in all_of(inclStates)) {
            
            p1 <- dfCounty %>%
                filter(state %in% all_of(thisState)) %>%
                bind_rows(filter(dfState, state %in% all_of(thisState))) %>%
                ggplot(aes(x=date, y=value7)) + 
                geom_line(aes(group=src, color=src)) + 
                facet_wrap(~name, scales="free_y") + 
                labs(x=NULL, 
                     y="Rolling 7-day mean", 
                     title="Summed county burden by metric (7-day mean)", 
                     subtitle=paste0(thisState, " counties")
                ) + 
                scale_color_discrete("Source")
            print(p1)
            
        }
    }
    
    if(returnData) list(dfState=dfState, dfCounty=dfCounty)
    
}

# Check that results are the same when creating the full frame (default)
chk1 <- compareStateSummedCounty(dfState=readFromRDS("cdc_daily_220416")$dfPerCapita, 
                                 dfCounty=cty_newdata_20220414$dfPerCapita, 
                                 inclStates=c(state.abb, "DC"), 
                                 dateThru="2022-04-11", 
                                 makePlot=FALSE,
                                 returnData=TRUE
                                 )
identical(chk1, cty_postdata_20220414$dfCompare)

# Check that results are the same when using the existing frame
chk2 <- compareStateSummedCounty(lstAll=cty_postdata_20220414$dfCompare,
                                 inclStates=c(state.abb, "DC"), 
                                 dateThru="2022-04-11", 
                                 createData=FALSE,
                                 makePlot=FALSE,
                                 returnData=TRUE
                                 )
identical(chk1, chk2)

# Example plotting for select states
compareStateSummedCounty(lstAll=cty_postdata_20220414$dfCompare,
                         inclStates=c("GA", "FL", "NE"),
                         dateThru="2022-04-11",
                         createData=FALSE,
                         makePlot=TRUE,
                         returnData=FALSE
                         )

```

