---
title: "Coronavirus US - USA Facts"
author: "davegoblue"
date: "6/6/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
This module builds on code contained in Coronavirus_Statistics_USAF_v005.Rmd.  This file includes the latest code for analyzing data from [USA Facts](https://usafacts.org/visualizations/coronavirus-covid-19-spread-map/).  USA Facts maintains data on cases and deaths by county for coronavirus in the US.  Downloaded data are unique by county with date as a column and a separate file for each of cases, deaths, and population.

The intent of this code is to source updated functions that allow for readRunUSAFacts() to be run to obtain, read, process, and analyze data from USA Facts.

## Sourcing Functions  
The tidyverse library is loaded, and the functions used for CDC daily processing are sourced.  Additionally, specific functions for USA Facts are also sourced:  
```{r}

library(tidyverse)

# Functions are available in source file
source("./Generic_Added_Utility_Functions_202105_v001.R")
source("./Coronavirus_CDC_Daily_Functions_v001.R")
source("./Coronavirus_USAF_Functions_v001.R")

```
  
Further, the mapping file specific to USA Facts is sourced:  
```{r}

source("./Coronavirus_USAF_Default_Mappings_v001.R")

```
  
Updated functions for diagnoseClusters(), createDetailedSummaries(), createSummary(), and helperSummaryMap() are added to Coronavirus_USAF_Functions_v001.R. These functions should be checked for consistency with state-level data with just a single copy kept later.

## Example Process  
The functions are tested on previously downloaded data, with results cached:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

urlMapper[["usafCase"]] <- "https://static.usafacts.org/public/data/covid-19/covid_confirmed_usafacts.csv"
urlMapper[["usafDeath"]] <- "https://static.usafacts.org/public/data/covid-19/covid_deaths_usafacts.csv"
urlMapper[["usafPop"]] <- "https://static.usafacts.org/public/data/covid-19/covid_county_population_usafacts.csv"

readList <- list("usafCase"="./RInputFiles/Coronavirus/covid_confirmed_usafacts_downloaded_20220308.csv", 
                 "usafDeath"="./RInputFiles/Coronavirus/covid_deaths_usafacts_downloaded_20220308.csv"
                 )
compareList <- list("usafCase"=readFromRDS("cty_newdata_20220202")$dfRaw$usafCase, 
                    "usafDeath"=readFromRDS("cty_newdata_20220202")$dfRaw$usafDeath
                    )

# Use existing clusters
cty_chkdata_20220308 <- readRunUSAFacts(maxDate="2022-03-06", 
                                        downloadTo=lapply(readList, 
                                                          FUN=function(x) if(file.exists(x)) NA else x
                                                          ),
                                        readFrom=readList, 
                                        compareFile=compareList, 
                                        writeLog="./RInputFiles/Coronavirus/USAF_NewData_20220308_chk_v005.log", 
                                        ovrwriteLog=TRUE,
                                        useClusters=readFromRDS("cty_newdata_20210813")$useClusters,
                                        skipAssessmentPlots=FALSE,
                                        brewPalette="Paired"
                                        )

# Plot all counties based on closest cluster
sparseCountyClusterMap(cty_chkdata_20220308$useClusters, 
                       caption="Includes only counties with 25k+ population",
                       brewPalette="viridis"
                       )

# Save the check file
saveToRDS(cty_chkdata_20220308, ovrWriteError=FALSE)

# Confirm that it is identical to the previous process
cty_newdata_20220308 <- readFromRDS("cty_newdata_20220308")
# Same names in the list
all.equal(names(cty_chkdata_20220308), names(cty_newdata_20220308))
# Identical items in the list
sapply(names(cty_chkdata_20220308), 
       FUN=function(x) identical(cty_chkdata_20220308[[x]], cty_newdata_20220308[[x]])
       )
# ggplot2 objects are never identical due to environment; confirm they are all.equal
all.equal(cty_chkdata_20220308$plotDataList, cty_newdata_20220308$plotDataList)

```

The capability for obtaining and processing county-level vaccines data is included:  
```{r fig.height=9, fig.width=9}

# Read the relevant vaccines data
vaxPartialRaw_20220309 <- downloadCountyVaccines(loc="./RInputFiles/Coronavirus/county_vaccine_20220309.csv")
vaxPartialRaw_20220309

# Repair the data for 65+
vaxFix65_20220309 <- repairVaxPopulation(vaxPartialRaw_20220309, colsRepair=c("popgte65"))
vaxFix65_20220309

```
  
Correlations data can also be run:  
```{r fig.height=9, fig.width=9}

corrList20220309 <- corrVaxBurden(lstCD=cty_newdata_20220308,
                                  dfVax=vaxPartialRaw_20220309, 
                                  minDateCD=c("2021-11-01", "2021-09-01"),
                                  maxDateCD="2022-02-28"
                                  )
corrList20220309

```
  
Comparisons can be run between summed county and state data:  
```{r fig.height=9, fig.width=9}

statePerCapita <- readFromRDS("cdc_daily_220304")$dfPerCapita

tempStateCompareList <- compareStateSummedCounty(dfState=statePerCapita, 
                                                 dfCounty=cty_newdata_20220308$dfPerCapita, 
                                                 aggData=TRUE,
                                                 dateThru="2022-02-28", 
                                                 returnData=TRUE
                                                 )
tempStateCompareList

```

The scoring metric is converted to functional form:  
```{r, fig.height=9, fig.width=9}

# Data for score similarity process
tempStateCompareList_v2 <- compareStateSummedCounty(dfState=statePerCapita, 
                                                    dfCounty=cty_newdata_20220308$dfPerCapita, 
                                                    inclStates=c(state.abb, "DC"), 
                                                    dateThru="2022-02-28", 
                                                    makePlot=FALSE,
                                                    returnData=TRUE
                                                    )
scoreSimilarity(tempStateCompareList_v2, minDate="2020-02-15", maxDate="2022-02-15", makeFacet=FALSE)

# Example states with meaningful disconnects on 1+ metrics
compareStateSummedCounty(dfState=statePerCapita, 
                         dfCounty=cty_newdata_20220308$dfPerCapita, 
                         inclStates=c("FL", "MO", "OK", "TX", "ME", "NE", "KY", "AL", "GA"), 
                         dateThru="2022-02-28", 
                         makePlot=TRUE,
                         returnData=FALSE
)

```
  
While cumulative deaths and cumulative cases are generally well aligned between sources, rolling 7-day deaths and cases are frequently divergent by source.

An integrated vaccines dataset can be created:  
```{r, fig.height=9, fig.width=9}

allState_20220309 <- integrateStateVaccine(vaxFix65_20220309, statePerCap=statePerCapita)
allState_20220309

```

Functionality for exploring vaccine evolution is included:  
```{r fig.height=9, fig.width=9}

# Example for a single state
stateAgeVaxEvolution(allState_20220309, keyState="FL", minDate="2020-12-15", returnData=TRUE)

# Example for multiple states without plotting
stateAgeVaxEvolution(allState_20220309, keyState=c("CA", "FL", "TX", "NY", "PA", "IL"), createPlot=FALSE)

# Example for multiple states with plotting
stateAgeVaxEvolution(allState_20220309, keyState=c("CT", "AR", "AZ"), minDate="2020-12-15", returnData=TRUE)

```
  
Scores can be created for every state, reflecting differences in the vaccination data:  
```{r fig.height=9, fig.width=9}

scoreVaxSimilarity(allState_20220309)
scoreVaxSimilarity(allState_20220309, minDate="2021-12-01", maxDate="2022-02-28", returnBaseData=TRUE)

stateAgeVaxEvolution(allState_20220309, 
                     keyState=c("HI", "TX", "VA", "GA", "CO", "WV", "VT"), 
                     createPlot = TRUE
                     )

```
  
County-level burden process mapping is included:  
```{r fig.height=9, fig.width=9}

dfRoll20220308 <- createBurdenCountyDate(cty_newdata_20220308, 
                                         maxDate="2022-02-28", 
                                         rollBy=months(c(0, -3, -6, -9)), 
                                         dateSpan=91
                                         )
dfRoll20220308

makeBurdenDatePlot(dfRoll20220308, keyVar="cpm91", timeLabel="3-month", varCeiling=100000, varDivBy=1000)
makeBurdenDatePlot(dfRoll20220308, keyVar="dpm91", timeLabel="3-month", varCeiling=1500)

```

The latest county-level burden data are downloaded:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

urlMapper[["usafCase"]] <- "https://static.usafacts.org/public/data/covid-19/covid_confirmed_usafacts.csv"
urlMapper[["usafDeath"]] <- "https://static.usafacts.org/public/data/covid-19/covid_deaths_usafacts.csv"
urlMapper[["usafPop"]] <- "https://static.usafacts.org/public/data/covid-19/covid_county_population_usafacts.csv"

readList <- list("usafCase"="./RInputFiles/Coronavirus/covid_confirmed_usafacts_downloaded_20220414.csv", 
                 "usafDeath"="./RInputFiles/Coronavirus/covid_deaths_usafacts_downloaded_20220414.csv"
                 )
compareList <- list("usafCase"=readFromRDS("cty_newdata_20220308")$dfRaw$usafCase, 
                    "usafDeath"=readFromRDS("cty_newdata_20220308")$dfRaw$usafDeath
                    )

# Use existing clusters
cty_newdata_20220414 <- readRunUSAFacts(maxDate="2022-04-12", 
                                        downloadTo=lapply(readList, 
                                                          FUN=function(x) if(file.exists(x)) NA else x
                                                          ),
                                        readFrom=readList, 
                                        compareFile=compareList, 
                                        writeLog="./RInputFiles/Coronavirus/USAF_NewData_20220414_chk_v005.log", 
                                        ovrwriteLog=TRUE,
                                        useClusters=readFromRDS("cty_newdata_20210813")$useClusters,
                                        skipAssessmentPlots=FALSE,
                                        brewPalette="Paired"
                                        )

# Plot all counties based on closest cluster
sparseCountyClusterMap(cty_newdata_20220414$useClusters, 
                       caption="Includes only counties with 25k+ population",
                       brewPalette="viridis"
                       )

# Save the check file
saveToRDS(cty_newdata_20220414, ovrWriteError=FALSE)

```

A function is included for reading and fixing vaccines data, as well as running correlations to the burden data:  
```{r fig.height=9, fig.width=9}

processCountyVaccines <- function(loc,
                                  ctyList,
                                  url="https://data.cdc.gov/api/views/8xkx-amqh/rows.csv?accessType=DOWNLOAD", 
                                  colsRepair=c("popgte65"), 
                                  ...
                                  ) {
    
    # FUNCTION ARGUMENTS:
    # loc: the location of the downloaded vaccines data
    # ctyList: processed list file of county-level burden data
    # url: the location for obtaining the vaccines data
    # colsRepair: columns in the raw vaccines data that require repairs to the population data
    # ...: arguments passed to corrVaxBurden()
    
    vaxRaw <- downloadCountyVaccines(loc=loc, url=url)
    vaxFix <- repairVaxPopulation(vaxRaw, colsRepair=colsRepair)
    corrList <- corrVaxBurden(lstCD=ctyList, dfVax=vaxRaw, ...)
    
    # Return the key items
    list(vaxRaw=vaxRaw, vaxFix=vaxFix, corrList=corrList)
    
}

cty_vaxdata_20220415 <- processCountyVaccines(loc="./RInputFiles/Coronavirus/county_vaccine_20220415.csv", 
                                              ctyList=cty_newdata_20220414, 
                                              minDateCD=c("2021-11-01", "2021-09-01"),
                                              maxDateCD="2022-03-31"
                                              )

```
  
Similarities between summed county-level data and state-level data are explored:  
```{r, fig.height=9, fig.width=9}

# Data for score similarity process
tempStateCompareList_v2 <- compareStateSummedCounty(dfState=readFromRDS("cdc_daily_220416")$dfPerCapita, 
                                                    dfCounty=cty_newdata_20220414$dfPerCapita, 
                                                    inclStates=c(state.abb, "DC"), 
                                                    dateThru="2022-04-10", 
                                                    makePlot=FALSE,
                                                    returnData=TRUE
                                                    )
scoreSimilarity(tempStateCompareList_v2, minDate="2020-02-15", maxDate="2022-04-10", makeFacet=FALSE)

# Example states with meaningful disconnects on 1+ metrics
compareStateSummedCounty(dfState=readFromRDS("cdc_daily_220416")$dfPerCapita, 
                         dfCounty=cty_newdata_20220414$dfPerCapita, 
                         inclStates=c("GA", "FL", "NE", "OK", "KY", "ME", "VT", "WY", "TN", "RI", "MO", "MA", "KS"), 
                         dateThru="2022-04-10", 
                         makePlot=TRUE,
                         returnData=FALSE
                         )

```
  
An integrated vaccines dataset is created, along with similarity scores:  
```{r, fig.height=9, fig.width=9}

allState_20220415 <- integrateStateVaccine(cty_vaxdata_20220415$vaxFix, 
                                           statePerCap=readFromRDS("cdc_daily_220416")$dfPerCapita
                                           )
allState_20220415

vaxDiff_20220415 <- scoreVaxSimilarity(allState_20220415, 
                                       minDate="2021-04-01", 
                                       maxDate="2022-03-31", 
                                       returnBaseData=TRUE
                                       )

```
  
Plots of the larger differences are included:  
```{r, fig.height=9, fig.width=9}

stateAgeVaxEvolution(allState_20220415, 
                     keyState=c("MA", "HI", "TX", "VA", "VT", "GA", "CO", "WV"), 
                     createPlot = TRUE
                     )

scoreVaxSimilarity(allState_20220415, minDate="2022-01-01", maxDate="2022-03-31")

stateAgeVaxEvolution(allState_20220415, keyState=c(state.abb, "DC"), createPlot = FALSE) %>% 
    filter(!complete.cases(.), date >= "2021-01-01") %>% 
    group_by(state, ym=customYYYYMM(date)) %>% 
    summarize(n=n()) %>% 
    pivot_wider(ym, names_from="state", values_from="n") %>% 
    arrange(desc(ym))

```
  
* HI and MA have never reported county-level data
* CA stopped reporting county-level data as of 2022-03
* TX and VA have around a week of missing county-level data in 2022-03
  
Function integrateStateVaccine() is updated to better manage sporadic NA values such as in TX and VA:  
```{r, fig.height=9, fig.width=9}

integrateStateVaccine <- function(vaxCounty, 
                                  statePerCap,
                                  keyStates=c(state.abb, "DC"),
                                  joinType=dplyr::right_join,
                                  treatNAZero=TRUE
                                  ) {
    
    # FUNCTION ARGUMENTS:
    # vaxCounty: processed county-level vaccines data
    # statePerCap: per-capita state level data frame
    # keyStates: states to be included
    # joinType: join to be made (statePerCap is 'left' and summed vaxCounty is 'right')
    # treatNAZero: boolean, should NA values in vaccines be treated as 0 rather than throwing an aggregate NA?
    
    # Create the aggregation function
    if(isTRUE(treatNAZero)) aggFunc <- specNA(sum) else aggFunc <- sum
    
    # Roll county-level data to state
    dfTemp <- vaxCounty %>%
        filter(state %in% all_of(keyStates), FIPS != "UNK") %>%
        group_by(date, state) %>%
        summarize(ctypoppct=aggFunc(vxcpoppct*pop)/sum(pop), 
                  ctygte18pct=aggFunc(vxcgte18pct*popgte18)/sum(popgte18),
                  ctygte65pct=aggFunc(vxcgte65pct*popgte65)/sum(popgte65),
                  across(starts_with("pop"), sum, na.rm=TRUE), 
                  .groups="drop"
        )
    
    # Integrate and return the data
    statePerCap %>%
        select(state, date, vxcpoppct, vxcgte18pct, vxcgte65pct) %>%
        filter(state %in% all_of(keyStates)) %>%
        joinType(dfTemp, by=c("state", "date"))
    
}

# Check that data are the same
all.equal(allState_20220415, 
          integrateStateVaccine(cty_vaxdata_20220415$vaxFix, 
                                statePerCap=readFromRDS("cdc_daily_220416")$dfPerCapita, 
                                treatNAZero=FALSE
                                )
          )

# Check differences in updated data
allState_20220415_v2 <- integrateStateVaccine(cty_vaxdata_20220415$vaxFix, 
                                              statePerCap=readFromRDS("cdc_daily_220416")$dfPerCapita, 
                                              treatNAZero=TRUE
                                              )

# Confirm equality where not NA in original data
all.equal(allState_20220415[complete.cases(allState_20220415), ], 
          allState_20220415_v2[complete.cases(allState_20220415), ]
          )

# Display updated records
allState_20220415_v2[complete.cases(allState_20220415_v2) & !complete.cases(allState_20220415), ] %>%
    mutate(ym=customYYYYMM(date)) %>%
    filter(ym >= "2021-01-01") %>%
    group_by(state, ym) %>%
    summarize(across(where(is.numeric), mean), n=n(), .groups="drop")

scoreVaxSimilarity(allState_20220415_v2, minDate="2022-01-01", maxDate="2022-03-31")

```

County-level burden process mapping is included:  
```{r fig.height=9, fig.width=9}

dfRoll20220414 <- createBurdenCountyDate(cty_newdata_20220414, 
                                         maxDate="2022-03-31", 
                                         rollBy=months(c(0, -3, -6, -9)), 
                                         dateSpan=91
                                         )
dfRoll20220414

makeBurdenDatePlot(dfRoll20220414, keyVar="cpm91", timeLabel="3-month", varCeiling=100000, varDivBy=1000)
makeBurdenDatePlot(dfRoll20220414, keyVar="dpm91", timeLabel="3-month", varCeiling=1500)

```
  
Post-processing steps are consolidated to a function, so that the process includes:  
  
1. readRunUSAFacts() and spareCountyClusterMap()  
2. processCountyVaccines()  
3. postProcessCountyData()  
4. Individual functions as needed  
  
The postProcessCountyData() includes:  
```{r fig.height=9, fig.width=9}

# Updated to include date range
scoreVaxSimilarity <- function(df, 
                               keyStates=c(state.abb, "DC"), 
                               minDate=NULL, 
                               maxDate=NULL, 
                               returnBaseData=FALSE
                               ) {
    
    # FUNCTION ARGUMENTS:
    # df: a processed file from integrateStateVaccine()
    # keyStates: states to include
    # minDate: earliest date to use for scoring (NULL means use all)
    # maxDate: latest date to use for scoring (NULL means use all)
    # returnBaseData: boolean, should dfBase be returned?
    
    # Set minDate and maxDate if NULL
    if(is.null(minDate)) minDate <- min(df$date, na.rm=TRUE)
    if(is.null(maxDate)) maxDate <- max(df$date, na.rm=TRUE)
    
    dfBase <- stateAgeVaxEvolution(df, keyState=keyStates, createPlot = FALSE) %>%
        mutate(value=ifelse(is.na(value), 0, value), src=ifelse(src=="State", "cdcState", "ctySum")) %>%
        pivotData(c("state", "date", "age"), nameVar="src", toLonger=FALSE) %>%
        filter(date >= minDate, date <= maxDate) %>%
        mutate(ym=customYYYYMM(date)) %>%
        group_by(state, ym, age) %>%
        summarize(n=n(), 
                  rmse=sqrt(mean((cdcState-ctySum)**2)), 
                  cdcState=mean(cdcState), 
                  ctySum=mean(ctySum), 
                  .groups="drop"
        )
    p1 <- dfBase %>%
        group_by(state, age) %>% 
        summarize(rmse=mean(rmse), .groups="drop") %>% 
        ggplot(aes(x=fct_reorder(state, rmse), y=rmse)) + 
        geom_col(fill="lightblue") + 
        coord_flip() + 
        facet_wrap(~age) + 
        labs(x=NULL, 
             y="RMSE (Vaccinated by State/Age difference by source)", 
             title="Difference in vaccinated by state data by source", 
             subtitle=paste0("Date range: ", minDate, " to ", maxDate)
        )
    print(p1)
    
    if(isTRUE(returnBaseData)) return(dfBase)
    
}

# Updated to handle lst passed as a perCapita file
makeBurdenSummary <- function(lst, 
                              groupVar=c("countyFIPS", "state"), 
                              numVarFinal=c("tdpm", "tcpm"), 
                              numVarSum=c("dpm", "cpm"), 
                              keyDate=NULL,
                              dateRange=28
                              ) {
    
    # FUNCTION ARGUMENTS
    # lst: list of processed county burden data (or extracted dfPerCapita file)
    # groupVar: grouping variables for the final dataset
    # numVarFinal: numeric variables to pull data from the key date
    # numVarSum: numeric variables to sum from the key date interval
    # keyDate: the key date for the summaries (NULL means use maximum in data)
    # dateRange: number of days to include in the numeric interval summaries
    
    # Extract perCapita data if passed as a list
    if("list" %in% class(lst)) lst <- lst[["dfPerCapita"]]
    
    # Find keyDate if not provided, convert to date if not already
    if(is.null(keyDate)) keyDate <- lst %>% pull(date) %>% max()
    if(!("Date" %in% class(keyDate))) keyDate <- as.Date(keyDate)
    
    # Create summary
    df <- lst %>% 
        group_by_at(all_of(groupVar)) %>%
        summarize(asofDate=keyDate, 
                  across(all_of(numVarFinal), .fns=~sum(ifelse(date==keyDate, .x, 0))),
                  across(all_of(numVarSum), 
                         .fns=~sum(ifelse(date>keyDate-dateRange & date<=keyDate, .x, 0)), 
                         .names=paste0("{.col}", as.character(dateRange))
                  ),
                  .groups="drop"
        )
    
    # Return the data frame
    df
    
}

postProcessCountyData <- function(lstCtyBurden,
                                  lstCtyVax,
                                  lstState, 
                                  maxDate=NULL, 
                                  minDateBurden="2020-02-15", 
                                  minDateVax="2021-04-01"
                                  ) {

    # FUNCTION ARGUMENTS:
    # lstCtyBurden: list of processed county-level burden data (or a dfPerCapita file from this list)
    # lstCtyVax: list of processed county-level vaccines data (or a vaxFix file from this list)
    # lstState: list of processed state-level burden data (or a dfPerCapita file from this list)
    # maxDate: maximum date to use for plotting (NULL means latest date in both lstCty and lstState)
    # minDateBurden: earliest date for scoring burden similarity across files
    # minDateVax: earliest date for scoring vaccine similarity across files
    
    # Extract the relevant perCapita and vaxFix data if needed
    if("list" %in% class(lstCtyBurden)) lstCtyBurden <- lstCtyBurden[["dfPerCapita"]]
    if("list" %in% class(lstState)) lstState <- lstState[["dfPerCapita"]]
    if("list" %in% class(lstCtyVax)) lstCtyVax <- lstCtyVax[["vaxFix"]]
    
    # Get maxDate if not provided
    if(is.null(maxDate)) maxDate <- min(max(lstCtyBurden$date, na.rm=TRUE), max(lstState$date, na.rm=TRUE))
    cat("\nParameter maxDate is:", as.character(maxDate), "\n\n")
    
    # Data for score similarity process
    dfCompare <- compareStateSummedCounty(dfState=lstState, 
                                          dfCounty=lstCtyBurden, 
                                          inclStates=c(state.abb, "DC"), 
                                          dateThru=maxDate, 
                                          makePlot=FALSE,
                                          returnData=TRUE
                                          )
    scoreSimilarity(dfCompare, minDate=minDateBurden, maxDate=maxDate, makeFacet=FALSE)

    # Check differences in data sources
    dfAllState <- integrateStateVaccine(lstCtyVax, statePerCap=lstState, treatNAZero=TRUE)
    vaxDiff <- scoreVaxSimilarity(dfAllState, minDate=minDateVax, maxDate=maxDate, returnBaseData=TRUE)

    # Create county-level burden data by quarters
    dfRoll91 <- createBurdenCountyDate(lstCtyBurden, 
                                       maxDate=maxDate, 
                                       rollBy=months(c(0, -3, -6, -9)), 
                                       dateSpan=91
                                       )
    makeBurdenDatePlot(dfRoll91, keyVar="cpm91", timeLabel="3-month", varCeiling=100000, varDivBy=1000) %>% print()
    makeBurdenDatePlot(dfRoll91, keyVar="dpm91", timeLabel="3-month", varCeiling=1500) %>% print()

    # Return the key elements
    list(dfCompare=dfCompare, dfAllState=dfAllState, vaxDiff=vaxDiff, dfRoll91=dfRoll91)
    
}

cty_postdata_20220414 <- postProcessCountyData(lstCtyBurden=cty_newdata_20220414$dfPerCapita, 
                                               lstCtyVax=cty_vaxdata_20220415$vaxFix, 
                                               lstState=readFromRDS("cdc_daily_220416")$dfPerCapita
                                               )

```

And stand-alone functions include:  
```{r fig.height=9, fig.width=9}

# 1. Plot states with meaningful disconnects on 1+ metrics
compareStateSummedCounty(dfState=readFromRDS("cdc_daily_220416")$dfPerCapita,
                         dfCounty=cty_newdata_20220414$dfPerCapita,
                         inclStates=c("GA", "FL", "NE", "OK", "KY", "ME", "VT", "WY", "TN", "RI", "MO", "MA", "KS"),
                         dateThru="2022-04-10",
                         makePlot=TRUE,
                         returnData=FALSE
                         )

# 2. Plot differences in vaccines data if needed
stateAgeVaxEvolution(cty_postdata_20220414$dfAllState,
                     keyState=c("MA", "HI", "TX", "VA", "VT", "GA", "CO", "WV"),
                     createPlot = TRUE
                     )

# 3. Check vaccine similarity scoring on a different time period
scoreVaxSimilarity(cty_postdata_20220414$dfAllState, minDate="2022-01-01", maxDate="2022-03-31")

# 4. Check for states with missing data (after adjustments, should only be HI which does not report by county)
stateAgeVaxEvolution(cty_postdata_20220414$dfAllState, keyState=c(state.abb, "DC"), createPlot = FALSE) %>%
    filter(!complete.cases(.), date >= "2021-01-01") %>%
    group_by(state, ym=customYYYYMM(date), .groups="drop") %>%
    summarize(n=n()) %>%
    pivot_wider(ym, names_from="state", values_from="n") %>%
    arrange(desc(ym))

# 5. Additional rolling data as needed
dfRoll_28 <- createBurdenCountyDate(cty_newdata_20220414,
                                    maxDate="2022-04-10",
                                    rollBy=months(c(0, -1, -2, -3)),
                                    dateSpan=28
                                    )
makeBurdenDatePlot(dfRoll_28, keyVar="cpm28", timeLabel="1-month", varCeiling=50000, varDivBy=1000)
makeBurdenDatePlot(dfRoll_28, keyVar="dpm28", timeLabel="1-month", varCeiling=500)

```
  
Function compareStateSummedCounty() is updated to accept a processed frame:  
```{r fig.height=9, fig.width=9}

pivotStateBurdenData <- function(df, 
                                 inclStates, 
                                 varKeep=c("date", "state", "tot_cases", "new_cases", "tot_deaths", "new_deaths"),
                                 varRename=c("tot_cases"="cases", "tot_deaths"="deaths"),
                                 dateThru=NULL
                                 ) {
    
    # FUNCTION ARGUMENTS:
    # df: a state-level burden data frame
    # inclStates: states to be included
    # varKeep: variables to be kept from state burden frame
    # varRename: variables to be renamed
    # dateThru: maximum date for the analysis (NULL means use max(date) from df)
    
    # Create and return pivoted state-level data
    df %>%
        colSelector(vecSelect=varKeep) %>%
        colRenamer(vecRename=varRename) %>%
        filter(state %in% all_of(inclStates), 
               date <= if(is.null(dateThru)) max(date) else as.Date(dateThru)
               ) %>%
        pivot_longer(-c(date, state)) %>%
        mutate(value=ifelse(is.na(value), 0, value)) %>%
        arrange(date, state, name) %>%
        group_by(state, name) %>%
        mutate(value7=zoo::rollmean(value, k=7, fill=NA, align="center"), src="state") %>%
        ungroup()
    
}

createSummedCountyBurdenData <- function(df, 
                                         inclStates, 
                                         varKeep=c("state", "countyFIPS", "date", 
                                                   "cases", "new_cases", "deaths", "new_deaths"
                                                   ),
                                         varRename=c(),
                                         dateThru=NULL
                                 ) {
    
    # FUNCTION ARGUMENTS:
    # df: a state-level burden data frame
    # inclStates: states to be included
    # varKeep: variables to be kept from state burden frame
    # varRename: variables to be renamed
    # dateThru: maximum date for the analysis (NULL means use max(date) from df)
    
    # Create and return summed and pivoted county-level data
    df %>%
        filter(state %in% all_of(inclStates), 
               date <= if(is.null(dateThru)) max(date) else as.Date(dateThru)
               ) %>%
        colSelector(vecSelect=varKeep) %>%
        colRenamer(vecRename=varRename) %>%
        pivot_longer(-c(state, countyFIPS, date)) %>%
        arrange(state, countyFIPS, date) %>%
        group_by(state, countyFIPS, name) %>%
        mutate(value7=zoo::rollmean(value, k=7, fill=NA, align="center")) %>%
        ungroup() %>%
        filter(state %in% all_of(inclStates)) %>%
        group_by(state, date, name) %>%
        summarize(across(c(value, value7), .fns=sum), .groups="drop") %>%
        filter(!is.na(value7)) %>%
        mutate(src="county")
    
}

compareStateSummedCounty <- function(dfState=NULL, 
                                     dfCounty=NULL,
                                     lstAll=NULL,
                                     aggData=FALSE,
                                     inclStates=if(isTRUE(aggData)) c(state.abb, "DC") else NULL, 
                                     dateThru=NULL, 
                                     makePlot=TRUE, 
                                     createData=TRUE,
                                     returnData=FALSE
                                     ) {
    
    # FUNCTION ARGUMENTS:
    # dfState: processed state-level metrics
    # dfCounty: processed county-level metrics
    # lstAll: list containing processed dfState and dfCounty
    # aggData: boolean, should data be aggregated (FALSE means one plot series per state)
    # inclStates: character vector of states to include
    # dateThru: latest date for analyzsis (NULL means use all data)
    # makePlot: boolean, should plots be created for each state?
    # createData: boolean, does dfAll need to be built from dfState and dfCounty? FALSE means use dfAll
    # returnData: boolean, should a list of processed dfState and processed dfCounty be returned?
    
    # Check that data passed matches parameters
    if(isTRUE(createData)) {
        if(is.null(dfState) | is.null(dfCounty)) stop("\nNeed to pass dfState and dfCounty when createData=TRUE\n")
        if(!is.null(lstAll)) cat("\nlstAll is ignored, to be built from dfState and dfCounty when createData=TRUE\n")
    }
    if(!isTRUE(createData)) {
        if(is.null(lstAll)) stop("\nNeed to pass lstAll when createData=FALSE\n")
        if(!is.null(dfState)) cat("\ndfState ignored; using lstAll due to createData=FALSE\n")
        if(!is.null(dfCounty)) cat("\ndfCounty ignored; using lstAll due to createData=FALSE\n")
    }
    
    # Check that at least one state has been passed
    if(is.null(inclStates) | length(inclStates)==0) {
        cat("\nNo states passed to compareStateSummedCounty, returning without running function\n")
        return()
    }
    
    # Create or extract data as directed by parameter createData
    if(isTRUE(createData)) {
        dfState <- pivotStateBurdenData(dfState, inclStates=inclStates, dateThru=dateThru)
        dfCounty <- createSummedCountyBurdenData(dfCounty, inclState=inclStates, dateThru=dateThru)
    } else {
        dfState <- lstAll[["dfState"]]
        dfCounty <- lstAll[["dfCounty"]]
    }
    
    # If data are to be aggregated, perform the aggregation
    if(isTRUE(aggData)) {
        tempAgg <- function(df) {
            df %>% 
                group_by(date, name, src) %>% 
                summarize(value=specNA(sum)(value, na.rm=TRUE), 
                          value7=specNA(sum)(value7, na.rm=TRUE), 
                          .groups="drop"
                          ) %>% 
                mutate(state="Aggregated")
        }
        dfState <- tempAgg(dfState)
        dfCounty <- tempAgg(dfCounty)
        inclStates <- "Aggregated"
    }
    
    if(isTRUE(makePlot)) {
        
        for(thisState in all_of(inclStates)) {
            
            p1 <- dfCounty %>%
                filter(state %in% all_of(thisState)) %>%
                bind_rows(filter(dfState, state %in% all_of(thisState))) %>%
                ggplot(aes(x=date, y=value7)) + 
                geom_line(aes(group=src, color=src)) + 
                facet_wrap(~name, scales="free_y") + 
                labs(x=NULL, 
                     y="Rolling 7-day mean", 
                     title="Summed county burden by metric (7-day mean)", 
                     subtitle=paste0(thisState, " counties")
                ) + 
                scale_color_discrete("Source")
            print(p1)
            
        }
    }
    
    if(returnData) list(dfState=dfState, dfCounty=dfCounty)
    
}

# Check that results are the same when creating the full frame (default)
chk1 <- compareStateSummedCounty(dfState=readFromRDS("cdc_daily_220416")$dfPerCapita, 
                                 dfCounty=cty_newdata_20220414$dfPerCapita, 
                                 inclStates=c(state.abb, "DC"), 
                                 dateThru="2022-04-11", 
                                 makePlot=FALSE,
                                 returnData=TRUE
                                 )
identical(chk1, cty_postdata_20220414$dfCompare)

# Check that results are the same when using the existing frame
chk2 <- compareStateSummedCounty(lstAll=cty_postdata_20220414$dfCompare,
                                 inclStates=c(state.abb, "DC"), 
                                 dateThru="2022-04-11", 
                                 createData=FALSE,
                                 makePlot=FALSE,
                                 returnData=TRUE
                                 )
identical(chk1, chk2)

# Example plotting for select states
compareStateSummedCounty(lstAll=cty_postdata_20220414$dfCompare,
                         inclStates=c("GA", "FL", "NE"),
                         dateThru="2022-04-11",
                         createData=FALSE,
                         makePlot=TRUE,
                         returnData=FALSE
                         )

```
  
An overall function for additional post-processing is written:  
```{r fig.height=9, fig.width=9}

additionalCountyPostProcess <- function(lstPost, 
                                        p1CompareStates=c(), 
                                        p1AggData=FALSE, 
                                        p2VaxStates=c(), 
                                        p3VaxTimes=c(), 
                                        p4DF=NULL,
                                        p4MaxDate=NULL, 
                                        p4RollBy=months(c(0, -1, -2, -3)),
                                        p4DateSpan=28, 
                                        p4CPMCeiling=50000, 
                                        p4DPMCeiling=500
                                        ) {
    
    # FUNCTION ARGUMENTS:
    # lstPost: list of post-processed county data
    # p1CompareStates: states that should be compared vs. summed county
    # p1AggData: boolean, should the comparison states all be aggregated to a single comparison?
    # p2VaxStates: states that should be compared for vaccine evolution
    # p3VaxTimes: character vector of form c(minDate, maxDate) for time period to score vaccine similarity
    # p4DF: data frame for creating rolling data (NULL means do not run)
    # p4MaxDate: maximum date for rolling analysis (NULL means use maximum date in p4DF minus 1 day)
    # p4RollBy: time periods to roll back for analysis
    # p4DateSpan: size of windows for rolling analysis
    # p4CPMCeiling: ceiling for plots on CPM (all values at or above this will be the same color)
    # p4DPMCeiling: ceiling for plots on DPM (all values at or above this will be the same color)
    
    # 1. Plotting state vs. summed county for key states
    if(length(p1CompareStates) > 0) {
        compareStateSummedCounty(lstAll=lstPost[["dfCompare"]], 
                                 inclStates=p1CompareStates, 
                                 createData=FALSE, 
                                 aggData=p1AggData
                                 )
    }

    # 2. Plot differences in vaccines data if needed
    if(length(p2VaxStates) > 0) 
        stateAgeVaxEvolution(lstPost[["dfAllState"]], keyState=p2VaxStates)

    # 3. Check vaccine similarity scoring on a different time period
    if(length(p3VaxTimes) > 0) {
        if(length(p3VaxTimes) != 2 | p3VaxTimes[2] < p3VaxTimes[1]) 
            cat("\np3VaxTimes should be c(minDate, maxDate), skipping this step due to bad parameter\n")
        else 
            scoreVaxSimilarity(lstPost[["dfAllState"]], minDate=p3VaxTimes[1], maxDate=p3VaxTimes[2])
    }

    # 4. Additional rolling data as needed
    if(!is.null(p4DF)) {
        if(is.null(p4MaxDate)) p4MaxDate <- max(p4DF$date) - lubridate::days(1)
        dfRoll <- createBurdenCountyDate(p4DF, maxDate=p4MaxDate, rollBy=p4RollBy, dateSpan=p4DateSpan)
        makeBurdenDatePlot(dfRoll, 
                           keyVar=paste0("cpm", p4DateSpan), 
                           timeLabel=paste0(p4DateSpan, "-day"), 
                           varCeiling=p4CPMCeiling, 
                           varDivBy=1000
                           ) %>%
            print()
        makeBurdenDatePlot(dfRoll, 
                           keyVar=paste0("dpm", p4DateSpan), 
                           timeLabel=paste0(p4DateSpan, "-day"), 
                           varCeiling=p4DPMCeiling
                           ) %>%
            print()
    }
    
}

# Nothing will run
additionalCountyPostProcess(cty_postdata_20220414)

# Just burden comparisons
additionalCountyPostProcess(cty_postdata_20220414, p1CompareStates=c("GA", "FL", "NE"))
additionalCountyPostProcess(cty_postdata_20220414, p1CompareStates=c(state.abb, "DC"), p1AggData=TRUE)

# Just vaccine comparisons
additionalCountyPostProcess(cty_postdata_20220414, p2VaxStates=c("MA", "HI", "TX"))

# Just scoring updates (and errors)
additionalCountyPostProcess(cty_postdata_20220414, p3VaxTimes=c("2022-01-01"))
additionalCountyPostProcess(cty_postdata_20220414, p3VaxTimes=c("2022-04-10", "2022-01-01"))
additionalCountyPostProcess(cty_postdata_20220414, p3VaxTimes=sort(c("2022-04-10", "2022-01-01")))

# Just new rolling data
additionalCountyPostProcess(p4DF=cty_newdata_20220414$dfPerCapita)
additionalCountyPostProcess(p4DF=cty_newdata_20220414$dfPerCapita, 
                            p4RollBy=months(c(0, -3, -6, -9)), 
                            p4DateSpan=91, 
                            p4CPMCeiling=100000, 
                            p4DPMCeiling=1000
                            )

```
  
The latest county-level burden data are downloaded:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

urlMapper[["usafCase"]] <- "https://static.usafacts.org/public/data/covid-19/covid_confirmed_usafacts.csv"
urlMapper[["usafDeath"]] <- "https://static.usafacts.org/public/data/covid-19/covid_deaths_usafacts.csv"
urlMapper[["usafPop"]] <- "https://static.usafacts.org/public/data/covid-19/covid_county_population_usafacts.csv"

readList <- list("usafCase"="./RInputFiles/Coronavirus/covid_confirmed_usafacts_downloaded_20220507.csv", 
                 "usafDeath"="./RInputFiles/Coronavirus/covid_deaths_usafacts_downloaded_20220507.csv"
                 )
compareList <- list("usafCase"=readFromRDS("cty_newdata_20220414")$dfRaw$usafCase, 
                    "usafDeath"=readFromRDS("cty_newdata_20220414")$dfRaw$usafDeath
                    )

# Use existing clusters
cty_newdata_20220507 <- readRunUSAFacts(maxDate="2022-05-05", 
                                        downloadTo=lapply(readList, 
                                                          FUN=function(x) if(file.exists(x)) NA else x
                                                          ),
                                        readFrom=readList, 
                                        compareFile=compareList, 
                                        writeLog="./RInputFiles/Coronavirus/USAF_NewData_20220414_chk_v005.log", 
                                        ovrwriteLog=TRUE,
                                        useClusters=readFromRDS("cty_newdata_20210813")$useClusters,
                                        skipAssessmentPlots=FALSE,
                                        brewPalette="Paired"
                                        )

# Plot all counties based on closest cluster
sparseCountyClusterMap(cty_newdata_20220507$useClusters, 
                       caption="Includes only counties with 25k+ population",
                       brewPalette="viridis"
                       )

# Save the refreshed file
saveToRDS(cty_newdata_20220507, ovrWriteError=FALSE)

```

Vaccines data are also updated:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

cty_vaxdata_20220508 <- processCountyVaccines(loc="./RInputFiles/Coronavirus/county_vaccine_20220508.csv", 
                                              ctyList=cty_newdata_20220507, 
                                              minDateCD=c("2022-02-01", "2022-02-01"),
                                              maxDateCD="2022-04-30"
                                              )

# Save the refreshed file
saveToRDS(cty_vaxdata_20220508, ovrWriteError=FALSE)

```

County-level data are post-processed:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

cty_postdata_20220507 <- postProcessCountyData(lstCtyBurden=cty_newdata_20220507$dfPerCapita, 
                                               lstCtyVax=cty_vaxdata_20220508$vaxFix, 
                                               lstState=readFromRDS("cdc_daily_220501")$dfPerCapita
                                               )

# Save the refreshed file
saveToRDS(cty_postdata_20220507, ovrWriteError=FALSE)

```
  
Additional post-processing steps are run:  
```{r, fig.height=9, fig.width=9}

# Step 1a: Burden comparisons for aggregated states
additionalCountyPostProcess(cty_postdata_20220507, p1CompareStates=c(state.abb, "DC"), p1AggData=TRUE)

# Step 1: Burden aggregation for key states
# Step 2: vaccine comparisons
# Step 3: Scoring updates (and errors)
# Step 4: New rolling data (28-day default with ceilings 50000 CPM, 500 DPM)
additionalCountyPostProcess(cty_postdata_20220507, 
                            p1CompareStates=c("GA", "FL", "NE"), 
                            p2VaxStates=c("MA", "HI", "TX", "VA", "VT", "GA", "CO", "SD"), 
                            p3VaxTimes=sort(c("2021-05-01", "2022-04-30")),
                            p4DF=cty_newdata_20220507$dfPerCapita
                            )

```
  
Evolution of burden and vaccines is compared for select counties:  
```{r, fig.height=9, fig.width=9}

# Sample list of counties
ctyList <- c("01089", "29510", "34027")

# Extract name and population data
tmpNamePop <- cty_newdata_20220507$countyData %>%
    filter(countyFIPS %in% ctyList) %>%
    mutate(fullName=paste0(countyName, ", ", state, " (pop: ", round(pop/1000), "k)"))

# Extract burden per-capita data
tmpBurden <- cty_newdata_20220507$dfPerCapita %>%
    filter(countyFIPS %in% ctyList)

# Extract vaccines per-capita data
tmpVax <- cty_vaxdata_20220508$vaxFix %>%
    filter(FIPS %in% ctyList)

# Create integrated database of burden and vaccines
tmpCombine <- tmpBurden %>%
    select(countyFIPS, date, cpm7, dpm7, tcpm7, tdpm7) %>%
    full_join(tmpVax %>% select(countyFIPS=FIPS, date, vxcpoppct, vxcgte18pct, vxcgte65pct), 
              by=c("countyFIPS", "date")
              ) %>%
    pivot_longer(-c(countyFIPS, date))

# Create plot from data
tmpNamePopVec <- tmpNamePop$fullName %>% purrr::set_names(tmpNamePop$countyFIPS)
tmpVars <- c("dpm7", "tdpm7", "cpm7", "tcpm7", "vxcpoppct", "vxcgte65pct")
tmpVarNames <- c("1. Death per million", "2. Death per million (cum)", 
                 "3. Case per million", "4. Case per million (cum)", 
                 "5. % Vaccinated (all)", "6. % Vaccinated (65+)"
                 ) %>%
    purrr::set_names(tmpVars)

tmpCombine %>%
    filter(name %in% all_of(tmpVars), !is.na(value)) %>%
    ggplot(aes(x=date, y=value)) + 
    geom_line(aes(color=tmpNamePopVec[countyFIPS], group=countyFIPS)) + 
    facet_wrap(~tmpVarNames[name], scales="free_y", ncol=2) + 
    labs(x=NULL, y=NULL, title="Evolution of metrics by select county") +
    scale_color_discrete("")

```
  
A function is written for the extracts:  
```{r, fig.height=9, fig.width=9}

compareBurdenVaxCounty <- function(lstBurden, 
                                   lstVax, 
                                   ctyIDs, 
                                   burdenVars=c("dpm7", "tdpm7", "cpm7", "tcpm7"), 
                                   vaxVars=c("vxcpoppct", "vxcgte65pct"), 
                                   plotVars=c(burdenVars, vaxVars),
                                   plotVarNames=c("1. Death per million", "2. Death per million (cum)", 
                                                  "3. Case per million", "4. Case per million (cum)", 
                                                  "5. % Vaccinated (all)", "6. % Vaccinated (65+)"
                                                  ), 
                                   printPlot=TRUE, 
                                   returnData=!isTRUE(printPlot)
                                   ) {

    # FUNCTION ARGUMENTS:
    # lstBurden: processed file containing county-level burden data
    # lstVax: processed file containing county-level vaccines data
    # ctyIDs: vector of county-FIPS to process OR named list of county-FIPS to amalgamate
    #         if vector, each plotted separately with county name as legend and color
    #         if named list, each element amalgamated with list name as legend and color
    # burdenVars: variables to plot from burden data
    # vaxVars: variables to plot from vaccines data
    # plotVars: variables to be plotted
    # plotVarNames: names to be associated to plotVars
    # printPlot: boolean, should plot be created and printed?
    # returnData: boolean, should data frame be returned?
    
    # Create valid list of countyFIPS for processing
    # If passed as list, convert to vector; convert all to 5-string characters
    if("list" %in% class(ctyIDs)) ctyUse <- zeroPad5(unname(unlist(ctyIDs)))
    else ctyUse <- zeroPad5(ctyIDs)
    
    # Extract name and population data
    dfNamePop <- lstBurden[["countyData"]] %>%
        filter(countyFIPS %in% ctyUse) %>%
        mutate(fullName=paste0(countyName, ", ", state, " (pop: ", round(pop/1000), "k)"))

    # Extract burden per-capita data
    dfBurden <- lstBurden[["dfPerCapita"]] %>%
        filter(countyFIPS %in% ctyUse)

    # Extract vaccines per-capita data
    dfVax <- lstVax[["vaxFix"]] %>%
        filter(FIPS %in% ctyUse)
    
    # Create integrated database of burden and vaccines
    dfCombine <- dfBurden %>%
        select(countyFIPS, date, all_of(burdenVars)) %>%
        full_join(dfVax %>% select(countyFIPS=FIPS, date, all_of(vaxVars)), 
                  by=c("countyFIPS", "date")
                  ) %>%
        pivot_longer(-c(countyFIPS, date))
    
    # If data to be amalgamated, run here
    if("list" %in% class(ctyIDs)) {
        # Create mapping frame
        mapFrame <- map_dfr(names(ctyIDs), .f=function(x) tibble::tibble(mapName=x, countyFIPS=ctyIDs[[x]]))
        # Add population data and mapped name
        dfCombine <- dfCombine %>%
            filter(!is.na(value)) %>%
            inner_join(select(dfNamePop, countyFIPS, pop), by="countyFIPS") %>%
            inner_join(mapFrame, by="countyFIPS") %>%
            group_by(mapName, date, name) %>%
            summarize(value=sum(value*pop)/sum(pop), pop=sum(pop), .groups="drop")
    }
    
    # Create vectors for mapping countyFIPS and metric abbreviations to descriptive names
    varNameVec <- plotVarNames %>% purrr::set_names(plotVars)
    
    # Create vectors for mapping countyFIPS to descriptive names (only relevant if not amalgamated)
    namePopVec <- dfNamePop$fullName %>% purrr::set_names(dfNamePop$countyFIPS)
    
    # Create and display plot (if requested)
    if(isTRUE(printPlot)) {
        p1 <- dfCombine %>%
            filter(name %in% all_of(plotVars), !is.na(value)) %>%
            ggplot(aes(x=date, y=value)) + 
            facet_wrap(~varNameVec[name], scales="free_y", ncol=2) + 
            labs(x=NULL, y=NULL, title="Evolution of metrics by select county") +
            scale_color_discrete("")
        # Add lines colored appropriately
        if("list" %in% class(ctyIDs)) p1 <- p1 + geom_line(aes(color=mapName, group=mapName))
        else p1 <- p1 + geom_line(aes(color=namePopVec[countyFIPS], group=countyFIPS))
        print(p1)
    }
    
    # Return data if requested
    if(isTRUE(returnData)) return(dfCombine)
    
}

# Run with defaults
compareBurdenVaxCounty(lstBurden=cty_newdata_20220507, lstVax=cty_vaxdata_20220508, ctyIDs=ctyList)

# Run for data only
compareBurdenVaxCounty(lstBurden=cty_newdata_20220507, lstVax=cty_vaxdata_20220508, ctyIDs=ctyList, printPlot=FALSE)

```
  
The function has been updated so that it can take an amalgamation of counties:  
```{r, fig.height=9, fig.width=9}

# Single amalgamation
compareBurdenVaxCounty(lstBurden=cty_newdata_20220507, lstVax=cty_vaxdata_20220508, ctyIDs=list("all"=ctyList))

# Select states
keyStates <- c("NY", "LA", "CA", "TX")
tmpStates <- cty_newdata_20220507$countyData %>% 
    filter(pop >= 100000, pop <= 500000, state %in% all_of(keyStates))
tmpList <- lapply(keyStates, FUN=function(x) tmpStates %>% filter(state==x) %>% pull(countyFIPS)) %>%
    purrr::set_names(paste0(keyStates, " counties 100k-500k"))
compareBurdenVaxCounty(lstBurden=cty_newdata_20220507, lstVax=cty_vaxdata_20220508, ctyIDs=tmpList, returnData=TRUE)

```
  
The function is run on subsets of counties based on most recent vaccination data:  
```{r, fig.height=9, fig.width=9}

tmpSegVax <- cty_vaxdata_20220508$vaxFix %>% 
    filter(date==max(date), pop >= 50000, pop <= 500000, !is.na(vxcgte18pct)) 
tmpSegVax %>%
    ggplot(aes(x=vxcgte18pct)) + 
    geom_histogram(fill="lightblue", bins=100) + 
    lims(x=c(0, 100)) + 
    labs(x="% Vaccinated (18+)", y=NULL, title="# counties by % vaccinated (18+)", subtitle="Population 50k-500k")
tmpSegVax <- tmpSegVax %>%
    mutate(bucket=case_when(vxcgte18pct<55 ~ "0-54", 
                            vxcgte18pct<=70 ~ "55-70", 
                            vxcgte18pct<=100 ~ "71-100", 
                            TRUE ~ "err"
                            )
           )
tmpList <- lapply(c("0-54", "55-70", "71-100"), FUN=function(x) filter(tmpSegVax, bucket==x) %>% pull(FIPS)) %>%
    purrr::set_names("3. Under 55%", "2. 55%-70%", "1. Over 70%")
compareBurdenVaxCounty(lstBurden=cty_newdata_20220507, lstVax=cty_vaxdata_20220508, ctyIDs=tmpList, returnData=TRUE)

```
  
The function is run on subsets of counties based on most recent change in deaths per capita:  
```{r, fig.height=9, fig.width=9}

tmpSegDeath <- cty_newdata_20220507$dfPerCapita %>% 
    inner_join(select(cty_newdata_20220507$countyData, countyFIPS, pop), by="countyFIPS") %>%
    filter(date %in% c(max(date), max(date)-lubridate::days(360)), 
           pop >= 50000, pop <= 500000, 
           !is.na(tdpm)
           ) %>%
    group_by(countyFIPS) %>%
    mutate(deltaDeath=max(tdpm)-min(tdpm)) %>%
    ungroup()
tmpSegDeath %>%
    filter(date==max(date)) %>%
    ggplot(aes(x=deltaDeath)) + 
    geom_histogram(fill="lightblue", bins=100) + 
    labs(x="Death per million in most recent year", 
         y=NULL, 
         title="# counties by DPM in most recent year", 
         subtitle="Population 50k-500k"
         )
tmpSegDeath <- tmpSegDeath %>%
    filter(date==max(date)) %>%
    mutate(bucket=case_when(deltaDeath<1000 ~ "0-999", 
                            deltaDeath<=2000 ~ "1000-2000", 
                            deltaDeath<=4000 ~ "2001+", 
                            TRUE ~ "err"
                            )
           )
tmpList <- lapply(c("0-999", "1000-2000", "2001+"), 
                  FUN=function(x) filter(tmpSegDeath, bucket==x) %>% pull(countyFIPS)
                  ) %>%
    purrr::set_names("3. Under 1000", "2. 1000-2000", "1. Over 2000")
compareBurdenVaxCounty(lstBurden=cty_newdata_20220507, lstVax=cty_vaxdata_20220508, ctyIDs=tmpList, returnData=TRUE)

```
  
The function is run on subsets of counties based on most recent change in cases per capita:  
```{r, fig.height=9, fig.width=9}

tmpSegCase <- cty_newdata_20220507$dfPerCapita %>% 
    inner_join(select(cty_newdata_20220507$countyData, countyFIPS, pop), by="countyFIPS") %>%
    filter(date %in% c(max(date), max(date)-lubridate::days(360)), 
           pop >= 50000, pop <= 500000, 
           !is.na(tcpm)
           ) %>%
    group_by(countyFIPS) %>%
    mutate(deltaCase=max(tcpm)-min(tcpm)) %>%
    ungroup()
tmpSegCase %>%
    filter(date==max(date)) %>%
    ggplot(aes(x=deltaCase)) + 
    geom_histogram(fill="lightblue", bins=100) + 
    labs(x="Cases per million in most recent year", 
         y=NULL, 
         title="# counties by CPM in most recent year", 
         subtitle="Population 50k-500k"
         )
tmpSegCase <- tmpSegCase %>%
    filter(date==max(date)) %>%
    mutate(bucket=case_when(deltaCase<125000 ~ "0-125k", 
                            deltaCase<=175000 ~ "125k-175k", 
                            deltaCase<=300000 ~ "175k+", 
                            TRUE ~ "err"
                            )
           )
tmpList <- lapply(c("0-125k", "125k-175k", "175k+"), 
                  FUN=function(x) filter(tmpSegCase, bucket==x) %>% pull(countyFIPS)
                  ) %>%
    purrr::set_names("3. Under 125k", "2. 125k-175k", "1. Over 175k")
compareBurdenVaxCounty(lstBurden=cty_newdata_20220507, lstVax=cty_vaxdata_20220508, ctyIDs=tmpList, returnData=TRUE)

```
  
The process is converted to functional form, allowing for custom labels:  
```{r, fig.height=9, fig.width=9}

compareBurdenVaxCounty <- function(lstBurden, 
                                   lstVax, 
                                   ctyIDs, 
                                   burdenVars=c("dpm7", "tdpm7", "cpm7", "tcpm7"), 
                                   vaxVars=c("vxcpoppct", "vxcgte65pct"), 
                                   plotVars=c(burdenVars, vaxVars),
                                   plotVarNames=c("1. Death per million", "2. Death per million (cum)", 
                                                  "3. Case per million", "4. Case per million (cum)", 
                                                  "5. % Vaccinated (all)", "6. % Vaccinated (65+)"
                                                  ), 
                                   printPlot=TRUE, 
                                   p1Title="Evolution of metrics by select county",
                                   p1SubTitle=ggplot2::waiver(),
                                   p1ScaleLabel="",
                                   returnData=!isTRUE(printPlot)
                                   ) {

    # FUNCTION ARGUMENTS:
    # lstBurden: processed file containing county-level burden data
    # lstVax: processed file containing county-level vaccines data
    # ctyIDs: vector of county-FIPS to process OR named list of county-FIPS to amalgamate
    #         if vector, each plotted separately with county name as legend and color
    #         if named list, each element amalgamated with list name as legend and color
    # burdenVars: variables to plot from burden data
    # vaxVars: variables to plot from vaccines data
    # plotVars: variables to be plotted
    # plotVarNames: names to be associated to plotVars
    # printPlot: boolean, should plot be created and printed?
    # p1Title: title to be used in plot
    # p1SubTitle: subtitle to be used in plot
    # p1ScaleLabel: label to be used for the color scale in plot
    # returnData: boolean, should data frame be returned?
    
    # Create valid list of countyFIPS for processing
    # If passed as list, convert to vector; convert all to 5-string characters
    if("list" %in% class(ctyIDs)) ctyUse <- zeroPad5(unname(unlist(ctyIDs)))
    else ctyUse <- zeroPad5(ctyIDs)
    
    # Extract name and population data
    dfNamePop <- lstBurden[["countyData"]] %>%
        filter(countyFIPS %in% ctyUse) %>%
        mutate(fullName=paste0(countyName, ", ", state, " (pop: ", round(pop/1000), "k)"))

    # Extract burden per-capita data
    dfBurden <- lstBurden[["dfPerCapita"]] %>%
        filter(countyFIPS %in% ctyUse)

    # Extract vaccines per-capita data
    dfVax <- lstVax[["vaxFix"]] %>%
        filter(FIPS %in% ctyUse)
    
    # Create integrated database of burden and vaccines
    dfCombine <- dfBurden %>%
        select(countyFIPS, date, all_of(burdenVars)) %>%
        full_join(dfVax %>% select(countyFIPS=FIPS, date, all_of(vaxVars)), 
                  by=c("countyFIPS", "date")
                  ) %>%
        pivot_longer(-c(countyFIPS, date))
    
    # If data to be amalgamated, run here
    if("list" %in% class(ctyIDs)) {
        # Create mapping frame
        mapFrame <- map_dfr(names(ctyIDs), .f=function(x) tibble::tibble(mapName=x, countyFIPS=ctyIDs[[x]]))
        # Add population data and mapped name
        dfCombine <- dfCombine %>%
            filter(!is.na(value)) %>%
            inner_join(select(dfNamePop, countyFIPS, pop), by="countyFIPS") %>%
            inner_join(mapFrame, by="countyFIPS") %>%
            group_by(mapName, date, name) %>%
            summarize(value=sum(value*pop)/sum(pop), pop=sum(pop), n=n(), .groups="drop") %>%
            group_by(mapName) %>%
            mutate(mapName2=paste0(mapName, " (n=", max(n), ")")) %>%
            ungroup()
    }
    
    # Create vectors for mapping countyFIPS and metric abbreviations to descriptive names
    varNameVec <- plotVarNames %>% purrr::set_names(plotVars)
    
    # Create vectors for mapping countyFIPS to descriptive names (only relevant if not amalgamated)
    namePopVec <- dfNamePop$fullName %>% purrr::set_names(dfNamePop$countyFIPS)
    
    # Create and display plot (if requested)
    if(isTRUE(printPlot)) {
        p1 <- dfCombine %>%
            filter(name %in% all_of(plotVars), !is.na(value)) %>%
            ggplot(aes(x=date, y=value)) + 
            facet_wrap(~varNameVec[name], scales="free_y", ncol=2) + 
            labs(x=NULL, y=NULL, title=p1Title, subtitle=p1SubTitle) +
            scale_color_discrete(p1ScaleLabel)
        # Add lines colored appropriately
        if("list" %in% class(ctyIDs)) {
            if(is.null(p1ScaleLabel) | p1ScaleLabel=="") p1 <- p1 + geom_line(aes(color=mapName, group=mapName))
            else p1 <- p1 + geom_line(aes(color=mapName2, group=mapName2))
        }
        else p1 <- p1 + geom_line(aes(color=namePopVec[countyFIPS], group=countyFIPS))
        print(p1)
    }
    
    # Return data if requested
    if(isTRUE(returnData)) return(dfCombine)
    
}

plotCountyEvolution <- function(lst,
                                lstVax,
                                cutsLabels,
                                baseVar,
                                lstFilter=list(),
                                lstExclude=list(),
                                segVar=baseVar,
                                popRange=c(0, +Inf), 
                                dateRange=c(lubridate::days(0)), 
                                p1Title="Evolution of metrics by select county",
                                p1SubTitle=ggplot2::waiver(),
                                p1ScaleLabel=""
                                ) {
    
    # FUNCTION ARGUMNETS:
    # lst: processed list file containing per-capita and county population data
    # lstVax: processed list file containing vaccines data
    # cutsLabels: named character vector of form c("label"="values-up-tp")
    # baseVar: base variable to be used for segmenting (needs to be not-NA)
    # lstFilter: named list of items to include when setting df (e.g., list("state"=state.abb[1:10]))
    # lstExclude: named list of items to exclude when setting df (e.g., list("state"=state.abb[41:50]))
    # segVar: variable used in segmentation (may be a transform of baseVar, allow for different name)
    # popRange: character vector of length 2 for minimum and maximum population to include
    # dateRange: dates to be considered for segmenting (all subtracted from max(date))
    #            if length 1, that date is used for segmenting on the key metric
    #            if length 2, change in variables between those dates is used on the key metric
    # p1Title: title to be used in plot
    # p1SubTitle: subtitle to be used in plot
    # p1ScaleLabel: label to be used for the color scale in plot
    
    # Check that dateRange is length-1 or length-2
    if(!(length(dateRange) %in% c(1, 2))) error("\nMust pass a dateRange vector of length 1 or length 2\n")
    
    # Create database including population, filter by population and relevant dates, remove NA issues
    df <- lst[["dfPerCapita"]] %>% 
        inner_join(select(lst[["countyData"]], countyFIPS, pop), by="countyFIPS") %>%
        inner_join(select(lstVax[["vaxFix"]], date, countyFIPS=FIPS, vxcpoppct, vxcgte18pct, vxcgte65pct), 
                  by=c("date", "countyFIPS")
                  ) %>%
        filter(pop >= popRange[1], 
               pop <= popRange[2], 
               date %in% (max(date)-dateRange), 
               !is.na(get(baseVar))
               ) %>%
        rowFilter(lstFilter=lstFilter, lstExclude=lstExclude)
 
    # If daterange is of length-2, calculate change in variable
    if(length(dateRange)==2) {
        if(segVar==baseVar) segVar <- "tempNew"
        df <- df %>%
            group_by(countyFIPS) %>%
            mutate(tempNew=sum(get(baseVar)*(date==max(date)))-sum(get(baseVar)*(date!=max(date)))) %>%
            ungroup() %>%
            colRenamer(vecRename=c("tempNew"=segVar))
    }

    # Histogram for key variables
    p1 <- df %>%
        filter(date==max(date)) %>%
        ggplot(aes_string(x=segVar)) + 
        geom_histogram(fill="lightblue", bins=100) + 
        labs(x=paste0("Variable: ", segVar), 
             y=NULL, 
             title=paste0("# counties by ", segVar, " bucket by time period")
             ) + 
        facet_wrap(~date)
    print(p1)
    
    # Create buckets for plotting
    df <- df %>%
        filter(date==max(date)) %>%
        mutate(bucket=c(names(cutsLabels), "999. error high")[1+findInterval(get(segVar), unname(cutsLabels))])
    
    # Create county list
    tmpList <- lapply(c(names(cutsLabels), "999. error high"), 
                      FUN=function(x) filter(df, bucket==x) %>% pull(countyFIPS)
                      ) %>%
        purrr::set_names(c(names(cutsLabels), "999. error high"))
    
    # Create plot of metrics over time
    compareBurdenVaxCounty(lstBurden=lst, 
                           lstVax=lstVax, 
                           ctyIDs=tmpList, 
                           returnData=TRUE, 
                           p1Title=p1Title, 
                           p1SubTitle=p1SubTitle, 
                           p1ScaleLabel=p1ScaleLabel
                           )
    
}

plotCountyEvolution(cty_newdata_20220507, 
                    lstVax=cty_vaxdata_20220508,
                    baseVar="tcpm",
                    lstExclude=list("state"=c("CO", "GA", "HI", "NM", "OH", "SD", "TX", "UT", "VA", "WV")),
                    popRange=c(100000, 250000), 
                    cutsLabels=c("1. Under 200k"=200000, "2. 200k-300k"=300000, "3. Over 300k"=500000)
                    )

plotCountyEvolution(cty_newdata_20220507, 
                    lstVax=cty_vaxdata_20220508,
                    baseVar="tdpm",
                    lstExclude=list("state"=c("CO", "GA", "HI", "NM", "OH", "SD", "TX", "UT", "VA", "WV")),
                    popRange=c(100000, 250000), 
                    cutsLabels=c("1. Under 2000"=2000, "2. 2000-4000"=4000, "3. Over 4000"=10000)
                    )

plotCountyEvolution(cty_newdata_20220507, 
                    lstVax=cty_vaxdata_20220508,
                    baseVar="vxcgte65pct",
                    lstExclude=list("state"=c("CO", "GA", "HI", "NM", "OH", "SD", "TX", "UT", "VA", "WV")),
                    popRange=c(100000, 250000), 
                    cutsLabels=c("1. Under 80%"=80, "2. 80%-90%"=90, "3. Over 90%"=100)
                    )

plotCountyEvolution(cty_newdata_20220507, 
                    lstVax=cty_vaxdata_20220508,
                    baseVar="tdpm",
                    segVar="d_tdpm_360",
                    lstExclude=list("state"=c("CO", "GA", "HI", "NM", "OH", "SD", "TX", "UT", "VA", "WV")),
                    popRange=c(100000, 250000), 
                    cutsLabels=c("1. Under 1000"=1000, "2. 1000-2000"=2000, "3. Over 2000"=4000), 
                    dateRange=c(lubridate::days(0), lubridate::days(360)), 
                    p1ScaleLabel="Segmented By: DPM\n(most recent 360 days)", 
                    p1SubTitle=paste0("US counties of 100k-250k (excluding states with spiky data)\n")
                    )

# Pull states from West South Central
wsc <- state.abb[state.division %in% c("West South Central", "East South Central")]

plotCountyEvolution(cty_newdata_20220507, 
                    lstVax=cty_vaxdata_20220508,
                    baseVar="tdpm",
                    segVar="d_tdpm_360",
                    lstFilter = list("state"=wsc),
                    lstExclude=list("state"=c("CO", "GA", "HI", "NM", "OH", "SD", "TX", "UT", "VA", "WV")),
                    popRange=c(100000, 250000), 
                    cutsLabels=c("1. Under 1000"=1000, "2. 1000-2000"=2000, "3. Over 2000"=4000), 
                    dateRange=c(lubridate::days(0), lubridate::days(360)), 
                    p1ScaleLabel="Segmented By: DPM\n(most recent 360 days)", 
                    p1SubTitle=paste0("South Central counties of 100k-250k (excluding states with spiky data)\n")
                    )

plotCountyEvolution(cty_newdata_20220507, 
                    lstVax=cty_vaxdata_20220508,
                    baseVar="vxcgte65pct",
                    lstFilter = list("state"=wsc),
                    lstExclude=list("state"=c("CO", "GA", "HI", "NM", "OH", "SD", "TX", "UT", "VA", "WV")),
                    popRange=c(100000, 250000), 
                    cutsLabels=c("1. Under 80%"=80, "2. 80%-90%"=90, "3. Over 90%"=100),
                    p1ScaleLabel="Segmented By: %vax\n(65+ population)", 
                    p1SubTitle=paste0("South Central counties of 100k-250k (excluding states with spiky data)\n")
                    )

```
  
Further exploration is made of growth rates in key metrics:  
```{r, fig.height=9, fig.width=9}

# Create integrated data, using only select time periods
dfVaxBurden_20220507 <- cty_newdata_20220507$dfPerCapita %>% 
    inner_join(cty_vaxdata_20220508$vaxFix, by=c("countyFIPS"="FIPS", "state", "date")) %>% 
    filter(date %in% c(max(date)-lubridate::days(c(4, 369))))

# Summarize and create plot
dfPlotVaxBurden <- dfVaxBurden_20220507 %>% 
    filter(pop >= 25000) %>%
    mutate(minday=ifelse(date==min(date), 1, 0), maxday=ifelse(date==max(date), 1, 0)) %>%
    group_by(countyFIPS) %>% 
    filter(n()==2) %>%
    summarize(across(c(tcpm7, tdpm7, cpm7, dpm7), 
                     .fns=function(x) sum(x*maxday)/sum(x*minday)-1, 
                     .names="g_{.col}"
                     ), 
              pop=median(pop), 
              mu_vxcpoppct=mean(vxcpoppct)
              ) %>% 
    pivot_longer(-c(countyFIPS, pop, mu_vxcpoppct)) %>%
    filter(value >= -1, 
           value <= 10
           ) 

dfPlotVaxBurden %>% 
    ggplot(aes(x=mu_vxcpoppct, y=value)) + 
    geom_point(aes(size=pop), alpha=0.25) + 
    geom_smooth(aes(weight=pop), method="lm") + 
    geom_hline(yintercept=c(-1, 0, 1), lty=2, color="red") +
    labs(y="Growth rate from 1 year ago", 
         x="% population vaccinated", 
         title="Association of 1-year change in burden with vaccination", 
         subtitle="Linear model is population weighted for counties >25k population with growth between -1 and 10"
         ) +
    facet_wrap(~name)

dfPlotVaxBurden %>%
    lm(value ~ mu_vxcpoppct:name + name + 0, data=., weights=pop) %>%
    summary()

```

The process is converted to functional form:  
```{r, fig.height=9, fig.width=9}

# 1. Create integrated data
integrateCountyBurdenVax <- function(lstBurden, lstVax, keyDates=NULL) {
    
    # FUNCTION ARGUMENTS:
    # lstBurden: processed county-level burden list containing dfPerCapita
    # lstVax: processed county-level vaccines list containing vaxFix
    # keyDates: character vector of integers for days to subtract from max(date) and include
    #           NULL means include all
    
    # Convert keyDates to useDates appropriately
    useDates <- sort(intersect(unique(lstBurden[["dfPerCapita"]]$date), unique(lstVax[["vaxFix"]]$date)))
    useDates <- as.Date(useDates, origin="1970-01-01")
    if(!is.null(keyDates)) useDates <- useDates[useDates %in% (max(useDates)-lubridate::days(keyDates))]
    
    # Create integrated burden data, using requested time periods
    lstBurden[["dfPerCapita"]] %>% 
        filter(date %in% useDates) %>%
        inner_join(lstVax[["vaxFix"]], by=c("countyFIPS"="FIPS", "state", "date"))
    
}


# 2. Create integrated county plot data
makeIntegratedCountyPlotData <- function(df, 
                                         burdenVars=c("tcpm7", "tdpm7", "cpm7", "dpm7"), 
                                         vaxVars=c("vxcpoppct", "vxcgte18pct", "vxcgte65pct"), 
                                         makeBurdenGrowth=TRUE,
                                         fnBurden=mean,
                                         makeVaxGrowth=FALSE,
                                         fnVax=mean
                                         ) {

    # FUNCTION ARGUMENTS:
    # df: processed data frame with integrated burden and vaccines
    # burdenVars: burden variables to be summarized
    # vaxVars: vaccine variables to be summarized
    # makeBurdenGrowth: boolean, should burden be calculated as latest minus earliest?
    # fnBurden: function for summarizing burden fields (used only if makeBurdenGrowth is FALSE)
    # makeVaxGrowth: boolean, should vaccines be calculated as latest minus earliest?
    # fnVax: function for summarizing vaccine fields (used only if makeBurdenGrowth is FALSE)
    
    # Create the prefixes for the burden and vaccines variables
    burdenPrefix <- ifelse(isTRUE(makeBurdenGrowth), "g", deparse(substitute(fnBurden)))
    vaxPrefix <- ifelse(isTRUE(makeVaxGrowth), "g", deparse(substitute(fnVax)))
    
    # Create delta variables if requested
    df %>% 
        mutate(minday=ifelse(date==min(date), 1, 0), maxday=ifelse(date==max(date), 1, 0)) %>%
        group_by(countyFIPS) %>% 
        summarize(across(all_of(burdenVars), 
                         .fns=if(isTRUE(makeBurdenGrowth)) function(x) sum(x*maxday)/sum(x*minday)-1 else fnBurden, 
                         .names=paste0(burdenPrefix, "_{.col}")
                         ), 
                  pop=median(pop), 
                  across(all_of(vaxVars), 
                         .fns=if(isTRUE(makeVaxGrowth)) function(x) sum(x*maxday)/sum(x*minday)-1 else fnVax, 
                         .names=paste0(vaxPrefix, "_{.col}")
                         ),
                  hasMaxMin=(sum(maxday)==1 & sum(minday)==1)
                  ) %>% 
        pivot_longer(-c(countyFIPS))
    
}

#3. Create plots
plotIntegratedCounty <- function(df, 
                                 demVars=c("countyFIPS", "pop", "hasMaxMin"), 
                                 vaxVar="mean_vxcpoppct", 
                                 burdenVars=c("g_tcpm7", "g_tdpm7", "g_cpm7", "g_dpm7"), 
                                 checkMaxMin=TRUE, 
                                 popRange=c(1, +Inf), 
                                 valueRange=c(-1, 10),
                                 xLabel=NULL,
                                 yLabel="Growth rate from 1 year ago",
                                 plotTitle="Association of 1-year change in burden with vaccination",
                                 plotSubtitle=NULL,
                                 returnData=TRUE
                                 ) {

    # FUNCTION ARGUMENTS:
    # df: data frame from makeIntegratedCountyPlotData()
    # demVars: variables for demographics
    # vaxVar: x-axis variable (vaccine)
    # burdenVars: variables on the facetted y-axes (burden)
    # checkMaxMin: boolean, keep only counties with data on the max and min dates (growth meaningless otherwise)
    # popRange: acceptable population range for data
    # valueRange: range of values to keep for plotting metrics
    # xLabel: label for the x-axis (NULL means create from parameters)
    # yLabel: label for the y-axis
    # plotTitle: title for the plot
    # plotSubtitle: subtitle for the plot
    # returnData: boolean, should data (df) be returned?
    
    # Create labels where needed
    if(is.null(xLabel)) {
        xLabel <- paste0("% population ", 
                         if(vaxVar=="mean_vxcgte18pct") "(18+) " else if(vaxVar=="mean_vxcgte65pct") "(65+) " else "", 
                         "vaccinated"
                         )
    }
    if(is.null(plotSubtitle)) {
        if(min(popRange)<=1 & max(popRange)==+Inf) popLab <- " of any "
        else if(min(popRange)<=1 & max(popRange)<+Inf) popLab <- paste0(" <", round(max(popRange)/1000, 1), "k ")
        else if(min(popRange)>1 & max(popRange)==Inf) popLab <- paste0(" >", round(min(popRange)/1000, 1), "k ")
        else popLab <- paste0(" between ", round(min(popRange)/1000, 1), "k and ", round(max(popRange)/1000, 1), "k ")
        if(min(valueRange)==-Inf & max(valueRange)==+Inf) valueLab <- " of any value"
        else if(min(valueRange)==-Inf & max(valueRange)<+Inf) valueLab <- paste0(" <", max(valueRange))
        else if(min(valueRange)>-Inf & max(valueRange)==Inf) valueLab <- paste0(" >", min(valueRange))
        else valueLab <- paste0(" between ", min(valueRange), " and ", max(valueRange))
        plotSubtitle <- paste0("Linear model is population weighted for counties", 
                               popLab, 
                               "population with y-axis", 
                               valueLab
                               )
    }
    # Create the data frame
    df <- df %>% 
        filter(name %in% c(all_of(demVars), all_of(vaxVar), all_of(burdenVars))) %>%
        pivot_wider(c(countyFIPS)) %>%
        filter(if(isTRUE(checkMaxMin)) hasMaxMin==1 else TRUE, 
               pop>=popRange[1], 
               pop<=popRange[2]
               ) %>%
        pivot_longer(-c(all_of(demVars), all_of(vaxVar))) %>%
        filter(value >= valueRange[1], value <= valueRange[2])
    
    # Create and print the plot
    p1 <- df %>%
        ggplot(aes_string(x=vaxVar, y="value")) + 
        geom_point(aes(size=pop), alpha=0.25) + 
        geom_smooth(aes(weight=pop), method="lm") + 
        geom_hline(yintercept=c(-1, 0, 1), lty=2, color="red") +
        labs(y=yLabel, 
             x=xLabel, 
             title=plotTitle, 
             subtitle=plotSubtitle
             ) +
        facet_wrap(~name)
    print(p1)

    if(isTRUE(returnData)) return(df)
    
}

#4. Create regressions
regIntegratedCounty <- function(df, 
                                vaxVar="mean_vxcpoppct", 
                                returnData=FALSE
                                ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame from lotIntegratedCounty
    # vaxVar: x-axis variable (vaccine)
    # returnData: boolean, should data (df) be returned?
    
    df %>%
        lm(value ~ get(vaxVar):name + name + 0, data=., weights=pop) %>%
        summary() %>%
        print()
    
    if(isTRUE(returnData)) return(df)
    
}

# Example for all dates and for select dates
integrateCountyBurdenVax(cty_newdata_20220507, cty_vaxdata_20220508)
integrateCountyBurdenVax(cty_newdata_20220507, cty_vaxdata_20220508, keyDates=c(4, 369))

# Example for integrated plot data
integrateCountyBurdenVax(cty_newdata_20220507, cty_vaxdata_20220508, keyDates=c(4, 369)) %>%
    makeIntegratedCountyPlotData()

# Check that data are the same
dfCheck1 <- integrateCountyBurdenVax(cty_newdata_20220507, cty_vaxdata_20220508, keyDates=c(4, 369)) %>%
    makeIntegratedCountyPlotData() %>%
    pivot_wider(countyFIPS) %>%
    filter(pop >= 25000, hasMaxMin==1)
dfCheck2 <- dfPlotVaxBurden %>% 
    pivot_wider(c(countyFIPS, pop, mu_vxcpoppct)) %>%
    rename(mean_vxcpoppct=mu_vxcpoppct)

# Confirm same fields
setdiff(names(dfCheck1), names(dfCheck2))
setdiff(names(dfCheck2), names(dfCheck1))

# Confirm same counties
setdiff(dfCheck1$countyFIPS, dfCheck2$countyFIPS)

# Confirm same value, except for NA
dfCheck <- dfCheck1 %>% 
    pivot_longer(-c(countyFIPS)) %>%
    inner_join(dfCheck2 %>% pivot_longer(-c(countyFIPS)), by=c("countyFIPS", "name")) %>%
    mutate(diff=(is.na(value.x) != is.na(value.y)) | (!is.na(value.x) & !is.na(value.y) & value.x != value.y))
# Summary of differences by field
dfCheck %>% count(name, diff) %>% pivot_wider(name, names_from="diff", values_from="n")
# Check that all are where the previous filtering rules produced NA for value.y
dfCheck %>% filter(diff) %>% is.na %>% colSums()
# Check values for mismatches
dfCheck %>% filter(diff) %>% mutate(exceeds=(value.x > 10 | value.x < -1)) %>% count(name, exceeds)

# Example for integrated plot and regression
integrateCountyBurdenVax(cty_newdata_20220507, cty_vaxdata_20220508, keyDates=c(4, 369)) %>%
    makeIntegratedCountyPlotData() %>%
    plotIntegratedCounty(popRange=c(25000, +Inf)) %>%
    regIntegratedCounty()

# Example using 65+ and 25k-500k
integrateCountyBurdenVax(cty_newdata_20220507, cty_vaxdata_20220508, keyDates=c(4, 369)) %>%
    makeIntegratedCountyPlotData() %>%
    plotIntegratedCounty(popRange=c(25000, 500000), vaxVar = "mean_vxcgte65pct") %>%
    regIntegratedCounty(vaxVar = "mean_vxcgte65pct")

```
  
