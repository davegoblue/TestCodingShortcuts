---
title: "Coronavirus US - USA Facts"
author: "davegoblue"
date: "6/6/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
This module builds on code contained in Coronavirus_Statistics_USAF_v005.Rmd.  This file includes the latest code for analyzing data from [USA Facts](https://usafacts.org/visualizations/coronavirus-covid-19-spread-map/).  USA Facts maintains data on cases and deaths by county for coronavirus in the US.  Downloaded data are unique by county with date as a column and a separate file for each of cases, deaths, and population.

The intent of this code is to source updated functions that allow for readRunUSAFacts() to be run to obtain, read, process, and analyze data from USA Facts.

## Sourcing Functions  
The tidyverse library is loaded, and the functions used for CDC daily processing are sourced.  Additionally, specific functions for USA Facts are also sourced:  
```{r}

library(tidyverse)

# Functions are available in source file
source("./Generic_Added_Utility_Functions_202105_v001.R")
source("./Coronavirus_CDC_Daily_Functions_v001.R")
source("./Coronavirus_USAF_Functions_v001.R")

```
  
Further, the mapping file specific to USA Facts is sourced:  
```{r}

source("./Coronavirus_USAF_Default_Mappings_v001.R")

```
  
Updated functions for diagnoseClusters(), createDetailedSummaries(), createSummary(), and helperSummaryMap() are added to Coronavirus_USAF_Functions_v001.R. These functions should be checked for consistency with state-level data with just a single copy kept later.

## Example Process  
The functions are tested on previously downloaded data, with results cached:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

urlMapper[["usafCase"]] <- "https://static.usafacts.org/public/data/covid-19/covid_confirmed_usafacts.csv"
urlMapper[["usafDeath"]] <- "https://static.usafacts.org/public/data/covid-19/covid_deaths_usafacts.csv"
urlMapper[["usafPop"]] <- "https://static.usafacts.org/public/data/covid-19/covid_county_population_usafacts.csv"

readList <- list("usafCase"="./RInputFiles/Coronavirus/covid_confirmed_usafacts_downloaded_20220308.csv", 
                 "usafDeath"="./RInputFiles/Coronavirus/covid_deaths_usafacts_downloaded_20220308.csv"
                 )
compareList <- list("usafCase"=readFromRDS("cty_newdata_20220202")$dfRaw$usafCase, 
                    "usafDeath"=readFromRDS("cty_newdata_20220202")$dfRaw$usafDeath
                    )

# Use existing clusters
cty_chkdata_20220308 <- readRunUSAFacts(maxDate="2022-03-06", 
                                        downloadTo=lapply(readList, 
                                                          FUN=function(x) if(file.exists(x)) NA else x
                                                          ),
                                        readFrom=readList, 
                                        compareFile=compareList, 
                                        writeLog="./RInputFiles/Coronavirus/USAF_NewData_20220308_chk_v005.log", 
                                        ovrwriteLog=TRUE,
                                        useClusters=readFromRDS("cty_newdata_20210813")$useClusters,
                                        skipAssessmentPlots=FALSE,
                                        brewPalette="Paired"
                                        )

# Plot all counties based on closest cluster
sparseCountyClusterMap(cty_chkdata_20220308$useClusters, 
                       caption="Includes only counties with 25k+ population",
                       brewPalette="viridis"
                       )

# Save the check file
saveToRDS(cty_chkdata_20220308, ovrWriteError=FALSE)

# Confirm that it is identical to the previous process
cty_newdata_20220308 <- readFromRDS("cty_newdata_20220308")
# Same names in the list
all.equal(names(cty_chkdata_20220308), names(cty_newdata_20220308))
# Identical items in the list
sapply(names(cty_chkdata_20220308), 
       FUN=function(x) identical(cty_chkdata_20220308[[x]], cty_newdata_20220308[[x]])
       )
# ggplot2 objects are never identical due to environment; confirm they are all.equal
all.equal(cty_chkdata_20220308$plotDataList, cty_newdata_20220308$plotDataList)

```

The capability for obtaining and processing county-level vaccines data is included:  
```{r fig.height=9, fig.width=9}

# Read the relevant vaccines data
vaxPartialRaw_20220309 <- downloadCountyVaccines(loc="./RInputFiles/Coronavirus/county_vaccine_20220309.csv")
vaxPartialRaw_20220309

# Repair the data for 65+
vaxFix65_20220309 <- repairVaxPopulation(vaxPartialRaw_20220309, colsRepair=c("popgte65"))
vaxFix65_20220309

```
  
Correlations data can also be run:  
```{r fig.height=9, fig.width=9}

corrVaxBurden <- function(lstCD, 
                          dfVax,
                          burdenVar=c("cpm", "dpm"),
                          vaxVar=c("vxcpoppct"),
                          useStates=list(c(state.abb, "DC")),
                          minDateCD=NULL, 
                          maxDateCD=NULL, 
                          returnData=TRUE
                          ) {
    
    # FUNCTION ARGUMENTS:
    # lstCD: list including dfPerCapita with county-level case-death burden data
    # dfVax: data frame of county-level vaccines data
    # burdenVar: variable(s) from lstCD to be used for burden analysis
    # vaxVar: vaccines variable(s) to use
    #         if length==1 then used for each burdenVar, otherwise needs to be same length as burdenVar
    # useStates: states to be used for analysis (passed as a list)
    # minDateCD: minimum date to pull data from case-death (NULL means use minimum date in data)
    #         if NULL or length==1 then used for each burdenVar, otherwise needs to be same length as burdenVar
    # maxDateCD: maximum date to pull data from case-death (NULL means use maximum date in data)
    #         if NULL or length==1 then used for each burdenVar, otherwise needs to be same length as burdenVar
    # returnData: should the data frames be returned as an output list?
    
    # Extract the burden data from lstCD
    dfBurden <- lstCD[["dfPerCapita"]]
    
    # Get minDateCD and maxDateCD if not passed
    if(is.null(minDateCD)) minDateCD <- as.character(min(dfBurden$date))
    if(is.null(maxDateCD)) maxDateCD <- as.character(max(dfBurden$date))
    
    # Check that arguments are all of acceptable length
    if(length(vaxVar) != length(burdenVar))
        if(length(vaxVar)==1) vaxVar <- rep(vaxVar, length(burdenVar)) else stop("\nInvalid vaxVar\n")
    if(length(minDateCD) != length(burdenVar))
        if(length(minDateCD)==1) minDateCD <- rep(minDateCD, length(burdenVar)) else stop("\nInvalid minDateCD\n")
    if(length(maxDateCD) != length(burdenVar))
        if(length(maxDateCD)==1) maxDateCD <- rep(maxDateCD, length(burdenVar)) else stop("\nInvalid maxDateCD\n")
    if(length(useStates) != length(burdenVar))
        if(length(useStates)==1) useStates <- rep(useStates, length(burdenVar)) else stop("\nInvalid useStates\n")
    
    # Display parameters
    cat("\nWill run with parameters:\nburdenVar:", burdenVar, 
        "\nvaxVar:", vaxVar, 
        "\nminDateCD:", minDateCD, 
        "\nmaxDateCD:", maxDateCD,
        "\n"
        )
    
    # Create a container for holding data
    lstReturn <- vector("list", length(burdenVar))
    
    # Run the relevant correlations
    for(ctr in 1:length(burdenVar)) {
        lstReturn[[ctr]] <- countyCorr(dfCaseDeath=dfBurden, 
                                       dfVax=dfVax, 
                                       burdenVar=burdenVar[ctr],
                                       vaxVar=vaxVar[ctr],
                                       useStates=useStates[[ctr]],
                                       minDateCD=minDateCD[ctr], 
                                       maxDateCD=maxDateCD[ctr], 
                                       returnData=returnData
                                       )
    }
    
    # Return the data if requested
    if(isTRUE(returnData)) return(lstReturn)
    
}

corrList20220309 <- corrVaxBurden(lstCD=cty_newdata_20220308,
                                  dfVax=vaxPartialRaw_20220309, 
                                  minDateCD=c("2021-11-01", "2021-09-01"),
                                  maxDateCD="2022-02-28"
                                  )

```

