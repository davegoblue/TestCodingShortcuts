---
title: "Data Camp Python Notes (Visualization)"
author: "davegoblue"
date: "September 2, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(engine.path=list(python="C:\\Users\\Dave\\AppData\\Local\\Programs\\Python\\Python36-32\\python.exe"))
```

## Background and Overview  

DataCamp offer interactive courses related to Python Programming.  Since R Markdown documents can run simple Python code chunks (though the data is not accessible to future chunks, a large difference from R Markdown for R), this document attempts to summarize notes from the modules when possible.

Topic areas summarized include:  
  
* Python Programming (Introduction, Intermediate, Toolbox I/II, Network Analysis I/II)  
* Python Import and Clean Data (Import I/II, Clean)  
* Python Data Manipulation (pandas Foundations, Manipulating DF with pandas, Merging DF with pandas, Databases in pandas, Data Types)  
* Python Visualization (Introduction to Python Data Visualization, Interactive Visualization with Bokeh)  
* Python Statistics (Statistical Thinking in Python Parts I/II)  
* Python Machine Learning ()  
  
The complete version as of July 31, 2017 has been archived as DataCamp_PythonNotes_v001.  Archive files for DataCamp_Python_ImportClean_v002 and DataCamp_Python_Programming_v002 have also been created to contain summaries of those areas.  Further, DataCamp_PythonNotes_v002 was created for capturing summaries of additional topics.

The version of DataCamp_PythonNotes_v002 as of September 1, 2017 has been archived.  Archive files for DataCamp_Python_DataManipulation_v003 and DataCamp_Python_Visualization_v003 have also been created to contain summaries of these areas.  Further, DataCamp_PythonNotes_v003 was created for capturing summaries of additional topics.

This document includes:  
  
* Python Visualization (Introduction to Python Data Visualization, Interactive Visualization with Bokeh)  
  
  
## Python Visualization  
###_Introduction to Data Visualization with Python_#  
  
Chapter 1 - Data Ingestion and Inspection  
  
Plotting multiple graphs - suppose that you have measurements time, Temperature, and DewPoint:  
  
* With "import matplotlib.pyplot as plt", then plt.plot() works on numpy arrays, lists, pandas DataSeries  
	* plt.plot(time, Temperature, "red")  
    * plt.plot(time, DewPoint, "red") # overlays the curve on the same axes  
    * plt.xlabel("Date") ; plt.title("Temperature & Dew Point")  
    * plt.show()  # shows the figure on screen  
* The plt.axes([]) commands will both establish axes and ask that the next curve(s) be drawn on those axes  
	* plt.axes([0.05, 0.05, 0.425, 0.9]) # sets up the axes for a first plot  
    * plt.<commands> # things to be drawn on this axis  
    * plt.axes([0.525, 0.05, 0.425, 0.9]) # sets up the axes for a second plot  
    * plt.<commands> # things to be drawn on this axis  
    * plt.show()  # shows the figure on the screen  
* The commands inside plt.axes([x_lo, y_lo, width, height]) will "sometimes require some trial and error to get right"  
	* The x_lo of 0.05 means 5% of the way to the right of the "full screen" while the width of 0.425 means 42.5% of the "full screen", so draw from 5% to 47.5% of "full-screen width"  
* Conversely, the suplot() command will create multiple axes without the need for this type of customization  
	* plt.subplot(nrows, ncols, thisSubPlot) # sets up a grid of nrows x ncols; activates thisSubPlot which will be active until next call of plt.subplot() - across rows, then down columns, indexed from 1 (not 0)  
    * plt.tight_layout() # helps avoid tick overlap and excessive white-space  
  
Customizing axes - making the plots less messy and more appealing:  
  
* The plt.axis([xmin, xmax, ymin, ymax]) will control the zoom of the x/y components of the axis  
    * Alternately, plt.xlim([xmin, xmax]) will control just the x-axis limits  
    * Alternately, plt.ylim([ymin, ymax]) will control just the y-axis limits  
    * Arguments can be passed as tuples or as lists - xlim((-2, 3)) and xlim([-2, 3]) do the same thing  
    * Interestingly, if just the xlim() is provided, then the ylim() will default to what is best for the full plot (including things not in xlim), so it may nonetheless be necessary to provide a ylim()  
* There are other commands available to plt.axis(), including  
	* axis("off") - turns off axis lines, labels  
    * axis("equal") - equal scaling on x, y axes  
    * axis("square") - forces square plot  
    * axis("tight") - sets xlim() and ylim() to show all the data  
  
Legends, annotations, and styles:  
  
* Legends - provide labels for overlaid points and curves  
	* Can be passed as part of the plotting command, such as plt.scatter(x, y, marker="o", color="red", label="setosa")  
    * The legend is then created using plt.legend(loc="upper right") # loc can be set to other areas to move the legend - default is "best"  
* Annotations - text labels, including optionally arrows from the text to other components of the graph  
	* plt.annotate("myText", xy=(x, y))  # will place "myText" at location x, y  
    * Additional options are xytext (coordinates of label) or arrowprops (controls drawing of arrow)  
    * plt.annotate("myText", xy=(x, y), xytext=(x1, y1), arrowprops={"color":"red"})  # will place "myText" at location x1, y1 and draw a red arrow to point x, y  
    * Often requires some experimentation to get to a visually pleasing plot  
* Styles - controlled by the default style sheets in Matplotlib  
	* Can switch between styles using plt.style.use() # ggplot is an option, so plt.style.use("ggplot") ; fivethirtyeight is an option, so plt.style.use("fivethirtyeight")  
    * Can see what styles are available with plt.style.available  
  
Example code includes:  
```{r engine='python'}

year = [1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011]
physical_sciences = [13.800000000000001, 14.9, 14.800000000000001, 16.5, 18.199999999999999, 19.100000000000001, 20.0, 21.300000000000001, 22.5, 23.699999999999999, 24.600000000000001, 25.699999999999999, 27.300000000000001, 27.600000000000001, 28.0, 27.5, 28.399999999999999, 30.399999999999999, 29.699999999999999, 31.300000000000001, 31.600000000000001, 32.600000000000001, 32.600000000000001, 33.600000000000001, 34.799999999999997, 35.899999999999999, 37.299999999999997, 38.299999999999997, 39.700000000000003, 40.200000000000003, 41.0, 42.200000000000003, 41.100000000000001, 41.700000000000003, 42.100000000000001, 41.600000000000001, 40.799999999999997, 40.700000000000003, 40.700000000000003, 40.700000000000003, 40.200000000000003, 40.100000000000001]
computer_science = [13.6, 13.6, 14.9, 16.399999999999999, 18.899999999999999, 19.800000000000001, 23.899999999999999, 25.699999999999999, 28.100000000000001, 30.199999999999999, 32.5, 34.799999999999997, 36.299999999999997, 37.100000000000001, 36.799999999999997, 35.700000000000003, 34.700000000000003, 32.399999999999999, 30.800000000000001, 29.899999999999999, 29.399999999999999, 28.699999999999999, 28.199999999999999, 28.5, 28.5, 27.5, 27.100000000000001, 26.800000000000001, 27.0, 28.100000000000001, 27.699999999999999, 27.600000000000001, 27.0, 25.100000000000001, 22.199999999999999, 20.600000000000001, 18.600000000000001, 17.600000000000001, 17.800000000000001, 18.100000000000001, 17.600000000000001, 18.199999999999999]

# Import matplotlib.pyplot
import matplotlib.pyplot as plt

# Plot in blue the % of degrees awarded to women in the Physical Sciences
plt.plot(year, physical_sciences, color='blue')

# Plot in red the % of degrees awarded to women in Computer Science
plt.plot(year, computer_science, color='red')

# Display the plot
# plt.show()
plt.savefig("_dummyPy110.png", bbox_inches="tight")
plt.clf()


# Create plot axes for the first line plot
plt.axes([0.05, 0.05, 0.425, 0.9])

# Plot in blue the % of degrees awarded to women in the Physical Sciences
plt.plot(year, physical_sciences, color='blue')

# Create plot axes for the second line plot
plt.axes([0.525, 0.05, 0.425, 0.9])

# Plot in red the % of degrees awarded to women in Computer Science
plt.plot(year, computer_science, color='red')

# Display the plot
# plt.show()
plt.savefig("_dummyPy111.png", bbox_inches="tight")
plt.clf()


# Create a figure with 1x2 subplot and make the left subplot active
plt.subplot(1, 2, 1)

# Plot in blue the % of degrees awarded to women in the Physical Sciences
plt.plot(year, physical_sciences, color='blue')
plt.title('Physical Sciences')

# Make the right subplot active in the current 1x2 subplot grid
plt.subplot(1, 2, 2)

# Plot in red the % of degrees awarded to women in Computer Science
plt.plot(year, computer_science, color='red')
plt.title('Computer Science')

# Use plt.tight_layout() to improve the spacing between subplots
plt.tight_layout()
# plt.show()
plt.savefig("_dummyPy112.png", bbox_inches="tight")
plt.clf()


health = [77.099999999999994, 75.5, 76.900000000000006, 77.400000000000006, 77.900000000000006, 78.900000000000006, 79.200000000000003, 80.5, 81.900000000000006, 82.299999999999997, 83.5, 84.099999999999994, 84.400000000000006, 84.599999999999994, 85.099999999999994, 85.299999999999997, 85.700000000000003, 85.5, 85.200000000000003, 84.599999999999994, 83.900000000000006, 83.5, 83.0, 82.400000000000006, 81.799999999999997, 81.5, 81.299999999999997, 81.900000000000006, 82.099999999999994, 83.5, 83.5, 85.099999999999994, 85.799999999999997, 86.5, 86.5, 86.0, 85.900000000000006, 85.400000000000006, 85.200000000000003, 85.099999999999994, 85.0, 84.799999999999997]
education = [74.535327580000001, 74.149203689999993, 73.554519959999993, 73.501814429999996, 73.336811429999997, 72.801854480000003, 72.166524710000004, 72.456394810000006, 73.192821339999995, 73.821142339999994, 74.981031520000002, 75.845123450000003, 75.843649139999997, 75.950601230000004, 75.869116009999999, 75.923439709999997, 76.143015160000004, 76.963091680000005, 77.627661770000003, 78.111918720000006, 78.866858590000007, 78.991245969999994, 78.435181909999997, 77.267311989999996, 75.814932639999995, 75.125256210000003, 75.035199210000002, 75.163701299999985, 75.486160269999999, 75.838162060000002, 76.692142840000002, 77.375229309999995, 78.644243939999996, 78.544948149999996, 78.65074774, 79.067121729999997, 78.686305509999997, 78.72141311, 79.196326740000003, 79.532908700000007, 79.618624510000004, 79.432811839999999]

# Create a figure with 2x2 subplot layout and make the top left subplot active
plt.subplot(2, 2, 1)

# Plot in blue the % of degrees awarded to women in the Physical Sciences
plt.plot(year, physical_sciences, color='blue')
plt.title('Physical Sciences')

# Make the top right subplot active in the current 2x2 subplot grid 
plt.subplot(2, 2, 2)

# Plot in red the % of degrees awarded to women in Computer Science
plt.plot(year, computer_science, color='red')
plt.title('Computer Science')

# Make the bottom left subplot active in the current 2x2 subplot grid
plt.subplot(2, 2, 3)

# Plot in green the % of degrees awarded to women in Health Professions
plt.plot(year, health, color='green')
plt.title('Health Professions')

# Make the bottom right subplot active in the current 2x2 subplot grid
plt.subplot(2, 2, 4)

# Plot in yellow the % of degrees awarded to women in Education
plt.plot(year, education, color='yellow')
plt.title('Education')

# Improve the spacing between subplots and display them
plt.tight_layout()
# plt.show()
plt.savefig("_dummyPy113.png", bbox_inches="tight")
plt.clf()


# Plot the % of degrees awarded to women in Computer Science and the Physical Sciences
plt.plot(year,computer_science, color='red') 
plt.plot(year, physical_sciences, color='blue')

# Add the axis labels
plt.xlabel('Year')
plt.ylabel('Degrees awarded to women (%)')

# Set the x-axis range
plt.xlim(1990, 2010)

# Set the y-axis range
plt.ylim(0, 50)

# Add a title and display the plot
plt.title('Degrees awarded to women (1990-2010)\nComputer Science (red)\nPhysical Sciences (blue)')
# plt.show()
plt.savefig("_dummyPy114.png", bbox_inches="tight")
plt.clf()


# Save the image as 'xlim_and_ylim.png'
# plt.savefig("xlim_and_ylim.png")


# Plot in blue the % of degrees awarded to women in Computer Science
plt.plot(year,computer_science, color='blue')

# Plot in red the % of degrees awarded to women in the Physical Sciences
plt.plot(year, physical_sciences,color='red')

# Set the x-axis and y-axis limits
plt.axis([1990, 2010, 0, 50])

# Show the figure
# plt.show()
plt.savefig("_dummyPy115.png", bbox_inches="tight")
plt.clf()


# Save the figure as 'axis_limits.png'
# plt.savefig("axis_limits.png")


# Specify the label 'Computer Science'
plt.plot(year, computer_science, color='red', label='Computer Science') 

# Specify the label 'Physical Sciences' 
plt.plot(year, physical_sciences, color='blue', label='Physical Sciences')

# Add a legend at the lower center
plt.legend(loc="lower center")

# Add axis labels and title
plt.xlabel('Year')
plt.ylabel('Enrollment (%)')
plt.title('Undergraduate enrollment of women')
# plt.show()
plt.savefig("_dummyPy116.png", bbox_inches="tight")
plt.clf()


# Plot with legend as before
plt.plot(year, computer_science, color='red', label='Computer Science') 
plt.plot(year, physical_sciences, color='blue', label='Physical Sciences')
plt.legend(loc='bottom right')

# Compute the maximum enrollment of women in Computer Science: cs_max
# cs_max = computer_science.max()
cs_max = max(computer_science)

# Calculate the year in which there was maximum enrollment of women in Computer Science: yr_max
#yr_max = year[computer_science.argmax()]
yr_max = year[computer_science.index(cs_max)]

# Add a black arrow annotation
plt.annotate("Maximum", xy=(yr_max, cs_max), xytext=(yr_max + 5, cs_max + 5), arrowprops={"facecolor":'black'})

# Add axis labels and title
plt.xlabel('Year')
plt.ylabel('Enrollment (%)')
plt.title('Undergraduate enrollment of women')
# plt.show()
plt.savefig("_dummyPy117.png", bbox_inches="tight")
plt.clf()


# Import matplotlib.pyplot
import matplotlib.pyplot as plt

# Set the style to 'ggplot'
plt.style.use("ggplot")

# Create a figure with 2x2 subplot layout
plt.subplot(2, 2, 1) 

# Plot the enrollment % of women in the Physical Sciences
plt.plot(year, physical_sciences, color='blue')
plt.title('Physical Sciences')

# Plot the enrollment % of women in Computer Science
plt.subplot(2, 2, 2)
plt.plot(year, computer_science, color='red')
plt.title('Computer Science')

# Add annotation
cs_max = max(computer_science)
yr_max = year[computer_science.index(cs_max)]
plt.annotate('Maximum', xy=(yr_max, cs_max), xytext=(yr_max-1, cs_max-10), arrowprops=dict(facecolor='black'))

# Plot the enrollmment % of women in Health professions
plt.subplot(2, 2, 3)
plt.plot(year, health, color='green')
plt.title('Health Professions')

# Plot the enrollment % of women in Education
plt.subplot(2, 2, 4)
plt.plot(year, education, color='yellow')
plt.title('Education')

# Improve spacing between subplots and display them
plt.tight_layout()
# plt.show()
plt.savefig("_dummyPy118.png", bbox_inches="tight")
plt.clf()


```
  
  
**Example #1: Unlabelled Plot on Single Set of Axes**:  
![](_dummyPy110.png)

**Example #2: Subplots on Separate Axes**:  
![](_dummyPy111.png)

**Example #3: Subplots on Separate Axes with Titles**:  
![](_dummyPy112.png)

**Example #4: Subplots on Separate Axes with Titles**:  
![](_dummyPy113.png)

**Example #5: Title and Axis Labels for Two Plots on a Single Set of Axes**:  
![](_dummyPy114.png)

**Example #6: Title, Axis Labels, and Legend for Two Plots on a Single Set of Axes**:  
![](_dummyPy116.png)

**Example #7: Annotation with Arrow**:  
![](_dummyPy117.png)

**Example #8: Subplots in ggplot2 Format with One Subplot Annotated**:  
![](_dummyPy118.png)

  
***


Chapter 2 - Plotting 2D Arrays (Raster Data or Bivariate Function Data)  
  
Working with 2D Arrays - reminders about NumPy arrays:  
  
* NumPy arrays are homogenous in type, allowing for calculations all at once across the entire array  
	* A[index] will grab an item from a 1D array  
    * A[index0, index1] will grab an item from a 2D array  
    * Slicing can be done with start:stop:stride  # runs from start to stop-1, with stride being the step  
* All images are 2D arrays of intensity - single intensity for gray-scale, multiple intensities (RGB) for color  
    * import numpy as np  
    * u = np.linspace(-2, 2, 3)  # 3 total elements equally spaced from -2 to 2, so [-2, 0, 2]  
    * v = np.linspace(-1, 1, 5)  # 5 total elements equally spaced from -1 to 1, so [-1, -0.5, 0, 0.5, 1]  
    * X, Y = np.meshgrid(u, v)  # replicates the 1D grids along different axes, more or less making a 2D array -- X and Y are both 5 x 3 with every row of X being u and every column of Y being v  
    * Z = X**2/25 + Y**2/4  ; print("Z:\n", Z)  
    * plt.set_cmap("gray")  # sets the color map to grey-scale  
    * plt.pcolor(Z)  # described later in the chapter, stands for "pseudo-color"  
    * plt.show()  
* Orientations of 2D arrays and images - arrays are written differently by hand than plotted by computer  
	* Plotting runs left-to-right but also bottom-to-top, so the first element of the array (upper-left) will appear in the bottom-left of the image  
  
Visualizing bivariate functions - including the "pseudo-color" (plt.pcolor()) calls:  
  
* Pseudo-color plot are multi-colored and have spill-over (white space on the sides) and have axes that are integers rather than coordinates  
	* Can see the colorbar using plt.colorbar() ; this will display the mapping of colors to values in the plot  
    * Using the cmap= option within plt.pcolor() allows for over-riding the defaults ; for example, plt.pcolor(Z, cmap="gray")  
* The issues with spill-over can be addressed using plt.axis("tight")  
* The issues with the axes as integers can be addressed by calling plt.pcolor(X, Y, Z) where X and Y are the associated elements of the mesh-grid and Z is the value to be plotted  
* By design, plt.pcolor() will make "blocky" images, which may be OK depending on the underlying data / issue explored  
	* The alternative is to use plt.contour(Z, n), which will make "n" smooth-curves of constant value  
    * The other alternative is plt.contourf(Z, n) which will make "n" filled contours of constant value  
  
Visualizing bivariate distributions - distributions of 2D points:  
  
* Example of 2D points given as two 1D arrays x and y (from automobiles data - Weight vs Acceleration), goal is to generate a histogram from x and y  
	* For 1D data, the histogram can show the counts of values by bin, accessible using plt.hist()  
* For 2D data, there are more options for binning shapes (as opposed to 1D where they will be line segments)  
	* Rectangles are the most obvious strategy - plt.hist2d(x, y, bins=(xbins, ybins))  
    * Hexagons are another strategy - plt.hexbin(x, y, gridsize=(xSize, ySize)  
  
Working with images (matrices of intensity values):  
  
* Color images are frequently stored as 3-D arrays, one 2-D array for each of Red, Green, Blue  
	* The values may range as floats from 0-1 reflecting intensity (0=0%, 1=100%)  
    * The values may range as integers from 0-255 reflecting intensity (0=0%, 255=100%)  
* Reading and displaying images using matplotlib.pyplot as plt  
	* img = plt.imread("myImageFile")  
    * plt.imshow(img)  
    * plt.axis("off")  
    * plt.show()  
* Creating a grey-scale image can be as easy as averaging the intensity across the third dimension (axis=2)  
	* collapsed = img.mean(axis=2)  
* Default assumption for plotting is that aspect-ratio is 1 (pixel means the same thing in every direction)  
	* Can over-ride, such as plt.imshow(img, aspect=2.0)  
    * Alternately, can over-ride such as plt.imshow(img, extent=(0, 640, 0, 480))  # value in extent are left, right, bottom, top  
  
Example code includes:  
```{r engine='python', engine.path=list(python="C:\\Users\\Dave\\Anaconda3\\python.exe")}

myPath = "./PythonInputFiles/"



# Import numpy and matplotlib.pyplot
import numpy as np
import matplotlib.pyplot as plt

# Generate two 1-D arrays: u, v
u = np.linspace(-2, 2, 41)
v = np.linspace(-1, 1, 21)

# Generate 2-D arrays from u and v: X, Y
X,Y = np.meshgrid(u, v)

# Compute Z based on X and Y
Z = np.sin(3*np.sqrt(X**2 + Y**2)) 

# Display the resulting image with pcolor()
plt.pcolor(Z)
# plt.show()
plt.savefig("_dummyPy119.png", bbox_inches="tight")
plt.clf()


# Save the figure to 'sine_mesh.png'
# plt.savefig("sine_mesh.png")


u = np.linspace(-2, 2, 101)
v = np.linspace(0, 2, 51)
X,Y = np.meshgrid(u, v)
Z = X**2/8 + Y**2/8


plt.set_cmap("viridis")  # bring back to what it looks like DataCamp may be using

# Generate a default contour map of the array Z
plt.subplot(2,2,1)
plt.contour(X, Y, Z)

# Generate a contour map with 20 contours
plt.subplot(2,2,2)
plt.contour(X, Y, Z, 20)

# Generate a default filled contour map of the array Z
plt.subplot(2,2,3)
plt.contourf(X, Y, Z)

# Generate a default filled contour map with 20 contours
plt.subplot(2,2,4)
plt.contourf(X, Y, Z, 20)

# Improve the spacing between subplots
plt.tight_layout()

# Display the figure
# plt.show()
plt.savefig("_dummyPy120.png", bbox_inches="tight")
plt.clf()


# Create a filled contour plot with a color map of 'viridis'
plt.subplot(2,2,1)
plt.contourf(X,Y,Z,20, cmap='viridis')
plt.colorbar()
plt.title('Viridis')

# Create a filled contour plot with a color map of 'gray'
plt.subplot(2,2,2)
plt.contourf(X,Y,Z,20, cmap='gray')
plt.colorbar()
plt.title('Gray')

# Create a filled contour plot with a color map of 'autumn'
plt.subplot(2,2,3)
plt.contourf(X,Y,Z,20, cmap='autumn')
plt.colorbar()
plt.title('Autumn')

# Create a filled contour plot with a color map of 'winter'
plt.subplot(2,2,4)
plt.contourf(X,Y,Z,20, cmap='winter')
plt.colorbar()
plt.title('Winter')

# Improve the spacing between subplots and display them
plt.tight_layout()
# plt.show()
plt.savefig("_dummyPy121.png", bbox_inches="tight")
plt.clf()


mpg = [18.0, 9.0, 36.100000000000001, 18.5, 34.299999999999997, 32.899999999999999, 32.200000000000003, 22.0, 15.0, 17.0, 44.0, 24.5, 32.0, 14.0, 15.0, 13.0, 36.0, 31.0, 32.0, 21.5, 19.0, 17.0, 16.0, 15.0, 23.0, 26.0, 32.0, 24.0, 21.0, 31.300000000000001, 32.700000000000003, 15.0, 23.0, 17.600000000000001, 28.0, 24.0, 14.0, 18.100000000000001, 36.0, 29.0, 35.100000000000001, 36.0, 16.5, 16.0, 29.899999999999999, 31.0, 27.199999999999999, 14.0, 32.100000000000001, 15.0, 12.0, 17.600000000000001, 25.0, 28.399999999999999, 29.0, 30.899999999999999, 20.0, 20.800000000000001, 22.0, 38.0, 31.0, 19.0, 16.0, 25.0, 22.0, 26.0, 13.0, 19.899999999999999, 11.0, 28.0, 15.5, 26.0, 14.0, 12.0, 24.199999999999999, 25.0, 22.5, 26.800000000000001, 23.0, 26.0, 30.699999999999999, 31.0, 27.199999999999999, 21.5, 29.0, 20.0, 13.0, 14.0, 38.0, 13.0, 24.5, 13.0, 25.0, 24.0, 34.100000000000001, 13.0, 44.600000000000001, 20.5, 18.0, 23.199999999999999, 20.0, 24.0, 25.5, 36.100000000000001, 23.0, 24.0, 18.0, 26.600000000000001, 32.0, 20.300000000000001, 27.0, 17.0, 21.0, 13.0, 24.0, 17.0, 39.100000000000001, 14.5, 13.0, 20.199999999999999, 27.0, 35.0, 15.0, 36.399999999999999, 30.0, 31.899999999999999, 26.0, 16.0, 20.0, 18.600000000000001, 14.0, 25.0, 33.0, 14.0, 18.5, 37.200000000000003, 18.0, 44.299999999999997, 18.0, 28.0, 43.399999999999999, 20.600000000000001, 19.199999999999999, 26.399999999999999, 18.0, 28.0, 26.0, 13.0, 25.800000000000001, 28.100000000000001, 13.0, 16.5, 31.5, 24.0, 15.0, 18.0, 33.5, 32.399999999999999, 27.0, 13.0, 31.0, 28.0, 27.199999999999999, 21.0, 19.0, 25.0, 23.0, 19.0, 15.5, 23.899999999999999, 22.0, 29.0, 14.0, 15.0, 27.0, 15.0, 30.5, 25.0, 17.5, 34.0, 38.0, 30.0, 19.800000000000001, 25.0, 21.0, 26.0, 16.5, 18.100000000000001, 46.600000000000001, 21.5, 14.0, 21.600000000000001, 15.5, 20.5, 23.899999999999999, 12.0, 20.199999999999999, 34.399999999999999, 23.0, 24.300000000000001, 19.0, 29.0, 23.5, 34.0, 37.0, 33.0, 18.0, 15.0, 34.700000000000003, 19.399999999999999, 32.0, 34.100000000000001, 33.700000000000003, 20.0, 15.0, 38.100000000000001, 26.0, 27.0, 16.0, 17.0, 13.0, 28.0, 14.0, 31.5, 34.5, 11.0, 16.0, 31.600000000000001, 19.100000000000001, 18.5, 15.0, 18.0, 35.0, 20.199999999999999, 13.0, 31.0, 22.0, 11.0, 33.5, 43.100000000000001, 25.399999999999999, 40.799999999999997, 14.0, 29.800000000000001, 16.0, 20.600000000000001, 18.0, 33.0, 31.800000000000001, 13.0, 20.0, 32.0, 13.0, 23.699999999999999, 19.199999999999999, 37.0, 18.0, 19.0, 32.299999999999997, 18.0, 13.0, 12.0, 36.0, 18.199999999999999, 19.0, 30.0, 15.0, 11.0, 10.0, 16.0, 14.0, 16.899999999999999, 13.0, 25.0, 21.0, 21.100000000000001, 26.0, 28.0, 29.0, 16.0, 26.600000000000001, 19.0, 32.799999999999997, 22.0, 19.0, 31.0, 23.0, 29.5, 17.5, 19.0, 24.0, 14.0, 28.0, 21.0, 22.399999999999999, 36.0, 18.0, 16.199999999999999, 39.399999999999999, 30.0, 18.0, 17.5, 28.800000000000001, 22.0, 34.200000000000003, 30.5, 16.0, 38.0, 41.5, 27.899999999999999, 22.0, 29.800000000000001, 17.699999999999999, 15.0, 14.0, 15.5, 17.5, 12.0, 29.0, 15.5, 35.700000000000003, 26.0, 30.0, 33.799999999999997, 18.0, 13.0, 20.0, 32.399999999999999, 16.0, 27.5, 23.0, 14.0, 17.0, 16.0, 23.0, 24.0, 27.0, 15.0, 27.0, 28.0, 14.0, 33.5, 39.0, 24.0, 26.5, 19.399999999999999, 15.0, 25.5, 14.0, 27.399999999999999, 13.0, 19.0, 17.0, 28.0, 22.0, 30.0, 18.0, 14.0, 22.0, 23.800000000000001, 24.0, 26.0, 26.0, 30.0, 29.0, 14.0, 25.399999999999999, 19.0, 12.0, 20.0, 27.0, 22.300000000000001, 10.0, 19.199999999999999, 26.0, 16.0, 37.299999999999997, 26.0, 20.199999999999999, 13.0, 21.0, 25.0, 20.5, 37.700000000000003, 36.0, 20.0, 37.0, 18.0, 27.0, 29.5, 17.5, 25.100000000000001]
hp = [88, 193, 60, 98, 78, 100, 75, 76, 130, 140, 52, 88, 84, 148, 150, 130, 58, 82, 65, 110, 95, 110, 140, 170, 78, 90, 96, 95, 110, 75, 132, 150, 83, 85, 86, 75, 140, 139, 70, 52, 60, 84, 138, 180, 65, 67, 97, 150, 70, 100, 180, 129, 95, 90, 83, 75, 100, 85, 112, 67, 65, 88, 100, 75, 100, 70, 145, 110, 210, 80, 145, 69, 150, 198, 120, 92, 90, 115, 95, 75, 76, 67, 71, 115, 84, 91, 150, 215, 67, 175, 60, 175, 110, 95, 68, 150, 67, 95, 110, 105, 102, 110, 89, 66, 88, 75, 78, 105, 70, 103, 60, 150, 72, 170, 90, 110, 58, 152, 145, 139, 83, 69, 150, 67, 80, 71, 46, 105, 90, 110, 175, 80, 74, 150, 150, 65, 100, 48, 105, 90, 48, 105, 105, 88, 100, 75, 113, 190, 92, 80, 165, 180, 71, 97, 72, 105, 90, 75, 88, 155, 68, 90, 84, 87, 112, 87, 125, 108, 142, 97, 105, 75, 137, 150, 88, 145, 63, 95, 140, 88, 85, 70, 85, 115, 86, 79, 120, 120, 65, 110, 220, 115, 170, 100, 90, 225, 85, 65, 97, 90, 90, 49, 110, 70, 92, 53, 100, 190, 63, 90, 67, 65, 75, 100, 110, 60, 93, 88, 150, 100, 150, 88, 225, 68, 70, 208, 105, 74, 90, 110, 72, 97, 88, 88, 129, 85, 86, 150, 70, 48, 77, 65, 175, 90, 150, 110, 130, 53, 65, 158, 95, 61, 215, 100, 145, 68, 150, 88, 67, 105, 175, 160, 74, 135, 100, 67, 198, 180, 215, 100, 225, 155, 170, 81, 85, 95, 80, 92, 70, 149, 84, 97, 52, 72, 85, 52, 95, 71, 140, 100, 96, 150, 75, 107, 110, 75, 97, 133, 70, 67, 112, 145, 115, 98, 70, 78, 230, 63, 76, 105, 95, 62, 165, 165, 160, 190, 95, 180, 78, 120, 80, 75, 68, 67, 95, 140, 110, 72, 150, 95, 54, 153, 130, 170, 86, 97, 90, 145, 86, 79, 165, 83, 64, 92, 72, 140, 150, 96, 150, 80, 130, 100, 125, 90, 94, 76, 90, 150, 97, 85, 81, 78, 46, 84, 70, 153, 116, 100, 167, 88, 88, 88, 200, 125, 92, 110, 69, 67, 90, 150, 90, 71, 105, 62, 88, 122, 65, 88, 90, 68, 110, 88]

# Generate a 2-D histogram
plt.hist2d(hp, mpg, bins=(20, 20), range=((40, 235), (8, 48)))

# Add a color bar to the histogram
plt.colorbar()

# Add labels, title, and display the plot
plt.xlabel('Horse power [hp]')
plt.ylabel('Miles per gallon [mpg]')
plt.title('hist2d() plot')
# plt.show()
plt.savefig("_dummyPy122.png", bbox_inches="tight")
plt.clf()


# Generate a 2d histogram with hexagonal bins
plt.hexbin(hp, mpg, gridsize=(15, 12), extent=(40, 235, 8, 48))

# Add a color bar to the histogram
plt.colorbar()

# Add labels, title, and display the plot
plt.xlabel('Horse power [hp]')
plt.ylabel('Miles per gallon [mpg]')
plt.title('hexbin() plot')
# plt.show()
plt.savefig("_dummyPy123.png", bbox_inches="tight")
plt.clf()


# Load the image into an array: img
# Downloaded Astrounaut-EVA.jpg from https://en.wikipedia.org/wiki/File:Astronaut-EVA.jpg
# img = plt.imread('480px-Astronaut-EVA.jpg')
# Cannot be read on my computer using regular Python but OK with Anaconda . . . 
img = plt.imread(myPath + 'Astronaut-EVA.jpg')


# Print the shape of the image
print(img.shape)

# Display the image
plt.imshow(img)

# Hide the axes
plt.axis("off")
# plt.show()
plt.savefig("_dummyPy124.png", bbox_inches="tight")
plt.clf()



# Compute the sum of the red, green and blue channels: intensity
intensity = img.sum(axis=2)

# Print the shape of the intensity
print(intensity.shape)

# Display the intensity with a colormap of 'gray'
plt.imshow(intensity, cmap="gray")

# Add a colorbar
plt.colorbar()

# Hide the axes and show the figure
plt.axis('off')
# plt.show()
plt.savefig("_dummyPy125.png", bbox_inches="tight")
plt.clf()


# Specify the extent and aspect ratio of the top left subplot
plt.subplot(2,2,1)
plt.title('extent=(-1,1,-1,1),\naspect=0.5') 
plt.xticks([-1,0,1])
plt.yticks([-1,0,1])
plt.imshow(img, extent=(-1,1,-1,1), aspect=0.5)

# Specify the extent and aspect ratio of the top right subplot
plt.subplot(2,2,2)
plt.title('extent=(-1,1,-1,1),\naspect=1')
plt.xticks([-1,0,1])
plt.yticks([-1,0,1])
plt.imshow(img, extent=(-1,1,-1,1), aspect=1)

# Specify the extent and aspect ratio of the bottom left subplot
plt.subplot(2,2,3)
plt.title('extent=(-1,1,-1,1),\naspect=2')
plt.xticks([-1,0,1])
plt.yticks([-1,0,1])
plt.imshow(img, extent=(-1,1,-1,1), aspect=2)

# Specify the extent and aspect ratio of the bottom right subplot
plt.subplot(2,2,4)
plt.title('extent=(-2,2,-1,1),\naspect=2')
plt.xticks([-2,-1,0,1,2])
plt.yticks([-1,0,1])
plt.imshow(img, extent=(-2,2,-1,1), aspect=2)

# Improve spacing and display the figure
plt.tight_layout()
# plt.show()
plt.savefig("_dummyPy126.png", bbox_inches="tight")
plt.clf()


# Downloaded Unequalized_Hawkes_Bay_NZ.jpg from https://commons.wikimedia.org/wiki/File:Unequalized_Hawkes_Bay_NZ.jpg
# Load the image into an array: image
# image = plt.imread('640px-Unequalized_Hawkes_Bay_NZ.jpg')
image = plt.imread(myPath + 'Unequalized_Hawkes_Bay_NZ.jpg')

# Extract minimum and maximum values from the image: pmin, pmax
pmin, pmax = image.min(), image.max()
print("The smallest & largest pixel intensities are %d & %d." % (pmin, pmax))

# Rescale the pixels: rescaled_image
imageMean = image.mean(axis=2)
rescaled_image = 256*(imageMean - pmin) / (pmax - pmin)
print("The rescaled smallest & largest pixel intensities are %.1f & %.1f." % 
      (rescaled_image.min(), rescaled_image.max()))

# Make it a 3D Numpy array for grayscale
# rescaled_gray = np.zeros((imageMean.shape[0], imageMean.shape[1], 3))

# rescaled_gray[:, :, 0] = rescaled_image
# rescaled_gray[:, :, 1] = rescaled_image
# rescaled_gray[:, :, 2] = rescaled_image

# Display the original image in the top subplot
plt.subplot(2,1,1)
plt.title('original image')
plt.axis('off')
plt.imshow(image)

# Display the rescaled image in the bottom subplot
plt.subplot(2,1,2)
plt.title('rescaled image')
plt.axis('off')
plt.imshow(rescaled_image, cmap="gray")

# plt.show()
plt.savefig("_dummyPy127.png", bbox_inches="tight")
plt.clf()

```
  
  
**Example #1: Pseudo-Color Plot**:  
![](_dummyPy119.png)  

**Example #2: Pseudo-Color Contour Plot**:  
![](_dummyPy120.png)  

**Example #3: Varying the Color Map**:  
![](_dummyPy121.png)  

**Example #4: Heat Map for mtcars**:  
![](_dummyPy122.png)  

**Example #5: Heat Map using hexbin for mtcars**:  
![](_dummyPy123.png)  

**Example #6: Astronaut Image**:  
![](_dummyPy124.png)  

**Example #7: Astronaut Image (GrayScale)**:  
![](_dummyPy125.png)  

**Example #8: Astronaut Image (Aspect Ratio)**:  
![](_dummyPy126.png)  

**Example #9: Hawkes Bay Image (Raw and Rescaled)**:  
![](_dummyPy127.png)  

	

***
  
Chapter 3 - Statistical Plots with Seaborn (statistical data visualization package)  
  
General background - designed by Michael Waskom (Stanford):  
  
* High-level interface for drawing attractive statistical graphics  
* Drawn on top of matplotlib - makes plotting both easier and prettier  
* Works best with pandas DataFrames rather than NumPy arrays or lists or anything else  
  
Visualizing Regressions - using the "tips" data and looking at "tip" vs. "total_bill":  
  
* Basic data process for plotting a regression using Seaborn  
	* import pandas as pd  
    * import matplotlib.pyplot as plt  
    * import seaborn as sns  
    * tips = sns.load_dataset("tips")  # Seaborn data-loading function  
    * sns.lmplot(x = "total_bill", y = "tip", data=tips)  # runs the regression, plots both the underlying data and the regression line  
    * plt.show()  
* Grouping factor variables, but displaying them on the same plot  
	* sns.lmplot(x = "total_bill", y = "tip", data=tips, hue="sex", palette="Set1")  # runs the regression, plots both the underlying data and the regression line, colors everything by "sex" (factor variable) using "Set1" palette  
* Grouping factor variables, and displaying them as separate sub-plots  
	* sns.lmplot(x = "total_bill", y = "tip", data=tips, col="sex")  # runs the regression, plots both the underlying data and the regression line, colors everything by "sex" (factor variable) using "Set1" palette  
    * The sns.lmplot() accepts the arguments row and/or col to arrangements of subplots for regressions  
* Residual plots can be obtained using residplot  
	* sns.residplot(x="age", y="fare", data=tips, color="indianred")  
    * The residplot is somewhat more flexible, in that x/y could be lists or NumPy arrays with data skipped as an input  
  
Visualizing univariate distributions - strip plots, swarm plots, violin plots:  
  
* Strip plots - variables drawn on a single line (optionally, by category)  
	* sns.stripplot(y = "tip", data=tips)  # single strip-plot of all the data  
    * sns.stripplot(x="day", y = "tip", data=tips)  # strip-plot of all data, once for each value of "day"  
    * Repeated values are drawn on top of each other by default, so there is no way to say where the most frequenct values have occurred  
    * Can add "jitter" to the plot, using sns.stripplot(x="day", y = "tip", data=tips, size=4, jitter=True)  
* Swarm plots - somewhat like strip plots, but automatically represent repeated data as multiple points  
	* sns.swarmplot(x="day", y = "tip", data=tips)  # swarm-plot of all data, once for each value of "day"  
    * sns.swarmplot(x="day", y = "tip", data=tips, hue="sex")  # swarm-plot of all the data, once for each value of "day", and with points colored by "sex" (factor variable)  
    * Can change orientation by swapping x/y arguments and adding orient="h" - so, sns.swarmplot(y="day", x = "tip", data=tips, hue="sex", orient="h")  
* Violin plots (fancier form of box plots) are more useful then strip/swarm plots in the presence of a very large volume of data  
	* Based on the KDE - kernel density estimate - wrapped around a box plot, leading to a thicker violin where there is more data  
    * sns.violinplot(x="day", y = "tip", data=tips)  # violin-plot of all the data, once for each value of "day"  
* Can combine multiple plot-types on the same graph, including  
	* sns.violinplot(x="day", y = "tip", data=tips, inner=None, color="lightgray")  # violin-plot of all the data, once for each value of "day", and with no colored fills of the violin  
    * sns.stripplot(x="day", y = "tip", data=tips, size=4, jitter=True)  # overlays the strip-plot on the violin-plot  
    * plt.show()  # shows the full dataset  
  
Visualizing bivariate / multivariate distributions - joint plots, pair plots, heat maps:  
  
* Joint plot - show the scatter plot of two variables, with the univariate histograms of each variable showed above (for x) and to the right (y) of the scatter  
	* sns.jointplot(x="total_bill", y="tip", data=tips)  
    * sns.jointplot(x="total_bill", y="tip", data=tips, kind="kde")  # will produce smooth graphs using the Kernel Density Estimate for the scatter (contours) and histograms  
    * kind='scatter' uses a scatter plot of the data points  
    * kind='reg' uses a regression plot (default order 1)  
    * kind='resid' uses a residual plot  
    * kind='kde' uses a kernel density estimate of the joint distribution  
    * kind='hex' uses a hexbin plot of the joint distribution  
* Pair plot - scatter plot of every possible pair of variables, with diagonals being self-histograms and off-diagonals being repeated (though as a transpose)  
	* sns.pairplot(tips)  # categorical variables will NOT be plotted ; only continuous, numeric variables  
    * sns.pairplot(tips, hue="sex")  # points will be colored by "sex" (categorical variables)  
* Heat map - covariance matrix represented as pseudo-colors, and with some additional functionality  
    * Assume that a covariance matrix has already been created, conveniently called "covariance"  
    * sns.heatmap(covariance)  
    * Typically used for gene expression, stocks, and other areas where there are a vast number of comparisons to be run  
  
Example code includes:  
```{r engine='python', engine.path=list(python="C:\\Users\\Dave\\Anaconda3\\python.exe")}

myPath = "./PythonInputFiles/"



# NEED TO BRING OVER "auto" data
import pandas as pd

auto = pd.read_csv(myPath + "mtcars.csv", index_col=0)
auto = auto[["mpg", "wt", "hp", "cyl", "am", "disp"]]

# Import plotting modules
import matplotlib.pyplot as plt
import seaborn as sns

# Plot a linear regression between 'weight' and 'hp'
sns.lmplot(x='wt', y='hp', data=auto)

# Display the plot
# plt.show()
plt.savefig("_dummyPy128.png", bbox_inches="tight")
plt.clf()


# Generate a green residual plot of the regression between 'hp' and 'mpg'
sns.residplot(x='hp', y='mpg', data=auto, color='green')

# Display the plot
# plt.show()
plt.savefig("_dummyPy129.png", bbox_inches="tight")
plt.clf()


# Generate a scatter plot of 'weight' and 'mpg' using red circles
plt.scatter(auto['wt'], auto["mpg"], label='data', color='red', marker='o')

# Plot in blue a linear regression of order 1 between 'weight' and 'mpg'
sns.regplot(x='wt', y='mpg', data=auto, color="blue", scatter=None, label='order 1')

# Plot in green a linear regression of order 2 between 'weight' and 'mpg'
sns.regplot(x='wt', y='mpg', data=auto, color="green", scatter=None, order=2, label='order 2')

# Add a legend and display the plot
plt.legend(loc="upper right")
# plt.show()
plt.savefig("_dummyPy130.png", bbox_inches="tight")
plt.clf()


# Plot a linear regression between 'weight' and 'hp', with a hue of 'cyl' and palette of 'Set1'
sns.lmplot(x="wt", y="hp", data=auto, hue="cyl", palette="Set1")

# Display the plot
# plt.show()
plt.savefig("_dummyPy131.png", bbox_inches="tight")
plt.clf()


# Plot linear regressions between 'weight' and 'hp' grouped row-wise by 'cyl'
sns.lmplot(x = "wt", y="hp", data=auto, row="cyl")

# Display the plot
# plt.show()
plt.savefig("_dummyPy132.png", bbox_inches="tight")
plt.clf()


# Make a strip plot of 'hp' grouped by 'cyl'
plt.subplot(2,1,1)
sns.stripplot(x="cyl", y="hp", data=auto)

# Make the strip plot again using jitter and a smaller point size
plt.subplot(2,1,2)
sns.stripplot(x="cyl", y="hp", data=auto, size=3, jitter=True)

# Display the plot
# plt.show()
plt.savefig("_dummyPy133.png", bbox_inches="tight")
plt.clf()


# Generate a swarm plot of 'hp' grouped horizontally by 'cyl'  
plt.subplot(2,1,1)
sns.swarmplot(x="cyl", y="hp", data=auto)

# Generate a swarm plot of 'hp' grouped vertically by 'cyl' with a hue of 'am'
plt.subplot(2,1,2)
sns.swarmplot(y="cyl", x="hp", data=auto, hue="am", orient="h")

# Display the plot
# plt.show()
plt.savefig("_dummyPy134.png", bbox_inches="tight")
plt.clf()


# Generate a violin plot of 'hp' grouped horizontally by 'cyl'
plt.subplot(2,1,1)
sns.violinplot(x="cyl", y="hp", data=auto)

# Generate the same violin plot again with a color of 'lightgray' and without inner annotations
plt.subplot(2,1,2)
sns.violinplot(x="cyl", y="hp", data=auto, color="lightgray", inner=None)

# Overlay a strip plot on the violin plot
sns.stripplot(x="cyl", y="hp", data=auto, size=1.5, jitter=True)

# Display the plot
# plt.show()
plt.savefig("_dummyPy135.png", bbox_inches="tight")
plt.clf()


# Generate a joint plot of 'hp' and 'mpg'
sns.jointplot(x="hp", y="mpg", data=auto)

# Display the plot
# plt.show()
plt.savefig("_dummyPy136.png", bbox_inches="tight")
plt.clf()


# Generate a joint plot of 'hp' and 'mpg' using a hexbin plot
sns.jointplot(x="hp", y="mpg", data=auto, kind="hex")

# Display the plot
# plt.show()
plt.savefig("_dummyPy137.png", bbox_inches="tight")
plt.clf()


# Print the first 5 rows of the DataFrame
print(auto.head())

# Plot the pairwise joint distributions from the DataFrame 
sns.pairplot(auto)

# Display the plot
# plt.show()
plt.savefig("_dummyPy138.png", bbox_inches="tight")
plt.clf()


# Plot the pairwise joint distributions grouped by 'am' along with regression lines
sns.pairplot(auto, hue="am", kind="reg")

# Display the plot
# plt.show()
plt.savefig("_dummyPy139.png", bbox_inches="tight")
plt.clf()


# NEED DATA - cov_matrix is 5x5 with mpg-hp-weight-accel-displ
# Print the covariance matrix
# print(cov_matrix)

# Visualize the covariance matrix using a heatmap
# sns.heatmap(cov_matrix)

# Display the heatmap
# plt.show()

```


**Example #1: Seaborn Linear Regression Plot (sns.lmplot)**:  
![](_dummyPy128.png)  

**Example #2: Seaborn Residual Plot (sns.residplot)**:  
![](_dummyPy129.png)  

**Example #3: Labelled Plots (Raw Data, Order 1 Regression, Order 2 Regression)**:  
![](_dummyPy130.png)  

**Example #4: Regressions Stratified by Factor Using Colors**:  
![](_dummyPy131.png)  

**Example #5: Regression Stratified by Factor (Separate Plots)**:  
![](_dummyPy132.png)  

**Example #6: Strip Plot**:  
![](_dummyPy133.png)  

**Example #7: Swarm Plot**:  
![](_dummyPy134.png)  

**Example #8: Violin Plot**:  
![](_dummyPy135.png)  

**Example #9: Joint Plot (sns.jointplot)**:  
![](_dummyPy136.png)  

**Example #10: Joint Plot (Hexagonal)**:  
![](_dummyPy137.png)  

**Example #11: Pair Plot (sns.pairplot)**:  
![](_dummyPy138.png)  

**Example #12: Pair Plot Stratified Using Color (sns.pairplot)**:  
![](_dummyPy139.png)  
	
	
***
  
Chapter 4 - Analyzing time series  
  
Visualizing time series - example of the Austin 2010 weather data:  
  
* Time series have a "datetime" as their index, representing various time periods or time stamps  
* Time series are particularly valuable in pandas due to slicing - weather["2010-07-04"] will slice ALL rows from July 4, 2010 in "weather"  
* If the index has hourly data, could set dates = dates = weather.index[::96] to select every 96th record (which will be every fourth day)  
	* Can then format these dates using strftime - labels = dates.strftime("%b %d")  
    * plt.xticks(dates, labels, rotation=60)  # will place labels (formatted dates) at each of dates (every 4 days), rotated at 60 degrees  
  
Time series with moving windows - taking a sample statistic (such as average or max/min) over a longer time period:  
  
* Suppose that the temperature data is still hourly, and that resampled averages have been used to create DataFrame smoothed with columns ['1d', '3d', '7d', '14d']  
	* plt.plot(smoothed["2010-01"])  
    * plt.legend(smoothed.columns)  
    * plt.title("Temperature (Jan. 2010)")  
    * plt.xticks(rotation=60)  
    * plt.show()  
  
Histogram equilization in images - spreading out intensities so that subtle contrasts can be enhanced:  
  
* Investigating a histogram of pixel intensities can suggest whether the intensities may be insufficiently spread out  
	* The .flatten() method applied to a NumPy array will convert 2D data to 1D data  
    * The .reshape(myDF.shape) method applied to 1D data will re-shape the data to whatever is in myDF.shape  
* A basic rescaling of intensities is to run (X - X.min()) / (X.max() - X.min())  
	* The image may not look materially different, though  
* Can investigate the CDF as well as the PDF for the original image data  
	* plt.hist(pixels, bins=256, range=(0, 256), normed=True, color="blue", alpha=0.3)  
    * plt.twinx()  # set up the second y-axis, with graphs overlaid  
    * orig_cdf, bins, patches = plt.hist(pixels, cumulative=True, bins=256, range=(0, 256), normed=True, color="red", alpha=0.3)  
    * plt.title("Image histogram and CDF")  
    * plt.xlim(0, 255)  
    * plt.show()  
* Can use interpolation to equalize the intensity values - resulting CDF looks more like a ramp from 0-255 rather than being "spiky" around a small area  
	* new_pixels = np.interp(pixels, bins[:-1], orig_cdf * 255)  
    * plt.imshow(new_pixels.reshape(orig.shape))  
    * plt.axis("off")  
    * plt.title("Equalized image")  
    * plt.show()  
  
Example code includes:  
```{r engine='python', engine.path=list(python="C:\\Users\\Dave\\Anaconda3\\python.exe")}

myPath = "./PythonInputFiles/"



# Load the relevant stocks data
import pandas as pd
import numpy as np
from datetime import datetime

rawStocks = pd.read_csv(myPath + "StockChart_20170615.csv", header=None, index_col=None)
rawStocks["Date"] = [datetime.strptime(x.split()[0], "%m/%d/%Y") for x in rawStocks.iloc[:, 1]]
rawStocks["Price"] = [float(x.split()[1]) for x in rawStocks.iloc[:, 1]]


aapl = rawStocks.loc[rawStocks.iloc[:, 0] == "AAPL", ["Date", "Price"]].set_index("Date").sort_index()
goog = rawStocks.loc[rawStocks.iloc[:, 0] == "GOOG", ["Date", "Price"]].set_index("Date").sort_index()
ibm = rawStocks.loc[rawStocks.iloc[:, 0] == "IBM", ["Date", "Price"]].set_index("Date").sort_index()


# Import matplotlib.pyplot
import matplotlib.pyplot as plt

# Plot the aapl time series in blue
plt.plot(aapl, color="blue", label='AAPL')

# Plot the ibm time series in green
plt.plot(ibm, color='green', label='IBM')

# Plot the goog time series in red
plt.plot(goog, color='red', label='GOOG')

# Add a legend in the top left corner of the plot
plt.legend(loc='upper left')

# Specify the orientation of the xticks
plt.xticks(rotation=60)

# Display the plot
# plt.show()
plt.savefig("_dummyPy140.png", bbox_inches="tight")
plt.clf()

# Plot the series in the top subplot in blue
plt.subplot(2,1,1)
plt.xticks(rotation=45)
plt.title('AAPL: MAT June 2017')
plt.plot(aapl, color='blue')

# Slice aapl from '2017-01' to '2017-02' inclusive: view
view = aapl['2017-01':'2017-02']

# Plot the sliced data in the bottom subplot in black
plt.subplot(2,1,2)
plt.xticks(rotation=45)
plt.title('AAPL: 2017-01 to 2017-02')
plt.plot(view, color="black")

plt.tight_layout()
# plt.show()
plt.savefig("_dummyPy141.png", bbox_inches="tight")
plt.clf()


# Slice aapl from Nov. 2016 to Apr. 2017 inclusive: view
view = aapl['2016-11':'2017-04']

# Plot the sliced series in the top subplot in red
plt.subplot(2, 1, 1)
plt.plot(view, color="red")
plt.title('AAPL: Nov. 2016 to Apr. 2017')
plt.xticks(rotation=45)

# Reassign the series by slicing the month January 2017
view = aapl['2017-01']

# Plot the sliced series in the bottom subplot in green
plt.subplot(2, 1, 2)
plt.plot(view, color="green")
plt.title('AAPL: Jan. 2017')
plt.xticks(rotation=45)

# Improve spacing and display the plot
plt.tight_layout()
# plt.show()
plt.savefig("_dummyPy142.png", bbox_inches="tight")
plt.clf()

# Slice aapl from Nov. 2016 to Apr. 2017 inclusive: view
view = aapl['2016-11':'2017-04']

# Plot the entire series 
plt.plot(aapl)
plt.xticks(rotation=45)
plt.title('AAPL: MAT June 2017')

# Specify the axes
plt.axes([0.25, 0.5, 0.35, 0.35])

# Plot the sliced series in red using the current axes
plt.plot(view, color="red")
plt.xticks(rotation=45)
plt.title('2016/11-2017/04')

# plt.show()
plt.savefig("_dummyPy143.png", bbox_inches="tight")
plt.clf()


# BASED OFF THE aapl DATASET
mean_10 = aapl.rolling(window=10).mean()
mean_30 = aapl.rolling(window=30).mean()
mean_75 = aapl.rolling(window=75).mean()
mean_125 = aapl.rolling(window=125).mean()

# Plot the 10-day moving average in the top left subplot in green
plt.subplot(2, 2, 1)
plt.plot(mean_10, color="green")
plt.plot(aapl, 'k-.')
plt.xticks(rotation=60)
plt.title('10d averages')

# Plot the 30-day moving average in the top right subplot in red
plt.subplot(2, 2, 2)
plt.plot(mean_30, 'red')
plt.plot(aapl, 'k-.')
plt.xticks(rotation=60)
plt.title('30d averages')

# Plot the 75-day moving average in the bottom left subplot in magenta
plt.subplot(2, 2, 3)
plt.plot(mean_75, color="magenta")
plt.plot(aapl, 'k-.')
plt.xticks(rotation=60)
plt.title('75d averages')

# Plot the 125-day moving average in the bottom right subplot in cyan
plt.subplot(2, 2, 4)
plt.plot(mean_125, color="cyan")
plt.plot(aapl, 'k-.')
plt.xticks(rotation=60)
plt.title('125d averages')

# Display the plot
# plt.show()
plt.savefig("_dummyPy144.png", bbox_inches="tight")
plt.clf()



std_10 = aapl.rolling(window=10).std()
std_30 = aapl.rolling(window=30).std()
std_75 = aapl.rolling(window=75).std()
std_125 = aapl.rolling(window=125).std()

# Plot std_10 in red
plt.plot(std_10, color="red", label='10d')

# Plot std_30 in cyan
plt.plot(std_30, color="cyan", label='30d')

# Plot std_75 in green
plt.plot(std_75, color="green", label='75d')

# Plot std_125 in magenta
plt.plot(std_125, color="magenta", label='125d')

# Add a legend to the upper left
plt.legend(loc="upper left")

# Add a title
plt.title('Moving standard deviations')

# Display the plot
# plt.show()
plt.savefig("_dummyPy145.png", bbox_inches="tight")
plt.clf()


# IMAGE AVAILABLE AT https://commons.wikimedia.org/wiki/File:Unequalized_Hawkes_Bay_NZ.jpg
# Load the image into an array, keeping just one of the RGB layers: image
image = plt.imread(myPath + 'Unequalized_Hawkes_Bay_NZ.jpg')[:, :, 0]

# Display image in top subplot using color map 'gray'
plt.subplot(2,1,1)
plt.title('Original image')
plt.axis('off')
plt.imshow(image, cmap="gray")

# Flatten the image into 1 dimension: pixels
pixels = image.flatten()

# Display a histogram of the pixels in the bottom subplot
plt.subplot(2,1,2)
plt.xlim((0,255))
plt.title('Normalized histogram')
plt.hist(pixels, bins=64, range=(0, 256), normed=True, color="red", alpha=0.4)

# Display the plot
# plt.show()
plt.savefig("_dummyPy146.png", bbox_inches="tight")
plt.clf()


# Load the image into an array: image
image = plt.imread(myPath + 'Unequalized_Hawkes_Bay_NZ.jpg')[:, :, 0]

# Display image in top subplot using color map 'gray'
plt.subplot(2,1,1)
plt.imshow(image, cmap='gray')
plt.title('Original image')
plt.axis('off')

# Flatten the image into 1 dimension: pixels
pixels = image.flatten()

# Display a histogram of the pixels in the bottom subplot
plt.subplot(2,1,2)
pdf = plt.hist(pixels, bins=64, range=(0,256), normed=False,
               color='red', alpha=0.4)
plt.grid('off')

# Use plt.twinx() to overlay the CDF in the bottom subplot
plt.twinx()

# Display a cumulative histogram of the pixels
cdf = plt.hist(pixels, bins=64, range=(0,256),
               normed=True, cumulative=True,
               color='blue', alpha=0.4)
               
# Specify x-axis range, hide axes, add title and display plot
plt.xlim((0,256))
plt.grid('off')
plt.title('PDF & CDF (original image)')

# plt.show()
plt.savefig("_dummyPy147.png", bbox_inches="tight")
plt.clf()


# Load the image into an array: image
image = plt.imread(myPath + 'Unequalized_Hawkes_Bay_NZ.jpg')[:, :, 0]

# Flatten the image into 1 dimension: pixels
pixels = image.flatten()

# Generate a cumulative histogram
cdf, bins, patches = plt.hist(pixels, bins=256, range=(0,256), normed=True, cumulative=True)
new_pixels = np.interp(pixels, bins[:-1], cdf*255)

# Reshape new_pixels as a 2-D array: new_image
new_image = new_pixels.reshape(image.shape)

# Display the new image with 'gray' color map
plt.subplot(2,1,1)
plt.title('Equalized image')
plt.axis('off')
plt.imshow(new_image, cmap="gray")

# Generate a histogram of the new pixels
plt.subplot(2,1,2)
pdf = plt.hist(new_pixels, bins=64, range=(0,256), normed=False,
               color='red', alpha=0.4)
plt.grid('off')

# Use plt.twinx() to overlay the CDF in the bottom subplot
plt.twinx()
plt.xlim((0,256))
plt.grid('off')

# Add title
plt.title('PDF & CDF (equalized image)')

# Generate a cumulative histogram of the new pixels
cdf = plt.hist(new_pixels, bins=64, range=(0,256),
               cumulative=True, normed=True,
               color='blue', alpha=0.4)
# plt.show()
plt.savefig("_dummyPy148.png", bbox_inches="tight")
plt.clf()


# NEXT IMAGE AVAILABLE AT http://imgsrc.hubblesite.org/hu/db/images/hs-2004-32-b-small_web.jpg
# Load the image into an array: image
# image = plt.imread('hs-2004-32-b-small_web.jpg')

# Display image in top subplot
# plt.subplot(2,1,1)
# plt.title('Original image')
# plt.axis('off')
# plt.imshow(image)

# Extract 2-D arrays of the RGB channels: red, blue, green
# red, green, blue = image[:,:,0], image[:,:,1], image[:,:,2]

# Flatten the 2-D arrays of the RGB channels into 1-D
# red_pixels = red.flatten()
# blue_pixels = blue.flatten()
# green_pixels = green.flatten()

# Overlay histograms of the pixels of each color in the bottom subplot
# plt.subplot(2,1,2)
# plt.title('Histograms from color image')
# plt.xlim((0,256))
# plt.hist(red_pixels, bins=64, normed=True, color='red', alpha = 0.2)
# plt.hist(blue_pixels, bins=64, normed=True, color='blue', alpha = 0.2)
# plt.hist(green_pixels, bins=64, normed=True, color='green', alpha = 0.2)

# Display the plot
# plt.show()


# Load the image into an array: image
# image = plt.imread('hs-2004-32-b-small_web.jpg')

# Extract RGB channels and flatten into 1-D array
# red, blue, green = image[:,:,0], image[:,:,1], image[:,:,2]
# red_pixels = red.flatten()
# blue_pixels = blue.flatten()
# green_pixels = green.flatten()

# Generate a 2-D histogram of the red and green pixels
# plt.subplot(2,2,1)
# plt.grid('off') 
# plt.xticks(rotation=60)
# plt.xlabel('red')
# plt.ylabel('green')
# plt.hist2d(x=red_pixels, y=green_pixels, bins=(32, 32))

# Generate a 2-D histogram of the green and blue pixels
# plt.subplot(2,2,2)
# plt.grid('off')
# plt.xticks(rotation=60)
# plt.xlabel('green')
# plt.ylabel('blue')
# plt.hist2d(x=green_pixels, y=blue_pixels, bins=(32, 32))

# Generate a 2-D histogram of the blue and red pixels
# plt.subplot(2,2,3)
# plt.grid('off')
# plt.xticks(rotation=60)
# plt.xlabel('blue')
# plt.ylabel('red')
# plt.hist2d(x=blue_pixels, y=red_pixels, bins=(32, 32))

# Display the plot
# plt.show()


```
  
  
**Example #1: Multiple Time Series on a Single Plot**:  
![](_dummyPy140.png)  

**Example #2: Multiple Time Series on Separate Sub-Plots**:  
![](_dummyPy141.png) 

**Example #3: Multiple Time Series on Separate Sub-Plots**:  
![](_dummyPy142.png) 

**Example #4: Multiple Time Series as Callout on Single Main Plot**:  
![](_dummyPy143.png) 

**Example #5: Rolling Mean Stock Prices (AAPL 10-d, 30-d, 75-d, 125-d)**:  
![](_dummyPy144.png) 

**Example #6: Rolling Standard Deviation of Stock Prices (AAPL 10-d, 30-d, 75-d, 125-d)**:  
![](_dummyPy145.png) 

**Example #7: Grayscale Image and Pixel Histogram**:  
![](_dummyPy146.png) 

**Example #8: Grayscale Image and Pixel CDF/PDF**:  
![](_dummyPy147.png) 

**Example #9: Original Grayscale Image and Normalized Grayscale Image**:  
![](_dummyPy148.png) 
  

###_Interactive Data Visualization with Bokeh_#  
  
Chapter 1 - Basic plotting with Bokeh  
  
Plotting with glyphs - visual shapes that can be drawn to the screen (line, points, rectangles, etc.):  
  
* Glyphs may have many properties - coordinates, size, color, transparency (alpha), etc.  
* General usage includes "from bokeh.io import output_file, show" AND "from bokeh.plotting import figure"  
	* plot = figure(width=400, tools="pan,box_zoom")  
    * plot.circle([1, 2, 3, 4, 5], [8, 6, 5, 2, 3])  
    * output_file("circle.html")  
    * show(plot)  
* Can set glyph properties using lists, arrays, sequences, etc.  
	* Can also set glyph values using a single fixed value, which will be propagated to all glyphs  
    * There are many default values that will be applied if not supplied  
  
Additional glyphs - available by default in Bokeh:  
  
* Lines can be created using the .line() method for a Bokeh figure  
* Glyphs will be drawn in the method called, so circles on top of lines can be generated with .line() followed later by .circle()  
* Patches can be useful for drawing geographic regions  
	* Data is provided to patches as a list of lists - one list has the patch X coordinates and another list has the patch y coordinates  
    * xs = [ [1, 1, 2, 2] , [2, 2, 4] , [2, 2, 3, 3] ]  
    * ys = [ [2, 5, 5, 2] , [3, 5, 5] , [2, 3, 4, 2] ]  
    * plot = figure() ; plot.patches(xs, ys, fill_color=["red", "blue", "green"], line_color="white")  
* While not covered in this course, there are many other types of glyphs - see the documentation for Bokeh  
  
Data formats - can pass lists, NumPy arrays, etc. as inputs to the glyphs:  
  
* Can pass the 1D NumPy arrays directly to the x and y arguments for Bokeh  
* Can also use pandas DataFrames, using the standard x["myVar"] to pull out the DataSeries of interest  
	* There appears to be a bokeh.sampledata that may have some of the standard datasets such as iris  
* Column Data Source - underlies most of the data structures in Bokeh  
	* Dictionaries for mapping string column names to sequences of data ; often created automatically  
    * Can be beneficial to create a Column Data Source directly - pass to multiple glyphs to link selections, enable use during hovering, etc.  
    * from bokeh.models import ColumnDataSource  
    * source = ColumnDataSource(data={"x":[] , "y":[]})  # just an example . . . All columns in the ColumnDataSource() must be the same length . . .   
    * An additional idea is to run a = ColumnDataSource(myDF), with a now being available anywhere as a ColumnDataSource()  
  
Customizing glyphs - actions in response to hovering, user clicks, etc.:  
  
* The tools are generally added as arguments to the figure(tools="box_select, lasso_select") function  
	* Arguments for what to do with "non-selected" points can be passed to the glyph  
    * plot.circle(x, y, selection_color="red", nonselection_fill_alpha = 0.2, nonselection_fill_color="grey")  # color is short-hand for fill_color and line_color  
* Hovering is more sophisticated and governs how the glyphs will react when hovered over  
	* from bokeh.models import HoverTool  
    * hover = HoverTool(tooltips=None, mode="hline")  
    * plot = figure(tools=[hover, "crosshair"])  
    * plot.circle(x, y, size=15, hover_color="red")  
* Color mapping - for example, colors by Species in the "iris" dataset  
	* from bokeh.models import CategoricalColorMapper
    * mapper = CategoricalColorMapper( factors=["setosa", "virginica", "versicolor"], palette=["red", "green", "blue"])  
    * plot.circle("x", "y", source=source, color={"field":"species", "transform":mapper})  
  
Example code includes:  
```{r engine='python', engine.path=list(python="C:\\Users\\Dave\\Anaconda3\\python.exe")}

myPath = "./PythonInputFiles/"



# Import figure from bokeh.plotting
from bokeh.plotting import figure

# Import output_file and show from bokeh.io
from bokeh.io import output_file, show


import pandas as pd
rawGap = pd.read_csv(myPath + "literacy_birth_rate.csv", index_col=None)
fertility = rawGap["fertility"]
female_literacy = rawGap["female literacy"]


# Create the figure: p
p = figure(x_axis_label='fertility (children per woman)', y_axis_label='female_literacy (% population)')

# Add a circle glyph to the figure p
p.circle(fertility, female_literacy)

# Call the output_file() function and specify the name of the file
output_file(myPath + "fert_lit.html")

# Display the plot
# show(p)


# Create the figure: p
p = figure(x_axis_label='fertility', y_axis_label='female_literacy (% population)')

fertility_latinamerica = fertility[rawGap["Continent"] == "LAT"]
female_literacy_latinamerica = female_literacy[rawGap["Continent"] == "LAT"]

# Add a circle glyph to the figure p
p.circle(fertility_latinamerica, female_literacy_latinamerica)

fertility_africa = fertility[rawGap["Continent"] == "AF"]
female_literacy_africa = female_literacy[rawGap["Continent"] == "AF"]

# Add an x glyph to the figure p
p.x(fertility_africa, female_literacy_africa)

# Specify the name of the file
output_file(myPath + 'fert_lit_separate.html')

# Display the plot
# show(p)


# Create the figure: p
p = figure(x_axis_label='fertility (children per woman)', y_axis_label='female_literacy (% population)')

# Add a blue circle glyph to the figure p
p.circle(fertility_latinamerica, female_literacy_latinamerica, color="blue", size=10, alpha=0.8)

# Add a red circle glyph to the figure p
p.circle(fertility_africa, female_literacy_africa, color="red", size=10, alpha=0.8)

# Specify the name of the file
output_file(myPath + 'fert_lit_separate_colors.html')

# Display the plot
# show(p)


# AAPL share price - 2000 to 2014
from datetime import datetime

aaplRaw = pd.read_csv(myPath + "aapl_2000_2014.csv", index_col=0)
date = [datetime.strptime(x, "%Y-%m-%d") for x in aaplRaw["date"]]
price = aaplRaw["adj_close"]

# Import figure from bokeh.plotting
from bokeh.plotting import figure

# Create a figure with x_axis_type="datetime": p
p = figure(x_axis_type="datetime", x_axis_label='Date', y_axis_label='US Dollars')

# Plot date along the x axis and price along the y axis
p.line(date, price)

# Specify the name of the output file and show the result
output_file(myPath + 'line.html')
# show(p)


# Import figure from bokeh.plotting
from bokeh.plotting import figure

# Create a figure with x_axis_type='datetime': p
p = figure(x_axis_type='datetime', x_axis_label='Date', y_axis_label='US Dollars')

# Plot date along the x-axis and price along the y-axis
p.line(date, price)

# With date on the x-axis and price on the y-axis, add a white circle glyph of size 4
p.circle(date, price, fill_color="white", size=4)

# Specify the name of the output file and show the result
output_file(myPath + 'line.html')
# show(p)


# Create a list of az_lons, co_lons, nm_lons and ut_lons: x
# x = [az_lons, co_lons, nm_lons, ut_lons]

# Create a list of az_lats, co_lats, nm_lats and ut_lats: y
# y = [az_lats, co_lats, nm_lats, ut_lats]

# Add patches to figure p with line_color=white for x and y
# p.patches(x, y, line_color="white")

# Specify the name of the output file and show the result
# output_file('four_corners.html')
# show(p)


# Import numpy as np
import numpy as np

# Create array using np.linspace: x
x = np.linspace(0, 5, 100)

# Create array using np.cos: y
y = np.cos(x)

# Add circles at x and y
p.circle(x, y)

# Specify the name of the output file and show the result
output_file(myPath + 'numpy.html')
# show(p)


# Import pandas as pd
import pandas as pd

# Read in the CSV file: df
df = pd.read_csv(myPath + "auto-mpg.csv")

# Import figure from bokeh.plotting
from bokeh.plotting import figure

# Create the figure: p
p = figure(x_axis_label='HP', y_axis_label='MPG')

# Plot mpg vs hp by color
p.circle(df["hp"], df["mpg"], size=10, color=df["color"])

# Specify the name of the output file and show the result
output_file(myPath + 'auto-df.html')
# show(p)


# Import the ColumnDataSource class from bokeh.plotting
from bokeh.plotting import ColumnDataSource

# Create a ColumnDataSource from df: source
source = ColumnDataSource(df)

# Add circle glyphs to the figure p
p.circle("yr", "accel", source=source, color="color", size=8)

# Specify the name of the output file and show the result
output_file(myPath + 'sprint.html')
# show(p)


# Create a figure with the "box_select" tool: p
p = figure(x_axis_label="Year", y_axis_label="Accel", tools="box_select")

# Add circle glyphs to the figure p with the selected and non-selected properties
p.circle("yr", "accel", source=source, selection_color="red", nonselection_alpha=0.1)

# Specify the name of the output file and show the result
output_file(myPath + 'selection_glyph.html')
# show(p)


# import the HoverTool
# from bokeh.models import HoverTool

# Add circle glyphs to figure p
# p.circle(x, y, size=10,
#          fill_color="grey", alpha=0.1, line_color=None,
#          hover_fill_color="firebrick", hover_alpha=0.5,
#          hover_line_color="white")

# Create a HoverTool: hover
# hover = HoverTool(tooltips=None, mode="vline")

# Add the hover tool to the figure p
# p.add_tools(hover)

# Specify the name of the output file and show the result
# output_file(myPath + 'hover_glyph.html')
# show(p)


#Import CategoricalColorMapper from bokeh.models
from bokeh.models import CategoricalColorMapper

# Convert df to a ColumnDataSource: source
source = ColumnDataSource(df)

# Make a CategoricalColorMapper object: color_mapper
color_mapper = CategoricalColorMapper(factors=['Europe', 'Asia', 'US'],
                                      palette=['red', 'green', 'blue'])

# Add a circle glyph to the figure p
p.circle("weight", 'mpg', source=source,
            color=dict(field='origin', transform=color_mapper),
            legend='origin')

# Specify the name of the output file and show the result
output_file(myPath + 'colormap.html')
# show(p)


```
  
  
***
  
Chapter 2 - Layouts, Interactions, and Annotations  
  
Introduction to Layouts - annotations, links across plots, etc.:  
  
* Placing plots in rows and columns  
	* from bokeh.layouts import row # can alternately run 'from bokeh.layouts import column' and then 'layout = column(p1, p2, p3)  
    * layout = row(p1, p2, p3)  # assumes that p1, p2, and p3 have already been created as desired using figure() and something like .circle() or .line() or the like  
    * Can also nest the columns and rows, such as layout = row(column(p1, p2), p3)  
  
Advanced Layouts - continuing with gridded layouts and tabbed layouts:  
  
* Gridded arrangements - start with 'from bokeh.layouts import gridplot'  
	* The arguments to gridplot include a list of lists, with each list being a row (as such, the inner lists need to all be the same length)  
    * There is then a single master toolbar that will zoom/pan on all the gridded data at once; set toolbar_location = None to override this, or specify a preferred location  
    * layout = gridplot([[None, p1], [p2, p3]], toolbar_location = None)  
* Tabbed layouts - creating a panel for each tab, then collecting all of the tabs in to a tabbed object  
	* from bokeh.models.widgets import Tabs, Panel  
    * first = Panel(child=row(p1, p2), title="first")  # child can be just about anything - single plot, grid, whatever  
    * second = Panel(child=row(p3), title="second")  # child can be just about anything - single plot, grid, whatever  
    * tabs = Tabs(tabs=[first, second])  
    * The final output will then be two tabs, allowing the user to click between a tab with p1, p2 and a tab with p3  
  
Linking plots together - for example, keeping the ranges of two plots synchronized (even when panning or zooming occurs):  
  
* To link together the x_axes, run a command like p3.x_range = p2.x_range = p1.x_range  
* To link together the y_axes, run a command like p3.y_range = p2.y_range = p1.y_range  
* To link to a common data source, run source = CommonDataSource(myDF), and then source=source in all of the plots - data will be the same, and can pick/choose columns as needed  
	* This seems to mean that when highlighting occurs on one of the plots, the corresponding data in the other plots are also highlighted  
    * "Linked brushing" seems to be the term for having the data linked in this fashion  
  
Annotations and guides - better communicate findings from the data:  
  
* Guides - helping to relate scale information to viewers  
	* Axes and Grids - typically, Bokeh defaults are reasonably solid for these already (not covered further in this course)  
* Legends serve as a common type of "guide" that explains the visual encodings  
	* The simplest way to install the legend would be p1.legend.location = "top_left"  # assume that p1 is already created using figure() and something like .circle(legend="species") if the desired legend is species  
* "Hover Tooltips" offer a way for people to drill down in to details that are otherwise not visible on the plot  
	* from bokeh.models import HoverTool  
    * hover = HoverTool(tooltips=[ ("species name", "@species"), ("petal length", "@petal_length") ] )  # pass list of tuples to HoverTool(), with the "@" being a special symbol meaning "column of the ColumnDataSource"  
    * plot = figure(tools=[hover, "pan", "wheel_zoom"])  
  
Example code includes:  
```{r engine='python', engine.path=list(python="C:\\Users\\Dave\\Anaconda3\\python.exe")}

myPath = "./PythonInputFiles/"



# Import row from bokeh.layouts
from bokeh.layouts import row
from bokeh.plotting import ColumnDataSource, figure
from bokeh.io import output_file, show

import pandas as pd
rawGap = pd.read_csv(myPath + "literacy_birth_rate.csv", index_col=None)
rawGap.columns = ["Country", "Continent", "female_literacy", "fertility", "population"]


source = ColumnDataSource(rawGap)


# Create the first figure: p1
p1 = figure(x_axis_label='fertility (children per woman)', y_axis_label='female_literacy (% population)')

# Add a circle glyph to p1
p1.circle("fertility", "female_literacy", source=source)

# Create the second figure: p2
p2 = figure(x_axis_label='population', y_axis_label='female_literacy (% population)')

# Add a circle glyph to p2
p2.circle("population", "female_literacy", source=source)

# Put p1 and p2 into a horizontal row: layout
layout = row(p1, p2)

# Specify the name of the output_file and show the result
output_file(myPath + 'fert_row.html')
# show(layout)


# Import column from the bokeh.layouts module
from bokeh.layouts import column

# Create a blank figure: p1
p1 = figure(x_axis_label='fertility (children per woman)', y_axis_label='female_literacy (% population)')

# Add circle scatter to the figure p1
p1.circle('fertility', 'female_literacy', source=source)

# Create a new blank figure: p2
p2 = figure(x_axis_label="population", y_axis_label='female_literacy (% population)')

# Add circle scatter to the figure p2
p2.circle("population", "female_literacy", source=source)

# Put plots p1 and p2 in a column: layout
layout = column(p1, p2)

# Specify the name of the output_file and show the result
output_file(myPath + 'fert_column.html')
# show(layout)


# Import column and row from bokeh.layouts
from bokeh.layouts import row, column

# Make a column layout that will be used as the second row: row2
# row2 = column([mpg_hp, mpg_weight], sizing_mode='scale_width')

# Make a row layout that includes the above column layout: layout
# layout = row([avg_mpg, row2], sizing_mode='scale_width')

# Specify the name of the output_file and show the result
# output_file(myPath + 'layout_custom.html')
# show(layout)


# Import gridplot from bokeh.layouts
from bokeh.layouts import gridplot

# Create a list containing plots p1 and p2: row1
# row1 = [p1, p2]

# Create a list containing plots p3 and p4: row2
# row2 = [p3, p4]

# Create a gridplot using row1 and row2: layout
# layout = gridplot([row1, row2])

# Specify the name of the output_file and show the result
# output_file(myPath + 'grid.html')
# show(layout)


# Import Panel from bokeh.models.widgets
from bokeh.models.widgets import Panel

# Create a blank figure: p1
source = ColumnDataSource(rawGap.loc[rawGap["Continent"] == "LAT", :])
p1 = figure(x_axis_label='fertility (children per woman)', y_axis_label='female_literacy (% population)')
p1.circle('fertility', 'female_literacy', source=source)

source = ColumnDataSource(rawGap.loc[rawGap["Continent"] == "AF", :])
p2 = figure(x_axis_label='fertility (children per woman)', y_axis_label='female_literacy (% population)')
p2.circle('fertility', 'female_literacy', source=source)

source = ColumnDataSource(rawGap.loc[rawGap["Continent"] == "ASI", :])
p3 = figure(x_axis_label='fertility (children per woman)', y_axis_label='female_literacy (% population)')
p3.circle('fertility', 'female_literacy', source=source)

source = ColumnDataSource(rawGap.loc[rawGap["Continent"] == "EUR", :])
p4 = figure(x_axis_label='fertility (children per woman)', y_axis_label='female_literacy (% population)')
p4.circle('fertility', 'female_literacy', source=source)

source = ColumnDataSource(rawGap)

# Create tab1 from plot p1: tab1
tab1 = Panel(child=p1, title='Latin America')

# Create tab2 from plot p2: tab2
tab2 = Panel(child=p2, title='Africa')

# Create tab3 from plot p3: tab3
tab3 = Panel(child=p3, title='Asia')

# Create tab4 from plot p4: tab4
tab4 = Panel(child=p4, title='Europe')


# Import Tabs from bokeh.models.widgets
from bokeh.models.widgets import Tabs

# Create a Tabs layout: layout
layout = Tabs(tabs=[tab1, tab2, tab3, tab4])

# Specify the name of the output_file and show the result
output_file(myPath + 'tabs.html')
# show(layout)


# Link the x_range of p2 to p1: p2.x_range
p2.x_range = p1.x_range

# Link the y_range of p2 to p1: p2.y_range
p2.y_range = p1.y_range

# Link the x_range of p3 to p1: p3.x_range
p3.x_range = p1.x_range

# Link the y_range of p4 to p1: p4.y_range
p4.y_range = p1.y_range

# Specify the name of the output_file and show the result
output_file(myPath + 'linked_range.html')
# show(layout)


# Create ColumnDataSource: source
source = ColumnDataSource(rawGap)

# Create the first figure: p1
p1 = figure(x_axis_label='fertility (children per woman)', y_axis_label='female literacy (% population)',
            tools="box_select,lasso_select")

# Add a circle glyph to p1
p1.circle("fertility", "female_literacy", source=source)

# Create the second figure: p2
p2 = figure(x_axis_label='fertility (children per woman)', y_axis_label='population (millions)',
            tools="box_select,lasso_select")

# Add a circle glyph to p2
p2.circle("fertility", "population", source=source)

# Create row layout of figures p1 and p2: layout
layout = row(p1, p2)

# Specify the name of the output_file and show the result
output_file(myPath + 'linked_brush.html')
# show(layout)


# Add the first circle glyph to the figure p
# p.circle('fertility', 'female_literacy', source=latin_america, size=10, color="red", legend="Latin America")

# Add the second circle glyph to the figure p
# p.circle('fertility', 'female_literacy', source=africa, size=10, color="blue", legend="Africa")

# Specify the name of the output_file and show the result
# output_file(myPath + 'fert_lit_groups.html')
# show(p)


# Assign the legend to the bottom left: p.legend.location
# p.legend.location = "bottom_left"

# Fill the legend background with the color 'lightgray': p.legend.background_fill_color
# p.legend.background_fill_color = "lightgray"

# Specify the name of the output_file and show the result
# output_file(myPath + 'fert_lit_groups.html')
# show(p)


# Import HoverTool from bokeh.models
from bokeh.models import HoverTool

# Create a HoverTool object: hover
# hover = HoverTool(tooltips=[('Country','@Country')])

# Add the HoverTool object to figure p
# p.add_tools(hover)

# Specify the name of the output_file and show the result
# output_file(myPath + 'hover.html')
# show(p)


```
  
  
***
  
Chapter 3 - High-Level Charts  
  
Pre-set interfaces to simlify chart design for common graphs like Histograms, Box-plots and Scatter-plots:  
  
Histograms - start with "from bokeh.charts import Histogram":  
  
* Single histogram creation, including optionally specifying the number of bins  
	* p = Histogram(myDF, "myColumn", title="myTitle", bins=n)  # note that myDF is a pandas DataFrame, and that a default number of bins will be selected if not specified  
    * show(p)  
* Multiple histogram creation, each colored by a factor variable  
	* p = Histogram(myDF, "myColumn", color="myFactor", title="myTitle", bins=n)  # note that myDF is a pandas DataFrame, and that a default number of bins will be selected if not specified  
  
BoxPlots - start with "from bokeh.charts import BoxPlot":  
  
* p = BoxPlot(df, values="myQuantVariable", label="myGroupingVariable", color="myGroupingVariable", title="myTitle")  # label == color means each group will be colored differently  
* show(p)  
  
Scatter Plots - main advantage relative to using glyphs as per previous chapters is certain automation of grouping options:  
  
* from bokeh.charts import Scatter  
* p = Scatter(myDF, x="myXColumn", y="myYColumn", title="myTitle", color="myColorVariable",  marker="myMarkerVariable")  # color/marker is optional; by default, x and y become the axis labels also  
  
Example code includes:  
```{r engine='python', engine.path=list(python="C:\\Users\\Dave\\Anaconda3\\python.exe")}

myPath = "./PythonInputFiles/"



from bokeh.layouts import row
from bokeh.plotting import ColumnDataSource, figure
from bokeh.io import output_file, show

import pandas as pd
rawGap = pd.read_csv(myPath + "literacy_birth_rate.csv", index_col=None)
rawGap.columns = ["Country", "Continent", "female_literacy", "fertility", "population"]


source = ColumnDataSource(rawGap)


# Import Histogram, output_file, and show from bokeh.charts
from bokeh.charts import Histogram, output_file, show

# Make a Histogram: p
p = Histogram(rawGap, "female_literacy", title="Female Literacy")

# Set the x axis label
p.xaxis.axis_label = ""

# Set the y axis label
p.yaxis.axis_label = ""

# Specify the name of the output_file and show the result
output_file(myPath + "histogram.html")
# show(p)


# Import Histogram, output_file, and show from bokeh.charts
from bokeh.charts import Histogram, output_file, show

# Make the Histogram: p
p = Histogram(rawGap, "female_literacy", title='Female Literacy', bins=40)

# Set axis labels
p.xaxis.axis_label = 'Female Literacy (% population)'
p.yaxis.axis_label = 'Number of Countries'

# Specify the name of the output_file and show the result
output_file(myPath + 'histogram.html')
# show(p)


# Import Histogram, output_file, and show from bokeh.charts
from bokeh.charts import Histogram, output_file, show

# Make a Histogram: p
p = Histogram(rawGap, "female_literacy", title='Female Literacy',
              color="Continent", legend="top_left")

# Set axis labels
p.xaxis.axis_label = 'Female Literacy (% population)'
p.yaxis.axis_label = 'Number of Countries'

# Specify the name of the output_file and show the result
output_file(myPath + 'hist_bins.html')
# show(p)


# Import BoxPlot, output_file, and show from bokeh.charts
from bokeh.charts import BoxPlot, output_file, show

# Make a box plot: p
p = BoxPlot(rawGap, values="female_literacy", label="Continent",
            title='Female Literacy (grouped by Continent)', legend='bottom_right')

# Set the y axis label
p.yaxis.axis_label = 'Female literacy (% population)'

# Specify the name of the output_file and show the result
output_file(myPath + 'boxplot.html')
# show(p)


# Import BoxPlot, output_file, and show
from bokeh.charts import BoxPlot, output_file, show

# Make a box plot: p
p = BoxPlot(rawGap, values="female_literacy", label='Continent', color="Continent",
            title='Female Literacy (grouped by Continent)', legend="bottom_right")

# Set y-axis label
p.yaxis.axis_label = 'Female literacy (% population)'

# Specify the name of the output_file and show the result
output_file(myPath + 'boxplot.html')
# show(p)


# Import Scatter, output_file, and show from bokeh.charts
from bokeh.charts import Scatter, output_file, show

# Make a scatter plot: p
p = Scatter(rawGap, x="population", y="female_literacy",
            title='Female Literacy vs Population')

# Set the x-axis label
p.xaxis.axis_label = "Population"

# Set the y-axis label
p.yaxis.axis_label = "Female Literacy"

# Specify the name of the output_file and show the result
output_file(myPath + 'scatterplot.html')
# show(p)


# Import Scatter, output_file, and show from bokeh.charts
from bokeh.charts import Scatter, output_file, show

# Make a scatter plot such that each circle is colored by its continent: p
p = Scatter(rawGap, x="population", y="female_literacy", color="Continent",
            title='Female Literacy vs Population')

# Set x-axis and y-axis labels
p.xaxis.axis_label = 'Population (millions)'
p.yaxis.axis_label = 'Female literacy (% population)'

# Specify the name of the output_file and show the result
output_file(myPath + 'scatterplot.html')
# show(p)


# Import Scatter, output_file, and show from bokeh.charts
from bokeh.charts import Scatter, output_file, show

# Make a scatter plot such that each continent has a different marker type: p
p = Scatter(rawGap, x="population", y="female_literacy", color="Continent", marker="Continent", title="Female Literacy vs. Population")

# Set x-axis and y-axis labels
p.xaxis.axis_label = 'Population (millions)'
p.yaxis.axis_label = 'Female literacy (% population)'

# Specify the name of the output_file and show the result
output_file(myPath + 'scatterplot.html')
# show(p)

```
  
  
***
  
Chapter 4 - Building Interactivity  
  
Introducing the Bokeh Server - expanding from the default static html, js, etc.:  
  
* Purpose of the Bokeh server is to connect user-inputs on the plot directly to a series of Python commands "behind the scenes"  
	1.  from bokeh.io import curdoc  (This will hold everything that we create down the line)  
    2.  create plots and widgets  
    3.  Add callbacks  
    4.  Arrange plot and widgets in layouts  
    5.  curdoc().add_root(layout)  (This loads the curdoc with everything we did in steps 2-4)  
* Bokeh is run by way of shell or Windows command line - "bokeh serve --show myapp.py"  # where 'myapp.py' is a stand-in for whatever the file happens to be  
	* Alternately, to pull a full directory, "bokeh serve --show myappdir/  
  
Connecting sliders to plots - frequently, the ColumnDataSource() is especially valuable for desired interactivity:  
  
* Suppose that a plot=figure() ; plot.circle(...) has been created as well as slider=Slider(.)  
* Next, define a function "callback" that has exactly three arguments "attr", "old", and "new" - so def callback(attr, old, new):  
	* This function "callback" and the arguments "attr", "old", "new" should always be used - not the place to get creative with names, apparently  
    * Can set N = slider.value to get the current value of the slider  
    * Can set source.data = { } to update the data that is used as ColumnDataSource() 
* Finally, link the function to the slider change using slider.on_change("value", callback)  # The "value" means that we want to run whenever the "value" property of the slider changes  
	* If setting layout = column(slider, plot) then the slider will be placed above the plot  
* And, set curdoc().add_root(layout) to link the slider and plot from "layout" in to current working space  
  
Updating plots from drop-downs - similar in many ways to setting up the sliders:  
  
* Suppose that a plot=figure() ; plot.circle(...) has been created  
* Bring in the drop-down capability, which is called "Select" ; "from bokeh.models import Select"  
	* menu = Select(options=["uniform", "normal", "lognormal"], value="uniform", title="Distribution")  # sets up menu as a drop-down with 3 options and "uniform" the default/current choice  
* Next, define a function "callback" that must still have exactly three arguments - "attr", "old", and "new"  
	* Can define a function f based on menu.value, such as if menu.value == "uniform": f=random  
    * source.data = {"x": f(size=N), "y": f(size=N) }  
* Lastly, link the drop-down to the data using menu.on_change("value", callback)  
	* If setting layout = column(menu, plot) then the drop-down will be placed above the plot  
* And, set curdoc().add_root(layout) to link the drop-down and plot from "layout" in to the current working space  
  
Buttons are the third example of a Bokeh widget (many other examples available in the documentation):  
  
* A primary difference with button clicks is that they are merely a yes/no event ; there is no inherent "value" to a button-click  
* Bring in the buttons capability, which is called "Button"; "from bokeh.models import Button"  
	* button = Button(label="press me")  
* Next define a call-back function (which can actually have any name), with no arguments  
	* Assign the function to do whatever you want upon the button click  
* Lastly, link up the button-click to the data using button.on_click(callback)  # or replace callback by the name of the function as defined above  
* There are also other "button types" such as Toggle, CheckboxGroup, and RadioGroup - these have both an on/off and an associated value (so more like a drop-down)  
	* Callbacks for these button types take a single argument, active  
  
Hosting applications for wider audiences - can run locally or send to someone else (with code) for them to run locally:  
  
* To make more broadly available, look at "Running Bokeh Server" for options  
* Bokeh Applications can now also be run easily using Anaconda Cloud  
  
Example code includes:  
```{r engine='python', engine.path=list(python="C:\\Users\\Dave\\Anaconda3\\python.exe")}

myPath = "./PythonInputFiles/"



# Perform necessary imports
from bokeh.io import curdoc
from bokeh.plotting import ColumnDataSource, figure
from bokeh.layouts import row, column


# Create a new plot: plot
plot = figure()

# Add a line to the plot
plot.line([1,2,3,4,5], [2,5,4,6,7])

# Add the plot to the current document
curdoc().add_root(plot)


# Perform the necessary imports
from bokeh.io import curdoc
from bokeh.layouts import widgetbox
from bokeh.models import Slider

# Create a slider: slider
slider = Slider(title='my slider', start=0, end=10, step=0.1, value=2)

# Create a widgetbox layout: layout
layout = widgetbox(slider)

# Add the layout to the current document
curdoc().add_root(layout)


# Perform necessary imports
from bokeh.io import curdoc
from bokeh.layouts import widgetbox
from bokeh.models import Slider, Button

# Create first slider: slider1
slider1 = Slider(title="slider1", start=0, end=10, step=0.1, value=2)

# Create second slider: slider2
slider2 = Slider(title="slider2", start=10, end=100, step=1, value=20)

# Add slider1 and slider2 to a widgetbox
layout = widgetbox(slider1, slider2)

# Add the layout to the current document
curdoc().add_root(layout)


# Create ColumnDataSource: source
x = [1, 2, 3, 4, 5]
y = [2, 5, 4, 6, 7]
source = ColumnDataSource( data={"x":x , "y":y} )

# Add a line to the plot
plot.line("x", "y", source=source)

# Create a column layout: layout
layout = column(widgetbox(slider), plot)

# Add the layout to the current document
curdoc().add_root(layout)


# Define a callback function: callback
def callback(attr, old, new):
    
    # Read the current value of the slider: scale
    scale = slider.value
    
    # Compute the updated y using np.sin(scale/x): new_y
    new_y = np.sin(scale/x)
    
    # Update source with the new data values
    source.data = {'x': x, 'y': new_y}

# Attach the callback to the 'value' property of slider
slider.on_change("value", callback)

# Create layout and add to current document
layout = column(widgetbox(slider), plot)
curdoc().add_root(layout)


# Perform necessary imports
from bokeh.models import ColumnDataSource, Select


import pandas as pd
rawGap = pd.read_csv(myPath + "literacy_birth_rate.csv", index_col=None)
fertility = rawGap["fertility"]
female_literacy = rawGap["female literacy"]
population = rawGap["population"]


# Create ColumnDataSource: source
source = ColumnDataSource(data={
    'x' : fertility,
    'y' : female_literacy
})

# Create a new plot: plot
plot = figure()

# Add circles to the plot
plot.circle('x', 'y', source=source)

# Define a callback function: update_plot
def update_plot(attr, old, new):
    # If the new Selection is 'female_literacy', update 'y' to female_literacy
    if new == "female_literacy": 
        source.data = {
            'x' : fertility,
            'y' : female_literacy
        }
    # Else, update 'y' to population
    else:
        source.data = {
            'x' : fertility,
            'y' : population
        }

# Create a dropdown Select widget: select    
select = Select(title="distribution", options=["female_literacy", "population"], value="female_literacy")

# Attach the update_plot callback to the 'value' property of select
select.on_change("value", update_plot)

# Create layout and add to current document
layout = row(select, plot)
curdoc().add_root(layout)


# Create two dropdown Select widgets: select1, select2
select1 = Select(title='First', options=['A', 'B'], value='A')
select2 = Select(title='Second', options=['1', '2', '3'], value='1')

# Define a callback function: callback
def callback(attr, old, new):
    # If select1 is 'A' 
    if select1.value == "A":
        # Set select2 options to ['1', '2', '3']
        select2.options = ['1', '2', '3']
        
        # Set select2 value to '1'
        select2.value = "1"
    else:
        # Set select2 options to ['100', '200', '300']
        select2.options = ['100', '200', '300']
        
        # Set select2 value to '100'
        select2.value = "100"

# Attach the callback to the 'value' property of select1
select1.on_change("value", callback)

# Create layout and add to current document
layout = widgetbox(select1, select2)
curdoc().add_root(layout)


# Create a Button with label 'Update Data'
button = Button(label="Update Data")

# Define an update callback with no arguments: update
def update():
    
    # Compute new y values: y
    y = np.sin(x) + np.random.random(N)
    
    # Update the ColumnDataSource data dictionary
    source.data = {"x":x, "y":y}

# Add the update callback to the button
button.on_click(update)

# Create layout and add to current document
layout = column(widgetbox(button), plot)
curdoc().add_root(layout)


# Import CheckboxGroup, RadioGroup, Toggle from bokeh.models
from bokeh.models import CheckboxGroup, RadioGroup, Toggle

# Add a Toggle: toggle
toggle = Toggle(button_type = "success", label="Toggle button")

# Add a CheckboxGroup: checkbox
checkbox = CheckboxGroup(labels=['Option 1', 'Option 2', 'Option 3'])

# Add a RadioGroup: radio
radio = RadioGroup(labels=['Option 1', 'Option 2', 'Option 3'])

# Add widgetbox(toggle, checkbox, radio) to the current document
curdoc().add_root(widgetbox(toggle, checkbox, radio))


```
  
  
***
  
Chapter 5 - Case Study  
  
Putting it all together - basic plotting, high-level charts, and interactivity:  
  
* Basic dataset will be from Gapminder (country dataset over time)  
* Goal is to create an interactive graph where the user can select the year (slider), x-variable (drop-down), and y-variable (drop-down)  
  
Starting the application - getting to a slider for year, with bubbles colored by continent, but with fixed x/y variables:  
  
* Import necessary modules - remember to use "from bokeh.io import curdoc"  
* Create plots and widgets  
* Add callbacks  
* Arrange plots and widgets in layouts  
* curdoc().add_root(layout)  # make all of the above active  
  
Adding more interactivity to the application - adding drop-downs for x/y variables, and adding a HoverTool to identify the relevant countries:  
  
* Reminder on HoverTool, which comes from 'from bokeh.models import HoverTool'  
	* hover = HoverTool(tooltips=[ ('myLabel1', '@myVar1') , ('myLabel2', '@myVar2') ])  # Passed as list of tuples, with the @ meaning "get this variable from the source data columns"  
* Recall that adding tools to a figure is as simple as plot = figure(tools=[hover, "pan", "wheel_zoom"])  
* Recall that drop-downs are formed by way of Select(options=[], value='', title='')  
	* The drop-downs similarly have an .on_change("value", callback) method  
  
Example code includes:  
```{r engine='python', engine.path=list(python="C:\\Users\\Dave\\Anaconda3\\python.exe")}

myPath = "./PythonInputFiles/"



import pandas as pd

rawGap = pd.read_csv(myPath + "gapminder_tidy.csv", index_col="Year")


# Perform necessary imports
from bokeh.io import output_file, show
from bokeh.plotting import figure
from bokeh.models import HoverTool, ColumnDataSource, Select

# Make the ColumnDataSource: source
source = ColumnDataSource(data={
    'x'       : rawGap.loc[1970]["fertility"],
    'y'       : rawGap.loc[1970]["life"],
    'country' : rawGap.loc[1970]["Country"]
})

# Create the figure: p
p = figure(title='1970', x_axis_label='Fertility (children per woman)', 
           y_axis_label='Life Expectancy (years)',
           plot_height=400, plot_width=700,
           tools=[HoverTool(tooltips='@country')]
           )

# Add a circle glyph to the figure p
p.circle(x='x', y='y', source=source)

# Output the file and show the figure
output_file(myPath + 'gapminder.html')
# show(p)


# Import the necessary modules
from bokeh.io import curdoc
from bokeh.models import ColumnDataSource
from bokeh.plotting import figure

# Make the ColumnDataSource: source
source = ColumnDataSource(data={
    'x'       : rawGap.loc[1970].fertility,
    'y'       : rawGap.loc[1970].life,
    'country' : rawGap.loc[1970].Country,
    'pop'     : (rawGap.loc[1970].population / 20000000) + 2,
    'region'  : rawGap.loc[1970].region
})

# Save the minimum and maximum values of the fertility column: xmin, xmax
xmin, xmax = min(rawGap.fertility), max(rawGap.fertility)

# Save the minimum and maximum values of the life expectancy column: ymin, ymax
ymin, ymax = min(rawGap.life), max(rawGap.life)

# Create the figure: plot
plot = figure(title='Gapminder Data for 1970', plot_height=400, plot_width=700,
              x_range=(xmin, xmax), y_range=(ymin, ymax))

# Add circle glyphs to the plot
plot.circle(x="x", y="y", fill_alpha=0.8, source=source)

# Set the x-axis label
plot.xaxis.axis_label ='Fertility (children per woman)'

# Set the y-axis label
plot.yaxis.axis_label = 'Life Expectancy (years)'

# Add the plot to the current document and add a title
curdoc().add_root(plot)
curdoc().title = 'Gapminder'


# Make a list of the unique values from the region column: regions_list
regions_list = rawGap.region.unique().tolist()

# Import CategoricalColorMapper from bokeh.models and the Spectral6 palette from bokeh.palettes
from bokeh.models import CategoricalColorMapper
from bokeh.palettes import Spectral6

# Make a color mapper: color_mapper
color_mapper = CategoricalColorMapper(factors=regions_list, palette=Spectral6)

# Add the color mapper to the circle glyph
plot.circle(x='x', y='y', fill_alpha=0.8, source=source,
            color=dict(field="region", transform=color_mapper), legend="region")

# Set the legend.location attribute of the plot to 'top_right'
plot.legend.location = 'top_right'

# Add the plot to the current document and add the title
curdoc().add_root(plot)
curdoc().title = 'Gapminder'


# Import the necessary modules
from bokeh.layouts import widgetbox, row
from bokeh.models import Slider

# Define the callback function: update_plot
def update_plot(attr, old, new):
    # set the `yr` name to `slider.value` and `source.data = new_data`
    yr = slider.value
    new_data = {
        'x'       : rawGap.loc[yr].fertility,
        'y'       : rawGap.loc[yr].life,
        'country' : rawGap.loc[yr].Country,
        'pop'     : (rawGap.loc[yr].population / 20000000) + 2,
        'region'  : rawGap.loc[yr].region,
    }
    source.data = new_data

# Make a slider object: slider
slider = Slider(start=1970, end=2010, step=1, value=1970, title="Year")

# Attach the callback to the 'value' property of slider
slider.on_change("value", update_plot)

# Make a row layout of widgetbox(slider) and plot and add it to the current document
layout = row(widgetbox(slider), plot)
curdoc().add_root(layout)


# Define the callback function: update_plot
def update_plot(attr, old, new):
    # Assign the value of the slider: yr
    yr = slider.value
    # Set new_data
    new_data = {
        'x'       : rawGap.loc[yr].fertility,
        'y'       : rawGap.loc[yr].life,
        'country' : rawGap.loc[yr].Country,
        'pop'     : (rawGap.loc[yr].population / 20000000) + 2,
        'region'  : rawGap.loc[yr].region,
    }
    # Assign new_data to: source.data
    source.data = new_data
    
    # Add title to figure: plot.title.text
    plot.title.text = 'Gapminder data for %d' % yr

# Make a slider object: slider
slider = Slider(start=1970, end=2010, step=1, value=1970, title="Year")

# Attach the callback to the 'value' property of slider
slider.on_change("value", update_plot)

# Make a row layout of widgetbox(slider) and plot and add it to the current document
layout = row(widgetbox(slider), plot)
curdoc().add_root(layout)


# Import HoverTool from bokeh.models
from bokeh.models import HoverTool

# Create a HoverTool: hover
hover = HoverTool(tooltips=[('Country', '@country')])

# Add the HoverTool to the plot
plot.add_tools(hover)

# Create layout: layout
layout = row(widgetbox(slider), plot)

# Add layout to current document
curdoc().add_root(layout)


# Define the callback: update_plot
def update_plot(attr, old, new):
    # Read the current value off the slider and 2 dropdowns: yr, x, y
    yr = slider.value
    x = x_select.value
    y = y_select.value
    # Label axes of plot
    plot.xaxis.axis_label = x
    plot.yaxis.axis_label = y
    # Set new_data
    new_data = {
        'x'       : rawGap.loc[yr][x],
        'y'       : rawGap.loc[yr][y],
        'country' : rawGap.loc[yr].Country,
        'pop'     : (rawGap.loc[yr].population / 20000000) + 2,
        'region'  : rawGap.loc[yr].region,
    }
    # Assign new_data to source.data
    source.data = new_data
    
    # Set the range of all axes
    plot.x_range.start = min(rawGap[x])
    plot.x_range.end = max(rawGap[x])
    plot.y_range.start = min(rawGap[y])
    plot.y_range.end = max(rawGap[y])
    
    # Add title to plot
    plot.title.text = 'Gapminder data for %d' % yr

# Create a dropdown slider widget: slider
slider = Slider(start=1970, end=2010, step=1, value=1970, title='Year')

# Attach the callback to the 'value' property of slider
slider.on_change('value', update_plot)

# Create a dropdown Select widget for the x data: x_select
x_select = Select(
    options=['fertility', 'life', 'child_mortality', 'gdp'],
    value='fertility',
    title='x-axis data'
)

# Attach the update_plot callback to the 'value' property of x_select
x_select.on_change('value', update_plot)

# Create a dropdown Select widget for the y data: y_select
y_select = Select(
    options=['fertility', 'life', 'child_mortality', 'gdp'],
    value='life',
    title='y-axis data'
)

# Attach the update_plot callback to the 'value' property of y_select
y_select.on_change('value', update_plot)

# Create layout and add to current document
layout = row(widgetbox(slider, x_select, y_select), plot)
curdoc().add_root(layout)

```
  
