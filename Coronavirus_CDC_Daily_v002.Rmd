---
title: "CDC Daily by State"
author: "davegoblue"
date: "5/27/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
This file is designed to use CDC data to assess coronavirus disease burden by state, including creating and analyzing state-level cluters.

Through March 7, 2021, [The COVID Tracking Project](https://covidtracking.com/) collected and integrated data on tests, cases, hospitalizations, deaths, and the like by state and date.  The latest code for using this data is available in Coronavirus_Statistics_CTP_v004.Rmd.

The COVID Tracking Project suggest that [US federal data sources](https://covidtracking.com/analysis-updates/federal-covid-data-101-how-to-find-data) are now sufficiently robust to be used for analyses that previously relied on COVID Tracking Project.  This code is an attempt to update modules in Coronavirus_Statistics_CTP_v004.Rmd to leverage US federal data.

The code in this module builds on code available in _v001, and splits many functions in to two main .R files that can be sourced:  
  
* Generic_Added_Utility_Functions_202105_v001.R - generic functions that can be used in other areas  
* Coronavirus_CDC_Daily_Functions_v001.R - functions specific to coronavirus daily data  
  
Broadly, the CDC data analyzed by this module includes:  
  
* CDC case and death data by state and date are available for download on the [CDC website](https://data.cdc.gov/api/views/9mfq-cb36/rows.csv?accessType=DOWNLOAD)  
* CDC hospital data are available for download on the [healthdata.gov website](https://beta.healthdata.gov/api/views/g62h-syeh/rows.csv?accessType=DOWNLOAD)  
  
## Functions and Mapping Files
The tidyverse package is loaded and functions are sourced:  
```{r}

# The tidyverse functions are routinely used without package::function format
library(tidyverse)

# Functions are available in source file
source("./Generic_Added_Utility_Functions_202105_v001.R")
source("./Coronavirus_CDC_Daily_Functions_v001.R")

```

A series of mapping files are also available to allow for parameterized processing.  Mappings include:  
  
* urlMapper - mapping file for urlType and url location to download data  
* renMapper - mapping file for renaming of variables in the raw data file  
* selfListMapper - mapping file for transformations by variable type  
* fullListMapper - mapping file for transformations across variable types  
* lstComboMapper - mapping file for elements to be combined by data type (most common is to combine NYC and NYS data to NY if the file provides them separately)  
* uqMapper - mapping file for fields that should combine to be unique keys for processed files  
* lstFilterMapper - mapping file for filtering to subset (most common is to keep 50 states and DC)  
* vecSelectMapper - mapping file for variables to keep  
* checkControlGroupMapper - mapping file for group_by() of control total checks  
* checkControlAggMapper - mapping file for numeric variables for control total checks  
* checkSimilarityMapper - mapping file for similarity checks to perform  
* plotSimilarityMaooer - mapping file for fields where differences in universe should be plotted
* keyAggMapper - mapping file for the aggregate-level control total checks to perform  
* perCapMapper - named vector that drives conversion from original field name to per capita field name  
  
These default parameters are maintained in a separate .R file and can be sourced:  
```{r}

source("./Coronavirus_CDC_Daily_Default_Mappings_v002.R")

```

Additionally, a mapping file could be maintained to give default plotting labels to variables.  This is currently not used by any of the sourced functions:  
```{r}

# Create a variable mapping file - this is currently redundant
varMapper <- c()

```

## Example for Comparison to Previous
Code from the previous model is run, with results compared to previous results:  
```{r, fig.height=9, fig.width=9}

readList <- list("cdcDaily"="./RInputFiles/Coronavirus/CDC_dc_downloaded_210502.csv", 
                 "cdcHosp"="./RInputFiles/Coronavirus/CDC_h_downloaded_210509.csv"
                 )

cdc_daily_compare <- readRunCDCDaily(thruLabel="May 2, 2021", 
                                     readFrom=readList, 
                                     compareFile=list("cdcDaily"=colRenamer(readFromRDS("dfRaw_dc_210414"),
                                                                            c('new_case'='new_cases', 
                                                                              'tot_death'='tot_deaths',
                                                                              'new_death'='new_deaths'
                                                                              )
                                                                            ), 
                                                      "cdcHosp"=readFromRDS("dfHosp_old")
                                                      ), 
                                     writeLog="./RInputFiles/Coronavirus/Coronavirus_CDC_Daily_v002.log", 
                                     ovrwriteLog=TRUE, 
                                     dfPerCapita=NULL, 
                                     useClusters=readFromRDS("cdc_daily_test_v2")$useClusters, 
                                     skipAssessmentPlots=FALSE, 
                                     brewPalette="Paired"
                                     )

identical(cdc_daily_compare[c("stateData", "dfRaw", "dfProcess", "dfPerCapita", "useClusters")],
          readFromRDS("cdc_daily_test_v3")[c("stateData", "dfRaw", "dfProcess", "dfPerCapita", "useClusters")]
          )
identical(cdc_daily_compare$plotDataList[c("dfFull", "dfAgg", "plotClusters")],
          readFromRDS("cdc_daily_test_v3")$plotDataList[c("dfFull", "dfAgg", "plotClusters")]
          )

```

The core data elements are identical, and the plots appear to convey the same information.  Next steps are to download the latest data and process with existing clusters.

Updated data are downloaded and processed, using existing segments.  The downloadTo argument is edited using lapply to avoid downloading data if it has previously been downloaded:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

readList <- list("cdcDaily"="./RInputFiles/Coronavirus/CDC_dc_downloaded_210528.csv", 
                 "cdcHosp"="./RInputFiles/Coronavirus/CDC_h_downloaded_210528.csv"
                 )
compareList <- list("cdcDaily"=readFromRDS("cdc_daily_test_v3")$dfRaw$cdcDaily, 
                    "cdcHosp"=readFromRDS("cdc_daily_test_v3")$dfRaw$cdcHosp
                    )

cdc_daily_210528 <- readRunCDCDaily(thruLabel="May 28, 2021", 
                                    downloadTo=lapply(readList, FUN=function(x) if(file.exists(x)) NA else x), 
                                    readFrom=readList,
                                    compareFile=compareList, 
                                    writeLog="./RInputFiles/Coronavirus/Coronavirus_CDC_Daily_210528.log", 
                                    useClusters=readFromRDS("cdc_daily_test_v2")$useClusters, 
                                    skipAssessmentPlots=FALSE, 
                                    brewPalette="Paired"
                                    )

saveToRDS(cdc_daily_210528, ovrWrite=FALSE, ovrWriteError=FALSE)

```

The process appears to work as intended.  Next steps are to update the county-level data process, making use of some of the functions available for CDC data processing.

The latest version of the data are downloaded and processed:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

readList <- list("cdcDaily"="./RInputFiles/Coronavirus/CDC_dc_downloaded_210708.csv", 
                 "cdcHosp"="./RInputFiles/Coronavirus/CDC_h_downloaded_210708.csv"
                 )
compareList <- list("cdcDaily"=readFromRDS("cdc_daily_210528")$dfRaw$cdcDaily, 
                    "cdcHosp"=readFromRDS("cdc_daily_210528")$dfRaw$cdcHosp
                    )

cdc_daily_210708 <- readRunCDCDaily(thruLabel="Jul 08, 2021", 
                                    downloadTo=lapply(readList, FUN=function(x) if(file.exists(x)) NA else x), 
                                    readFrom=readList,
                                    compareFile=compareList, 
                                    writeLog="./RInputFiles/Coronavirus/Coronavirus_CDC_Daily_210708.log", 
                                    useClusters=readFromRDS("cdc_daily_210528")$useClusters, 
                                    skipAssessmentPlots=FALSE, 
                                    brewPalette="Paired"
                                    )

saveToRDS(cdc_daily_210708, ovrWrite=FALSE, ovrWriteError=FALSE)

```

Vaccines data are also available for download on the [CDC website](https://data.cdc.gov/api/views/unsk-b7fc/rows.csv?accessType=DOWNLOAD):  
```{r cache=TRUE}

urlVaccine <- "https://data.cdc.gov/api/views/unsk-b7fc/rows.csv?accessType=DOWNLOAD"
locVaccine <- "./RInputFiles/Coronavirus/CDC_vax_downloaded_210712.csv"

fileDownload(locVaccine, urlVaccine)

```

The file has many fields, including:  
  
* Location - state abbreviation
* Date - date of reporting
* MMWR_week - epidemiological week
* Administered - total doses administered
* Administered_[12Plus|18Plus|65Plus] - age breakdown of administered doses  
* Admin_per_100k - per capita doses administered  
* Admin_per_100k_[12Plus|18Plus|65Plus] - per capita administered doses by age bucket  
* Recip_Administered - total number of administered vaccines based on jurisdiction of residence  
* Series_Complete_Yes - number of people fully vaccinated  
* Series_Complete_[12Plus|18Plus|65Plus] - age breakdown of fully vaccinated  
* Series_Complete_Pop_Pct - percent of population fully vaccinated  
* Series_Complete_[12Plus|18Plus|65Plus]Pop_Pct - fully vaccinated percent by age bucket  
  
An individual can live in one state but be vaccinated in another state.  Per the [CDC field descriptions](https://data.cdc.gov/Vaccinations/COVID-19-Vaccinations-in-the-United-States-Jurisdi/unsk-b7fc):  
  
* Administered - based on state of receiving vaccine  
* Recip_Administered - based on state where recipient lives  
* Administered_[age] - based on state where recipient lives  
* Admin_per_100k and Admin_per_100k_[age] - based on state where recipient lives  
* Series_Complete[all] - based on state where recipient lives  
  
Fully vaccinated (series complete) metrics is defined as "Total number of people who are fully vaccinated (have second dose of a two-dose vaccine or one dose of a single-dose vaccine) based on the jurisdiction where recipient lives"
  
```{r}

vaxRaw_210712 <- fileRead(locVaccine)
glimpse(vaxRaw_210712)

vaxRenamer <- c("Location"="state", 
                "Date"="date", 
                "Admin_Per_100K"="Admin_Per_100k"
                )
vaxKeeper <- c("state", "date", "MMWR_week", 
               "Administered", "Administered_12Plus", "Administered_18Plus", "Administered_65Plus", 
               "Admin_Per_100k", "Admin_Per_100k_12Plus", "Admin_Per_100k_18Plus", "Admin_Per_100k_65Plus", 
               "Recip_Administered", 
               "Series_Complete_Yes", 
               "Series_Complete_12Plus", "Series_Complete_18Plus", "Series_Complete_65Plus",
               "Series_Complete_Pop_Pct",
               "Series_Complete_12PlusPop_Pct", "Series_Complete_18PlusPop_Pct", "Series_Complete_65PlusPop_Pct"
               )

vaxProcessed_210712 <- vaxRaw_210712 %>%
    colRenamer(vecRename=vaxRenamer) %>%
    colSelector(vecSelect=vaxKeeper) %>%
    colMutater(selfList=list("date"=lubridate::mdy))
glimpse(vaxProcessed_210712)

```
  
Counts by state are created:  
```{r, fig.height=9, fig.width=9}

vaxState <- vaxProcessed_210712 %>%
    group_by(state) %>%
    filter(date==max(date)) %>%
    select(state, date, Administered, Recip_Administered, Series_Complete_Yes) %>%
    ungroup() %>%
    arrange(-Administered)
vaxState
vaxState %>%
    filter(!(state %in% c(state.abb, "DC")))
vaxState %>%
    filter(!(state == "US")) %>%
    mutate(pctComplete=Series_Complete_Yes/sum(Series_Complete_Yes)) %>%
    mutate(is50DC=state %in% c(state.abb, "DC")) %>%
    group_by(is50DC) %>%
    summarize(n=n(), across(where(is.numeric), sum), .groups="drop")

vaxProcessed_210712 %>%
    filter(state=="US") %>%
    select(state, date, Administered, Recip_Administered, Series_Complete_Yes) %>%
    pivot_longer(-c(state, date)) %>%
    ggplot(aes(x=date, y=value/1000000)) + 
    geom_line(aes(group=name, color=name)) + 
    labs(x="", y="Number of Doses/People (millions)", title="All-US Vaccination totals")
    
```
  
* Shots administered in LTC are being tracked back to the location where the recipient lives  
* Shots administered by VA, DOD, Indian Health, etc., do not appear to map back to one of the 50 states or DC  
* Data for territories are included  
* A US total is included  
  
Roughly 5% of completely vaccinated individuals are tracked to entities that do not map back to states.  These will be deleted for further analysis, which may lead to some disconnects.

Next steps are to continue processing the data and to integrate with the other state-level metrics.

Implied populations and vaccinations by subgroup are calculated:  
```{r, fig.height=9, fig.width=9}

vaxImplied_210712 <- vaxProcessed_210712 %>%
    mutate(popTot=100*Series_Complete_Yes/Series_Complete_Pop_Pct, 
           pop65Plus=100*Series_Complete_65Plus/Series_Complete_65PlusPop_Pct, 
           pop18Plus=100*Series_Complete_18Plus/Series_Complete_18PlusPop_Pct, 
           pop12Plus=100*Series_Complete_12Plus/Series_Complete_12PlusPop_Pct, 
           pop1864=pop18Plus-pop65Plus,
           pop1217=pop12Plus-pop18Plus,
           pop0011=popTot-pop12Plus, 
           vax65Plus=Series_Complete_65Plus,
           vax1864=Series_Complete_18Plus-Series_Complete_65Plus,
           vax1217=Series_Complete_12Plus-Series_Complete_18Plus,
           vax0011=Series_Complete_Yes-Series_Complete_12Plus
           )

popData <- vaxImplied_210712 %>%
    filter(state %in% c(state.abb, "DC", "PR", "US")) %>%
    group_by(state) %>%
    summarize(across(.cols=c(pop65Plus, pop1864, pop1217, pop0011), 
                     .fns=list(mu=~mean(.x, na.rm=TRUE), 
                               sdmu=~sd(.x, na.rm=TRUE)/mean(.x, na.rm=TRUE),
                               rangemu=~diff(range(.x, na.rm=TRUE)/mean(.x, na.rm=TRUE))
                               )
                     ), 
              .groups="drop"
              )

popData %>%
    select(state, contains("_rangemu")) %>%
    pivot_longer(-state) %>%
    ggplot(aes(x=fct_reorder(state, value, .fun=max), y=value)) + 
    geom_point() + 
    coord_flip() + 
    facet_wrap(~name, nrow=1) + 
    labs(y="Range divided by mean", x=NULL, title="Consistency of population estimates by subgroup and state")

popData %>%
    select(state, contains("_mu")) %>%
    pivot_longer(-state) %>%
    group_by(state) %>%
    mutate(pct65Plus=sum(ifelse(name=="pop65Plus_mu", value, 0))/sum(value)) %>%
    ungroup() %>%
    ggplot(aes(x=fct_reorder(state, pct65Plus), y=value)) + 
    geom_col(aes(fill=name), position="fill") +
    coord_flip() +
    scale_fill_discrete("") +
    labs(y="Proportion of population", x=NULL, title="Population breakout by state")

vaxImplied_210712 %>%
    filter(state=="US") %>%
    select(state, date, starts_with("vax")) %>%
    pivot_longer(-c(state, date)) %>%
    ggplot(aes(x=date, y=value)) + 
    geom_line(aes(group=name, color=name))

vaxImplied_210712 %>%
    filter(state=="US") %>%
    select(state, date, starts_with("vax")) %>%
    pivot_longer(-c(state, date)) %>% 
    mutate(eq0=(value==0), lt0=(value<0)) %>%
    filter(value<=0) %>%
    group_by(eq0, lt0, name) %>% 
    summarize(across(date, .fns=list(min=min, max=max)), .groups="drop")

```

Population estimates are generally consistent by state across dates, with the greatest variability in the 12-17 age estimates (expected since it is the smallest group where rounded percent vaccinated would have the most impact).

Distributions by age and state appear reasonable.

There has clearly been a change in tracking where fully vaccinated are tracked using age buckets:  
  
* 2020-12-13 through 2021-03-04 has no age breakouts  
* 2021-03-05 through 2021-05-12 has no age breakouts for 12-17 years old  
  
Next steps are to modify code so that subtotal statistics by age bucket are used only when where appropriate.

The availability of fields for state 'US' (full nation) is explored:  
```{r, fig.height=9, fig.width=9}

vaxProcessed_210712 %>%
    filter(state=="US") %>%
    pivot_longer(-c(state, date)) %>%
    mutate(valType=case_when(value < 0 ~ "red", value==0 ~ "orange", value > 0 ~ "green")) %>%
    ggplot(aes(x=date, y=fct_reorder(name, valType=="green", .fun=sum), fill=valType)) + 
    geom_tile() +
    scale_fill_identity() + 
    labs(x=NULL, y=NULL, title="Data availability by metric", subtitle="Red is negative, orange is zero")

```

In the early months, data are available only for administration.  The "series complete" metrics are introduced later, with the 12Plus bucket added even later as authorizations for use in ages 12-17 were added.

A comparison of states/DC to US is made for each of the key metrics:  
```{r, fig.height=9, fig.width=9}

vaxProcessed_210712 %>%
    mutate(stateType=case_when(state=="US" ~ "US", state %in% c(state.abb, "DC") ~ "state/DC", TRUE ~ "other")) %>%
    group_by(stateType, date, MMWR_week) %>%
    summarize(across(where(is.numeric), .fns=sum), .groups="drop") %>%
    pivot_longer(-c(stateType, date, MMWR_week)) %>%
    filter(!(str_detect(name, "Per|Pct"))) %>%
    ggplot(aes(x=date, y=value)) + 
    geom_line(aes(group=stateType, color=stateType)) + 
    facet_wrap(~name, scales="free_y")

```
  
In general, the sum of the states and DC are close to the total for US.  Per capita and percentage metrics cannot be summed and were not compared directly.

Next steps are to adapt the population splits to account for the variable timing of initial data availability  A heuristic can likely be used for the split of 65Plus in the early days, with 12Plus and 18Plus assumed to be equal (no usage in 0-17 group) prior to age being broken out.

An assumption is made that Series_Complete_Yes maps to the oldest group still left to populate when data breakouts are incomplete:  
```{r, fig.height=9, fig.width=9}

vaxImplied_210712_v2 <- vaxProcessed_210712 %>%
    mutate(popTot=100*Series_Complete_Yes/Series_Complete_Pop_Pct, 
           pop65Plus=100*Series_Complete_65Plus/Series_Complete_65PlusPop_Pct, 
           pop18Plus=100*Series_Complete_18Plus/Series_Complete_18PlusPop_Pct, 
           pop12Plus=100*Series_Complete_12Plus/Series_Complete_12PlusPop_Pct, 
           pop1864=pop18Plus-pop65Plus,
           pop1217=pop12Plus-pop18Plus,
           pop0011=popTot-pop12Plus, 
           vax65Plus=Series_Complete_65Plus,
           vax1864=Series_Complete_18Plus-Series_Complete_65Plus,
           vax1217=ifelse(Series_Complete_12Plus>0, Series_Complete_12Plus, Series_Complete_Yes)-Series_Complete_18Plus,
           vax0011=Series_Complete_Yes-vax65Plus-vax1864-vax1217
           )

popData_v2 <- vaxImplied_210712_v2 %>%
    filter(state %in% c(state.abb, "DC", "US")) %>%
    group_by(state) %>%
    summarize(across(.cols=c(popTot, pop65Plus, pop1864, pop1217, pop0011), 
                     .fns=list(mu=~mean(.x, na.rm=TRUE), 
                               sdmu=~sd(.x, na.rm=TRUE)/mean(.x, na.rm=TRUE),
                               rangemu=~diff(range(.x, na.rm=TRUE)/mean(.x, na.rm=TRUE))
                               )
                     ), 
              .groups="drop"
              )

popData_v2 %>%
    select(state, contains("_rangemu")) %>%
    pivot_longer(-state) %>%
    ggplot(aes(x=fct_reorder(state, value, .fun=max), y=value)) + 
    geom_point() + 
    coord_flip() + 
    facet_wrap(~name, nrow=1) + 
    labs(y="Range divided by mean", 
         x=NULL, 
         title="Consistency of population estimates by subgroup and state"
         )

popData_v2 %>%
    select(state, contains("_mu"), -contains("popTot")) %>%
    pivot_longer(-state) %>%
    group_by(state) %>%
    mutate(pct65Plus=sum(ifelse(name=="pop65Plus_mu", value, 0))/sum(value)) %>%
    ungroup() %>%
    ggplot(aes(x=fct_reorder(state, pct65Plus), y=value)) + 
    geom_col(aes(fill=name), position="fill") +
    coord_flip() +
    scale_fill_discrete("") +
    labs(y="Proportion of population", x=NULL, title="Population breakout by state")

vaxImplied_210712_v2 %>%
    filter(state=="US") %>%
    select(state, date, starts_with("vax")) %>%
    pivot_longer(-c(state, date)) %>%
    ggplot(aes(x=date, y=value)) + 
    geom_line(aes(group=name, color=name))

vaxImplied_210712_v2 %>%
    filter(state=="US") %>%
    select(state, date, starts_with("vax")) %>%
    pivot_longer(-c(state, date)) %>% 
    mutate(eq0=(value==0), lt0=(value<0)) %>%
    filter(value<=0) %>%
    group_by(eq0, lt0, name) %>% 
    summarize(across(date, .fns=list(min=min, max=max)), .groups="drop")

```

Data appear reasonable for further use, though with some anomalies still related to the breakouts by age.  Metrics per million on a rolling-7 basis are created:  
```{r, fig.height=9, fig.width=9}

popDataUse <- popData_v2 %>%
    filter(state %in% c(state.abb, "DC")) %>%
    select(state, contains("_mu")) %>%
    pivot_longer(-state) %>%
    mutate(ageGroup=stringr::str_replace_all(name, "pop|_mu", "")) %>%
    rename(pop=value) %>%
    select(state, ageGroup, pop)

vaxDataUse <- vaxImplied_210712_v2 %>%
    filter(state %in% c(state.abb, "DC")) %>%
    select(state, date, vaxTot=Series_Complete_Yes, starts_with("vax")) %>%
    pivot_longer(-c(state, date)) %>%
    mutate(ageGroup=stringr::str_replace_all(name, "vax", "")) %>%
    rename(vax=value) %>%
    select(state, date, ageGroup, vax)

popVaxData <- vaxDataUse %>%
    inner_join(popDataUse, by=c("state", "ageGroup")) %>%
    mutate(vaxpct=vax/pop) %>%
    arrange(state, ageGroup, date) %>%
    group_by(state, ageGroup) %>%
    helperRollingAgg(origVar="vaxpct", newName="vaxpct7") %>%
    ungroup()

popVaxData %>%
    filter(!is.na(vaxpct7)) %>%
    ggplot(aes(x=date, y=vaxpct7)) + 
    geom_line(aes(group=state, color=state.region[match(state, state.abb)]), alpha=0.5) + 
    lims(y=c(0, 1)) +
    facet_wrap(~ageGroup) + 
    labs(title="Percent Fully Vaccinated", x=NULL, y="Rolling 7 'Series Complete' percentage") + 
    scale_color_discrete("Census\nRegion")

popVaxData %>%
    filter(!is.na(vaxpct7)) %>%
    ggplot(aes(x=date, y=vaxpct7)) + 
    geom_line(aes(group=ageGroup, color=ageGroup)) + 
    lims(y=c(0, 1)) +
    facet_wrap(~state) + 
    labs(title="Percent Fully Vaccinated", x=NULL, y="Rolling 7 'Series Complete' percentage") + 
    scale_color_discrete("Age")

```

Next steps are to incorporate these steps as a reproducible function.

The function readQCRawCDCDaily() is copied and applied:  
```{r, fig.height=9, fig.width=9}

# Function to read and check a raw data file
readQCRawCDCDaily <- function(fileName, 
                              writeLog=NULL,
                              ovrwriteLog=TRUE,
                              dfRef=NULL,
                              urlType=NULL,
                              url=NULL, 
                              getData=TRUE,
                              ovrWriteDownload=FALSE, 
                              vecRename=NULL, 
                              selfList=NULL,
                              fullList=NULL,
                              uniqueBy=NULL, 
                              step3Group=NULL,
                              step3Vals=NULL, 
                              step4KeyVars=NULL, 
                              step5PlotItems=NULL,
                              step6AggregateList=NULL,
                              inferVars=list("url"=urlMapper, 
                                             "vecRename"=renMapper, 
                                             "selfList"=selfListMapper, 
                                             "fullList"=fullListMapper, 
                                             "uniqueBy"=uqMapper, 
                                             "step3Group"=checkControlGroupMapper,
                                             "step3Vals"=checkControlVarsMapper, 
                                             "step4KeyVars"=checkSimilarityMapper, 
                                             "step5PlotItems"=plotSimilarityMapper,
                                             "step6AggregateList"=keyAggMapper
                                             )
                              ) {
    
    # FUNCTION ARGUMENTS
    # fileName: the location where downloaded data either is, or will be, stored
    # writeLog: the external file location for printing (NULL means use the main log stdout)
    # ovrwriteLog: boolean, if using an external log, should it be started from scratch (overwritten)?
    # dfRef: a reference data frame for comparison (either NULL or NA means do not run comparisons)
    # urlType: character vector that can be mapped using urlMapper and keyVarMapper
    # url: direct URL passed as character string
    #      NOTE that if both url and urlType are NULL, no file will be downloaded
    # getData: boolean, should an attempt be made to get new data using urlType or url?
    # ovrWriteDownload: boolean, if fileName already exists, should it be overwritten?
    # vecRename: vector for renaming c('existing name'='new name'), can be any length from 0 to ncol(df)
    #            NULL means infer from urlType, if not available there use c()
    # selfList: list for functions to apply to self, list('variable'=fn) will apply variable=fn(variable)
    #           processed in order, so more than one function can be applied to self
    #           NULL means infer from urlType, if not available in mapping file use list()
    # fullList: list for general functions to be applied, list('new variable'=expression(code))
    #           will create 'new variable' as eval(expression(code))
    #           for now, requires passing an expression
    #           NULL means infer from urlType, use list() if not in mapping file
    # uniqueBy: combination of variables for checking uniqueness
    #           NULL means infer from data, keep as NULL (meaning use-all) if cannot be inferred
    # step3Group: variable to be used as the x-axis (grouping) for step 3 plots
    #             NULL means infer from data
    # step3Vals: values to be plotted on the y-axis for step 3 plots
    #            NULL means infer from data
    # step4KeyVars: list of parameters to be passed as keyVars= in step 4
    #               NULL means infer from urlType
    # step5PlotItems: items to be plotted in step 5
    #                 NULL means infer from urlType
    # step6AggregateList: drives the elements to be passed to compareAggregate() and flagLargeDelta()
    #                     NULL means infer from urlType
    # inferVars: vector of c('variable'='mapper') for inferring parameter values when passed as NULL
    
    # Step 0a: Use urlType to infer key variables if passed as NULL
    for (vrbl in names(inferVars)) {
        mapper <- inferVars[[vrbl]]
        if (is.null(get(vrbl))) {
            if (urlType %in% names(mapper)) assign(vrbl, mapper[[urlType]])
            else if ("default" %in% names(mapper)) assign(vrbl, mapper[["default"]])
        }
    }
    
    # Step 1: Download a new file (if requested)
    if (!is.null(url) & isTRUE(getData)) fileDownload(fileName=fileName, url=url, ovrWrite=ovrWriteDownload)
    else cat("\nNo file has been downloaded, will use existing file:", fileName, "\n")
    
    # Step 2: Read file, rename and mutate variables, confirm uniqueness by expected levels
    dfRaw <- fileRead(fileName) %>% 
        colRenamer(vecRename) %>% 
        colMutater(selfList=selfList, fullList=fullList) %>%
        checkUniqueRows(uniqueBy=uniqueBy)
    
    # Step 3: Plot basic control totals for new cases and new deaths by month
    dfRaw %>%
        checkControl(groupBy=step3Group, useVars=step3Vals, printControls=FALSE, na.rm=TRUE) %>%
        helperLinePlot(x=step3Group, y="newValue", facetVar="name", facetScales="free_y", groupColor="name")
    
    # If there is no file for comparison, return the data
    if (is.null(dfRef) | if(length(dfRef)==1) is.na(dfRef) else FALSE) return(dfRaw)
    
    # Step 4b: Check similarity of existing and reference file
    # ovrWriteLog=FALSE since everything should be an append after the opening text line in step 0
    diffRaw <- checkSimilarity(df=dfRaw, 
                               ref=dfRef, 
                               keyVars=step4KeyVars, 
                               writeLog=writeLog, 
                               ovrwriteLog=FALSE
                               )
    
    # Step 5: Plot the similarity checks
    plotSimilarity(diffRaw, plotItems=step5PlotItems)
    
    # Step 6: Plot and report on differences in aggregates
    helperAggMap <- function(x) {
        h1 <- compareAggregate(df=dfRaw, ref=dfRef, grpVar=x$grpVar, numVars=x$numVars, 
                               sameUniverse=x$sameUniverse, plotData=x$plotData, isLine=x$isLine, 
                               returnDelta=x$returnDelta)
        if (isTRUE(x$flagLargeDelta)) {
            h2 <- flagLargeDelta(h1, pctTol=x$pctTol, absTol=x$absTol, sortBy=x$sortBy, 
                                 dropNA=x$dropNA, printAll=x$printAll
            )
            if (is.null(writeLog)) print(h2)
            else {
                cat(nrow(h2), " records", sep="")
                txt <- paste0("\n\n***Differences of at least ", 
                              x$absTol, 
                              " and at least ", 
                              round(100*x$pctTol, 3), "%\n\n"
                )
                printLog(h2, txt=txt, writeLog=writeLog)
            }
        }
    }
    lapply(step6AggregateList, FUN=helperAggMap)
    
    cat("\n\n")
    
    # Return the raw data file
    dfRaw
    
}



# Run without downloading data and without a comparison file
vaxRaw_210712_func <- readQCRawCDCDaily(fileName="./RInputFiles/Coronavirus/CDC_vax_downloaded_210712.csv", 
                                        url="https://data.cdc.gov/api/views/unsk-b7fc/rows.csv?accessType=DOWNLOAD",
                                        getData=FALSE,
                                        vecRename=c("Location"="state", 
                                                    "Date"="date", 
                                                    "Admin_Per_100K"="Admin_Per_100k"
                                                    ),
                                        selfList=list("date"=lubridate::mdy),
                                        uniqueBy=c("date", "state"),
                                        step3Group=c("date"),
                                        step3Vals=c("Administered", 
                                                    "Series_Complete_Yes", 
                                                    "Series_Complete_12Plus",
                                                    "Series_Complete_18Plus", 
                                                    "Series_Complete_65Plus"
                                                    ),
                                        inferVars=list()
                                        )

```

While there is double-counting due to the "US" record being included, the general process for a basic file read is working as intended.  Next steps are to update the process to allow for comparison to an existing file.

The latest vaccines data are downloaded, with results cached:  
```{r cache=TRUE}

urlVaccine <- "https://data.cdc.gov/api/views/unsk-b7fc/rows.csv?accessType=DOWNLOAD"
locVaccine <- "./RInputFiles/Coronavirus/CDC_vax_downloaded_210717.csv"

fileDownload(locVaccine, urlVaccine)

```
  
The function readQCRawCDCDaily() is applied using the previous data as the control:  
```{r, fig.height=9, fig.width=9}

# Run without downloading data and with a comparison file
vaxRaw_210717_func <- readQCRawCDCDaily(fileName="./RInputFiles/Coronavirus/CDC_vax_downloaded_210717.csv", 
                                        dfRef=vaxRaw_210712_func,
                                        url="https://data.cdc.gov/api/views/unsk-b7fc/rows.csv?accessType=DOWNLOAD",
                                        getData=FALSE,
                                        vecRename=c("Location"="state", 
                                                    "Date"="date", 
                                                    "Admin_Per_100K"="Admin_Per_100k"
                                                    ),
                                        selfList=list("date"=lubridate::mdy),
                                        uniqueBy=c("date", "state"),
                                        step3Group=c("date"),
                                        step3Vals=c("Administered", 
                                                    "Series_Complete_Yes", 
                                                    "Series_Complete_12Plus",
                                                    "Series_Complete_18Plus", 
                                                    "Series_Complete_65Plus"
                                                    ),
                                        step4KeyVars=list(date=list(label='date', countOnly=TRUE, convChar=TRUE), 
                                                          state=list(label='state', countOnly=FALSE)
                                                          ),
                                        step5PlotItems=c("date"),
                                        step6AggregateList=list("l1"=list("grpVar"="date",
                                                                          "numVars"=c("Administered", 
                                                                                      "Series_Complete_Yes", 
                                                                                      "Series_Complete_12Plus",
                                                                                      "Series_Complete_18Plus", 
                                                                                      "Series_Complete_65Plus"
                                                                                      ),
                                                                          "sameUniverse"=NA,
                                                                          "plotData"=TRUE,
                                                                          "isLine"=TRUE,
                                                                          "returnDelta"=TRUE,
                                                                          "flagLargeDelta"=TRUE,
                                                                          "pctTol"=0.01,
                                                                          "absTol"=1,
                                                                          "sortBy"=c("name", "pctDelta", "absDelta"),
                                                                          "dropNA"=TRUE,
                                                                          "printAll"=TRUE
                                                                          ),
                                                                "l3"=list("grpVar"="state",
                                                                          "numVars"=c("Administered", 
                                                                                      "Series_Complete_Yes", 
                                                                                      "Series_Complete_12Plus",
                                                                                      "Series_Complete_18Plus", 
                                                                                      "Series_Complete_65Plus"
                                                                                      ),
                                                                          "sameUniverse"="date",
                                                                          "plotData"=TRUE,
                                                                          "isLine"=FALSE,
                                                                          "returnDelta"=TRUE,
                                                                          "flagLargeDelta"=TRUE,
                                                                          "pctTol"=0.001,
                                                                          "absTol"=0,
                                                                          "sortBy"=c("name", "pctDelta", "absDelta"),
                                                                          "dropNA"=TRUE,
                                                                          "printAll"=TRUE
                                                                          )
                                                                ),
                                        inferVars=list()
                                        )

```
  
The function works well for reading a raw vaccines data file, running basic checks, and comparing to a previous vaccines data file.  Next steps are to adapt the function for processing a vaccines data file.

The function processRawFile() is leveraged:  
```{r}

# Generic function for processing a raw file
processRawFile <- function(df, 
                           vecRename=c(), 
                           vecSelect=NULL,
                           lstCombo=list(), 
                           lstFilter=list(), 
                           lstExclude=list()
                           ) {
    
    # FUNCTION ARGUMENTS:
    # df: the raw data frame or tibble
    # vecRename: vector for renaming c('existing name'='new name'), can be any length from 0 to ncol(df)
    # vecSelect: vector of columns to select (run after vecRename), NULL means select all columns
    # lstCombo: a nested list of combinations to be applied
    #           each element of the list should include comboVar, uqVars, vecCombo, and fn
    # lstFilter: a list for filtering records, of form list("field"=c("allowed values"))
    # lstExclude: a list for filtering records, of form list("field"=c("disallowed values"))
    
    # STEP 1: Rename and select variables (selection occurs AFTER renaming)
    dfProcess <- df %>%
        colRenamer(vecRename=vecRename) %>%
        colSelector(vecSelect=vecSelect)
    
    # STEP 2: Combine multiple records to a single record
    for (ctr in seq_along(lstCombo)) {
        dfProcess <- dfProcess %>%
            combineRows(comboVar=lstCombo[[ctr]]$comboVar, 
                        uqVars=lstCombo[[ctr]]$uqVars, 
                        vecCombo=lstCombo[[ctr]]$vecCombo, 
                        fn=lstCombo[[ctr]]$fn
            )
    }
    
    # STEP 3: Filter records
    qcOrig <- dfProcess %>% 
        summarize(across(where(is.numeric), sum, na.rm=TRUE), n=n()) %>% 
        mutate(isType="before")
    dfProcess <- dfProcess %>% 
        rowFilter(lstFilter=lstFilter, lstExclude=lstExclude)
    
    # STEP 4: Report on differences
    cat("\nColumn sums before and after applying filtering rules:\n")
    dfProcess %>% 
        summarize(across(where(is.numeric), sum, na.rm=TRUE), n=n()) %>% 
        mutate(isType="after") %>%
        bind_rows(qcOrig) %>%
        arrange(desc(isType)) %>%
        bind_rows(mutate(summarize(., across(where(is.numeric), function(x) (max(x)-min(x))/max(x))), 
                         isType="pctchg"
                         )
                  ) %>%
        select(isType, everything()) %>%
        print()
    cat("\n")
    
    # Return the processed data file
    dfProcess
    
}



vaxProc_210717_func <- processRawFile(vaxRaw_210717_func, 
                                      vecRename=c(),
                                      vecSelect=c("date", "state", "MMWR_week", 
                                                  "Administered", "Admin_Per_100k",
                                                  "Series_Complete_Yes", "Series_Complete_Pop_Pct",
                                                  "Series_Complete_12Plus", "Series_Complete_12PlusPop_Pct",  
                                                  "Series_Complete_18Plus", "Series_Complete_18PlusPop_Pct",  
                                                  "Series_Complete_65Plus", "Series_Complete_65PlusPop_Pct"
                                                  ), 
                                      lstCombo=list(), 
                                      lstFilter=list("state"=c(state.abb, "DC")),
                                      lstExclude=list()
                                      )
vaxProc_210717_func

```

Next steps are to run the per-capita process for conversion of Administered and Series_Complete_Yes based on the same state population data used for cases, deaths, and hospitalizations.

The function createPerCapita() is leveraged:  
```{r, fig.height=9, fig.width=9}

# Function to extract and format key state data
getStateData <- function(df=readFromRDS("statePop2019"), 
                         renameVars=c("stateAbb"="state", "NAME"="name", "pop_2019"="pop"), 
                         keepVars=c("state", "name", "pop")
                         ) {
    
    # FUNCTION ARGUMENTS:
    # df: the data frame containing state data
    # renameVars: variables to be renamed, using named list with format "originalName"="newName"
    # keepVars: variables to be kept in the final file
    
    # Rename variables where appropriate
    names(df) <- ifelse(is.na(renameVars[names(df)]), names(df), renameVars[names(df)])
    
    # Return file with only key variables kept
    df %>%
        select_at(vars(all_of(keepVars)))
    
}


useVars <- c("state", "date", "Administered", "Series_Complete_Yes")


vaxPerCap_210717_func <- createPerCapita(select(vaxProc_210717_func, all_of(useVars)), 
                                         uqBy=c("state", "date"), 
                                         popData=getStateData(), 
                                         mapper=c("Administered"="vxapm", "Series_Complete_Yes"="vxcpm"), 
                                         )
vaxPerCap_210717_func

vaxPerCap_210717_func %>%
    select(state, date, vxapm7, vxcpm7) %>%
    pivot_longer(-c(state, date)) %>%
    filter(!is.na(value), name=="vxcpm7") %>%
    mutate(region=ifelse(state=="DC", "South Atlantic", as.character(state.division)[match(state, state.abb)])) %>%
    ggplot(aes(x=date, y=value/1000000)) + 
    geom_line(aes(group=state), alpha=0.25) + 
    geom_line(data=~summarize(group_by(., region, date), value=median(value), .groups="drop"), 
              aes(color=region)
              ) +
    facet_wrap(~region) + 
    lims(y=c(0, 1)) +
    labs(x=NULL, 
         y="Proportion Fully Vaccinated (of total population)", 
         title="Evolution of fully vaccinated by state and census division", 
         subtitle="Colored line is median in region, gray line is individual states in region"
         ) + 
    theme(legend.position="none")

```
  
The createPerCapita() function is updated to allow for keeping variables without calculating per-million or rolling-7 aggregates:  
```{r}

# Generic function to create per-capita metrics using an existing file and source of population data
createPerCapita <- function(lst, 
                            uqBy,
                            popData,
                            mapper,
                            asIsVars=c(),
                            lstSortBy=uqBy,
                            fnJoin=dplyr::full_join, 
                            popJoinBy="state",
                            popVar="pop",
                            k=7,
                            mult=1000000,
                            ...
                            ) {
    
    # FUNCTION ARGUMENTS:
    # lst: A list containing one or more files to be joined OR a data frame that is already joined
    # uqBy: character string that the input file is unique by (will be the join keys if a list is passed)
    # popData: file containing population data that can be joined to the processed lst
    # mapper: mapping file of c('current name'='per capita name') for mapping variables
    # asIsVars: variables to be kept, but without creating pm or pm7
    # lstSortBy: the sorting that should be used for creating rolling metrics
    # fnJoin: The function to be used for joining files
    # popJoinBy: character string for the variable(s) to be used in joining popData to lst
    # popVar: character string for the variable in popData that represents population
    # k: time perior for rolling aggregations
    # mult: the unit for the per-capita data (default 1 million means make metrics per million)
    # ...: other arguments to be passed to combineFiles()
    
    # Step 1: If a list has been passed, use a joining process to create a data frame
    if ("list" %in% class(lst)) lst <- combineFiles(lst, byVars=uqBy, fn=fnJoin, ...)
    
    # Step 2: Sort the data using sortBy
    df <- dplyr::arrange(lst, across(all_of(lstSortBy)))
    
    # Step 3: Check that all variables other than uqBy and asIsVars can be mapped using mapper
    keyVars <- setdiff(names(df), c(uqBy, asIsVars))
    if (any(isFALSE(keyVars %in% mapper))) stop("\nVariable is missing in per capita mapper file\n")
    
    # Step 4: Run the per capita mapping process
    df <- helperMakePerCapita(df, 
                              mapVars=mapper[keyVars], 
                              popData=popData, 
                              k=k, 
                              byVar=popJoinBy, 
                              sortVar=setdiff(lstSortBy, popJoinBy), 
                              popVar=popVar, 
                              mult=mult
    )
    
    # Return the data frame
    df
    
}

```

The updated process is then run, keeping the breakout for 65+ and 18+:  
```{r, fig.height=9, fig.width=9}

uqVars <- c("state", "date")
perCapVars <- c("Administered", "Series_Complete_Yes")
asIsVars <- c("Series_Complete_65Plus", "Series_Complete_65PlusPop_Pct", 
              "Series_Complete_18Plus", "Series_Complete_18PlusPop_Pct", 
              "Admin_Per_100k", "Series_Complete_Pop_Pct"
              )


vaxPerCap_210717_func_v2 <- createPerCapita(select(vaxProc_210717_func, all_of(c(uqVars, perCapVars, asIsVars))), 
                                            uqBy=uqVars, 
                                            asIsVars=asIsVars,
                                            popData=getStateData(), 
                                            mapper=c("Administered"="vxapm", "Series_Complete_Yes"="vxcpm")
                                            ) %>%
    colRenamer(c("Series_Complete_Yes"="vxc", 
                 "Administered"="vxa", 
                 "Series_Complete_Pop_Pct"="vxcpoppct",
                 "Series_Complete_65Plus"="vxcgte65",
                 "Series_Complete_65PlusPop_Pct"="vxcgte65pct", 
                 "Series_Complete_18Plus"="vxcgte18",
                 "Series_Complete_18PlusPop_Pct"="vxcgte18pct"
                 )
               )
vaxPerCap_210717_func_v2 

# Check consistency of 'Admin_Per_100k' and 'vxapm'
vaxPerCap_210717_func_v2 %>%
    filter(date==max(date)) %>%
    ggplot(aes(x=Admin_Per_100k, y=vxapm)) + 
    geom_text(aes(label=state)) + 
    geom_abline(slope=10, intercept=0, lty=2) +
    labs(x="Raw data administered per 100k", 
         y="Function-calculated adminsitered per million",
         title="Consistency of raw data and function-calculated per capita data",
         subtitle="Dotted line is per-million at 10x per-100k (expected)"
         )

# Check consistency of 'vxcpoppct' and 'vxcpm'
vaxPerCap_210717_func_v2 %>%
    filter(date==max(date)) %>%
    ggplot(aes(x=vxcpoppct, y=vxcpm)) + 
    geom_text(aes(label=state)) + 
    geom_abline(slope=10000, intercept=0, lty=2) +
    labs(x="Raw data percent of population completely vaccinated", 
         y="Function-calculated completely vaccinated per million",
         title="Consistency of raw data and function-calculated per capita data",
         subtitle="Dotted line is per-million at 10,000x per-100 (expected)"
         )

```
  
The raw data and per-capita totals are aligned, suggesting that population estimates used in the datasets are very similar (functions use 2019 estimates as per getStateData()).

The colMutater() function is added to include:  
  
1. Counts for 18-64 and 0-17 based on subtraction  
2. Daily change in administered and completed by day (rather than raw data cumulative)  
  
Variables are added as follows:  
```{r, fig.height=9, fig.width=9}

# Conversions for 18-64 and 0-17
subGroupList <- list("vxc1864"=expression(vxcgte18-vxcgte65), 
                     "vxc0017"=expression(vxc-vxcgte18)
                     )

# Conversions for per-day
perDayFunc <- function(x) ifelse(row_number()==1, x, ifelse(lag(x)==0, 0, x-lag(x)))
perDayList <- list("vxa_perday"=expression(perDayFunc(vxa)), 
                   "vxc_perday"=expression(perDayFunc(vxc)), 
                   "vxcgte65_perday"=expression(perDayFunc(vxcgte65)), 
                   "vxc1864_perday"=expression(perDayFunc(vxc1864)), 
                   "vxc0017_perday"=expression(perDayFunc(vxc0017))
                   )

vaxPerCap_210717_func_v3 <- vaxPerCap_210717_func_v2 %>%
    colMutater(fullList=subGroupList) %>%
    arrange(date, state) %>%
    group_by(state) %>%
    colMutater(fullList=perDayList) %>%
    ungroup()

# Check that files are identical for same variables
sapply(names(vaxPerCap_210717_func_v2), 
       FUN=function(x) all.equal(vaxPerCap_210717_func_v2[[x]], vaxPerCap_210717_func_v3[[x]])
       ) %>% 
    t() %>% 
    t()

# Plot evolution of vaccines by age
vaxPerCap_210717_func_v3 %>%
    select(date, vxc, vxcgte65, vxc1864, vxc0017) %>%
    group_by(date) %>%
    summarize(across(.fns=sum)) %>%
    pivot_longer(-date) %>%
    ggplot(aes(x=date)) + 
    geom_point(data=~filter(., name=="vxc"), aes(y=value/1000000)) + 
    geom_col(data=~filter(., name!="vxc"), aes(y=value/1000000, fill=name), position="stack") + 
    labs(x=NULL, 
         y="Completely Vaccinated (millions)", 
         title="Evolution of fully vaccinated by age group", 
         subtitle="Dots are total people fully vaccinated"
         ) + 
    scale_fill_discrete("Age")

# Plot evolution of vaccines administered per day
vaxPerCap_210717_func_v3 %>%
    select(date, vxa, vxa_perday) %>%
    group_by(date) %>%
    summarize(across(where(is.numeric), sum)) %>%
    pivot_longer(-date) %>%
    group_by(name) %>%
    mutate(value7=zoo::rollmean(value, k=7, fill=NA)) %>%
    ungroup() %>%
    ggplot(aes(x=date)) + 
    geom_line(aes(y=value/1000000)) + 
    geom_line(data=~filter(., name=="vxa_perday", !is.na(value7)), aes(y=value7/1000000), color="red", lwd=2) +
    facet_wrap(~c("vxa"="Cumulative", "vxa_perday"="Daily")[name], scales="free_y") + 
    labs(x=NULL, 
         y="Vaccines Adminsitered (millions)", 
         title="Evolution of vaccines administered", 
         subtitle="Red line is rolling 7-day average"
         )

```

Variables appear to be created as intended.

Next, total population is estimated and plots of vaccines administered per capita are created:  
```{r, fig.height=9, fig.width=9}

# Plot evolution of vaccines administered per day
vaxPerCap_210717_func_v3 %>%
    select(state, date, vxa, vxa_perday, Admin_Per_100k) %>% 
    group_by(state) %>%
    mutate(pop=median(100000*vxa/Admin_Per_100k, na.rm=TRUE)) %>% 
    ungroup() %>%
    pivot_longer(-c(state, date, pop)) %>%
    group_by(state, pop, name) %>%
    mutate(value7=zoo::rollmean(value, k=7, fill=NA)) %>%
    ungroup() %>%
    ggplot(aes(x=date)) + 
    geom_line(data=~filter(., name=="vxa_perday", !is.na(value7), state != "NM"), 
              aes(y=1000*value7/pop, group=state)
              ) + 
    facet_wrap(~state) +
    labs(x=NULL, 
         y="Vaccines Adminsitered (per thousand)", 
         title="Evolution of vaccines administered (rolling 7-day average)"
    )

# Plot evolution of vaccines administered (cumulative)
vaxPerCap_210717_func_v3 %>%
    select(state, date, vxa, vxa_perday, Admin_Per_100k) %>% 
    group_by(state) %>%
    mutate(pop=median(100000*vxa/Admin_Per_100k, na.rm=TRUE)) %>% 
    ungroup() %>%
    pivot_longer(-c(state, date, pop)) %>%
    group_by(state, pop, name) %>%
    mutate(value7=zoo::rollmean(value, k=7, fill=NA)) %>%
    ungroup() %>%
    ggplot(aes(x=date)) + 
    geom_line(data=~filter(., name=="vxa", !is.na(value)), 
              aes(y=1000*value/pop, group=state)
              ) + 
    geom_hline(yintercept=1000, lty=2) +
    facet_wrap(~state) +
    labs(x=NULL, 
         y="Vaccines Adminsitered (per thousand)", 
         title="Evolution of vaccines administered (cumulative)"
    )

```

Estimates are made for population 65+, 18-64, and 0-17 based on completion percentages:  
```{r, fig.height=9, fig.width=9}

popEstAgeState <- vaxPerCap_210717_func_v3 %>%
    select(state, date, vxcgte65, vxcgte65pct, vxcgte18, vxcgte18pct, vxc, vxcpoppct) %>%
    mutate(popgte65=100*vxcgte65/vxcgte65pct, popgte18=100*vxcgte18/vxcgte18pct, pop=100*vxc/vxcpoppct) %>%
    group_by(state) %>%
    summarize(across(c(popgte65, popgte18, pop), median, na.rm=TRUE), .groups="drop") %>%
    mutate(pop1864=popgte18-popgte65, pop0017=pop-popgte18)
popEstAgeState

popEstAgeState %>%
    summarize(across(where(is.numeric), sum))

popEstAgeState %>%
    select(-popgte18, -pop) %>%
    pivot_longer(-state) %>%
    group_by(state) %>%
    mutate(pctg65=ifelse(name=="popgte65", value, 0)/sum(value)) %>%
    ggplot(aes(x=fct_reorder(state, pctg65, .fun=max), y=value)) + 
    geom_col(aes(fill=name), position="fill") + 
    coord_flip() + 
    labs(x=NULL, 
         y="Proportion", 
         title="Distribution of population by state", 
         subtitle="Estimated from reported vaccine completion percentages by sub-group"
         ) + 
    scale_fill_discrete("Age Group")

```

Metrics for evolution of complete vaccination by age cohort are calculated and plotted:  
```{r, fig.height=9, fig.width=9}

popState <- popEstAgeState %>%
    select(state, popgte65, pop1864, pop0017) %>%
    pivot_longer(-state) %>%
    mutate(age=str_replace_all(name, "pop", "")) %>%
    select(state, age, pop=value)
popState

vaxPerCap_210717_func_v3 %>%
    select(state, date, vxcgte65_perday, vxc1864_perday, vxc0017_perday) %>%
    pivot_longer(-c(state, date)) %>%
    mutate(age=stringr::str_replace_all(name, "vxc|_perday", "")) %>%
    select(state, date, age, perday=value) %>%
    left_join(popState, by=c("state", "age")) %>%
    mutate(perday_percap=perday/pop) %>%
    arrange(state, date, age) %>%
    group_by(state, age) %>%
    helperRollingAgg("perday_percap", newName="perday_percap7") %>%
    ungroup() %>% 
    filter(!is.na(perday_percap7), state != "DC") %>%
    ggplot(aes(x=date, y=1000*perday_percap7)) + 
    geom_line(aes(group=state, color=state.region[match(state, state.abb)])) + 
    labs(x=NULL, 
         y="Completed per thousand (rolling 7-day)", 
         title="Newly fully vaccinated by day", 
         subtitle="Persons vaccinated before age-breakouts included NOT counted"
         ) +
    facet_wrap(~age) + 
    scale_color_discrete("Census\nRegion")

```
  
There are discontinuities in the data, particularly for the age group 0-17 bucket.  This is likely driven by differences in timing of age breakouts based on authorizations for vaccines by age cohort.  Next steps are to investigate and correct for discontinuities, particularly those showing negative completed vaccinations.

The big spike then decline in 0017 is investigated:  
```{r, fig.height=9, fig.width=9}

deltaData_210717 <- vaxPerCap_210717_func_v3 %>%
    select(state, date, vxc, vxcgte65, vxcgte18) %>%
    group_by(date) %>%
    summarize(across(where(is.numeric), sum)) %>%
    mutate(across(where(is.numeric), .fn=function(x) ifelse(lag(x)==0, NA, x - lag(x)), .names="d_{.col}")) 

deltaData_210717 %>%
    select(date, starts_with("d")) %>%
    pivot_longer(-date) %>%
    filter(!is.na(value)) %>%
    ggplot(aes(x=date, y=value)) + 
    geom_line(aes(group=name, color=name))

deltaData_210717 %>%
    filter(d_vxc < d_vxcgte18)

deltaData_210717 %>%
    filter(date %in% (as.Date("2021-04-01")+0:10))

```

There is a situation on April 4-6 where age breakouts for vaccination increases do not make sense.  An assumption is made for April 4-6 that d_vxcgte18 will be set to d_vxc for each state:  
```{r, fig.height=9, fig.width=9}

# Conversions for per-day
perDayFunc <- function(x) ifelse(row_number()==1, x, ifelse(lag(x)==0, 0, x-lag(x)))
perDayList <- list("vxa_perday"=expression(perDayFunc(vxa)), 
                   "vxc_perday"=expression(perDayFunc(vxc)), 
                   "vxcgte65_perday"=expression(perDayFunc(vxcgte65)), 
                   "vxc1864_perday"=expression(perDayFunc(vxc1864)), 
                   "vxc0017_perday"=expression(perDayFunc(vxc0017))
                   )

vaxPerCap_210717_func_v4 <- vaxPerCap_210717_func_v2 %>%
    arrange(state, date) %>%
    group_by(state) %>%
    mutate(vxcgte18=ifelse(date %in% c(as.Date("2021-04-04")), lag(vxcgte18) + vxc - lag(vxc), vxcgte18)) %>%
    mutate(vxcgte18=ifelse(date %in% c(as.Date("2021-04-05")), lag(vxcgte18) + vxc - lag(vxc), vxcgte18)) %>%
    mutate(vxcgte18=ifelse(date %in% c(as.Date("2021-04-06")), lag(vxcgte18) + vxc - lag(vxc), vxcgte18)) %>%
    ungroup() %>%
    colMutater(fullList=subGroupList) %>%
    arrange(date, state) %>%
    group_by(state) %>%
    colMutater(fullList=perDayList) %>%
    ungroup()
all.equal(vaxPerCap_210717_func_v4, vaxPerCap_210717_func_v3)
all.equal(vaxPerCap_210717_func_v4[!(vaxPerCap_210717_func_v3$date %in% c(as.Date("2021-04-04")+0:3)), ], 
          vaxPerCap_210717_func_v3[!(vaxPerCap_210717_func_v3$date %in% c(as.Date("2021-04-04")+0:3)), ]
          )

deltaData_210717_v4 <- vaxPerCap_210717_func_v4 %>%
    select(state, date, vxc, vxcgte65, vxcgte18) %>%
    group_by(date) %>%
    summarize(across(where(is.numeric), sum)) %>%
    mutate(across(where(is.numeric), .fn=function(x) ifelse(lag(x)==0, NA, x - lag(x)), .names="d_{.col}")) 
deltaData_210717_v4 %>%
    select(date, starts_with("d")) %>%
    pivot_longer(-date) %>%
    filter(!is.na(value)) %>%
    ggplot(aes(x=date, y=value)) + 
    geom_line(aes(group=name, color=name))
deltaData_210717_v4 %>%
    filter(d_vxc < d_vxcgte18)

vaxPerCap_210717_func_v4 %>%
    select(state, date, vxcgte65_perday, vxc1864_perday, vxc0017_perday) %>%
    pivot_longer(-c(state, date)) %>%
    mutate(age=stringr::str_replace_all(name, "vxc|_perday", "")) %>%
    select(state, date, age, perday=value) %>%
    left_join(popState, by=c("state", "age")) %>%
    mutate(perday_percap=perday/pop) %>%
    arrange(state, date, age) %>%
    group_by(state, age) %>%
    helperRollingAgg("perday_percap", newName="perday_percap7") %>%
    ungroup() %>% 
    filter(!is.na(perday_percap7), state != "DC") %>%
    ggplot(aes(x=date, y=1000*perday_percap7)) + 
    geom_line(aes(group=state, color=state.region[match(state, state.abb)])) + 
    labs(x=NULL, 
         y="Completed per thousand (rolling 7-day)", 
         title="Newly fully vaccinated by day", 
         subtitle="Persons vaccinated before age-breakouts included NOT counted"
         ) +
    facet_wrap(~age) + 
    scale_color_discrete("Census\nRegion")

```
  
The data appear improved, though there are still a handful of states with negative vaccinations completed on given days.  This is an area for further investigation.

A function is written to update key variables by day:  
```{r, fig.height=9, fig.width=9}

updateByDay <- function(df, 
                        dateStart, 
                        dateEnd=NULL,
                        nDates=NULL,
                        varGroup=c("state"), 
                        varSort=c("date"), 
                        exprList=list()
                        ) {
    
    # FUNCTION ARGUMENTS
    # df: the data frame to be processed

    # Convert dateStart to date if not already in that format
    if ("character" %in% class(dateStart)) dateStart <- as.Date(dateStart)
    if (!("Date") %in% class(dateStart)) stop("\nArgument dateStart must be a Date object or character YYYY-MM-DD\n")
    
    # Create dateEnd from nDates if needed
    if (is.null(dateEnd)) {
        if (is.null(nDates)) stop("\nMust pass either dateEnd or nDates\n")
        dateEnd <- dateStart + nDates - 1
    }
    if ("character" %in% class(dateEnd)) dateEnd <- as.Date(dateEnd)
    if (!("Date") %in% class(dateEnd)) stop("\nArgument dateEnd must be a Date object or character YYYY-MM-DD\n")
    
    # Declare the dates to be investigated
    keyDates <- seq.Date(from=dateStart, to=dateEnd, by=1)
    cat("\nData will be modified as needed for dates:",  keyDates, "\n")
    
    # Arrange and group the data as requested
    df <- df %>%
        arrange(across(all_of(c(varGroup, varSort)))) %>%
        group_by(across(all_of(varGroup)))
    
    # Make updates for each of the keyDates
    for (keyDate in keyDates) {
        df <- df %>%
            mutate(modThis=(date %in% keyDate)) %>%
            colMutater(fullList=exprList) %>%
            select(-modThis)
    }
    
    df
    
}

modList <- list("vxcgte18"=expression(ifelse(modThis, lag(vxcgte18) + vxc - lag(vxc), vxcgte18)))

vaxPerCap_210717_func_v4 <- updateByDay(vaxPerCap_210717_func_v2, 
                                        dateStart="2021-04-03", 
                                        dateEnd="2021-04-06", 
                                        exprList=modList
                                        ) %>%
    colMutater(fullList=subGroupList) %>%
    colMutater(fullList=perDayList) %>%
    ungroup()

vaxPerCap_210717_func_v4 %>%
    select(state, date, vxcgte65_perday, vxc1864_perday, vxc0017_perday) %>%
    pivot_longer(-c(state, date)) %>%
    mutate(age=stringr::str_replace_all(name, "vxc|_perday", "")) %>%
    select(state, date, age, perday=value) %>%
    left_join(popState, by=c("state", "age")) %>%
    mutate(perday_percap=perday/pop) %>%
    arrange(state, date, age) %>%
    group_by(state, age) %>%
    helperRollingAgg("perday_percap", newName="perday_percap7") %>%
    ungroup() %>% 
    filter(!is.na(perday_percap7), state != "DC") %>%
    ggplot(aes(x=date, y=1000*perday_percap7)) + 
    geom_line(aes(group=state, color=state.region[match(state, state.abb)])) + 
    labs(x=NULL, 
         y="Completed per thousand (rolling 7-day)", 
         title="Newly fully vaccinated by day", 
         subtitle="Persons vaccinated before age-breakouts included NOT counted"
         ) +
    facet_wrap(~age) + 
    scale_color_discrete("Census\nRegion")

vaxPerCap_210717_func_v4 %>% 
    filter(vxcgte65_perday < 0) %>% 
    arrange(vxcgte65_perday) %>% 
    select(state, date, vxcgte65_perday, vxc1864_perday, vxc0017_perday, everything())

vaxPerCap_210717_func_v4 %>% 
    filter(vxc1864_perday < 0) %>% 
    arrange(vxc1864_perday) %>% 
    select(state, date, vxcgte65_perday, vxc1864_perday, vxc0017_perday, everything())

vaxPerCap_210717_func_v4 %>% 
    filter(vxc0017_perday < 0) %>% 
    arrange(vxc0017_perday) %>% 
    select(state, date, vxcgte65_perday, vxc1864_perday, vxc0017_perday, everything())

```

The data continue to be in better shape, with rolling-7 smoothing out many of the negative/positive swings.  Next steps are to further investigate Texas (65+) and the April 6 data for 65+ and 18-64.  It appears that most of the 65+ data is a bolus on April 6, which may need to be smoothed backwards.
