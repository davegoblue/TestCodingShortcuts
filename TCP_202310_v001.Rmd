---
title: "Three Card Poker"
author: "davegoblue"
date: "2023-10-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
Three Card Poker is a simple game in which the player and the dealer each receive 3 cards from a standard 52-card deck. Hand ranks from high to low are:
  
* Straight flush (AKQ is highest, 32A is lowest)  
* Three-of-a-kind (AAA is highest, 222 is lowest) 
* Straight (AKQ is highest, 32A is lowest)  
* Flush (AKJ is highest, 532 is lowest)  
* Pair (AAK is highest, 223 is lowest)  
* High card (AKJ is highest, 532 is lowest)  
  
Of note, a straight is better than a flush in Three Card Poker. The player makes an Ante wager and then looks at their cards. The player may either make a Play wager equal to their Ante or may fold and lose only their Ante. If the player makes the Play bet, the dealer reveals their cards, with bets resolved as follows:  
  
* Dealer hand is lower than Q32 - pays Ante 1:1 and pushes Play (even if player hand is worse than dealer hand)  
* Dealer hand is Q32 or better and player hand beats dealer hand - pays Ante 1:1 and pays Play 1:1  
* Dealer hand is Q32 or better and player hand ties dealer hand - Ante and Play push  
* Dealer hand is Q32 or better and player hand loses to dealer hand - Ante and Play lose  
  
In addition, the player receives an "Ante Bonus" for holding a very strong hand, regardless of whether the dealer qualifies (Q32 or better) or even beats the player. Typically, the Ante bonus is 1 for Straight, 4 for Three-of-a-Kind, and 5 for Straight Flush

This file explores hands and outcomes in Three Card Poker. Tidyverse and several custom functions are used throughout:  
```{r}

library(tidyverse)
source("./Generic_Added_Utility_Functions_202105_v001.R")

```


## Analysis
All possible combinations of 52 cards are gathered in a matrix:

```{r}

# All combinations of 3 cards from a 52-card deck
aHands <- combn(1:52, 3) %>% t()
str(aHands)

# Suits (1-13 are 1, 14-26 are 2, 27-39 are 3, 40-52 are 4)
aSuits <- 1 + (aHands-1) %/% 13
str(aSuits)
table(aSuits)

# Ranks (1/14/27/40 are A stored as 1, ... , 13/26/39/52 are K stored as 13)
aRanks <- 1 + (aHands-1) %% 13
str(aRanks)
table(aRanks)

```
  
The combinations of suits (and therefore flushes) are explored:  
```{r}

tblSuits <- as.data.frame(sapply(1:4, 
                                 FUN=function(x) apply(aSuits[,], 
                                                       1, 
                                                       FUN=function(y) sum(y==x)
                                                       )
                                 )
                          ) %>% 
    tibble::as_tibble() %>%
    mutate(nMax=apply(., 1, FUN=function(x) max(x)), 
           isFlush=(nMax==3), 
           handNum=row_number()
           ) %>%
    select(handNum, everything())

# Sample of tibble
tblSuits

# Counts of suit distributions
tblSuits %>% 
    count(nMax, isFlush, V1, V2, V3, V4)

```

The combinations of ranks (and therefore trips and straights and pairs) is explored, and combined with the suits data to create overall hand types:  
```{r}

tblRanks <- as.data.frame(sapply(1:13, 
                                 FUN=function(x) apply(aRanks[,], 
                                                       1, 
                                                       FUN=function(y) sum(y==x)
                                                       )
                                 )
                          ) %>% 
    tibble::as_tibble() %>%
    mutate(nMax=apply(., 1, FUN=function(x) max(x)), 
           isTrips=(nMax==3),
           isPair=(nMax==2),
           handNum=row_number()
           ) %>%
    select(handNum, everything())

# Matrix of ranks that constitute a straight
mtxStrRanks <- matrix(data=0L, nrow=13, ncol=12)
for(idx in 1:11) mtxStrRanks[idx:(idx+2), idx] <- 1L
mtxStrRanks[c(1, 12, 13), 12] <- 1L
mtxStrRanks

# tblRanks converted to matrix of yes/no by rank
mtxBoolRanks <- tblRanks %>%
    select(V1:V13) %>%
    mutate(across(.cols=everything(), .fns=function(x) pmin(1L, x))) %>%
    as.matrix()
str(mtxBoolRanks)

# Check for each type of straight
tblRanks <- tblRanks %>%
    mutate(maxStr=mtxBoolRanks %*% mtxStrRanks %>% apply(., 1, FUN=max), 
           isStraight=(maxStr==3)
           )

# Example of tibble
tblRanks

# Counts of hand types based on rank
tblRanks %>% 
    count(nMax, isTrips, isPair, maxStr, isStraight)

# Counts by straight
tblRanks %>%
    filter(isStraight) %>%
    group_by(across(starts_with("V"))) %>%
    summarize(n=n(), .groups="drop")

# Create handTypes
tblHandTypes <- tblRanks %>%
    select(handNum, isTrips, isPair, isStraight) %>%
    full_join(select(tblSuits, handNum, isFlush), by="handNum") %>%
    mutate(handType=case_when(isStraight & isFlush ~ "01. SF", 
                              isTrips ~ "02. Trips", 
                              isStraight ~ "03. Straight", 
                              isFlush ~ "04. Flush", 
                              isPair ~ "05. Pair", 
                              TRUE ~ "06. High Card"
                              )
           )
tblHandTypes

tblHandTypes %>%
    count(handType, isTrips, isStraight, isFlush, isPair) %>%
    arrange(n) %>%
    mutate(pct=n/sum(n))

```

Hands by type are given a ranking:  
```{r}

# Ranks database
tblHandRanks <- tblHandTypes %>%
    select(handNum, handType) %>%
    full_join(select(tblRanks, handNum, V1:V13)) %>%
    pivot_longer(cols=-c(handNum, handType)) %>%
    filter(value>0) %>%
    mutate(card=as.integer(str_replace(name, "V", "")), 
           card=ifelse(card==1, 14, card)
           ) %>%
    arrange(handNum, desc(value), desc(card))
tblHandRanks

# Hands without straights can be ranked directly
rnkNonStraight <- tblHandRanks %>%
    group_by(handNum) %>%
    mutate(rn=paste0("C", row_number())) %>%
    filter(!(handType %in% c("01. SF", "03. Straight"))) %>%
    pivot_wider(id_cols=c(handNum, handType), 
                names_from="rn", 
                values_from="card", 
                values_fill=0
                ) %>%
    ungroup()
rnkNonStraight

# Ranks within type for non-straights
rnkNonStraight <- rnkNonStraight %>%
    count(handType, C1, C2, C3, name="nSameRank") %>%
    arrange(handType, desc(C1), desc(C2), desc(C3)) %>%
    group_by(handType) %>%
    mutate(rankOfType=row_number()) %>%
    ungroup() %>%
    inner_join(rnkNonStraight, by=c("handType", "C1", "C2", "C3"))
rnkNonStraight

# Ranks for hands with straights
rnkStraight <- tblHandRanks %>%
    group_by(handNum) %>%
    mutate(rn=paste0("C", row_number())) %>%
    filter(handType %in% c("01. SF", "03. Straight")) %>%
    pivot_wider(id_cols=c(handNum, handType), 
                names_from="rn", 
                values_from="card", 
                values_fill=0
                ) %>%
    ungroup() %>%
    mutate(C1=ifelse(C1==14 & C2==3, 1, C1))
rnkStraight

# Ranks within type for straights
rnkStraight <- rnkStraight %>%
    count(handType, C1, C2, C3, name="nSameRank") %>%
    arrange(handType, desc(C1), desc(C2), desc(C3)) %>%
    group_by(handType) %>%
    mutate(rankOfType=row_number()) %>%
    ungroup() %>%
    inner_join(rnkStraight, by=c("handType", "C1", "C2", "C3"))
rnkStraight

# Full hand ranks
rnkAllHands <- bind_rows(rnkStraight, rnkNonStraight) %>%
    arrange(handType, rankOfType) %>%
    mutate(chgType=handType!=lag(handType), 
           chgRank=rankOfType!=lag(rankOfType), 
           chgVal=ifelse(row_number()==1, 1, ifelse(chgType|chgRank, 1, 0)), 
           rankOverall=cumsum(chgVal)
           )
rnkAllHands

rnkAllHands %>% count(rankOverall, name="nRankOverall")
rnkAllHands %>% 
    count(rankOverall, handType, name="nRankOverall") %>% 
    count(handType, nRankOverall)

```

A list of hand numbers containing each card (1-52) is created, as well as a function to generate excluded hand numbers:  
```{r}

cardInHand <- lapply(1:52, FUN=function(x) which(rowSums(aHands==x)==1))
str(cardInHand)

exclHands <- function(exclCards, lstExclude=cardInHand) {
    purrr::reduce(.x=lstExclude[c(exclCards)], .f=union)
}

# Example usages
str(exclHands(c(1)))
str(exclHands(c(1, 14, 27)))
str(exclHands(c(1:39)))
str(exclHands(c(1:49)))

# Confirm correct lengths of exclusion
choose(52,3) - choose(c(51, 49, 13, 3), 3)

# Confirm distribution of remaining cards
# Note that 1e9 is a workaround to send a non-existent index to avoid mismatched formats
map_dfr(list(c(), c(1), c(1, 14, 27), c(1:39), c(1:49)), 
       .f=function(x) {
           a <- if(length(x)>0) table(aHands[-exclHands(x),]) else table(aHands[-1e9,])
           as.data.frame(a)
           }, 
       .id="src"
       ) %>%
    tibble::as_tibble() %>%
    mutate(src=c("1"="All", 
                 "2"="Excl 1", 
                 "3"="Excl 3", 
                 "4"="Excl 39", 
                 "5"="Excl 49"
                 )[src]) %>%
    pivot_wider(id_cols="Var1", names_from="src", values_from="Freq", values_fill=0) %>%
    rename(Card=Var1) %>%
    print(n=52)

```

Possible outcomes for an example hand are explored:  
```{r}

# Include whether the hand qualifies
tblHands <- rnkAllHands %>%
    mutate(qual=(handType!="06. High Card" | C1 >= 12))
tblHands %>% count(handType, qual) %>% mutate(pct=n/sum(n))

# Pull an example hand number, get rank and exclusions
tmpHand <- 12345
aHands[tmpHand,]
tblHands %>% filter(handNum==tmpHand)
tmpRank <- tblHands %>% filter(handNum==tmpHand) %>% pull(rankOverall)
tmpRes <- tblHands %>%
    select(handNum, rankOverall, qual) %>%
    filter(!(handNum %in% exclHands(aHands[tmpHand,,drop=TRUE]))) %>%
    mutate(res=case_when(rankOverall<tmpRank~"L", rankOverall>tmpRank~"W", TRUE~"T")) %>%
    count(qual, res) %>%
    mutate(pct=n/sum(n), 
           resPlay=case_when(!qual~1, res=="L"~-2, res=="W"~2, TRUE~0)
           )
tmpRes
cat("EV of playing:", 
    round(sum(tmpRes$pct*tmpRes$resPlay), 3), 
    "vs. EV of folding: -1.000\n"
    )

```

The process is converted to functional form:  
```{r}

assessHand <- function(hn, 
                       dbHands=tblHands, 
                       mtxHands=aHands, 
                       exclList=exclHands
                       ) {
    
    # FUNCTION ARGUMENTS:
    # hn: hand number to evaluate
    # dbHands: data frame containing map of hand number to overall rank and qualification
    # mtxHands: matrix of hands to cards, sorted by hand number
    # exclList: list of hands excluded by card
    
    # Get rank of requested hand
    keyRank <- dbHands %>% filter(handNum==hn) %>% pull(rankOverall)

    # Get and return outcomes of requested hand
    dbHands %>%
        select(handNum, rankOverall, qual) %>%
        filter(!(handNum %in% exclList(mtxHands[hn,,drop=TRUE]))) %>%
        mutate(res=case_when(rankOverall<keyRank~"L", 
                             rankOverall>keyRank~"W", 
                             TRUE~"T"
                             )
               ) %>%
        count(qual, res) %>%
        mutate(pct=n/sum(n), handNum=hn)

}

assessHand(12345)
map_dfr(.x=1:100, .f=function(x) assessHand(x))

```

Every hand is assessed, with process cached and results saved as RDS:
```{r cache=TRUE}

t <- proc.time()
allTCPHandData <- map_dfr(.x=1:nrow(tblHands), .f=function(x) assessHand(x))
allTCPHandData
proc.time() - t

saveToRDS(allTCPHandData)

```

Data are converted to a single line per hand:  
```{r}

# Counts of result by hand type
allTCPHandN <- allTCPHandData %>%
    mutate(name=paste0("n", res, ifelse(qual, "Q", "N"))) %>%
    pivot_wider(id_cols="handNum", names_from="name", values_from="n", values_fill=0)
allTCPHandN

# Percentages of result by hand type
allTCPHandPct <- allTCPHandData %>%
    mutate(name=paste0("p", res, ifelse(qual, "Q", "N"))) %>%
    pivot_wider(id_cols="handNum", names_from="name", values_from="pct", values_fill=0)
allTCPHandPct

# Identical results by hand type
eqResults <- allTCPHandN %>%
    arrange(nWN, nLQ, nTQ, nWQ, nLN, nTN) %>%
    mutate(oa=apply(select(., -handNum), 1, FUN=function(x) paste0(x, collapse="-")), 
           isNew=ifelse(row_number()==1, 1, ifelse(oa!=lag(oa), 1, 0)), 
           typeNum=cumsum(isNew)
           )
eqResults
summary(eqResults)

```

There are 1,652 unique combinations of outcomes across the 22,100 starting hands

The optimal decision is included, based on hand percentages:  
```{r}

allTCPHandAction <- allTCPHandPct %>%
    mutate(evPlay=(pWN+pTN+pLN)+2*(pWQ-pLQ), 
           action=ifelse(evPlay>=-1, "Play", "Fold"), 
           evOptimal=ifelse(action=="Fold", -1, evPlay)
           ) %>%
    select(handNum, evPlay, action, evOptimal)
allTCPHandAction

allTCPHandAction %>%
    summarize(across(starts_with("ev"), mean))

allTCPHandAction %>%
    group_by(action) %>%
    summarize(n=n(), across(starts_with("ev"), mean))

allTCPHandAction %>%
    full_join(select(tblHands, handNum, handType), by="handNum") %>%
    group_by(handType, action) %>%
    summarize(n=n(), across(starts_with("ev"), mean), .groups="drop")

```

The decision function for hands with only a high card is plotted:  
```{r, fig.height=9, fig.width=9}

allTCPHandAction %>% 
    full_join(select(tblHands, handNum, handType, C1, C2), by="handNum") %>%
    filter(handType=="06. High Card") %>%
    group_by(C1, C2) %>%
    summarize(pctPlay=mean(action=="Play"), 
              evPlay=mean(evPlay), 
              n=n(), 
              .groups="drop"
              ) %>%
    ggplot(aes(y=factor(C1, levels=5:14), x=factor(C2, levels=13:3))) + 
    geom_tile(aes(fill=pctPlay)) + 
    geom_text(aes(label=paste0(round(100*pctPlay, 1), "%\n(", round(evPlay, 3), ")")), 
              size=2.5
              ) +
    scale_fill_continuous("% Play", low="white", high="lightgreen") + 
    labs(title="Percentage of hands played optimally (high-card only hands)",
         subtitle="Cell contents are % played (mean EV of playing)",
         y="Highest card (14=A, 13=K, 12=Q, 11=J)", 
         x="Second-highest card (13=K, 12=Q, 11=J)"
         )

```

The EV for hands with a pair is plotted:  
```{r, fig.height=9, fig.width=9}

allTCPHandAction %>% 
    full_join(select(tblHands, handNum, handType, C1, C2), by="handNum") %>%
    filter(handType=="05. Pair") %>%
    group_by(C1, C2) %>%
    summarize(pctPlay=mean(action=="Play"), 
              evPlay=mean(evPlay), 
              n=n(), 
              .groups="drop"
              ) %>%
    ggplot(aes(y=factor(C1, levels=2:14), x=factor(C2, levels=14:2))) + 
    geom_tile(aes(fill=evPlay)) +
    geom_text(aes(label=paste0(round(evPlay, 3))), 
              size=2.5
              ) + 
    scale_fill_continuous("EV Play", low="white", high="lightgreen", limits=c(0, 2)) +
    labs(title="EV of pair hands (pair hands always played)",
         subtitle="Cell contents are mean EV of playing",
         y="Paired card (14=A, 13=K, 12=Q, 11=J)", 
         x="Kicker (14=A, 13=K, 12=Q, 11=J)"
         )

```

Due to the unlikelihood of a kicker being needed when comparing a player and dealer pair, there are some non-monotonic features to EV. In general, a better kicker is less likely to block dealer qualifying (not A/K/Q) but more likely to block higher dealer pairs. For example, with a pair of 4s, J kicker has EV +0.81 while Q kicker has EV +0.79, and 5 kicker has EV +0.80 while 3 kicker has EV +0.77

The impact of suits on EV is explored:  
```{r, fig.height=9, fig.width=9}

allTCPHandAction %>% 
    full_join(select(tblHands, handNum, handType, C1, C2, C3), by="handNum") %>%
    full_join(select(tblSuits, handNum, nMax), by="handNum") %>%
    filter(handType=="06. High Card") %>%
    group_by(C1, C2, nMax) %>%
    summarize(n=n(), 
              evMean=mean(evPlay), 
              evMax=max(evPlay), 
              evMin=min(evPlay), 
              .groups="drop"
              ) %>%
    arrange(C1, C2, nMax) %>%
    group_by(C1, C2) %>%
    summarize(delta_21=last(evMean)-first(evMean), .groups="drop") %>%
    ggplot(aes(y=factor(C1, levels=5:14), x=factor(C2, levels=13:3))) + 
    geom_tile(aes(fill=delta_21)) +
    geom_text(aes(label=paste0("", round(delta_21, 4), "")), 
              size=2.5
              ) + 
    scale_fill_continuous("Delta EV", high="white", low="pink") +
    labs(title="Mean difference in EV for suits 2-1-0 vs. 1-1-1 (high card only)",
         subtitle="Negative reflects 2-1-0 having lower mean EV than 1-1-1",
         y="Highest card (14=A, 13=K, 12=Q, 11=J)", 
         x="Second-highest card (13=K, 12=Q, 11=J)"
         )

```

Suits play a very small role in mean EV for given high-card hand ranks, with impact ranging from ~0.0020 better for AKx rainbow to ~0.0005 better for Q32 rainbow

Function assessHand() is re-written to allow for specifying cards to be excluded:  
```{r}

oldAssess <- assessHand

assessHand <- function(hn=NULL, 
                       keyRank=NULL,
                       dbHands=tblHands, 
                       mtxHands=aHands,
                       exclCards=NULL,
                       exclList=exclHands
                       ) {
    
    # FUNCTION ARGUMENTS:
    # hn: hand number to evaluate (if NULL, need to pass keyRank and exclCards instead)
    # keyRank: hand rank for use in dbHands (if NULL, calculated from hn)
    # dbHands: data frame containing map of hand number to overall rank and qualification
    # mtxHands: matrix of hands to cards, sorted by hand number
    # exclCards: cards not available for other hands (if NULL, the cards in hn)
    # exclList: list of hands excluded by card
    
    # Get rank of requested hand
    if(is.null(keyRank)) {
        if(is.null(hn)) stop("\nMust pass either hn or keyRank\n")
        keyRank <- dbHands %>% filter(handNum==hn) %>% pull(rankOverall)
    }
    
    # Get cards to be excluded
    if(is.null(exclCards)) {
        if(is.null(hn)) stop("\nMust pass either hn or exclCards\n")
        exclCards <- mtxHands[hn,,drop=TRUE]
    }
    
    # Get and return outcomes of requested hand
    dbHands %>%
        select(handNum, rankOverall, qual) %>%
        filter(!(handNum %in% exclList(exclCards))) %>%
        mutate(res=case_when(rankOverall<keyRank~"L", 
                             rankOverall>keyRank~"W", 
                             TRUE~"T"
                             )
               ) %>%
        count(qual, res) %>%
        mutate(pct=n/sum(n), 
               handNum=ifelse(is.null(hn), NA_integer_, as.integer(hn)), 
               keyRank=keyRank
               )

}

# hn=123 has cards 1, 4, 28 (A42 with A-4 suited) and is of rank 531
oldAssess(hn=123)
assessHand(hn=123)
assessHand(keyRank=531, exclCards=c(1, 4, 28))
assessHand(keyRank=531, exclCards=c(1, 4, 28, 38)) # exclude an extra offsuit Q

```

The lowest playing hand is explored for the impact of each additional card excluded:  
```{r, fig.height=9, fig.width=9}

tmpHand <- allTCPHandAction %>% 
    filter(action=="Play") %>%
    arrange(evPlay) %>%
    slice(1) %>%
    pull(handNum)
tmpRank <- tblHands %>%
    filter(handNum==tmpHand) %>%
    pull(rankOverall)
tmpCards <- aHands[tmpHand,,drop=TRUE]

cat("\nHand number:", 
    tmpHand, 
    "with cards [", 
    paste0(tmpCards, sep=""), 
    "] and rank", 
    tmpRank, 
    "will be explored\n"
    )

assessHand(hn=tmpHand)
assessHand(keyRank=tmpRank, exclCards=tmpCards)

tmpWL <- map_dfr(.x=setdiff(1:52, tmpCards), 
                 .f=function(x) {
                     assessHand(keyRank=tmpRank, exclCards=c(tmpCards, x)) %>%
                         mutate(extraCard=x)
                     }
                 )
tmpWL

tmpWL %>%
    mutate(outc=case_when(!qual ~ 1, res=="L" ~ -2, res=="W" ~ 2, res=="T" ~ 0)) %>%
    group_by(extraCard) %>%
    summarize(ev=sum(outc*n)/sum(n), pQual=sum(qual*n)/sum(n)) %>%
    mutate(ecSuit=1+((extraCard-1) %/% 13), 
           ecRank=1+((extraCard-1) %% 13), 
           ecRank=ifelse(ecRank==1, 14, ecRank)
           ) %>%
    ggplot(aes(x=factor(ecRank, levels=14:2), y=ev)) +
    geom_text(aes(y=ev+0.005*ifelse(ev>-1, -1, 1), 
                  label=round(ev, 3), 
                  hjust=ifelse(ev>-1, 1, 0)
                  ), 
              size=2.5
              ) +
    geom_point() + 
    coord_flip() +
    facet_wrap(~ecSuit, nrow=1) +
    geom_hline(yintercept=-1, lty=2) +
    labs(y="EV", 
         x="Card Rank", 
         title=paste0("EV of playing ", 
                      paste0(tmpCards, collapse="-"), 
                      " if one extra card excluded"
                      ), 
         subtitle="Facetted by suit"
         )

```

Data are integrated to include a full picture of possible outcomes, for use in sampling:  
```{r}

# Table of ante bonus and pair-plus bonus
tblBonus <- tibble::tibble(handType=sort(unique(tblHandTypes$handType)),
                           ppBonus=c(40, 30, 6, 3, 1, -1), 
                           anteBonus=c(5, 4, 1, 0, 0, 0)
                           )
tblBonus

# Add hand type, optimal action, and pivot longer
# Add qualification, win/loss, main payout, ante bonus, pair-plus bonus
allTCPOutcome <- allTCPHandN %>%
    full_join(select(tblHandTypes, handNum, handType), by="handNum") %>%
    full_join(select(allTCPHandAction, handNum, action), by="handNum") %>%
    pivot_longer(cols=-c(handNum, handType, action), values_to="n") %>%
    mutate(dealerQual=str_sub(name, 3, 3), 
           playerRaw=str_sub(name, 2, 2),
           antePay=case_when(action=="Fold"~-1, 
                             dealerQual=="N"~1, 
                             playerRaw=="W"~1, 
                             playerRaw=="T"~0, 
                             playerRaw=="L"~-1
                             ), 
           playPay=case_when(action=="Fold"~0, 
                             dealerQual=="N"~0, 
                             playerRaw=="W"~1, 
                             playerRaw=="T"~0, 
                             playerRaw=="L"~-1
                             )
           ) %>%
    left_join(tblBonus, by="handType")
allTCPOutcome

# Confirm expected values
tmpSum <- allTCPOutcome %>%
    select(-handNum) %>%
    summarize(across(where(is.numeric), .fns=function(x) sum(x*n)/sum(n)))
tmpSum %>% select(-n)
tmpSum %>% select(-n, -ppBonus) %>% sum()

```

Expected values are consistent with the summary provided by Wizard of Odds website:  
  
* Pair Plus Bonus: -7.276% (Wizard) matches
* Main Bet: -3.37% (Wizard) matches

Hands are simulated, with summary statistics calculated:  
```{r}

nSims <- 10000
nPer <- 100

set.seed(23110314)

# Example simulation
allTCPSim <- allTCPOutcome %>% 
    sample_n(size=nSims*nPer, replace=TRUE, weight=n) %>%
    mutate(simNumber=rep(1:nSims, each=nPer))
allTCPSim

# Example summary of outcomes
allTCPSim %>%
    group_by(simNumber) %>%
    summarize(n=n(), across(c(antePay, playPay, ppBonus, anteBonus), sum)) %>%
    mutate(mainPay=antePay+playPay+anteBonus) %>%
    select(-n, -simNumber) %>%
    summary()

```

Simulation means are very close to theoretical game EV

Results by simulation are assessed assuming a 2:1 ratio of Ante-Bonus:
```{r}

allTCPSim %>%
    mutate(mainBet=(antePay+playPay+anteBonus), overall=2*mainBet+ppBonus) %>%
    group_by(simNumber) %>%
    mutate(ovCum=cumsum(overall), ovMain=cumsum(mainBet), ovBonus=cumsum(ppBonus)) %>%
    summarize(minOverall=min(ovCum), 
              sumOverall=sum(overall), 
              minMain=min(ovMain),
              sumMain=sum(mainBet),
              minBonus=min(ovBonus),
              sumBonus=sum(ppBonus),
              pQ=mean(dealerQual=="Q")
              ) %>%
    summary()

```

Theoretical means and standard errors are calculated for comparison:  
```{r}

sdCols <- c("qual", "fold",
            "win", "tie", "lose", 
            "antePay", "playPay", "anteBonus", "mainOutcome", 
            "ppBonus", "outcome2_1"
            )

allTCPOutcome %>%
    mutate(mainOutcome=(antePay+playPay+anteBonus), 
           outcome2_1=2*mainOutcome+ppBonus, 
           qual=dealerQual=="Q", 
           win=playerRaw=="W", 
           tie=playerRaw=="T", 
           lose=playerRaw=="L", 
           fold=action=="Fold"
           ) %>%
    pivot_longer(cols=all_of(sdCols), names_to="metric", values_to="metricVal") %>%
    group_by(metric) %>%
    summarize(mu=sum(metricVal*n)/sum(n), 
              variance=sum(n*metricVal**2)/sum(n)-mu**2, 
              sd=sqrt(variance), 
              se100=sd/10
              ) %>%
    mutate(ord=match(metric, sdCols)) %>%
    arrange(ord) %>%
    select(-ord)

```

Simulated and theoretical means and standard errors are compared:  
```{r, fig.height=9, fig.width=9}

sdCols <- c("qual", "fold",
            "win", "tie", "lose", 
            "antePay", "playPay", "anteBonus", "mainOutcome", 
            "ppBonus", "outcome2_1"
            )

tcpTheoretical <- allTCPOutcome %>%
    mutate(mainOutcome=(antePay+playPay+anteBonus), 
           outcome2_1=2*mainOutcome+ppBonus, 
           qual=dealerQual=="Q", 
           win=playerRaw=="W", 
           tie=playerRaw=="T", 
           lose=playerRaw=="L", 
           fold=action=="Fold"
           ) %>%
    pivot_longer(cols=all_of(sdCols), names_to="metric", values_to="metricVal") %>%
    group_by(metric) %>%
    summarize(mu=sum(metricVal*n)/sum(n), 
              variance=sum(n*metricVal**2)/sum(n)-mu**2, 
              sd=sqrt(variance)
              ) %>%
    mutate(ord=match(metric, sdCols)) %>%
    arrange(ord) %>%
    select(-ord)
tcpTheoretical

tcpSimSummary <- allTCPSim %>%
    mutate(mainBet=(antePay+playPay+anteBonus), overall=2*mainBet+ppBonus) %>%
    group_by(simNumber) %>%
    mutate(ovCum=cumsum(overall), ovMain=cumsum(mainBet), ovBonus=cumsum(ppBonus)) %>%
    summarize(minOverall=min(ovCum), 
              sumOverall=sum(overall), 
              minMain=min(ovMain),
              sumMain=sum(mainBet),
              minBonus=min(ovBonus),
              sumBonus=sum(ppBonus),
              pQ=mean(dealerQual=="Q")
              )
tcpSimSummary

# Comparison of the main bet and bonus bet
tmpCompare <- tcpSimSummary %>%
    select(simNumber, sumMain, sumBonus) %>%
    colRenamer(vecRename=c("sumMain"="mainOutcome", "sumBonus"="ppBonus")) %>%
    pivot_longer(cols=-c(simNumber)) %>%
    group_by(name) %>%
    summarize(simMean=mean(value), simSD=sd(value)) %>%
    left_join(tcpTheoretical, by=c("name"="metric"))
tmpCompare

# Comparison of actual and expected SD
tmpCompare %>%
    mutate(sd100=sd*10) %>%
    select(metric=name, sim=simSD, theory=sd100) %>%
    pivot_longer(cols=-c(metric)) %>%
    ggplot(aes(x=metric, y=value)) + 
    geom_point(aes(color=name)) +
    coord_flip() + 
    labs(title="Theoretical and actual SD for 10,000 simulations of 100 hands", 
         y="Standard Deviation (SD)", 
         x=NULL
         ) + 
    scale_color_discrete(NULL) + 
    lims(y=c(0, NA))

# Comparison of actual and expected mean
tmpCompare %>%
    mutate(mean100=mu*100, 
           theorySE=sqrt(100)*sd/sqrt(10000), 
           oneUp=mean100+theorySE, 
           oneDown=mean100-theorySE
           ) %>%
    select(metric=name, 
           sim=simMean, 
           theoryMean=mean100, 
           theorySE, 
           oneUp, 
           oneDown
           ) %>%
    ggplot(aes(x=metric)) + 
    geom_point(aes(y=sim), color="blue") +
    geom_point(aes(y=theoryMean), color="green") +
    geom_errorbar(aes(ymin=oneDown, ymax=oneUp), color="green") +
    coord_flip() + 
    labs(title="Theoretical mean/SE (green) and actual mean (blue)", 
         subtitle="10,000 simulations of 100 hands", 
         y="Mean result of 100 hands (theoretical includes +/- 1 SE)", 
         x=NULL
         )

```

Associations between main bet and bonus are explored:  
```{r, fig.height=9, fig.width=9}

# Verify the 2:1 ratio
lm(sumOverall ~ sumMain + sumBonus, data=tcpSimSummary) %>%
    summary()

# Explore associations
tcpSimSummary %>%
    select(-simNumber) %>%
    cor() %>% 
    as.data.frame() %>%
    rownames_to_column("var1") %>%
    tibble::as_tibble() %>%
    pivot_longer(cols=-c(var1), names_to="var2", values_to="corr") %>%
    filter(var1<=var2) %>%
    ggplot(aes(x=var1, y=var2)) +
    geom_tile(aes(fill=corr)) + 
    geom_text(aes(label=round(corr, 3))) + 
    scale_fill_gradient2("Corr:", high="green") + 
    labs(title="Correlation of outcomes in 10,000 simulations, each of 100 hands", 
         y=NULL, 
         x=NULL
         )

```

Relationships between pQ (percent dealer hands qualifying) and main/bonus bet outcomes are explored:  
```{r, fig.height=9, fig.width=9}

tcpSimSummary %>%
    select(simNumber, pQ, sumMain, sumBonus) %>%
    pivot_longer(cols=c(sumMain, sumBonus)) %>%
    mutate(r_pQ=round(pQ, 2), r_value=round(5*value)/5) %>%
    count(name, r_pQ, r_value) %>%
    ggplot(aes(x=r_pQ, y=r_value)) + 
    geom_point(aes(size=n), alpha=0.1) + 
    geom_point(data=~summarize(group_by(., name), 
                               across(c(r_pQ, r_value), .fns=function(x) sum(x*n)/sum(n))
                               ), 
               color="red", 
               size=3
               ) +
    geom_smooth(aes(weight=n), method="lm") +
    facet_wrap(~name) + 
    labs(title="Main and bonus bet outcomes associated to dealer percent qualified", 
         subtitle="10,000 simulations, each of 100 hands",
         caption="Red dot is simulation mean",
         x="Percent dealer qualified", y="Outcome (rounded to nearest 5 units)"
         ) + 
    scale_size_continuous("# Sims")

```

Predictive power is explored:  
```{r}

library(ranger) # needs to be called for predict.ranger later

rfTest <- ranger::ranger(sumMain ~ sumBonus + pQ, data=tcpSimSummary)
rfTest

lmTest <- lm(sumMain ~ sumBonus + pQ, data=tcpSimSummary)
summary(lmTest)

```

The simple linear model and the base random forest each explain ~25% of the variance in main bet outcomes, given bonus bet outcomes and percent dealer qualified

Performance on holdout data is explored:  
```{r, fig.height=9, fig.width=9}

set.seed(23111015)
idxTrain <- sample(1:nrow(tcpSimSummary), 
                   size=round(0.7*nrow(tcpSimSummary)), 
                   replace=FALSE
                   )

tcpSimTrain <- tcpSimSummary[idxTrain, ]
tcpSimTest <- tcpSimSummary[-idxTrain, ]

rfTest <- ranger::ranger(sumMain ~ sumBonus + pQ, data=tcpSimTrain)
rfTest

lmTest <- lm(sumMain ~ sumBonus + pQ, data=tcpSimTrain)
summary(lmTest)

# Apply to holdout data
tcpSimPlotData <- tcpSimTest %>%
    mutate(lmPred=predict(lmTest, newdata=.), 
           rfPred=predict(rfTest, data=.)$predictions
           ) %>%
    select(simNumber, sumMain, lmPred, rfPred) %>%
    pivot_longer(cols=-c(simNumber, sumMain)) %>%
    mutate(err=value-sumMain)
tcpSimPlotData

# Get statistics
tcpSimPlotData %>%
    group_by(name) %>%
    summarize(n=n(), 
              err2Orig=mean((sumMain-mean(sumMain))**2), 
              err2Pred=mean(err**2), 
              r2=1-err2Pred/err2Orig
              )

tcpSimPlotData %>%
    ggplot(aes(y=sumMain, x=value)) + 
    geom_point(alpha=0.1) + 
    facet_wrap(~name) + 
    labs(title="Predictions on unseen data", x="Predicted Main", y="True Main") +
    geom_smooth(method="lm") + 
    geom_abline(intercept=0, slope=1, lty=2, color="red")

```

Both models perform as well on unseen data as on training data. The relationship known to have perfect predictive power is explored:  
```{r, fig.height=9, fig.width=9}

rfTest <- ranger::ranger(sumOverall ~ sumMain + sumBonus, data=tcpSimTrain)
rfTest

lmTest <- lm(sumOverall ~ sumMain + sumBonus, data=tcpSimTrain)
summary(lmTest)

# Apply to holdout data
tcpSimPlotData <- tcpSimTest %>%
    mutate(lmPred=predict(lmTest, newdata=.), 
           rfPred=predict(rfTest, data=.)$predictions
           ) %>%
    select(simNumber, sumOverall, lmPred, rfPred) %>%
    pivot_longer(cols=-c(simNumber, sumOverall)) %>%
    mutate(err=value-sumOverall)
tcpSimPlotData

# Get statistics
tcpSimPlotData %>%
    group_by(name) %>%
    summarize(n=n(), 
              err2Orig=mean((sumOverall-mean(sumOverall))**2), 
              err2Pred=mean(err**2), 
              r2=1-err2Pred/err2Orig
              )

tcpSimPlotData %>%
    ggplot(aes(y=sumOverall, x=value)) + 
    geom_point(alpha=0.1) + 
    facet_wrap(~name) + 
    labs(title="Predictions on unseen data", x="Predicted Overall", y="True Overall") +
    geom_smooth(method="lm") + 
    geom_abline(intercept=0, slope=1, lty=2, color="red")

```

Both models perform very well, though the linear model is slightly better at finding the exact linear relationship among the variables

ECDF are explored for simulation summaries:  
```{r, fig.height=9, fig.width=9}

percKey <- c(0, 0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99, 1)

tcpSimSummary %>%
    select(minMain) %>%
    arrange(minMain) %>%
    mutate(pct=(row_number()-1)/(n()-1)) %>%
    ggplot(aes(x=minMain, y=pct)) + 
    geom_text(data=~filter(., round(pct,4) %in% percKey), 
              aes(label=paste0(minMain, " (", round(1000*pct)/10, "%)"), 
                  hjust=ifelse(pct %in% c(0, 1), 0, 1),
                  vjust=ifelse(pct==1, 1, 0)
                  ), 
              color="red", 
              size=2.5
              ) +
    geom_point(alpha=0.1, size=0.5) + 
    labs(title="ECDF of minimum position of main bet over 100 hands", 
         y=NULL, 
         x="Minimum position of main bet (100 hands)", 
         subtitle="10,000 simulations"
         )

```

ECDF are updated to include final main bet summaries:  
```{r, fig.height=9, fig.width=9}

# Need better rounding for percentiles and selection
percKey <- c(0, 0.05, 0.25, 0.5001, 0.75, 0.95, 1)

tcpSimSummary %>%
    select(simNumber, minMain, sumMain) %>%
    pivot_longer(cols=-c(simNumber)) %>%
    arrange(name, value) %>%
    group_by(name) %>%
    mutate(pct=(row_number()-1)/(n()-1)) %>%
    ggplot(aes(x=value, y=pct)) + 
    geom_text(data=~filter(., round(pct,4) %in% percKey), 
              aes(label=paste0(value, " (", round(1000*pct)/10, "%)"), 
                  hjust=ifelse(pct %in% c(0, 1), 0, 1),
                  vjust=ifelse(pct==1, 1, 0)
                  ), 
              color="red", 
              size=2.5
              ) +
    geom_point(alpha=0.1, size=0.5) + 
    facet_wrap(~name) +
    labs(title="ECDF of main bet over 100 hands", 
         y=NULL, 
         x="Main bet (100 hands)", 
         subtitle="10,000 simulations"
         )

```

The process is updated for better percentile matching:  
```{r, fig.height=9, fig.width=9}

percKey <- c(0, 0.05, 0.25, 0.5, 0.75, 0.95, 1)

# Function to get closest match in x to y
getBestMatch <- function(x, y, preferLess=TRUE) {
    x <- sort(x)
    op <- vector("numeric", length(y))
    
    for(ctr in 1:length(y)) {
        av <- abs(x-y[ctr])
        wm <- which.min(av)
        op[ctr] <- x[wm[ifelse(isTRUE(preferLess), 1, length(wm))]]
    }
 
    op
    
}

# Check pulling reasonable matches
getBestMatch((0:9999)/9999, percKey)

tcpSimSummary %>%
    select(simNumber, minMain, sumMain) %>%
    pivot_longer(cols=-c(simNumber)) %>%
    arrange(name, value) %>%
    group_by(name) %>%
    mutate(pct=(row_number()-1)/(n()-1)) %>%
    ggplot(aes(x=value, y=pct)) + 
    geom_text(data=~filter(., pct %in% getBestMatch(.$pct, percKey)), 
              aes(label=paste0(value, " (", round(1000*pct)/10, "%)"), 
                  hjust=ifelse(pct %in% c(0, 1), 0, 1),
                  vjust=ifelse(pct==1, 1, 0)
                  ), 
              color="red", 
              size=2.5
              ) +
    geom_point(alpha=0.1, size=0.5) + 
    facet_wrap(~name) +
    labs(title="ECDF of main bet over 100 hands", 
         y=NULL, 
         x="Main bet (100 hands)", 
         subtitle="10,000 simulations"
         )

```

The ECDF process is converted to functional form:  
```{r, fig.height=9, fig.width=9}

getSimECDF <- function(df, 
                       ecdfVars, 
                       uqid="simNumber", 
                       percPoint=c(),
                       labObj=labs()
                       ) {
    
    # FUNCTION ARGUMENTS:
    # df: data frame containing simulation data
    # ecdfVars: variables to use in creating ECDF
    # uqid: unique id in simulations
    # percPoint: percentiles to call out values on ECDF plot
    # labObj: labelling object
    
    p1 <- df %>%
        select(all_of(c(uqid, ecdfVars))) %>%
        pivot_longer(cols=-c(all_of(uqid))) %>%
        arrange(name, value) %>%
        group_by(name) %>%
        mutate(pct=(row_number()-1)/(n()-1)) %>%
        ggplot(aes(x=value, y=pct)) + 
        geom_text(data=~filter(., pct %in% getBestMatch(.$pct, percPoint)), 
                  aes(label=paste0(value, " (", round(1000*pct)/10, "%)"), 
                  hjust=ifelse(pct %in% c(0, 1), 0, 1),
                  vjust=ifelse(pct==1, 1, 0)
                  ), 
                  color="red", 
                  size=2.5
                  ) +
        geom_point(alpha=0.1, size=0.5) + 
        labObj

    if(length(ecdfVars)>1) p1 <- p1 + facet_wrap(~name, nrow=1)
    
    p1
    
}

keyLabs <- labs(title="ECDF over 100 hands", 
                subtitle="10,000 simulations", 
                y=NULL, 
                x=NULL
                )

# No percent-values plotted, no labels
getSimECDF(tcpSimSummary, ecdfVars=c("minMain"))
getSimECDF(tcpSimSummary, ecdfVars=c("minMain", "sumMain"))

# Percent-values plotted, standard labels
getSimECDF(tcpSimSummary, ecdfVars=c("minMain"), percPoint=percKey, labObj=keyLabs)
getSimECDF(tcpSimSummary, 
           ecdfVars=c("minMain", "sumMain"), 
           percPoint=percKey, 
           labObj=keyLabs
           )

# Customized labels
cLab <- keyLabs
cLab$x <- "Main bet minimum (units)"
getSimECDF(tcpSimSummary, 
           ecdfVars=c("minMain"), 
           percPoint=percKey, 
           labObj=cLab
           )

cLab$x <- "Main bet (units)"
getSimECDF(tcpSimSummary, 
           ecdfVars=c("minMain", "sumMain"), 
           percPoint=percKey, 
           labObj=cLab
           )

```

The ECDF process is run for bonus bets:  
```{r, fig.height=9, fig.width=9}

# Customized labels
cLab$x <- "Bonus bet (units)"
getSimECDF(tcpSimSummary, 
           ecdfVars=c("minBonus", "sumBonus"), 
           percPoint=percKey, 
           labObj=cLab
           )

```

The ECDF process is run for overall outcome:  
```{r, fig.height=9, fig.width=9}

# Customized labels
cLab$x <- "Overall (units)\n2*Main + Bonus"
getSimECDF(tcpSimSummary, 
           ecdfVars=c("minOverall", "sumOverall"), 
           percPoint=percKey, 
           labObj=cLab
           )

```

Relationships between minimum and final are explored:  
```{r, fig.height=9, fig.width=9}

lmSim <- lm(sumOverall ~ minOverall, data=tcpSimSummary)
summary(lmSim)

tcpSimSummary %>%
    select(simNumber, minOverall, sumOverall) %>%
    count(minOverall, sumOverall) %>%
    ggplot(aes(x=minOverall, y=sumOverall)) + 
    geom_point(aes(size=n), alpha=0.1) + 
    labs(x="Overall minimum", 
         y="Overall final", 
         title="Final vs. minimum (overall)"
         ) + 
    geom_smooth(method="lm", aes(weight=n)) + 
    geom_abline(slope=1, intercept=0, color="red", lty=2) + 
    geom_text(data=~summarize(., 
                              minOverall=min(minOverall), 
                              sumOverall=max(sumOverall)
                              ), 
              aes(label=paste0("y = ", 
                               round(coef(lmSim)[1], 1), 
                               " + ", 
                               round(coef(lmSim)[2], 3), 
                               "*x\n", 
                               "R2: ", 
                               round(summary(lmSim)$r.squared, 3)
                               )
                  ), 
              hjust=0, 
              vjust=1
              )

```

The process is converted to functional form:  
```{r, fig.height=9, fig.width=9}

finalVsMin <- function(df, y, x, txt="") {
    
    # FUNCTION ARGUMENTS:
    # df: data frame with simulations
    # y: dependent variable
    # x: independent variable
    # txt: descriptor for chart labeling

    tmpLM <- lm(get(y) ~ get(x), data=df)
    summary(tmpLM)
    
    p1 <- df %>%
        group_by(across(all_of(c(y, x)))) %>%
        summarize(n=n(), .groups="drop") %>%
        ggplot(aes(x=.data[[x]], y=.data[[y]])) + 
        geom_point(aes(size=n), alpha=0.1) + 
        labs(x=paste0(txt, " Minimum"), 
             y=paste0(txt, " Final"), 
             title=paste0("Final vs. Minimum", 
                          ifelse(txt=="", "", paste0(" (", txt, ")"))
                          )
             ) + 
        geom_smooth(method="lm", aes(weight=n)) + 
        geom_abline(slope=1, intercept=0, color="red", lty=2) + 
        geom_text(data=~summarize(., 
                                  minX=min(get(x)), 
                                  maxY=max(get(y))
                                  ), 
                  aes(x=minX, 
                      y=maxY, 
                      label=paste0("y = ", 
                                   round(coef(tmpLM)[1], 1), 
                                   " + ", 
                                   round(coef(tmpLM)[2], 3), 
                                   "*x\n", 
                                   "R2: ", 
                                   round(summary(tmpLM)$r.squared, 3)
                                   )
                      ), 
                  hjust=0, 
                  vjust=1
                  )

    print(p1)
    
}

finalVsMin(tcpSimSummary, y="sumOverall", x="minOverall", txt="Overall")

```

The process is run for the main bet and bonus bet:  
```{r, fig.height=9, fig.width=9}

finalVsMin(tcpSimSummary, y="sumMain", x="minMain", txt="Main")
finalVsMin(tcpSimSummary, y="sumBonus", x="minBonus", txt="Bonus")

```

The function is run for comparing end results:  
```{r, fig.height=9, fig.width=9}

finalVsMin(tcpSimSummary, y="sumOverall", x="sumMain", txt="Main")
finalVsMin(tcpSimSummary, y="sumOverall", x="sumBonus", txt="Bonus")

```

The function can be updated for better control of title and axis labels:  
```{r, fig.height=9, fig.width=9}

finalVsMin <- function(df, y, x, txt="", xTxt="Minimum", yTxt="Final") {
    
    # FUNCTION ARGUMENTS:
    # df: data frame with simulations
    # y: dependent variable
    # x: independent variable
    # txt: descriptor for chart labeling
    # xTxt: x-axis descriptor for chart labeling
    # yTxt: y-axis descriptor for chart labeling

    # Create text labels
    titleTxt <- paste0(yTxt, 
                       " vs. ", 
                       xTxt, 
                       ifelse(txt=="", "", paste0(" (", txt, ")"))
                       )
    xTxt <- paste0(ifelse(txt=="", "", paste0(txt, " ")), xTxt)
    yTxt <- paste0(ifelse(txt=="", "", paste0(txt, " ")), yTxt)
    
    
    # Run linear regression
    tmpLM <- lm(get(y) ~ get(x), data=df)
    
    p1 <- df %>%
        group_by(across(all_of(c(y, x)))) %>%
        summarize(n=n(), .groups="drop") %>%
        ggplot(aes(x=.data[[x]], y=.data[[y]])) + 
        geom_point(aes(size=n), alpha=0.1) + 
        labs(x=xTxt, y=yTxt, title=titleTxt) + 
        geom_smooth(method="lm", aes(weight=n)) + 
        geom_abline(slope=1, intercept=0, color="red", lty=2) + 
        geom_text(data=~summarize(., 
                                  minX=min(get(x)), 
                                  maxY=max(get(y))
                                  ), 
                  aes(x=minX, 
                      y=maxY, 
                      label=paste0("y = ", 
                                   round(coef(tmpLM)[1], 1), 
                                   " + ", 
                                   round(coef(tmpLM)[2], 3), 
                                   "*x\n", 
                                   "R2: ", 
                                   round(summary(tmpLM)$r.squared, 3)
                                   )
                      ), 
                  hjust=0, 
                  vjust=1
                  )

    print(p1)
    
}

finalVsMin(tcpSimSummary, y="sumOverall", x="minOverall", txt="Overall")
finalVsMin(tcpSimSummary, 
           y="sumOverall", 
           x="sumMain", 
           txt="Final", 
           xTxt="Main", 
           yTxt="Overall"
           )
finalVsMin(tcpSimSummary, 
           y="sumOverall", 
           x="sumBonus", 
           txt="Final", 
           xTxt="Bonus", 
           yTxt="Overall"
           )

```

The results of regressions are compared using bonus, given Overall = 2*Main + Bonus:  
```{r, fig.height=9, fig.width=9}

# Regression of main vs. bonus
lmMainBonus <- lm(sumMain ~ sumBonus, data=tcpSimSummary)
summary(lmMainBonus)

# Expected coefficients for Overall ~ Bonus
cat("\nExpected coefficients for Overall ~ Bonus:\n", 
    "Intercept: ", round(2*coef(lmMainBonus)[1], 3), 
    "\nSlope: ", 1 + round(2*coef(lmMainBonus)[2], 3),
    "\n", 
    sep=""
    )

# Actual coefficients for Overall ~ Bonus
lmOverallBonus <- lm(sumOverall ~ sumBonus, data=tcpSimSummary)
cat("\nActual coefficients for Overall ~ Bonus:\n", 
    "Intercept: ", round(coef(lmOverallBonus)[1], 3), 
    "\nSlope: ", round(coef(lmOverallBonus)[2], 3),
    "\nR-squared: ", round(summary(lmOverallBonus)$r.squared, 3),
    "\n", 
    sep=""
    )

```

The results of regressions are compared using main, given Overall = 2*Main + Bonus:  
```{r, fig.height=9, fig.width=9}

# Regression of main vs. bonus
lmBonusMain <- lm(sumBonus ~ sumMain, data=tcpSimSummary)
summary(lmBonusMain)

# Expected coefficients for Overall ~ Main
cat("\nExpected coefficients for Overall ~ Main:\n", 
    "Intercept: ", round(coef(lmBonusMain)[1], 3), 
    "\nSlope: ", 2 + round(coef(lmBonusMain)[2], 3),
    "\n", 
    sep=""
    )

# Actual coefficients for Overall ~ Main
lmOverallMain <- lm(sumOverall ~ sumMain, data=tcpSimSummary)
cat("\nActual coefficients for Overall ~ Main:\n", 
    "Intercept: ", round(coef(lmOverallMain)[1], 3), 
    "\nSlope: ", round(coef(lmOverallMain)[2], 3),
    "\nR-squared: ", round(summary(lmOverallMain)$r.squared, 3),
    "\n", 
    sep=""
    )

```

The results of regressions on minimum values are compared using bonus, given Overall = 2*Main + Bonus:  
```{r, fig.height=9, fig.width=9}

# Regression of main vs. bonus
lmMinMainBonus <- lm(minMain ~ minBonus, data=tcpSimSummary)
summary(lmMinMainBonus)

# (Rough) expected coefficients for Overall ~ Bonus
cat("\nExpected (rough) coefficients for minimum Overall ~ Bonus:\n", 
    "Intercept: ", round(2*coef(lmMinMainBonus)[1], 3), 
    "\nSlope: ", 1 + round(2*coef(lmMinMainBonus)[2], 3),
    "\n", 
    sep=""
    )

# Actual coefficients for Overall ~ Bonus
lmMinOverallBonus <- lm(minOverall ~ minBonus, data=tcpSimSummary)
cat("\nActual coefficients for minimum Overall ~ Bonus:\n", 
    "Intercept: ", round(coef(lmMinOverallBonus)[1], 3), 
    "\nSlope: ", round(coef(lmMinOverallBonus)[2], 3),
    "\nR-squared: ", round(summary(lmMinOverallBonus)$r.squared, 3),
    "\n", 
    sep=""
    )

# Actual regression for minima
lm(minOverall ~ minMain + minBonus, data=tcpSimSummary) %>%
    summary()

```

Timing of first hitting the overall minimum and maximum by simulation is calculated:  
```{r, fig.height=9, fig.width=9}

# Pull first occurrence of minima and maxima
tcpSimWhich <- allTCPSim %>%
    mutate(mainBet=(antePay+playPay+anteBonus), overall=2*mainBet+ppBonus) %>%
    group_by(simNumber) %>%
    mutate(ovCum=cumsum(overall), ovMain=cumsum(mainBet), ovBonus=cumsum(ppBonus)) %>%
    summarize(across(c(ovCum, ovMain, ovBonus), 
                     .fns=list(whichmin=function(x) which.min(x), 
                               whichmax=function(x) which.max(x)
                               )
                     )
              )
tcpSimWhich

```

Distributions for hand where maximum is first achieved are plotted:  
```{r, fig.height=9, fig.width=9}

tcpSimWhich %>%
    select(simNumber, ends_with("max")) %>%
    pivot_longer(cols=-c(simNumber)) %>%
    mutate(useName=str_replace_all(name, pattern="_whichmax", replacement="")) %>%
    count(useName, value) %>%
    ggplot(aes(x=value, y=n)) + 
    geom_line(aes(group=useName, color=useName)) + 
    labs(title="Hand number where overall maximum is first obtained", 
         subtitle="10,000 simulations, each of 100 hands", 
         y="# Simulations\n(log-10 scale)", 
         x="Hand where overall maximum is first achieved"
         ) + 
    scale_color_discrete("Bet Type") + 
    scale_y_log10() + 
    geom_text(data=~filter(., value %in% c(1, 100)), 
              aes(label=n, color=useName, hjust=ifelse(value==1, 1, 0)), 
              size=2.5
              )

```

As expected given negative per-hand expectation, maximum is typically reached early in the simulation

Distributions for hand where minimum is first achieved are plotted:  
```{r, fig.height=9, fig.width=9}

tcpSimWhich %>%
    select(simNumber, ends_with("min")) %>%
    pivot_longer(cols=-c(simNumber)) %>%
    mutate(useName=str_replace_all(name, pattern="_whichmin", replacement="")) %>%
    count(useName, value) %>%
    ggplot(aes(x=value, y=n)) + 
    geom_line(aes(group=useName, color=useName)) + 
    labs(title="Hand number where overall minimum is first obtained", 
         subtitle="10,000 simulations, each of 100 hands", 
         y="# Simulations\n(log-10 scale)", 
         x="Hand where overall minimum is first achieved"
         ) + 
    scale_color_discrete("Bet Type") + 
    scale_y_log10() + 
    geom_text(data=~filter(., value %in% c(1, 100)), 
              aes(label=n, color=useName, hjust=ifelse(value==1, 1, 0)), 
              size=2.5
              )

```

As expected given negative per-hand expectation, minimum is typically reached late in the simulation

Time for reaching minimum and maximum is compared (overall):  
```{r, fig.height=9, fig.width=9}

tcpSimWhich %>%
    select(simNumber, starts_with("ovCum")) %>%
    pivot_longer(cols=-c(simNumber)) %>%
    mutate(useName=str_replace_all(name, pattern="_which.*", replacement=""), 
           metric=str_replace_all(name, pattern=".*_which", replacement="")
           ) %>%
    pivot_wider(id_cols=c("simNumber", "useName"), 
                names_from="metric", 
                values_from="value"
                ) %>%
    count(useName, min, max) %>%
    ggplot(aes(x=min, y=max)) + 
    geom_point(aes(size=n), alpha=0.25) + 
    labs(title="Hand number where overall minimum and maximum is first obtained", 
         subtitle="10,000 simulations, each of 100 hands", 
         y="Hand where overall maximum is first achieved", 
         x="Hand where overall minimum is first achieved", 
         caption="Red point is weighted mean"
         ) + 
    scale_size_continuous("# Sims") + 
    geom_smooth(method="lm", aes(weight=n)) + 
    geom_point(data=~summarize(., across(c(min, max), 
                                         .fns=function(x) sum(x*n)/sum(n)
                                         )
                               ), 
               size=5, 
               color="red"
               )

```

Time for reaching minimum and maximum is compared (all):  
```{r, fig.height=9, fig.width=9}

tcpSimWhich %>%
    select(simNumber, starts_with("ov")) %>%
    pivot_longer(cols=-c(simNumber)) %>%
    mutate(useName=str_replace_all(name, pattern="_which.*", replacement=""), 
           metric=str_replace_all(name, pattern=".*_which", replacement="")
           ) %>%
    pivot_wider(id_cols=c("simNumber", "useName"), 
                names_from="metric", 
                values_from="value"
                ) %>%
    count(useName, min, max) %>%
    ggplot(aes(x=min, y=max)) + 
    geom_point(aes(size=n), alpha=0.25) + 
    labs(title="Hand number where minimum and maximum is first obtained", 
         subtitle="10,000 simulations, each of 100 hands", 
         y="Hand where maximum is first achieved", 
         x="Hand where minimum is first achieved", 
         caption="Red point is weighted mean"
         ) + 
    scale_size_continuous("# Sims") + 
    geom_smooth(method="lm", aes(weight=n)) + 
    facet_wrap(~useName) +
    geom_point(data=~summarize(group_by(., useName), 
                               across(c(min, max), .fns=function(x) sum(x*n)/sum(n))
                               ), 
               size=5, 
               color="red"
               )

```

Data for being at an all-time low/high is explored:  
```{r, fig.height=9, fig.width=9}

# Get new minima and maxima
tcpSimAllTime <- allTCPSim %>%
    mutate(mainBet=(antePay+playPay+anteBonus), overall=2*mainBet+ppBonus) %>%
    group_by(simNumber) %>%
    mutate(ovCum=cumsum(overall), ovMain=cumsum(mainBet), ovBonus=cumsum(ppBonus)) %>%
    select(simNumber, ovCum, ovMain, ovBonus) %>%
    mutate(hn=row_number()) %>%
    ungroup() %>%
    pivot_longer(cols=-c(simNumber, hn)) %>%
    arrange(simNumber, name, hn) %>%
    group_by(simNumber, name) %>%
    mutate(cmax=cummax(value), 
           cmin=cummin(value),
           newmax=(cmax==value & (hn==1 | cmax>lag(cmax))), 
           newmin=(cmin==value & (hn==1 | cmin<lag(cmin))),
           tiemax=(cmax==value) & !newmax, 
           tiemin=(cmax==value) & !newmin
           ) %>%
    ungroup()
tcpSimAllTime

```

Probability for being at an all-time high for overall is plotted:  
```{r, fig.height=9, fig.width=9}

# Probability for being at all-time high overall
tcpSimAllTime %>% 
    filter(name=="ovCum") %>% 
    count(hn, newmax, tiemax) %>% 
    group_by(hn) %>% 
    mutate(pct=n/sum(n), 
           type=case_when(newmax~"allHigh", tiemax~"tieHigh", TRUE~"none")
           ) %>% 
    ungroup() %>% 
    pivot_wider(id_cols="hn", names_from="type", values_from="pct", values_fill=0) %>%
    pivot_longer(cols=-hn) %>% 
    filter(hn>1) %>% 
    ggplot(aes(x=hn, y=value)) + 
    geom_line(aes(group=name, 
                  color=c("allHigh"="3. New high", 
                          "tieHigh"="2. Ties previous high", 
                          "none"="1. Below previous high"
                          )[name]
                  )
              ) + 
    labs(x="Hand Number", 
         y="Proportion of simulations", 
         title="Likelihood of new overall maximum by hand number", 
         caption="Hand 1 not plotted (always a new high)"
         ) + 
    scale_color_discrete(NULL) + 
    theme(legend.position = "right")

```

