---
title: "Coronavirus US Data"
author: "davegoblue"
date: "10/1/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
```

## Background
This file is for analysis of several coronavirus data sources focused on the US in 2020.  Data include areas such as cases, hospitalizations, and deaths tracked to cornavirus, as well as all-cause deaths.

The previous version of this file includes many exploratory analysis components.  This version is designed with the following portions of the previous code:  
  
1.  Functions  
2.  Run key analyses  
3.  Save and load key files  
  
### _COVID Tracking Project_ 
The first section is for analysis of data from [The COVID Tracking Project](https://covidtracking.com/).  This file contains data on positive tests, hospitalizations, deaths, and the like for coronavirus cases in the US.  Downloaded data are unique by state and date.

#### _Key Functions (COVID Tracking Project, USA Facts, CDC All-Cause Deaths)_  
Functions for working with data from the COVID Tracking Project, USA Facts, and the CDC All-Cause Death data are available in a separate file which is sourced below:  
```{r}

source("./Coronavirus_Statistics_Functions_v002.R")

```

### _Running Key Analyses (COVID Tracking Project)_  
The data from COVID Tracking Project can be loaded and analyzed using the functions above and a variable mapping file:  
```{r cache=TRUE}

# STEP 0: Create a variable mapping file
varMapper <- c("cases"="Cases", 
               "newCases"="Increase in cases, most recent 30 days",
               "casesroll7"="Rolling 7-day mean cases", 
               "deaths"="Deaths", 
               "newDeaths"="Increase in deaths, most recent 30 days",
               "deathsroll7"="Rolling 7-day mean deaths", 
               "cpm"="Cases per million",
               "cpm7"="Cases per day (7-day rolling mean) per million", 
               "newcpm"="Increase in cases, most recent 30 days, per million",
               "dpm"="Deaths per million", 
               "dpm7"="Deaths per day (7-day rolling mean) per million", 
               "newdpm"="Increase in deaths, most recent 30 days, per million", 
               "hpm7"="Currently Hospitalized per million (7-day rolling mean)", 
               "tpm"="Tests per million", 
               "tpm7"="Tests per million per day (7-day rolling mean)"
               )


# Test function for hierarchical clustering with Vermont reassigned to New Hampshire
test_hier5 <- readRunCOVIDTrackingProject(thruLabel="Aug 20, 2020", 
                                          readFrom="./RInputFiles/Coronavirus/CV_downloaded_200820.csv", 
                                          hierarchical=TRUE,
                                          kCut=6, 
                                          reAssignState=list("VT"="NH"), 
                                          minShape=3, 
                                          ratioDeathvsCase = 5, 
                                          ratioTotalvsShape = 0.5, 
                                          minDeath=100, 
                                          minCase=10000
                                          )


# Test function for k-means clustering using the per capita data file previously created
test_km5 <- readRunCOVIDTrackingProject(thruLabel="Aug 20, 2020", 
                                        dfPerCapita=test_hier5$dfPerCapita,
                                        hierarchical=FALSE,
                                        makeCumulativePlots=FALSE,
                                        minShape=3, 
                                        ratioDeathvsCase = 5, 
                                        ratioTotalvsShape = 0.5, 
                                        minDeath=100, 
                                        minCase=10000, 
                                        nCenters=5,
                                        testCenters=1:10, 
                                        iter.max=20,
                                        nstart=10, 
                                        seed=2008261400
                                        )

  
# Run in a session that has access to the old data files
# identical(test_hier5$useClusters, clustVec)  # TRUE
# identical(test_km5$useClusters, testCluster_km5$objCluster$cluster)  # TRUE

```
  
Cluster files produced using the new functions and the existing August 20, 2020 data are identical to 'clustVec' and 'testCluster_km5' produced in the _v001 code.
  
Further, new data is downloaded that is current through September 30, 2020, and the test_hier5 clusters are used for analysis:  
```{r cache=TRUE}

# Test function for hierarchical clustering with Vermont reassigned to New Hampshire
locDownload <- "./RInputFiles/Coronavirus/CV_downloaded_201001.csv"
test_hier5_201001 <- readRunCOVIDTrackingProject(thruLabel="Sep 30, 2020", 
                                                 readFrom=locDownload, 
                                                 compareFile=test_hier5$dfRaw,
                                                 useClusters=test_hier5$useClusters
                                                 )

```
  
Segments appear to be on trend with previous analysis, with what was previously called "late pandemic" having peaked and the segments that had smaller deaths per million showing higher percentage increases.
  

### _USA Facts_ 
The second section is for analysis of data from [USA Facts](https://usafacts.org/visualizations/coronavirus-covid-19-spread-map/).  This site contains county-level data for the US focused on coronavirus cases and deaths.  Data are provided with one row per county and one column for each date, and are thus unique by county.  There are differences in state and US totals for coronavirus cases and deaths when reported by COVID Tracking Project and USA Facts, though trends, timing, and relative magnitudes are generally in agreement between the two sources.
  
#### _Key Functions (USA Facts)_  
Functions for reading and analyzing data from USA Facts are sourced above from Coronavirus_Statistics_Functions_v002.R
  
### _Running Key Analyses (USA Facts)_  
The data from USA Facts can be loaded and analyzed using the sourced functions, a variable mapping file, and a main function that calls the other functions and returns a list:  
```{r cache=TRUE}

# STEP 1a: Define the locations for the population, cases, and deaths file
popFile <- "./RInputFiles/Coronavirus/covid_county_population_usafacts.csv"
caseFile_20200903 <- "./RInputFiles/Coronavirus/covid_confirmed_usafacts_downloaded_20200903.csv"
deathFile_20200903 <- "./RInputFiles/Coronavirus/covid_deaths_usafacts_downloaded_20200903.csv"
maxDate_20200903 <- "2020-08-31"

# STEP 1b: Read and pivot data from USA Facts; extract population data file as pop_usafacts
rawUSAFacts_20200903 <- readPivotUSAFacts(popFile=popFile, 
                                          caseFile=caseFile_20200903, 
                                          deathFile=deathFile_20200903, 
                                          unassignedDate=maxDate_20200903
                                          )
pop_usafacts <- rawUSAFacts_20200903$pop

# STEP 2: Read case and death data (redundant), combine, and add population totals; no clusters by default
burden_20200903_new <- readUSAFacts(
    caseFile=caseFile_20200903, 
    deathFile=deathFile_20200903, 
    stateClusters=NULL
    )


# STEP 3: Explore the cases and deaths by county (can be repeated for other counties)
casesDeathsByCounty(useDate=maxDate_20200903, 
                    inclStates=c("FL", "GA", "SC", "AL", "MS"), 
                    caseData=rawUSAFacts_20200903$cases, 
                    deathData=rawUSAFacts_20200903$deaths,
                    highCaseAmount=80000, 
                    highDeathAmount=2000
                    )

# STEP 4: Create county-level clusters (k-means, 5 clusters, minimum county population 25k)
clust_20200903_new <- prepClusterCounties(burdenFile=burden_20200903_new, 
                                          maxDate=maxDate_20200903, 
                                          minPop=25000, 
                                          hierarchical=FALSE, 
                                          minShape=3,
                                          ratioDeathvsCase = 5,
                                          ratioTotalvsShape = 0.5,
                                          minDeath=100,
                                          minCase=5000,
                                          nCenters=5,
                                          testCenters=1:25,
                                          iter.max=20,
                                          nstart=10,
                                          seed=2009081450
                                          )


# STEP 5: Extract the clusters from the clustering object
clustVec_county_20200903_new <- clust_20200903_new$objCluster$objCluster$cluster

# STEP 6: Assess the quality of the new clusters
helperACC_county_20200903_new <- helperAssessCountyClusters(clustVec_county_20200903_new, 
                                                            dfPop=clust_20200903_new$countyFiltered, 
                                                            dfBurden=clust_20200903_new$countyFiltered, 
                                                            thruLabel="Sep 3, 2020", 
                                                            plotsTogether=TRUE, 
                                                            orderCluster=TRUE
                                                            )

# STEP 7: Create a plot of cumulative burden by cluster
helperACC_county_20200903_new %>%
    select(cluster, date, pop, cases, deaths) %>%
    group_by(cluster, date) %>%
    summarize_if(is.numeric, sum, na.rm=TRUE) %>%
    arrange(date) %>%
    mutate(cpmcum=cumsum(cases)*1000000/pop, dpmcum=cumsum(deaths)*1000000/pop) %>%
    ungroup() %>%
    select(cluster, date, cases=cpmcum, deaths=dpmcum) %>%
    pivot_longer(-c(cluster, date)) %>%
    ggplot(aes(x=date, y=value, color=cluster)) + 
    geom_line(size=1) + 
    geom_text(data=~filter(., date==max(date)), 
              aes(x=date+lubridate::days(2), label=round(value)), 
              size=3, 
              hjust=0
              ) +
    labs(x="", title="Cumulative burden per million people by segment", y="") +
    facet_wrap(~c("cases"="Cases per million", "deaths"="Deaths per million")[name], scales="free_y") + 
    scale_x_date(date_breaks="1 months", date_labels="%b", expand=expand_scale(c(0, 0.1)))

# STEP 8: Add back clusters not used for analysis (code 999) and associated disease data
clusterStateData_20200903_new <- helperMakeClusterStateData(helperACC_county_20200903_new, 
                                                            dfBurden=clust_20200903_new$countyDailyPerCapita,
                                                            orderCluster=TRUE
                                                            )

# STEP 9: Run an example state-level summary (can expand to other states)
stateCountySummary(states=c("MN", "ND", "SD", "WI"),
                   df=changeOrderLabel(clusterStateData_20200903_new, grpVars="fipsCounty"),
                   keyDate=maxDate_20200903,
                   showQuadrants=TRUE, 
                   showCumulative=TRUE, 
                   facetCumulativeByState = TRUE, 
                   showAllFactorLevels = TRUE
                   )

# STEP 10a: Read in updated raw data
caseFile_20200917 <- "./RInputFiles/Coronavirus/covid_confirmed_usafacts_downloaded_20200917.csv"
deathFile_20200917 <- "./RInputFiles/Coronavirus/covid_deaths_usafacts_downloaded_20200917.csv"
maxDate_20200917 <- "2020-09-15"

rawUSAFacts_20200917 <- readPivotUSAFacts(popFile=popFile, 
                                          caseFile=caseFile_20200917, 
                                          deathFile=deathFile_20200917, 
                                          unassignedDate=maxDate_20200917
                                          )


# STEP 10b: Use existing state-level segments with updated raw data
burden_20200917 <- readUSAFacts(
    caseFile=caseFile_20200917, 
    deathFile=deathFile_20200917,
    stateClusters=test_hier5_201001$useClusters
    )

# STEP 11: Compare burden in old data and new data
bind_rows(burden_20200903_new, burden_20200917, .id="source") %>%
    mutate(source=factor(case_when(source==1 ~ "2020-09-03", source==2 ~ "2020-09-17", TRUE ~ "Unknown"), 
                         levels=c("2020-09-17", "2020-09-03", "Unknown")
                         )
           ) %>%
    group_by(source, date) %>%
    summarize(cumDeaths=sum(cumDeaths), cumCases=sum(cumCases)) %>%
    pivot_longer(-c(source, date)) %>%
    ggplot(aes(x=date, y=value/1000, group=source, color=source)) + 
    geom_line() + 
    facet_wrap(~c("cumCases"="Cases", "cumDeaths"="Deaths")[name], scales="free_y") + 
    scale_x_date(date_breaks="1 months", date_labels="%m") + 
    labs(y="Burden (000s)", title="US National Coronavirus Burden by Source")

# STEP 12: Show top-level findings by segment
plotBurdenData(burden_20200917, maxDate=maxDate_20200917, minPop=10000)

# STEP 13: Create county-level clusters (k-means, 5 clusters, minimum county population 25k)
clust_20200917_new <- prepClusterCounties(burdenFile=burden_20200917, 
                                          maxDate=maxDate_20200917, 
                                          minPop=25000, 
                                          hierarchical=FALSE, 
                                          minShape=3,
                                          ratioDeathvsCase = 5,
                                          ratioTotalvsShape = 0.5,
                                          minDeath=100,
                                          minCase=5000,
                                          nCenters=5,
                                          testCenters=1:25,
                                          iter.max=20,
                                          nstart=10,
                                          seed=2009081450
                                          )

# STEP 14: Assess the previous clusters on the updated data
helper_test_20200917 <- helperAssessCountyClusters(vecCluster=clustVec_county_20200903_new, 
                                                   dfPop=clust_20200917_new$countyFiltered, 
                                                   dfBurden=clust_20200917_new$countyFiltered, 
                                                   thruLabel="Sep 15, 2020", 
                                                   plotsTogether=TRUE, 
                                                   showMap=TRUE, 
                                                   clusterPlotsTogether=TRUE, 
                                                   orderCluster=TRUE
                                                   )

# STEP 15: Create normalized data
cNorm_20200917 <- helperMakeNormData(helper_test_20200917)

# STEP 16: Assess lags for early pandemic and late pandemic
lagData_early_20200917 <- helperTestLags(cNorm_20200917, minDate="2020-03-01", maxDate="2020-05-31")
lagData_late_20200917 <- helperTestLags(cNorm_20200917, minDate="2020-06-01", maxDate="2020-09-15")

# STEP 17: Generate a list of key counties
keyCounties_20200917 <- helper_test_20200917 %>%
    mutate(state=str_pad(state, width=5, side="left", pad="0")) %>%
    filter(pop >= 100000) %>%
    group_by(state, cluster) %>%
    summarize(dpm=sum(dpm), pop=mean(pop)) %>%
    group_by(cluster) %>%
    top_n(n=3, wt=dpm) %>%
    ungroup() %>%
    arrange(cluster, -dpm) %>%
    inner_join(select(usmap::countypop, -pop_2015), by=c("state"="fips")) %>%
    mutate(countyName=paste0(cluster, " - ", 
                             stringr::str_replace(county, "County|Parish", "("), 
                             abbr, 
                             ")"
                             )
           ) %>%
    select(-abbr, -county)

# STEP 18: Keep only key counties
cNorm_keyCounties_20200917 <- helper_test_20200917 %>%
    mutate(state=str_pad(state, width=5, side="left", pad="0")) %>%
    inner_join(select(keyCounties_20200917, state, countyName), by=c("state"="state")) %>%
    helperMakeNormData(aggBy=c("countyName", "state", "cluster"))

# STEP 19: Create early and late lags for key counties
lagData_early_keycounties_20200917 <- helperTestLags(cNorm_keyCounties_20200917, 
                                                     minDate="2020-03-01", 
                                                     maxDate="2020-05-31", 
                                                     aggBy=c("countyName", "state", "cluster"), 
                                                     maxRatio=0.25
                                                     )
lagData_late_keycounties_20200917 <- helperTestLags(cNorm_keyCounties_20200917, 
                                           minDate="2020-06-01", 
                                           maxDate="2020-09-15", 
                                           aggBy=c("countyName", "state", "cluster"), 
                                           maxRatio=0.25
                                           )

# STEP 20: Run for only key counties
exploreTopCounties(helper_test_20200917, minDate="2020-03-01", maxDate="2020-05-31", nVar="pop", nKey=12)
exploreTopCounties(helper_test_20200917, minDate="2020-06-15", maxDate="2020-09-15", nVar="pop", nKey=12)

```
  
The process is further converted to functional form as follows:  
  
1.  Capability to either start the process from scratch or to leverage existing clusters at the state or county level  
2.  Add the capability to compare a newly read file to an existing file  
3.  Add the capability to show burden by existing segment after reading in an existing file  
4.  Add the capability to prepare the data (create countyFiltered) without running the clustering proces  
5.  Add the cumulative burden chart to helperAssessCountyClusters  
  
New data are downloaed from 2020-10-03, and the updated code includes:  
```{r cache=TRUE}

# STEP 1a: Define the locations for the population, cases, and deaths file
popFile <- "./RInputFiles/Coronavirus/covid_county_population_usafacts.csv"
caseFile_20201003 <- "./RInputFiles/Coronavirus/covid_confirmed_usafacts_downloaded_20201003.csv"
deathFile_20201003 <- "./RInputFiles/Coronavirus/covid_deaths_usafacts_downloaded_20201003.csv"
maxDate_20201003 <- "2020-09-30"

# STEP 1b: Read and pivot data from USA Facts; extract population data file as pop_usafacts
rawUSAFacts_20201003 <- readPivotUSAFacts(popFile=popFile, 
                                          caseFile=caseFile_20201003, 
                                          deathFile=deathFile_20201003, 
                                          unassignedDate=maxDate_20201003
                                          )
pop_usafacts <- rawUSAFacts_20201003$pop

# STEP 2: Read case and death data (redundant), combine, and add population totals
# Add previous clusters by county rather than by state (function readUSAFacts updated)
burden_20201003 <- readUSAFacts(
    caseFile=caseFile_20201003, 
    deathFile=deathFile_20201003, 
    oldFile=burden_20200903_new,
    showBurdenMinPop=10000,
    maxDate=maxDate_20201003,
    stateClusters=NULL, 
    countyClusters=clustVec_county_20200903_new
    )

# STEP 3: Create appropriately filtered data without creating new clusters
clust_20201003 <- prepClusterCounties(burdenFile=burden_20201003, 
                                      maxDate=maxDate_20201003, 
                                      minPop=25000,
                                      createClusters=FALSE
                                      )

# STEP 4: Assess the existing clusters against the new data, including the cumulative plot
helperACC_county_20201003 <- helperAssessCountyClusters(vecCluster=clustVec_county_20200903_new, 
                                                        dfPop=clust_20201003$countyFiltered, 
                                                        dfBurden=clust_20201003$countyFiltered, 
                                                        showCum=TRUE,
                                                        thruLabel="Sep 30, 2020", 
                                                        plotsTogether=TRUE, 
                                                        orderCluster=TRUE
                                                        )

# STEP 5: Add back clusters not used for analysis (code 999) and associated disease data
clusterStateData_20201003 <- helperMakeClusterStateData(helperACC_county_20201003, 
                                                        dfBurden=clust_20201003$countyDailyPerCapita,
                                                        orderCluster=TRUE
                                                        )

# STEP 6: Run an example state-level summary using several of the largest states
stateCountySummary(states=c("CA", "TX", "FL", "NY", "IL", "PA"),
                   df=changeOrderLabel(clusterStateData_20201003, grpVars="fipsCounty"),
                   keyDate=maxDate_20201003,
                   showQuadrants=TRUE, 
                   showCumulative=TRUE, 
                   facetCumulativeByState = TRUE, 
                   showAllFactorLevels = TRUE
                   )

# STEP 7: Assess lags for largest counties and counties with highest death rates
# STEP 7a: Save data for top-100 counties by death rate (filtered to only counties of 100k+ population)
top100_dpm_20201003 <- exploreTopCounties(helperACC_county_20201003, 
                                          minDate="2020-03-01", 
                                          maxDate="2020-09-30", 
                                          minPop=100000,
                                          nVar="dpm", 
                                          nKey=100, 
                                          plotData=FALSE
                                          )
glimpse(top100_dpm_20201003)

# STEP 7b: Top-3 by population by cluster with plots
exploreTopCounties(helperACC_county_20201003, 
                   minDate="2020-03-01", 
                   maxDate="2020-09-30", 
                   topNBy="cluster",
                   nVar="pop", 
                   nKey=3, 
                   plotData=TRUE
                   )

# STEP 7c: Top-5 by dpm by cluster with plots
exploreTopCounties(helperACC_county_20201003, 
                   minDate="2020-03-01", 
                   maxDate="2020-09-30", 
                   topNBy="cluster",
                   nVar="dpm", 
                   nKey=5, 
                   plotData=TRUE
                   )

```
  
### _CDC All-Cause Deaths_ 
The CDC maintain public data for all-cause deaths by week and jurisdiction, available at [CDC Weekly Deaths by Jurisdiction](https://catalog.data.gov/dataset/weekly-counts-of-deaths-by-jurisdiction-and-age-group).  

These data are known to have a lag between death and reporting, and the CDC back-correct to report deaths at the time the death occurred even if the death is reported in following weeks.  This means totals for recent weeks tend to run low (lag), and the CDC run a projection of the expected total number of deaths given the historical lag times.  Per other analysts on the internet, there is currently significant supra-lag, with lag times much longer than historical averages causing CDC projected deaths for recent weeks to be low.

#### _Key Functions (CDC All-Cause Deaths)_  
Functions for reading and analyzing CDC all-cause deaths data have been sourced above from Coronavirus_Statistics_Functions_v002.R.
  
### _Running Key Analyses (CDC All-Cause Deaths)_  
The CDC data can be loaded and analyzed:  
```{r cache=TRUE}

# Read and process the CDC data
cdc20200923 <- readProcessCDC("Weekly_counts_of_deaths_by_jurisdiction_and_age_group_downloaded_20200923.csv", 
                              weekThru=30
                              )

# Generate plots of the processed CDC data
cdcBasicPlots(cdc20200923, clustVec=test_hier5$useClusters)


# Example cohort analysis for age 65+
list_65plus <- cdcCohortAnalysis(cohortName="65+ years old", 
                                 df=cdc20200923,
                                 critFilter=list("age"=c("65-74 years", 
                                                         "75-84 years", 
                                                         "85 years and older"
                                                         )
                                                 ), 
                                 curYear=2020, 
                                 startYear=2015,
                                 startWeek=9,
                                 plotTitle="All-cause deaths for 65+ years old cohort", 
                                 predActualPlotsOnePage=TRUE
                                 )

# Example cohort analysis for full US
list_allUS <- cdcCohortAnalysis(cohortName="all ages, all states", 
                                df=cdc20200923,
                                curYear=2020, 
                                startYear=2015,
                                startWeek=9,
                                plotTitle="All-cause US total deaths",
                                predActualPlotsOnePage=TRUE
                                )

# Example cohort analysis for handful of state hit early
list_early <- cdcCohortAnalysis(cohortName="all ages, NY/NJ/CT/MA", 
                                df=cdc20200923,
                                critFilter=list("state"=c("NY", "NJ", "CT", "MA")),
                                curYear=2020, 
                                startYear=2015,
                                startWeek=9,
                                plotTitle="All-cause total deaths for NY/NJ/CT/MA",
                                predActualPlotsOnePage=TRUE
                                )

```
  
Next steps are to continue with the CDC aggregates function (analyze by cluster or age or state ot etc.):  
```{r cache=TRUE}

# Testing the aggregation function for cluster
# Need to fix plot chart titles
clusterList_hier5_201001 <- helperKeyStateClusterMetrics(test_hier5_201001)
clusterAgg_20200923 <- cdcAggregateSummary(df=cdc20200923, 
                                           critVar="state", 
                                           critSubsets=clusterList_hier5_201001$stateCluster,
                                           startWeek=9, 
                                           critListNames=paste0("cluster ", 1:5),
                                           factorCritList=FALSE,
                                           popData=clusterList_hier5_201001$pop,
                                           cvDeathData=clusterList_hier5_201001$deaths,
                                           idVarName="cluster"
                                           )


# Testing the aggregation function for state (no plots)
stateAgg_20200923 <- cdcAggregateSummary(df=cdc20200923, 
                                         critVar="state", 
                                         critSubsets=names(clusterList_hier5_201001$clData),
                                         startWeek=9, 
                                         idVarName="state", 
                                         subListNames=names(clusterList_hier5_201001$clData),
                                         showAllPlots=FALSE
                                         )


# Create a mapping of epiweek to month (use 2020 for this)
epiMonth <- tibble::tibble(dt=as.Date("2020-01-01")+0:365, 
                           month=lubridate::month(dt),
                           quarter=lubridate::quarter(dt),
                           ew=lubridate::epiweek(dt)
                           ) %>%
    count(ew, month, quarter) %>%
    arrange(ew, -n) %>%
    group_by(ew) %>%
    summarize(month=factor(month.abb[first(month)], levels=month.abb), quarter=first(quarter))

# Create plots by state
helperKeyStateExcessPlots(df=stateAgg_20200923, 
                          epiMonth=epiMonth,
                          cvDeaths=test_hier5_201001$consolidatedPlotData,
                          startWeek=10,
                          cvDeathDate=as.Date("2020-07-31"),
                          subT="CDC data through July 2020 (Q3 incomplete)"
                          )


# Testing the aggregation function for age (no plots)
ageAgg_20200923 <- cdcAggregateSummary(df=cdc20200923, 
                                       critVar="age", 
                                       critSubsets=levels(cdc20200923$age),
                                       startWeek=9, 
                                       idVarName="age", 
                                       subListNames=levels(cdc20200923$age),
                                       showAllPlots=TRUE
                                       )


# Estimated US population by age (2020)
usPopAge2020 <- survival::uspop2[, , "2020"] %>%
    apply(1, FUN=sum) %>%
    tibble::tibble(ageActual=as.integer(names(.)), pop_2020=.)
usPopAge2020

# Sums by age bucket
usPopBucket2020 <- usPopAge2020 %>%
    mutate(age=factor(case_when(ageActual <= 24 ~ "Under 25 years", 
                                ageActual <= 44 ~ "25-44 years", 
                                ageActual <= 64 ~ "45-64 years", 
                                ageActual <= 74 ~ "65-74 years", 
                                ageActual <= 84 ~ "75-84 years", 
                                TRUE ~ "85 years and older"
                                ), levels=levels(cdc20200923$age)
                      )
           ) %>%
    group_by(age) %>%
    summarize(pop=sum(pop_2020))
usPopBucket2020

# Create plots by age
helperKeyAgeExcessPlots(df=ageAgg_20200923, 
                        epiMonth=epiMonth,
                        cvDeaths=test_hier5_201001$consolidatedPlotData,
                        popData=usPopBucket2020,
                        startWeek=10,
                        cvDeathDate=as.Date("2020-07-31"),
                        subT="CDC data through July 2020 (Q3 incomplete)"
                        )


# Create data at the level of elderly and non-elderly, using 65 as the start if elderly
ageOld <- c("65-74 years", "75-84 years", "85 years and older")
cdcTwoAge <- cdc20200923 %>%
    mutate(ageSplit=factor(ifelse(age %in% ageOld, "65 and over", "Under 65"), 
                           levels=c("Under 65", "65 and over")
                           )
           ) %>%
    group_by(state, year, week, ageSplit) %>%
    summarize(deaths=sum(deaths)) %>%
    ungroup() %>%
    mutate(keyVar=paste(ageSplit, state, sep="_"))
cdcTwoAge

# Testing the aggregation function for state and elderly (no plots)
ageStateAgg_20200923 <- cdcAggregateSummary(df=cdcTwoAge, 
                                            critVar="keyVar", 
                                            critSubsets=unique(cdcTwoAge$keyVar),
                                            startWeek=9, 
                                            idVarName="keyVar", 
                                            subListNames=unique(cdcTwoAge$keyVar),
                                            showAllPlots=FALSE
                                            ) %>%
    tidyr::separate(keyVar, into=c("age", "state"), sep="_")

# Plot of excess deaths ratio by state and age
ageStateAgg_20200923 %>%
    filter(year==2020, week>=10) %>%
    group_by(age, state) %>%
    summarize(excess=sum(delta)) %>%
    ggplot(aes(x=fct_reorder(state, excess, .fun=sum), y=excess/1000, fill=age)) + 
    geom_col(position="fill") + 
    coord_flip() + 
    labs(x="State", 
         y="% of All-cause excess deaths", 
         title="Proportion of all-cause excess deaths by age cohort in 2020", 
         subtitle="CDC data March 2020 through July 2020"
         ) +
    scale_fill_discrete("Age Group") + 
    geom_hline(aes(yintercept=0.25), lty=2)

# Plots by age cohort
for (age in levels(cdcTwoAge$ageSplit)) {
    cdcCohortAnalysis(df=cdcTwoAge, 
                      cohortName=paste0("ages ", age), 
                      critFilter=list("ageSplit"=age),
                      plotTitle=paste0("All-cause total deaths for age ", age), 
                      showSubsetPlots=FALSE,
                      showPredActualPlots=TRUE,
                      predActualPlotsOnePage=TRUE
                      )
}

```
  
Next steps are to further clean up and integrate the functions so that the full process can be run with more recent data using fewer changes to the code.
  
### _Running the Full Process_ 
First, data are downloaded from COVID Tracking Project (run only once) without creating clusters (this chunk is set to eval=FALSE to avoid over-writing previously downloaded data):  
```{r eval=FALSE}

# Test function for hierarchical clustering with Vermont reassigned to New Hampshire
locDownload <- "./RInputFiles/Coronavirus/CV_downloaded_201010.csv"
test_hier5_201010 <- readRunCOVIDTrackingProject(thruLabel="Oct 9, 2020", 
                                                 downloadTo=locDownload, 
                                                 compareFile=test_hier5_201001$dfRaw,
                                                 useClusters=test_hier5_201001$useClusters
                                                 )


```
  
The segments are recreated from the downloaded data so that evolution in segment type and membership can be explored:  
```{r cache=TRUE}

# Explore the newly downloaded data and the dendrogram if using for clusters
locDownload <- "./RInputFiles/Coronavirus/CV_downloaded_201010.csv"
test_hier_201010_dendonly <- readRunCOVIDTrackingProject(thruLabel="Oct 9, 2020", 
                                                         readFrom=locDownload, 
                                                         compareFile=test_hier5_201001$dfRaw,
                                                         hierarchical=TRUE, 
                                                         minShape=3, 
                                                         ratioDeathvsCase = 5, 
                                                         ratioTotalvsShape = 0.5, 
                                                         minDeath=100, 
                                                         minCase=10000, 
                                                         skipAssessmentPlots=TRUE
                                                         )

```
  
The dendrogram reveals similarities in several of the main clusters - a clear early and high group (NJ, NY, CT, MA); a clear late and high group (GA, FL, SC, TX, AL, NV, AZ, MS); a clear early and medium group (MI, DE, PA, IN, IL, IN, MD); 1-2 groups that have had low death rates so far; and two groups (LA, DC, RI) and (VT, ME, CO, WA) that appear different than in previous analyses.

Cutting to seven segments should allow for further exploration of the two stand-alone groups of distinct states while leaving most other states in their previous segments.  The full process is then run:  
```{r cache=TRUE}

locDownload <- "./RInputFiles/Coronavirus/CV_downloaded_201010.csv"
test_hier7_201010 <- readRunCOVIDTrackingProject(thruLabel="Oct 9, 2020", 
                                                 readFrom=locDownload, 
                                                 compareFile=test_hier5_201001$dfRaw,
                                                 hierarchical=TRUE, 
                                                 kCut=7, 
                                                 minShape=3, 
                                                 ratioDeathvsCase = 5, 
                                                 ratioTotalvsShape = 0.5, 
                                                 minDeath=100, 
                                                 minCase=10000
                                                 )

```
  
The LA, DC, RI segment does not merit being on its own.  It has a small population (6 million) and has broadly the same shape, with somewhat higher deaths, as the much larger MI, DE, PA, IN, IL, MD segment.  The number of segments can be cut back to 6 as this is the first segment that would be consolidated by that.

The VT, ME, CO, WA segment also questionably merit stand-alone treatment.  It is a variation of the segment that had mild disease early, but is rather differentiated on the dendrogram and has a population (15 million) that is at least in the same order of magnitude as the other clusters.

Suppose that 6 segments are created, using the parameters "as is":  
```{r cache=TRUE}

locDownload <- "./RInputFiles/Coronavirus/CV_downloaded_201010.csv"
test_hier6_201010 <- readRunCOVIDTrackingProject(thruLabel="Oct 9, 2020", 
                                                 readFrom=locDownload, 
                                                 compareFile=test_hier5_201001$dfRaw,
                                                 hierarchical=TRUE, 
                                                 kCut=6, 
                                                 minShape=3, 
                                                 ratioDeathvsCase = 5, 
                                                 ratioTotalvsShape = 0.5, 
                                                 minDeath=100, 
                                                 minCase=10000
                                                 )

```
  
The segments appear to follow reasonable patterns:  
  
* High impact, skewed early  
* Medium impact, skewed early  
* Medium impact, skewed late  
* Small impact, skewed early (two segments are broadly in this category)  
* Small impact, sustained  
  
Comparisons of segment membership can also be made:  
```{r}

# Confirm that the names 
if (!all.equal(names(test_hier5$useClusters), names(test_hier6_201010$useClusters))) {
    stop("\nIssue with cluster names not matching\n")
}

# Create a data frame of segment changes
segChanges <- tibble::tibble(state=names(test_hier5$useClusters), 
                             oldCluster=test_hier5$useClusters, 
                             newCluster=test_hier6_201010$useClusters
                             )

# Counts of states by oldCluster and newCluster
segChanges %>%
    count(oldCluster, newCluster)

# Print states that changed clusters
segChanges %>%
    filter(oldCluster != newCluster)

```
  
What was previously one of the two low-impact segments has been split in to:  
  
* CO, ME, VT, WA (new segment from split); and  
* IA, MN, NE, NH, NM, OH, VA, WI (new segment from split); and  
* KS, KY, MO, ND, SD (consolidates to other low-impact segment that has rising cases with stable deaths)  
  
At a glance it seems reasonable, though the "lower impact" segments could theoretically all be consolidated without losing too much differentiation.  That said, the dendrogram built with reasonable input parameters considers the split of the lower-impact segments to be more meaningful than the split of the moderate-early and moderate-late segments.  And, the moderate-early and moderate-late split is valuable for analysis, so the decision is made to remain with the 6 hierarchical clusters as of the October 9, 2020 data.
  

