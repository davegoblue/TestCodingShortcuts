---
title: "Coronavirus US - CDC"
author: "davegoblue"
date: "06/23/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
  
## Background  
This module extends code contained in Coronavirus_Statistics_v003.Rmd to include 2020-2021 data.  This file includes the latest code for analyzing all-cause death data from [CDC Weekly Deaths by Jurisdiction](https://catalog.data.gov/dataset/weekly-counts-of-deaths-by-jurisdiction-and-age-group).  CDC maintains data on deaths by week, age cohort, and state in the US.  Downloaded data are unique by state, epidemiological week, year, age, and type (actual vs. predicted/projected).

These data are known to have a lag between death and reporting, and the CDC back-correct to report deaths at the time the death occurred even if the death is reported in following weeks.  This means totals for recent weeks tend to run low (lag), and the CDC run a projection of the expected total number of deaths given the historical lag times.  Per other analysts on the internet, there is currently significant supra-lag, with lag times much longer than historical averages causing CDC projected deaths for recent weeks to be low.

Functions for the previous module are available in Coronavirus_Statistics_Functions_CDC_v003.R and Coronavirus_Statistics_Functions_Shared_v003.R.  The appropriate subset of these functions are copied and edited for use in this module.  The code leverages tidyverse and a variable mapping file throughout:  
```{r}

# All functions assume that tidyverse and its components are loaded and available
library(tidyverse)

# If the same function is in both files, use the version from the more specific source
source("./Generic_Added_Utility_Functions_202105_v001.R")
# source("./Coronavirus_Statistics_Functions_USAF_v003.R")

```
  
## Running Code  
The main function is readRunCDCAllCause(), which performs multiple tasks:  
  
STEP 0: Optionally, downloads the latest data file from CDC
STEP 1: Reads and processes a data file has been downloaded from CDC to local  
STEP 2: Extract relevant data from a processed state-level COVID Tracking Project list  
STEP 3: Basic plots of the CDC data  
STEP 4: Basic excess-deaths analysis  
STEP 5: Create cluster-level aggregate plots  
STEP 6: Create state-level aggregate plots  
STEP 7: Create age-cohort aggregate plots  
STEP 8: Returns a list of key data frames, modeling objects, named cluster vectors, etc.  
  
#### _Modifications: Main function_  
The main function to be edited is readRunCDCAllCause():  
```{r}

# Function to read and run the CDC all-cause deaths analysis
readRunCDCAllCause <- function(loc, 
                               startYear, 
                               curYear,
                               weekThru, 
                               startWeek, 
                               lst, 
                               cvDeathThru,
                               epiMap=readFromRDS("epiMonth"),
                               agePopData=readFromRDS("usPopBucket2020"),
                               cdcPlotStartWeek=startWeek,
                               periodKeep=paste0(startYear, "-", curYear-1), 
                               url="https://data.cdc.gov/api/views/y5bj-9g5w/rows.csv?accessType=DOWNLOAD",
                               dlData=isFALSE(file.exists(paste0(dir, loc))), 
                               dir="./RInputFiles/Coronavirus/", 
                               stateNoCheck=c()
                               ) {
    
    # FUNCTION ARGUMENTS:
    # loc: the CDC .csv file name (without path)
    # startYear: the starting year in the CDC data
    # curYear: the current analyis year in the CDC data
    # weekThru: how many weeks of the current year are the data valid thru?
    # startWeek: the starting week to use for cumulative sum of difference in expected all-cause deaths
    # lst: a state clustering process output list
    # epiMap: a mapping file of ew-month-quarter that mas epiweek (ew) to an appropriate month and quarter
    # agePopData: data containing US population as age (fct) - pop (int)
    # cvDeathThru: the date to use for pulling the CV death data
    # cdcPlotStartWeek: start week for CDC plots (10 is March which avoids a 1-week February outlier)
    # periodKeep: the period of previous data in the CDC all-cause deaths file (should be kept regardless)
    # url: the url for downloading CDC data
    # dlData: should CDC data be downloaded?  default is to not overwrite an existing file
    # dir: the CDC .csv directory (will use paste0(dir, loc) as the file location)
    # stateNoCheck: vector of states that should not error out for failing suppression checks
    
    # STEP 0: Download CDC data if requested
    if (dlData) fileDownload(fileName=paste0(dir, loc), url=url)
    
    return()
    
    # STEP 1: Read and process the CDC data
    cdc <- readProcessCDC(loc, weekThru=weekThru, periodKeep=periodKeep, fDir=dir, stateNoCheck=stateNoCheck)
    
    # STEP 2: Create the key data required for using state-level clusters
    clusterList <- helperKeyStateClusterMetrics(lst)
    
    # STEP 3: Generate plots of the processed CDC data
    cdcBasicPlots(cdc, clustVec=clusterList$clData, stateExclude=stateNoCheck)

    # Exclude stateNoCheck states
    cat("\nPlots will be run after excluding stateNoCheck states\n")
    cdcUse <- cdc %>% filter(!(state %in% stateNoCheck))
    
    # STEP 4: Full US excess deaths
    list_allUS <- cdcCohortAnalysis(cohortName="all US", 
                                    df=cdcUse,
                                    curYear=curYear, 
                                    startYear=startYear,
                                    startWeek=startWeek,
                                    plotTitle="All-cause US total deaths",
                                    predActualPlotsOnePage=TRUE
    )
    # cat("\n\n\n*** THROUGH STEP 4 ***\n\n\n")
    
    # STEP 5: Generate cluster-level aggregate plots
    clusterAgg <- cdcAggregateSummary(df=cdcUse, 
                                      critVar="state", 
                                      critSubsets=clusterList$stateCluster,
                                      startWeek=startWeek, 
                                      critListNames=paste0("cluster ", 1:length(clusterList$stateCluster)),
                                      factorCritList=FALSE,
                                      popData=clusterList$pop,
                                      cvDeathData=clusterList$deaths,
                                      idVarName="cluster"
    )
    # cat("\n\n\n*** THROUGH STEP 5 ***\n\n\n")
    
    # STEP 6: Generate state-level aggregate data, then plot
    stateAgg <- cdcAggregateSummary(df=cdcUse, 
                                    critVar="state", 
                                    critSubsets=setdiff(names(clusterList$clData), stateNoCheck),
                                    startWeek=startWeek, 
                                    idVarName="state", 
                                    subListNames=setdiff(names(clusterList$clData), stateNoCheck),
                                    showAllPlots=FALSE
    )
    # cat("\n\n\n*** THROUGH STEP 6a ***\n\n\n")
    
    helperKeyStateExcessPlots(df=stateAgg, 
                              epiMonth=epiMap,
                              cvDeaths=lst$consolidatedPlotData,
                              startWeek=cdcPlotStartWeek,
                              cvDeathDate=as.Date(cvDeathThru),
                              subT=paste0("CDC data through week ", weekThru, " of ", curYear)
    )
    # cat("\n\n\n*** THROUGH STEP 6b ***\n\n\n")
    
    # STEP 7: Generate age-level aggregate data, then plot
    ageAgg <- cdcAggregateSummary(df=cdcUse, 
                                  critVar="age", 
                                  critSubsets=levels(cdc$age),
                                  startWeek=startWeek, 
                                  idVarName="age", 
                                  subListNames=levels(cdc$age),
                                  showAllPlots=TRUE
    )
    helperKeyAgeExcessPlots(df=ageAgg, 
                            epiMonth=epiMap,
                            cvDeaths=lst$consolidatedPlotData,
                            popData=agePopData,
                            startWeek=cdcPlotStartWeek,
                            cvDeathDate=as.Date(cvDeathThru),
                            subT=paste0("CDC data through week ", weekThru, " of ", curYear)
    )
    
    # STEP 8: Return a list of key files
    list(cdc=cdc, 
         clusterList=clusterList, 
         allUSAgg=list_allUS$preds,
         clusterAgg=clusterAgg, 
         stateAgg=stateAgg, 
         ageAgg=ageAgg
    )
    
}


```

#### _Modifications: Additional functions_  
The data are initially run to download the latest CDC data:  
```{r cache=TRUE}

cdcLoc <- "Weekly_counts_of_deaths_by_jurisdiction_and_age_group_downloaded_20210623.csv"
readRunCDCAllCause(loc=cdcLoc)

```

The data are inspected to check that they are sufficient for the next steps:  
```{r, fig.height=9, fig.width=9}

remapVars=c('Jurisdiction'='fullState', 
            'Week Ending Date'='weekEnding', 
            'State Abbreviation'='state', 
            'Age Group'='age', 
            'Number of Deaths'='deaths', 
            'Time Period'='period', 
            'Year'='year', 
            'Week'='week'
            )

cdcRaw <- fileRead(paste0("./RInputFiles/Coronavirus/", cdcLoc), col_types="cccddcdcccc") %>%
    colRenamer(vecRename=remapVars)

cdcRaw
cdcRaw %>% 
    group_by(state, Type) %>% 
    summarize(deaths=sum(deaths, na.rm=TRUE)) %>%
    arrange(-deaths)

cdcRaw %>%
    mutate(subUnit=ifelse(state=="US", "whole", "components")) %>%
    group_by(subUnit, Type, year) %>%
    summarize(deaths=sum(deaths, na.rm=TRUE), .groups="drop") %>%
    ggplot(aes(x=year)) + 
    geom_col(aes(y=deaths), fill="lightblue") + 
    geom_text(aes(y=deaths/2, label=paste0(round(deaths/1000000, 2), " MM")), size=3) + 
    facet_grid(Type~subUnit) + 
    labs(x=NULL, y="Deaths", title="Raw CDC Summed Deaths")

```

Back of the envelope, the data appear reasonable for use in refining code.

The readrProcessCDC() function is updated:  
```{r, fig.height=9, fig.width=9}

ageLevels <- c("Under 25 years", "25-44 years", "45-64 years", 
               "65-74 years", "75-84 years", "85 years and older"
               )
periodLevels <- c("2015-2019", "2020", "2021")
yearLevels <- 2015:2021

# Function to read and process raw CDC all-cause deaths data
readProcessCDC <- function(fName, 
                           weekThru,
                           periodKeep=c("2015-2019", "2020"),
                           fDir="./RInputFiles/Coronavirus/",
                           col_types="ccciicdcccc", 
                           renameVars=remapVars,  # Update this approach 
                           maxSuppressAllowed=10, 
                           stateNoCheck=c()
                           ) {
    
    # FUNCTION ARGUMENTS:
    # fName: name of the downloaded CDC data file
    # weekThru: any record where week is less than or equal to weekThru will be kept
    # periodKeep: any record where period is in periodKeep will be kept
    # fDir: directory name for the downloaded CDC data file
    # col_types: variable type by column in the CDC data (passed to readr::read_csv())
    # renameVars: named vector for variable renaming of type c("Existing Name"="New Name")
    # maxSuppressAllowed: maximum number of data suppressions (must be in current week/year) to avoid error
    # stateNoCheck: vector of states that do NOT have suppression errors thrown
    
    # STEP 1: Read the CSV data
    cdcRaw <- fileRead(paste0(fDir, fName), col_types=col_types)
    # glimpse(cdcRaw)
    
    # STEP 2: Rename the variables for easier interpretation
    cdcRenamed <- cdcRaw %>%
        colRenamer(vecRename=renameVars) %>%
        colMutater(selfList=list("weekEnding"=lubridate::mdy))
    # glimpse(cdcRenamed)
    
    # STEP 3: Convert to factored data
    cdcFactored <- cdcRenamed %>%
        colMutater(selfList=list("age"=factor), levels=ageLevels) %>%
        colMutater(selfList=list("period"=factor), levels=periodLevels) %>%
        colMutater(selfList=list("year"=factor), levels=yearLevels)
    # glimpse(cdcFactored)
    
    # STEP 4: Filter the data to include only weighted deaths and only through the desired time period
    cdcFiltered <- cdcFactored %>%
        rowFilter(lstFilter=list("Type"="Predicted (weighted)")) %>%
        filter(period %in% all_of(periodKeep) | week <= weekThru)
    # glimpse(cdcFiltered)
    
    # STEP 4a: Check that all suppressed data and NA deaths have been eliminated
    cat("\n\n *** Data suppression checks *** \n")
    checkProblems <- cdcFiltered %>% 
        mutate(problem=(!is.na(Suppress) | is.na(deaths)), 
               curWeek=(!(year %in% all_of(periodKeep)) & week==weekThru), 
               noCheck=state %in% all_of(stateNoCheck)
               ) %>%
        group_by(noCheck, state, problem, curWeek) %>%
        summarize(n=n(), deaths=specNA(sum)(deaths), .groups="drop")
    errorProblems <- checkProblems %>%
        filter(problem)
    print(errorProblems)
    errorProblems <- errorProblems %>%
        group_by(noCheck, curWeek) %>%
        summarize(n=sum(n), .groups="drop")
    print(errorProblems)
    nPrev <- errorProblems %>% filter(!noCheck, !curWeek) %>% pull(n) %>% sum()
    nCur <- errorProblems %>% filter(!noCheck, curWeek) %>% pull(n) %>% sum()
    if (nPrev > 0) stop(paste0("\n\n", nPrev, " records not from current week/year with problems.  Fix and retry\n"))
    if (nCur > maxSuppressAllowed) {
        cat("\n\n", nCur, " records from current week/year with problems, exceeds tolerance of ", maxSuppressAllowed)
        stop("\nFix and retry\n")
    }

    cat("\n\nData suppression checks passed\n\n")
    
    # STEP 5: Remove any NA death fields, delete the US record, convert YC to be part of NY
    cdcProcessed <- cdcFiltered %>%
        rowFilter(lstExclude=list("state"=c("US", "PR"), "deaths"=c(NA))) %>%
        mutate(state=ifelse(state=="YC", "NY", state), 
               fullState=ifelse(state %in% c("NY", "YC"), "New York State (NY plus YC)", fullState)
        ) %>%
        group_by(fullState, weekEnding, state, year, week, age, period, Type, Suppress) %>%
        arrange(!is.na(Note)) %>%
        summarize(n=n(), deaths=sum(deaths), Note=first(Note), .groups="drop") %>%
        ungroup() %>%
        checkUniqueRows(uniqueBy=c("state", "year", "week", "age"))
    glimpse(cdcProcessed)
    
    # STEP 5a: Check control levels for key variables in processed file
    cat("\nCheck Control Levels and Record Counts for Processed Data:\n")
    cdcCheck <- cdcProcessed %>% mutate(n=1, n_deaths_na=ifelse(is.na(deaths), 1, 0))
    purrr::walk(list(c("age"), c("period", "year", "Type"), c("period", "Suppress"), c("period", "Note")), 
                .f=function(x) {
                    cat("\n\nChecking variable combination:", x, "\n")
                    checkControl(cdcCheck, groupBy=x, useVars=c("n", "n_deaths_na", "deaths"), fn=specNA(sum))
                    }
                )
    p1 <- checkControl(cdcCheck, 
                       groupBy=c("state"), 
                       useVars=c("deaths"), 
                       fn=specNA(sum), 
                       printControls=FALSE, 
                       pivotData=FALSE
                       ) %>%
        ggplot(aes(x=fct_reorder(state, deaths), y=deaths)) + 
        geom_col(fill="lightblue") + 
        geom_text(aes(y=deaths, label=paste0(round(deaths/1000), "k")), hjust=0, size=3) + 
        coord_flip() +
        labs(y="Total deaths", x=NULL, title="Total deaths by state in all years in processed file")
    print(p1)
    p2 <- checkControl(cdcCheck, 
                       groupBy=c("year", "week"), 
                       useVars=c("deaths"), 
                       fn=specNA(sum), 
                       printControls=FALSE, 
                       pivotData=FALSE
                       ) %>%
        ggplot(aes(x=week, y=deaths)) + 
        geom_line(aes(group=year, color=year)) + 
        labs(title="Deaths by year and epidemiological week", x="Epi week", y="US deaths") + 
        scale_color_discrete("Year") + 
        lims(y=c(0, NA))
    print(p2)
    
    # STEP 6: Return the processed data file
    cdcProcessed
    
}

cdc_temp <- readProcessCDC(cdcLoc, weekThru=17, stateNoCheck=c("NC"))
cdc_temp

```
  
The process now reads and processes the file and runs diagnostics for sanity checks.  

The helperKeyStateClusterMetrics() function is also updated:  
```{r, fig.height=9, fig.width=9}

# Convert the output of a state-level clustering list to population, membership, and deaths
helperKeyStateClusterMetrics <- function(lst) {
    
    # FUNCTION ARGUMENTS:
    # lst: the list containing the outputs of the state clustering routing
    
    # Extract the relevant elements from lst
    plotClusters <- lst[["plotDataList"]][["plotClusters"]]
    dfFull <- lst[["plotDataList"]][["dfFull"]] %>% select(state, date, pop, tot_deaths, new_deaths)
    
    # Create the aggregated data
    df <- joinFrames(plotClusters, dfFull, keyJoin="state")
    
    # Create reported cvDeaths by cluster
    dfWeekly <- df %>%
        mutate(year=lubridate::epiyear(date), week=lubridate::epiweek(date), cluster=as.character(cluster)) %>%
        group_by(state, cluster, year, week) %>%
        summarize(pop=max(pop), 
                  tot_deaths=specNA(max)(tot_deaths), 
                  new_deaths=specNA(sum)(new_deaths), 
                  .groups="drop"
                  ) %>%
        group_by(cluster, year, week) %>%
        summarize(pop=sum(pop), 
                  tot_deaths=specNA(sum)(tot_deaths), 
                  new_deaths=specNA(sum)(new_deaths), 
                  .groups="drop"
                  ) %>%
        checkUniqueRows(uniqueBy=c("cluster", "year", "week"))
    
    list(deaths=dfWeekly, useClusters=lst[["useClusters"]])
    
}

# Get a state-level clustering file
cdc_daily_210528 <- readFromRDS("cdc_daily_210528")
clusterList_temp <- helperKeyStateClusterMetrics(cdc_daily_210528)
clusterList_temp

clusterList_temp$deaths %>%
    pivot_longer(-c("cluster", "year", "week")) %>%
    filter(name %in% c("tot_deaths", "new_deaths"), !is.na(value)) %>%
    ggplot(aes(x=week, y=value)) + 
    geom_line(aes(group=cluster, color=cluster)) + 
    facet_grid(name~year, scales="free_y") + 
    labs(x="Epi Week", y="Deaths (total or incremental)", title="Evolution of deaths by cluster")

```

Data appear to be usable for the next steps in CDC processing.  The function cdcBasicPlots() is updated:  
```{r, fig.height=9, fig.width=9}

# Basic plots of the CDC data, including by a state-level cluster (passed as argument)
cdcBasicPlots <- function(df, 
                          weekThru=NULL, 
                          curYear=NULL, 
                          p5Years=curYear,
                          clustVec=NULL, 
                          stateExclude=c()
                          ) {
    
    # FUNCTION ARGUMENTS:
    # df: a processed CDC data file
    # weekThru: week of the current year that data are thru (NULL means infer from data)
    # curYear: current year (NULL means infer from data)
    # p5Years: years for plotting deaths by week/cohort (defaults to only current year)
    # clustVec: clustering vector with names as state abbreviations (NULL means no plots by cluster)
    # stateExclude: vector of states to exclude from the analysis
    
    # Get the week and year if passed as NULL
    if (is.null(curYear)) { curYear <- df %>% pull(year) %>% as.character() %>% as.integer() %>% max() }
    if (is.null(weekThru)) { weekThru <- df %>% filter(year==curYear) %>% pull(week) %>% max() }
    
    # Filter to exclude stateExclude
    df <- df %>%
        filter(!(state %in% stateExclude))
    
    # Update subtitle appropriately
    subT <- NULL
    if (length(stateExclude) > 0) subT <- paste0("Excludes ", paste0(stateExclude, collapse=", "))
    
    # Plot of total deaths by year (50 states plus DC)
    p1 <- df %>%
        group_by(year) %>%
        summarize(deaths=sum(deaths), .groups="drop") %>%
        ggplot(aes(x=year, y=deaths/1000)) + 
        geom_col(fill="lightblue") + 
        geom_text(aes(y=deaths/2000, label=round(deaths/1000))) + 
        labs(title=paste0("CDC Deaths for 50 states plus DC through week ", weekThru, " of ", curYear), 
             x="", 
             y="Deaths (000s)"
        )
    if (!is.null(subT)) p1 <- p1 + labs(subtitle=subT)
    print(p1)
    
    # Plot of total deaths by week by year
    p2 <- df %>%
        group_by(year, week) %>%
        summarize(deaths=sum(deaths), .groups="drop") %>%
        ggplot(aes(x=week, y=deaths, group=year, color=year)) + 
        geom_line() +
        ylim(c(0, NA)) + 
        labs(x="Week of Year", y="Deaths", title="US deaths per week by year")
    if (!is.null(subT)) p2 <- p2 + labs(subtitle=subT)
    print(p2)
    
    # Plot of total deaths by year by age cohort
    p3 <- df %>%
        group_by(year, week, age) %>%
        summarize(deaths=sum(deaths), .groups="drop") %>%
        ggplot(aes(x=week, y=deaths, group=year, color=year)) + 
        geom_line() +
        ylim(c(0, NA)) + 
        facet_wrap(~age) +
        labs(x="Week of Year", y="Deaths", title="US deaths per week by year")
    if (!is.null(subT)) p3 <- p3 + labs(subtitle=subT)
    print(p3)
    
    # Plots of total deaths by week by year by cluster
    if (!is.null(clustVec)) {
        p4 <- df %>%
            mutate(cluster=clustVec[state]) %>%
            group_by(year, week, cluster) %>%
            summarize(deaths=sum(deaths), .groups="drop") %>%
            ggplot(aes(x=week, y=deaths, group=year, color=year)) + 
            geom_line() +
            ylim(c(0, NA)) + 
            facet_wrap(~cluster, scales="free_y") +
            labs(x="Week of Year", 
                 y="Deaths", 
                 title="US deaths per week by year"
            )
        if (is.null(subT)) p4 <- p4 + labs(subtitle="Facetted by state cluster")
        else p4 <- p4 + labs(subtitle=paste0("Facetted by state cluster\n", subT))
        print(p4)
        
        p5 <- df %>%
            mutate(cluster=clustVec[state]) %>%
            filter(year %in% p5Years) %>%
            group_by(year, age, week, cluster) %>%
            summarize(deaths=sum(deaths), .groups="drop") %>%
            mutate(weekUse=week+53*(as.integer(as.character(year))-curYear)) %>%
            ggplot(aes(x=weekUse, y=deaths, fill=age)) + 
            geom_col(position="stack") +
            ylim(c(0, NA)) + 
            facet_wrap(~cluster, scales="free_y") +
            labs(x="Week of Year", 
                 y="Deaths", 
                 title=paste0("US deaths per week (Week 1 is start of year ", curYear, ")")
            )
        if (is.null(subT)) p5 <- p5 + labs(subtitle="Facetted by state cluster")
        else p5 <- p5 + labs(subtitle=paste0("Facetted by state cluster\n", subT))
        print(p5)
    }
    
}


cdcBasicPlots(cdc_temp, clustVec=clusterList_temp$useClusters, stateExclude="NC", p5Years=2019:2021)

```

The function cdcCohortAnalysis() is updated:  
```{r, fig.height=9, fig.width=9}

# Function to subset CDC data
subsetCDC <- function(df, 
                      critFilter=vector("list", 0), 
                      showPlot=TRUE, 
                      plotTitle=NULL, 
                      curYear=2020:2021, 
                      prevYears=paste0("2015-", min(curYear)-1)
                      ) {
    
    # FUNCTION ARGUMENTS:
    # df: the data frame containing the processed CDC data
    # critFilter: a filtering list of the form variable=c(possibleValues)
    # showPlot: boolean, whether to show plots of deaths by week and year
    # plotTitle: the title to be used for the plot (NULL will use a default title)
    # curYear: the current year (will be excluded from the mean and standard deviation plot)
    
    # Filter such that only matches to critFilter are included
    for (xNum in seq_len(length(critFilter))) {
        df <- df %>%
            filter_at(vars(all_of(names(critFilter)[xNum])), ~. %in% critFilter[[xNum]])
    }
    
    # Create a default title if none provided
    if (is.null(plotTitle)) plotTitle <- "All-cause deaths for filtered cohort"
    
    # All deaths by week and year for the filtered cohort
    allDeath <- df %>%
        group_by(year, week) %>%
        summarize(deaths=sum(deaths), .groups="drop") %>%
        mutate(weekfct=factor(week), yearint=as.integer(as.character(year)))
    
    # Show plots if requested
    if (showPlot) {
        # Plot of all deaths for the filtered cohort by week and year
        p1 <- allDeath %>%
            ggplot(aes(x=week, y=deaths, color=year, group=year)) + 
            geom_line() + 
            ylim(c(0, NA)) + 
            labs(x="Week", y="Deaths", title=plotTitle)
        print(p1)
        
        # Plot of mean and standard deviation from previous years
        p2 <- allDeath %>%
            filter(!(year %in% curYear)) %>%
            group_by(week) %>%
            summarize(mean=mean(deaths), sd=sd(deaths), .groups="drop") %>%
            ggplot(aes(x=week)) + 
            geom_line(aes(y=mean), color="red", size=2) + 
            geom_ribbon(aes(ymin=mean-sd, ymax=mean+sd), fill="pink", alpha=0.5) +
            labs(x="Week", 
                 y="Deaths", 
                 title=paste0(prevYears, " ", plotTitle), 
                 subtitle=paste0("Line is ", 
                                 prevYears, 
                                 " annual mean deaths, ribbon is +/- 1 standard deviation"
                 )
            ) + 
            ylim(c(0, NA))
        print(p2)
        
    }
    
    # Return the processed data frame
    allDeath
    
}



# Function to run the linear model to predict CDC deaths by week and year
cdcRegression <- function(df, 
                          curYear=2020:2021, 
                          startYear=2015
                          ) {
    
    # FUNCTION ARGUMENTS:
    # df: the data frame containing the processed CDC data
    # curYear: the current year(s)
    # startYear: the year that is defined as the zero-point for the regression
    
    # Very basic linear model for deaths vs. week and year
    df %>%
        filter(!(year %in% curYear)) %>%
        lm(deaths ~ weekfct + I(yearint-startYear) + 0, data=.)
    
}



# Function to make predictions based on the regression
cdcPrediction <- function(df, 
                          lmReg
                          ) {
    
    # FUNCTION ARGUMENTS:
    # df: the data frame or tibble containing the data
    # lmReg: the linear regression model
    
    # Predictions and deltas
    allPred <- df %>%
        mutate(oldweekfct=weekfct, weekfct=factor(ifelse(weekfct==53, 52, weekfct))) %>%
        mutate(pred=predict(lmReg, newdata=.), delta=(deaths-pred)) %>%
        group_by(year) %>%
        arrange(week) %>%
        mutate(cumDelta=cumsum(delta), cumPred=cumsum(pred), weekfct=oldweekfct) %>%
        select(-oldweekfct) %>%
        ungroup()
    
    # Return the predictions and deltas    
    allPred
    
}



# Function to make plots of the predictions
cdcPredictedvsActual <- function(df, 
                                 cohortName,
                                 curYear=2020:2021, 
                                 prevYears=paste0("2015-", min(curYear)-1), 
                                 startWeek=1, 
                                 showCurrentPredvsPrev=TRUE, 
                                 showActualsvsPred=TRUE,
                                 showActualsvsPredRatio=TRUE, 
                                 showExcessDeaths=TRUE, 
                                 predActualPlotsOnePage=FALSE
                                 ) {
    
    # FUNCTION ARGUMENTS:
    # df: the data frame containing actual and predicted deaths
    # cohortName: cohort name to use for plot titles
    # curYear: the current year
    # prevYears: the previous years
    # startWeek: week to use for starting the counts of cumulative excess deaths
    # showCurrentPredvsPrev: boolean, whether to plot current year predictions vs. previous years
    # showActualsvsPred: boolean, whether to plot actuals vs. predictions by year
    # showActualsvsPredRatio: boolean, whether to plot actuals vs. predictions ratios by yrea
    # showExcessDeaths: boolean, whether to plot estimated excess deaths
    # predActualPlotsOnePage: boolean, whether to place the predicted vs. actual plots all on one page
    
    if (showCurrentPredvsPrev) {
        # Current year predictions vs. previous year actuals
        p1 <- df %>%
            ggplot(aes(x=week)) + 
            geom_line(data=~filter(., !(year %in% curYear)), aes(y=deaths, color=year, group=year)) + 
            geom_line(data=~filter(., year %in% curYear), aes(y=pred, group=year, color=year), lty=2, size=1) +
            ylim(c(0, NA)) + 
            labs(x="Week", 
                 y="Deaths", 
                 title=paste0("All-cause deaths for ", cohortName, " cohort"), 
                 subtitle=paste0("Solid lines are actual ", 
                                 prevYears, 
                                 ", dashed line is predicted ", 
                                 if(length(curYear)>1) range(curYear) %>% paste0(collapse="-") else curYear
                 )
            )
        if (!predActualPlotsOnePage) print(p1)
    }
    
    if (showActualsvsPred) {
        # Plot of predictions and actuals facetted by year - deaths
        p2 <- df %>%
            select(year, week, deaths, pred) %>%
            pivot_longer(c(deaths, pred)) %>%
            mutate(name=ifelse(name=="deaths", "Actual", "Predicted")) %>%
            ggplot(aes(x=week)) + 
            geom_line(aes(y=value, color=name, group=name)) + 
            ylim(c(0, NA)) + 
            facet_wrap(~year) + 
            labs(x="Week", 
                 y="Deaths", 
                 title=paste0("All-cause deaths for ", cohortName, " cohort"), 
                 subtitle=paste0("Predictions based on simple linear model for ", prevYears, " data")
            ) + 
            scale_color_discrete("Deaths")
        if (!predActualPlotsOnePage) print(p2)
    }
    
    if (showActualsvsPredRatio) {
        # Plot of predictions and actuals facetted by year - ratios
        p3 <- df %>%
            mutate(rat=deaths/pred) %>%
            ggplot(aes(x=week)) + 
            geom_line(aes(y=rat)) + 
            facet_wrap(~year) + 
            geom_hline(yintercept=1, lty=2) +
            labs(x="Week", 
                 y="Ratio (Actual vs. Predicted Deaths)", 
                 title=paste0("Actual vs. predicted deaths for ", cohortName, " cohort"), 
                 subtitle=paste0("Predictions based on simple linear model for ", prevYears, " data")
            )
        if (!predActualPlotsOnePage) print(p3)
    }
    
    if (showExcessDeaths) {
        # Plot of excess deaths after a starting week
        p4 <- df %>%
            select(-cumDelta, -cumPred) %>%
            filter(week >= startWeek) %>%
            group_by(year) %>%
            arrange(week) %>%
            mutate(cumDelta=cumsum(delta)) %>%
            ggplot(aes(x=week)) + 
            geom_line(aes(y=cumDelta)) + 
            facet_wrap(~year) + 
            geom_hline(yintercept=0, lty=2) +
            labs(x="Week", 
                 y=paste0("Deaths vs. prediction (cumulative from week ", startWeek, ")"), 
                 title=paste0("Cumulative estimated excess deaths starting week ", 
                              startWeek, 
                              "\nfor ", 
                              cohortName, 
                              " cohort"
                 ), 
                 subtitle=paste0("Predictions based on simple linear model for ", prevYears, " data")
            )
        if (!predActualPlotsOnePage) print(p4)
    }
    
    # Create a one-page summary
    if (predActualPlotsOnePage) {
        if (!exists("p1", inherits=FALSE)) p1 <- ggplot()
        if (!exists("p2", inherits=FALSE)) p2 <- ggplot()
        if (!exists("p3", inherits=FALSE)) p3 <- ggplot()
        if (!exists("p4", inherits=FALSE)) p4 <- ggplot()
        gridExtra::grid.arrange(p1, p2, p3, p4, nrow=2)
    }
    
}



# Integrated function with all steps
cdcCohortAnalysis <- function(cohortName, 
                              df=cdcProcessed, 
                              critFilter=vector("list", 0), 
                              plotTitle=NULL, 
                              curYear=2020:2021, 
                              startYear=2015,
                              prevYears=paste0(startYear, "-", min(curYear)-1), 
                              startWeek=1, 
                              showSubsetPlots=TRUE, 
                              showPredActualPlots=TRUE, 
                              predActualPlotsOnePage=FALSE
                              ) {
    
    # FUNCTION ARGUMENTS:
    # cohortName: the name of the cohort
    # df: the processed CDC death data
    # critFilter: the filtering criteria in the form of a named list "variable"=c("possibleValues")
    # plotTitle: title to be used for plot in subsetCDC()
    # curYear: the current year(s) for the death data
    # startYear: the starting year for the death data
    # prevYears: the previous years for the death data (used for making predictions)
    # startWeek: the starting week for counting excess deaths
    # showSubsetPlots: boolean, whether to show the two plots in subsetCDC()
    # showPredActualPlots: boolean, whether to show the four plots in cdcPredictedvsActual()
    # predActualPlotsOnePage: boolean, whether to place the predicted vs. actual plots all on one page
    
    # Subset the data (will show both plots by default)
    allDeath_cohort <- subsetCDC(df=df, 
                                 critFilter=critFilter,
                                 showPlot=showSubsetPlots,
                                 plotTitle=plotTitle, 
                                 curYear=curYear,
                                 prevYears=prevYears
                                 )
    
    # Create the linear model for the subsetted data
    lm_cohort <- cdcRegression(df=allDeath_cohort, curYear=curYear, startYear=startYear)
    
    # Apply the predictions to the data
    allPred_cohort <- cdcPrediction(df=allDeath_cohort, lmReg=lm_cohort)
    
    # Plots for predicted vs. actual (will show all plots by default)
    cdcPredictedvsActual(df=allPred_cohort, 
                         cohortName=cohortName, 
                         curYear=curYear,
                         prevYears=prevYears,
                         startWeek=startWeek, 
                         showCurrentPredvsPrev=showPredActualPlots,
                         showActualsvsPred=showPredActualPlots,
                         showActualsvsPredRatio=showPredActualPlots,
                         showExcessDeaths=showPredActualPlots, 
                         predActualPlotsOnePage=predActualPlotsOnePage
    )
    
    # Return a list containing the lm model and the filtered data
    list(lmReg=lm_cohort, preds=allPred_cohort)
    
}



list_allUS_temp <- cdcCohortAnalysis(cohortName="all US", 
                                     df=cdc_temp %>% filter(!(state %in% c("NC"))),
                                     curYear=2020:2021, 
                                     startYear=2015,
                                     startWeek=1,
                                     plotTitle="All-cause US total deaths",
                                     predActualPlotsOnePage=TRUE
                                     )
list_allUS_temp

```

The function cdcAggregateSummary() is updated:  
```{r, fig.height=9, fig.width=9}

# Function to create data and plots for an aggregate (cluster in this case)
cdcAggregateSummary <- function(df, 
                                critVar, 
                                critSubsets, 
                                startWeek,
                                idVarName=critVar,
                                curYear=2020:2021, 
                                startYear=2015,
                                subListNames=NULL,
                                critListNames=subListNames,
                                factorCritList=!is.null(critListNames),
                                popData=NULL,
                                cvDeathData=NULL,
                                showAllPlots=TRUE, 
                                showStep1Plots=showAllPlots,
                                showStep3Plots=showAllPlots
                                ) {
    
    # FUNCTION ARGUMENTS:
    # df: the data frame containing the processed CDC all-cause deaths data
    # critVar: the main variable supplied to critFilter
    # critSubsets: the subsets used for critVar
    # startWeek: the starting week for analysis (will assume no excess deaths prior to startWeek or curYear)
    # idVarName: name to be used for the identifying variable when excess deaths data are combined
    # curYear: current year(s) of CDC deaths data
    # subListNames: names to be used in place of numbers for idVarName column of excessFull
    #               (NULL means use numbers)
    # critListNames: names to be used for describing the key cohorts (NULL means use numbers)
    # factorCritList: boolean, whether to factor the variable that results from critListNames
    # startYear: starting year of CDC deaths data
    # popData: population data file, unique and matching by idVarName (NULL means no population plots)
    # cvDeathData: coronavirus deaths data file, unique and matching by idVarName
    #              NULL means no plots of excess all-cause deaths vs reported coronavirus deaths
    # showAllPlots: boolean, whether to show all the plots
    # showStep1Plots: boolean, whether to show a 1-page plot summary for each element of critSubsets
    # showStep3Plots: boolean, whether to show a 1-page cross-element summary
    
    # STEP 0: Initialize list to store results for each combination of critSubsets    
    tmpList <- vector("list", length(critSubsets))
    
    # STEP 1: Run the process for each combination of critSubsets (produce plots if showStep1Plots is TRUE)
    for (ctr in seq_along(critSubsets)) {
        critUse <- list(critSubsets[[ctr]])
        names(critUse) <- critVar
        useName <- if(is.null(critListNames)) paste0("Iteration: ", ctr) else critListNames[ctr]
        tmpList[[ctr]] <- cdcCohortAnalysis(cohortName=useName, 
                                            df=df, 
                                            critFilter=critUse, 
                                            plotTitle="",
                                            curYear=curYear,
                                            startYear=startYear,
                                            startWeek=startWeek, 
                                            showSubsetPlots=FALSE, 
                                            showPredActualPlots=showStep1Plots,
                                            predActualPlotsOnePage=showStep1Plots
        )
    }
    
    # STEP 1a: Add names if requeated
    if (!is.null(subListNames)) names(tmpList) <- subListNames
    
    # STEP 2: Create the excess file
    excessFull <- map_dfr(.x=tmpList, .f=function(x) { x[["preds"]] }, .id=idVarName)
    
    # STEP 2a: Convert idVarName to factor if critListName is passed
    if (factorCritList) {
        excessFull <- excessFull %>%
            mutate(!!idVarName:=factor(get(idVarName), levels=critListNames))
    }
    
    # STEP 3: Produce a plot of excess deaths by week by idVarName
    if (showStep3Plots) {
        p1 <- excessFull %>%
            filter(year %in% curYear) %>%
            ggplot(aes(x=week, y=delta)) + 
            geom_line(aes_string(group=idVarName, color=idVarName)) + 
            labs(title=paste0("Actual minus predicted deaths by week (", 
                              if(length(curYear)>1) range(curYear) %>% paste0(collapse="-") else curYear, 
                              ")"
                              ), 
                 x="Week", 
                 y="Actual minus predicted deaths"
            ) + 
            facet_wrap(~year) +
            scale_color_discrete(idVarName)
        print(p1)
    }
    
    # STEP 4: Augment the data to include population (if popData is not NULL) and plot "per million"
    if (!is.null(popData)) {
        # Add population data to excessFull (only variables should be idVarName and pop)
        excessFull <- excessFull %>%
            left_join(select_at(popData, vars(all_of(c(idVarName, "pop")))), by=idVarName)
        # Plot of excess deaths per million by week by cluster
        p2 <- excessFull %>%
            filter(year %in% curYear) %>%
            ggplot(aes(x=week, y=1000000*delta/pop)) + 
            geom_line(aes(group=cluster, color=cluster)) + 
            labs(title=paste0("Actual minus predicted deaths by week (", 
                              if(length(curYear)>1) range(curYear) %>% paste0(collapse="-") else curYear, 
                              ")"
                              ), 
                 subtitle="Per million people, per week",
                 x="Week", 
                 y="Actual minus predicted deaths (per million people)"
            ) + 
            scale_color_discrete(idVarName) + 
            facet_wrap(~year) +
            geom_hline(aes(yintercept=0), lty=2)
        print(p2)
    }
    
    # STEP 5: Augment the data to show plot of excess all-cause deaths vs. reported coronavirus deaths
    if (!is.null(cvDeathData)) {
        # Add the reported coronavirus deaths total
        excessFull <- excessFull %>%
            left_join(select_at(cvDeathData, vars(all_of(c(idVarName, "year", "week", "cvDeaths")))), 
                      by=c(idVarName, "yearint"="year", "week")
            ) %>%
            mutate(cvDeaths=ifelse(is.na(cvDeaths) | !(year %in% curYear), 0, cvDeaths))
        # Plot for total excess deaths and reported coronavirus deaths by idVarName by week
        p3 <- excessFull %>%
            filter(year %in% curYear) %>%
            mutate(useWeek=week+53*(yearint-min(curYear))) %>%
            select_at(vars(all_of(c(idVarName, "year", "week", "useWeek", "cvDeaths", "delta")))) %>%
            pivot_longer(c(cvDeaths, delta), names_to="source", values_to="deaths") %>%
            ggplot(aes(x=useWeek, y=deaths)) + 
            geom_line(aes(group=source, 
                          color=c("cvDeaths"="Reported COVID", "delta"="Excess All-Cause")[source]
                          )
                      ) + 
            facet_wrap(~get(idVarName)) + 
            scale_color_discrete("Deaths") + 
            labs(x="Week", 
                 y="Deaths", 
                 title=paste0("Deaths by ", idVarName, " by week"), 
                 subtitle=paste0("Week 1 is the first epi week of ", min(curYear))
                 )
        print(p3)
    }
    
    # STEP n: Return the excess file
    excessFull
    
}


clNames <- clusterList_temp$useClusters %>% unique()
clValues <- lapply(clNames, FUN=function(x) names(clusterList_temp$useClusters)[clusterList_temp$useClusters==x])
clusterAgg_temp <- cdcAggregateSummary(df=cdc_temp %>% filter(!(state %in% c("NC"))), 
                                       critVar="state", 
                                       critSubsets=clValues,
                                       startWeek=1, 
                                       subListNames=clNames,
                                       critListNames=paste0("cluster ", clNames),
                                       factorCritList=FALSE,
                                       popData=clusterList_temp$deaths %>% 
                                           group_by(cluster) %>% 
                                           summarize(pop=max(pop), .groups="drop"),
                                       cvDeathData=clusterList_temp$deaths %>% 
                                           select(cluster, year, week, cvDeaths=new_deaths),
                                       idVarName="cluster"
                                       )
    
stateAgg_temp <- cdcAggregateSummary(df=cdc_temp %>% filter(!(state %in% c("NC"))), 
                                     critVar="state", 
                                     critSubsets=setdiff(names(clusterList_temp$useClusters), "NC"),
                                     startWeek=1, 
                                     idVarName="state", 
                                     subListNames=setdiff(names(clusterList_temp$useClusters), "NC"),
                                     showAllPlots=FALSE
                                     )
stateAgg_temp

ageAgg_temp <- cdcAggregateSummary(df=cdc_temp %>% filter(!(state %in% c("NC"))), 
                                   critVar="age", 
                                   critSubsets=levels(cdc_temp$age),
                                   startWeek=1, 
                                   idVarName="age", 
                                   subListNames=levels(cdc_temp$age),
                                   showAllPlots=TRUE
                                   )
ageAgg_temp

```

