---
title: 'Additional Coding: Update #4'
author: "davegoblue"
date: "September 26, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Overview  
This document explores video poker hands, using <http://wizardofodds.com/games/video-poker/methodology/> as a template, and applying DataCamp_Insights_v001 materials where applicable.  This document builds on the more salient components of the analysis in AdditionalCoding_v003.Rmd.  

## Analysis Approach  
The Wizard of Odds suggests an 11-step approach to calculating the returns for a video poker pay table:  
  
1.  Initialize arrays for discarding 0-5 cards  
2.  Loop through all 52c5 hands, score them based on their poker value, then place them in the appropriate arrays (each of discard 0 through discard 5)  
3.  Create the 134,459 non-duplicate starting hands possible (e.g., Ad Kh Tc 9c 3d is the same as As Kh Td 9d 3s), and assign it a weighting based on how much duplication it covers  
4.  Lookup each of the 134,459 hands and score the discard 0 (hold 5) option  
5.  Lookup every possible discard 1 (hold 4) option, find the EV in the discard 1 array and then subtract the outcome in the discard 0 array (cannot get back the same hand)  
6.  Lookup every possible discard 2 (hold 3) option, find the EV in the discard 2 array and then subtract the outcomes in the discard 1 array and then add back the outcome in the discard 0 array (double-subtracted)  
7.  Lookup every possible discard 3 (hold 2) option, find the EV in the discard 3 array and then subtract the outcomes in the discard 2 array and then add back the outcomes in the discard 1 array and then subtract out the outcome in the discard 0 array (typical set theory add/subtract)  
8.  Lookup every possible discard 4 (hold 1) option, find the EV in the discard 4 array and then subtract the outcomes in the discard 3 array and then add back the outcomes in the discard 2 array and then subtract out the outcome in the discard 1 array and then add back the outcome in the discard 0 array (typical set theory add/subtract)  
9.  Lookup every possible discard 5 (hold 0) option, find the EV in the discard 5 array and then subtract the outcomes in the discard 4 array and then add back the outcomes in the discard 3 array and then subtract out the outcome in the discard 2 array and then add back the outcome in the discard 1 array and then subtract out the outcome of the discard 0 array (typical set theory add/subtract)  
10.  Calculate the EV of every possible decision, and assign the appropriate weightings  
11.  Determine overall return, or other statistics of interest about the game  
  

### Step 1:  Initialize Arrays  
First, the relevant arrays for discard 0 (array0) through discard 5 (array5) are created.  A baseline assumption is made that there are only 16 possible final scores for the hand, and these are declared for the game of interest:  
```{r}


library(tidyr)
library(dplyr)
library(ggplot2)


# Declare overall game variables
nScores <- 10  # Standard JB Outcomes
scoreVector <- c(-1L,  0L,  1L,  2L,   3L,  
                  5L,  8L, 24L, 49L, 799L
                 )  # Standard JB outcomes, sorted low to high


# Create the relevant arrays
array0 <- matrix(data=0L, nrow=choose(52, 5), ncol=nScores)
array1 <- matrix(data=0L, nrow=choose(52, 4), ncol=nScores)
array2 <- matrix(data=0L, nrow=choose(52, 3), ncol=nScores)
array3 <- matrix(data=0L, nrow=choose(52, 2), ncol=nScores)
array4 <- matrix(data=0L, nrow=choose(52, 1), ncol=nScores)
array5 <- matrix(data=0L, nrow=choose(52, 0), ncol=nScores)

```
  
### Step 2:  Create/Score Hands, Create Indexing, and Place Scores in Appropriate Arrays  
#### Step 2a:  Create/Score Hands  
First, the 52c5 possible hands are created and scored.  For this coding, the standard 9-6 Jacks or Better pay table is used, subtracting off the coin that was bet (e.g., "win 1" is really a break-even):  
```{r}

startTime <- proc.time()


# Create the 52c5 hands
aHands <- t(combn(1:52, 5))
str(aHands)


proc.time() - startTime


# Find the ranks and suits
aRanks <- 1 + (aHands-1) %% 13
aSuits <- (aHands-1) %/% 13
    

# Find the flushes
aFlush <- aSuits[, 1] == aSuits[, 5]


# Find the straights
strMatrix <- matrix(data=0L, nrow=13, ncol=10)
strMatrix[c(1, 10, 11, 12, 13), 1] <- 1L
for (intCtr in 1:9) { strMatrix[intCtr:(intCtr+4), intCtr+1] <- 1L }

aRankCount <- matrix(data=-1L, nrow=choose(52, 5), ncol=13)
for (intCtr in 1:13) { aRankCount[, intCtr] <- rowSums(aRanks == intCtr) }


# Find max and count of ranks (sufficient to determine quds, full houses, trips, two pair, and pair)
aQuads <- rowSums(aRankCount == 4)
aTrips <- rowSums(aRankCount == 3)
aPairs <- rowSums(aRankCount == 2)
aHiPair <- rowSums(aRankCount[, c(1, 11, 12, 13)] == 2)
aStraight <- rowSums( ((aRankCount == 1) %*% strMatrix) == 5)

aType <- rep(-1L, choose(52, 5))


# Declare types
aType[aFlush == 1 & aStraight == 1 & aRankCount[, 1] == 1 & 
          aRankCount[, 13] == 1] <- 799  # Royal Flush
aType[aFlush == 1 & aStraight == 1 & 
          (aRankCount[, 1] == 0 | aRankCount[, 13] == 0)] <- 49  # Straight Flush
aType[aQuads == 1] <- 24  # Quads
aType[aTrips == 1 & aPairs == 1] <- 8  # Full House
aType[aFlush == 1 & aStraight == 0] <- 5  # Flush
aType[aFlush == 0 & aStraight == 1] <- 3  # Straight
aType[aTrips == 1 & aPairs == 0] <- 2  # Trips
aType[aPairs == 2] <- 1  # Two Pair
aType[aTrips == 0 & aPairs == 1 & aHiPair == 1] <- 0  # High Pair


proc.time() - startTime
```
  
The process takes ~10 seconds, but with the many interim files, it also consumes ~1.5 GB.  
  
#### Step 2b:  Create Indexing  
Next, a methodology is created to index any combination of held cards:  
```{r}

# Create a matrix to hold results for choose(n, k)
mtxCombin <- matrix(data=0L, nrow=52, ncol=5)
for (intCtr in 1:52) {
    for (intCtr2 in 1:5) {
        # Note that choose() is a guarded function where choose(n, k) returns 0 for k > n
        mtxCombin[intCtr, intCtr2] <- choose(intCtr, intCtr2)
    }
}


idxCard1 <- function(c1) {
    # Just return yourself
    c1
}

idxCard2 <- function(c1, c2) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    1 + mtxCombin[52, 2] - mtxCombin[53-c1, 2] +
        mtxCombin[52-c1, 1] - mtxCombin[53-c2, 1]
}

idxCard3 <- function(c1, c2, c3) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    1 + mtxCombin[52, 3] - mtxCombin[53-c1, 3] +
        mtxCombin[52-c1, 2] - mtxCombin[53-c2, 2] +
        mtxCombin[52-c2, 1] - mtxCombin[53-c3, 1]
}

idxCard4 <- function(c1, c2, c3, c4) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    1 + mtxCombin[52, 4] - mtxCombin[53-c1, 4] +
        mtxCombin[52-c1, 3] - mtxCombin[53-c2, 3] +
        mtxCombin[52-c2, 2] - mtxCombin[53-c3, 2] + 
        mtxCombin[52-c3, 1] - mtxCombin[53-c4, 1]
}

idxCard5 <- function(c1, c2, c3, c4, c5) {
    # Need to convert the C++ algorithm which is 0:51 to R which wants 1:52
    1 + mtxCombin[52, 5] - mtxCombin[53-c1, 5] +
        mtxCombin[52-c1, 4] - mtxCombin[53-c2, 4] +
        mtxCombin[52-c2, 3] - mtxCombin[53-c3, 3] + 
        mtxCombin[52-c3, 2] - mtxCombin[53-c4, 2] +
        mtxCombin[52-c4, 1] - mtxCombin[53-c5, 1]
}

```
  
This allows any combination of 1-5 cards to be converted to a relevant index.  This will be useful for several further components of the program.  
  
#### Step 2c:  Place Scores in Appropriate Arrays  
```{r}

# Create array5, which is discarding everything
b <- data.frame(idx=1, val=match(aType, scoreVector)) %>% 
    group_by(idx, val) %>% 
    summarize(ct=n()) %>%
    spread(val, ct, fill=0)
    
all.equal( as.integer(colnames(b[, -1])) , 1:nScores )
nrow(b) == nrow(array5)

array5 <- t(as.matrix(as.integer(b[, -1])))


# Create array4, which is discarding four and keeping one
idx <- integer(0)
for (intCtr in 1:5) { idx <- c(idx, idxCard1(c1=aHands[, intCtr])) }
b <- data.frame(idx=idx, val=rep(match(aType, scoreVector), 5)) %>% 
    group_by(idx, val) %>% 
    summarize(ct=n()) %>%
    spread(val, ct, fill=0)
    
all.equal( unique(as.integer(colnames(b[, -1]))) , 1:nScores )
nrow(b) == nrow(array4)

array4 <- as.matrix(b[, -1])


# Create array3, which is discarding three and keeping two
idx <- integer(0)
for (intCtr in 1:4) { 
    for (intCtr2 in (intCtr+1):5) { 
        idx <- c(idx, idxCard2(c1=aHands[, intCtr], c2=aHands[, intCtr2])) 
    }
}
b <- data.frame(idx=idx, val=rep(match(aType, scoreVector), 10)) %>% 
    group_by(idx, val) %>% 
    summarize(ct=n()) %>%
    spread(val, ct, fill=0)
    
all.equal( unique(as.integer(colnames(b[, -1]))) , 1:nScores )
nrow(b) == nrow(array3)

array3 <- as.matrix(b[, -1])


# Create array2, which is discarding two and keeping three
idx <- integer(0)
for (intCtr in 1:3) { 
    for (intCtr2 in (intCtr+1):4) {
        for (intCtr3 in (intCtr2+1):5) {
            idx <- c(idx, idxCard3(c1=aHands[, intCtr], c2=aHands[, intCtr2], 
                                   c3=aHands[, intCtr3]
                                   )
                     )
        }
    }
}
b <- data.frame(idx=idx, val=rep(match(aType, scoreVector), 10)) %>% 
    group_by(idx, val) %>% 
    summarize(ct=n()) %>%
    spread(val, ct, fill=0)
    
all.equal( unique(as.integer(colnames(b[, -1]))) , 1:nScores )
nrow(b) == nrow(array2)

array2 <- as.matrix(b[, -1])


# Create array1, which is discarding one and keeping four
idx <- integer(0)
for (intCtr in 1:2) { 
    for (intCtr2 in (intCtr+1):3) {
        for (intCtr3 in (intCtr2+1):4) {
            for (intCtr4 in (intCtr3+1):5) {
                idx <- c(idx, idxCard4(c1=aHands[, intCtr], c2=aHands[, intCtr2], 
                                       c3=aHands[, intCtr3], c4=aHands[, intCtr4]
                                       )
                         )
            }
        }
    }
}
b <- data.frame(idx=idx, val=rep(match(aType, scoreVector), 5)) %>% 
    group_by(idx, val) %>% 
    summarize(ct=n()) %>%
    spread(val, ct, fill=0)
    
all.equal( unique(as.integer(colnames(b[, -1]))) , 1:nScores )
nrow(b) == nrow(array1)

array1 <- as.matrix(b[, -1])


# Create array0, which is discarding zero and keeping five
idx <- idxCard5(c1=aHands[, 1], c2=aHands[, 2], 
                c3=aHands[, 3], c4=aHands[, 4],
                c5=aHands[, 5]
                )
            
b <- data.frame(idx=idx, val=rep(match(aType, scoreVector), 1)) %>% 
    group_by(idx, val) %>% 
    summarize(ct=n()) %>%
    spread(val, ct, fill=0)
    
all.equal( unique(as.integer(colnames(b[, -1]))) , 1:nScores )
nrow(b) == nrow(array0)

array0 <- as.matrix(b[, -1])

```
  
Next, each of the arrays is double-checked for proper row sums, then converted to an expected value:  
```{r}
foo <- function(x, y) { z <- rowSums(x); c(mean(z), choose(47+y, y), length(z), max(z) == min(z)) }
foo(array0, 0)
foo(array1, 1)
foo(array2, 2)
foo(array3, 3)
foo(array4, 4)
foo(array5, 5)

ev0 <- array0 %*% as.matrix(scoreVector)
ev1 <- array1 %*% as.matrix(scoreVector) / choose(48, 1)
ev2 <- array2 %*% as.matrix(scoreVector) / choose(49, 2)
ev3 <- array3 %*% as.matrix(scoreVector) / choose(50, 3)
ev4 <- array4 %*% as.matrix(scoreVector) / choose(51, 4)
ev5 <- array5 %*% as.matrix(scoreVector) / choose(52, 5)

summary(ev0)
summary(ev1)
summary(ev2)
summary(ev3)
summary(ev4)
summary(ev5)

```
  
Encouragingly, the mean EV is the same everywhere.  The max/min gain variance as the number of cards kept increases, meaning there is opportunity to raise the overall EV by picking the best hold of 0-5 cards.
  
### Step 3:  Create/Weight non-duplicate hands  
The next step is to create the 134,459 non-duplicate starting hands possible (e.g., Ad Kh Tc 9c 3d is the same as As Kh Td 9d 3s), and assign each a weighting based on how much duplication it covers.  
  
This is adapted heavily from clever thinking at <http://wizardofodds.com/games/video-poker/methodology/>, using in order:  
  
* Four of a Kind (all that matters is what is the rank of the quad/kicker)  
* Full House (need to know ranks for A full of B, as well as whether B contains the fourth suit or not)  
* Trips (singletons can be all of fourth suit, one match and one fourth suit, no fourth suit/same, or no fourth suit/different)  
* Two Pair (suits matter for how much is in common between the two pairs, as well as the singleton)  
* Pair (many combinations for suits of the singletons)  
* Nothing (suits matter a great deal!)  
  
```{r}
# Quads are simple - there are 13 possible quads and 12 possible kickers
# Each hand can be captured once with a weight of 4 since the kicker will always match one suit
quadSmall <- matrix(data=0L, nrow=13*12, ncol=5)
quadWeight <- rep(4L, times=13*12)
curIdx <- 1

for (intCtr in 1:13) {
    for (intCtr2 in (1:13)[-intCtr]) {
        quadSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr+39, intCtr2))
        curIdx <- curIdx + 1
    }
}


# Full Houses are not too much more complex, though there are two suit pairing options for each
fhSmall <- matrix(data=0L, nrow=13*12*2, ncol=5)
fhWeight <- rep(12L, times=13*12*2)
curIdx <- 1

for (intCtr in 1:13) {
    for (intCtr2 in (1:13)[-intCtr]) {
        # First option has both pairs matching the suits of the trips
        fhSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr2+13))
        # Second option has one pair not matching the suits of the trips
        fhSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr2+39))
        curIdx <- curIdx + 2
    }
}


# Trips become a touch more complicated
# There is weight 24 for both singletons match different trips suits
# There is weight 12 for one singleton matches and the other does not
# There is weight 12 for both singletons match the same trips suit
# There is weight 4 for both singletons match each other but not any of the trips suits
tripSmall <- matrix(data=0L, nrow=13*choose(12, 2)*5, ncol=5)
tripWeight <- rep(c(24, 12, 12, 12, 4), times=13*choose(12,2))
curIdx <- 1

for (intCtr in 1:13) {
    intAvail <- (1:13)[-intCtr]
    for (intCtr2 in intAvail[-length(intAvail)]) {
        for (intCtr3 in intAvail[intAvail > intCtr2]) {
            # First option has both singletons matching a different trips suit
            tripSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr3+13))
            # Second option has singleton one matching a trips suit and singleton two not
            tripSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr3+39))
            # Third option has singleton two matching a trips suit and singleton one not
            tripSmall[curIdx+2, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2+39, intCtr3))
            # Fourth option has both singletons matching the same trips suit
            tripSmall[curIdx+3, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2, intCtr3))
            # Fifth option has both singletons failing to match a trips suit
            tripSmall[curIdx+4, ] <- sort(c(intCtr, intCtr+13, intCtr+26, intCtr2+39, intCtr3+39))
            # Increment the index by 5
            curIdx <- curIdx + 5
        }
    }
}


# Two Pair becomes even more complicated
# There is weight 12 for four suits across the two pair -- singleton matches pair #1 or pair #2
# There is weight 24 for each of one suit match across the two pair; singleton can be four suits
# There is weight 12 for the two pair having identical suits; once for the singleton matching, once for not
twoSmall <- matrix(data=0L, nrow=choose(13, 2)*11*8, ncol=5)
twoWeight <- rep(c(12, 12, 24, 24, 24, 24, 12, 12), times=choose(13, 2)*11)
curIdx <- 1

for (intCtr in 1:12) {
    for (intCtr2 in (intCtr+1):13) {
        for (intCtr3 in (1:13)[-c(intCtr, intCtr2)]) {
            
            # First option has all two pair cards being different suits
            twoSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr2+39, intCtr3))
            twoSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr2+39, intCtr3+26))
            
            # Second option has one matched suits in the two pair
            twoSmall[curIdx+2, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3))
            twoSmall[curIdx+3, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3+13))
            twoSmall[curIdx+4, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3+26))
            twoSmall[curIdx+5, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+26, intCtr3+39))
            
            # Third option has fully matched suits across the two pair
            twoSmall[curIdx+6, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+13, intCtr3))
            twoSmall[curIdx+7, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr2+13, intCtr3+26))
            
            # Increment the index by 8
            curIdx <- curIdx + 8
        }
    }
}


# One Pair becomes even more complicated
# The pair is (obviously) two-suited; consider them to be 1 and 2; the game is in the singletons
# Weight 12 (2): Singletons all same suit, once matching to a pair suit, and once not
# Weight 12 (3): Singletons are suited 2-1, all matching to the pairs - 112, 121, 211
# Weight 24 (3): Singletons are suited 2-1, two matching to the pairs - 113, 131, 311
# Weight 24 (3): Singletons are suited 2-1, one matching to the pairs - 133, 313, 331 
# Weight 12 (3): Singletons are suited 2-1, none matching to the pairs - 344, 434, 443
# Weight 24 (3): Singletons are suited 1-1-1, two matching to the pairs - 123, 132, 312
# Weight 24 (3): Singletons are suited 1-1-1, one matching to the pairs - 134, 314, 341
pairSmall <- matrix(data=0L, nrow=13*choose(12, 3)*20, ncol=5)
pairWeight <- rep(c(12, 12, 12, 12, 12, 24, 24, 24, 24, 24, 24, 
                    12, 12, 12, 24, 24, 24, 24, 24, 24), 
                  times=13*choose(12, 3)
                  )
curIdx <- 1

for (intCtr in 1:13) {
    intAvail <- (1:13)[-intCtr]
    for (intCtr2 in intAvail[-c(11, 12)]) {
        nextAvail <- (intCtr2+1):13
        nextAvail <- nextAvail[!(nextAvail %in% c(intCtr))]
        for (intCtr3 in nextAvail[-length(nextAvail)]) {
            lastAvail <- (intCtr3+1):13
            lastAvail <- lastAvail[!(lastAvail %in% c(intCtr))]
            for (intCtr4 in lastAvail) {
                # Weight 12 (2): Singletons all same suit, once matching to a pair suit, and once not
                pairSmall[curIdx, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3, intCtr4))
                pairSmall[curIdx+1, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+26, intCtr4+26))
            
                # Weight 12 (3): Singletons are suited 2-1, all matching to the pairs - 112, 121, 211
                pairSmall[curIdx+2, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3, intCtr4+13))
                pairSmall[curIdx+3, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+13, intCtr4))
                pairSmall[curIdx+4, ] <- sort(c(intCtr, intCtr+13, intCtr2+13, intCtr3, intCtr4))
                
                # Weight 24 (3): Singletons are suited 2-1, two matching to the pairs - 113, 131, 311
                pairSmall[curIdx+5, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3, intCtr4+26))
                pairSmall[curIdx+6, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4))
                pairSmall[curIdx+7, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4))
                
                # Weight 24 (3): Singletons are suited 2-1, one matching to the pairs - 133, 313, 331 
                pairSmall[curIdx+8, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4+26))
                pairSmall[curIdx+9, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4+26))
                pairSmall[curIdx+10, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+26, intCtr4))
                
                # Weight 12 (3): Singletons are suited 2-1, none matching to the pairs - 344, 434, 443
                pairSmall[curIdx+11, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+39, intCtr4+39))
                pairSmall[curIdx+12, ] <- sort(c(intCtr, intCtr+13, intCtr2+39, intCtr3+26, intCtr4+39))
                pairSmall[curIdx+13, ] <- sort(c(intCtr, intCtr+13, intCtr2+39, intCtr3+39, intCtr4+26))
                
                # Weight 24 (3): Singletons are suited 1-1-1, two matching to the pairs - 123, 132, 312
                pairSmall[curIdx+14, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+13, intCtr4+26))
                pairSmall[curIdx+15, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4+13))
                pairSmall[curIdx+16, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4+13))
                
                # Weight 24 (3): Singletons are suited 1-1-1, one matching to the pairs - 134, 314, 341
                pairSmall[curIdx+17, ] <- sort(c(intCtr, intCtr+13, intCtr2, intCtr3+26, intCtr4+39))
                pairSmall[curIdx+18, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3, intCtr4+39))
                pairSmall[curIdx+19, ] <- sort(c(intCtr, intCtr+13, intCtr2+26, intCtr3+39, intCtr4))

                # Increment the index by 20
                curIdx <- curIdx + 20
            }
        }
    }
}


# No Pair becomes even more complicated
# The entire game is in the suits for the singletons
# Weight 4 (1): Singletons all same suit - 11111
# Weight 12 (5): Singletons are suited 4-1 - 11112, 11121, 11211, 12111, 21111
# Weight 12 (10): Singletons are suited 3-2 - 11122, 11212, 11221, 12112, 12121, 
#                                             12211, 21112, 21121, 21211, 22111
# Weight 24 (10): Singletons are suited 3-1-1 - 11123, 11213, 11231, 12113, 12131,
#                                               12311, 21113, 21131, 21311, 23111
# Weight 24 (15): Singletons are suited 2-2-1 - 11223, 12123, 12213, 11232, 12132, 
#                                               12231, 11322, 12312, 12321, 13122, 
#                                               13212, 13221, 31122, 31212, 31221
# Weight 24 (10): Singletons are suited 2-1-1-1 - 11234, 12134, 12314, 12341, 21134, 
#                                                 21314, 21341, 23114, 23141, 23411
noneSmall <- matrix(data=0L, nrow=choose(13, 5)*51, ncol=5)
noneWeight <- rep(c(4, 12, 12, 12, 12, 12, 
                    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 
                    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
                    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
                    24, 24, 24, 24, 24, 24, 24, 24, 24, 24
                    ), times=choose(13, 5)
                  )

mtxAdd <- matrix(data=c(0, 0, 0, 0, 0, 
                        0, 0, 0, 0, 1,
                        0, 0, 0, 1, 0, 
                        0, 0, 1, 0, 0, 
                        0, 1, 0, 0, 0, 
                        1, 0, 0, 0, 0, 
                        0, 0, 0, 1, 1,
                        0, 0, 1, 0, 1,
                        0, 1, 0, 0, 1,
                        1, 0, 0, 0, 1,
                        0, 0, 1, 1, 0,
                        0, 1, 0, 1, 0,
                        1, 0, 0, 1, 0,
                        0, 1, 1, 0, 0,
                        1, 0, 1, 0, 0,
                        1, 1, 0, 0, 0,
                        0, 0, 0, 1, 2,
                        0, 0, 1, 0, 2,
                        0, 1, 0, 0, 2,
                        1, 0, 0, 0, 2,
                        0, 0, 1, 2, 0,
                        0, 1, 0, 2, 0,
                        1, 0, 0, 2, 0,
                        0, 1, 2, 0, 0,
                        1, 0, 2, 0, 0,
                        1, 2, 0, 0, 0,
                        0, 0, 1, 1, 2,
                        0, 1, 0, 1, 2,
                        1, 0, 0, 1, 2,
                        0, 0, 1, 2, 1,
                        0, 1, 0, 2, 1,
                        1, 0, 0, 2, 1,
                        0, 0, 2, 1, 1,
                        0, 1, 2, 0, 1,
                        1, 0, 2, 0, 1,
                        0, 2, 0, 1, 1,
                        0, 2, 1, 0, 1,
                        1, 2, 0, 0, 1,
                        2, 0, 0, 1, 1,
                        2, 0, 1, 0, 1,
                        2, 1, 0, 0, 1,
                        0, 0, 1, 2, 3,
                        0, 1, 0, 2, 3,
                        0, 1, 2, 0, 3,
                        0, 1, 2, 3, 0,
                        1, 0, 0, 2, 3,
                        1, 0, 2, 0, 3,
                        1, 0, 2, 3, 0,
                        1, 2, 0, 0, 3,
                        1, 2, 0, 3, 0,
                        1, 2, 3, 0, 0
                        ) * 13, ncol=5, byrow=TRUE)

curIdx <- 1

for (intCtr in 1:9) {
    for (intCtr2 in (intCtr+1):10) {
        for (intCtr3 in (intCtr2+1):11) {
            for (intCtr4 in (intCtr3+1):12) {
                for (intCtr5 in (intCtr4+1):13) {
                    vecNone <- c(intCtr, intCtr2, intCtr3, intCtr4, intCtr5)
                    mtxNone <- matrix(data=rep(vecNone, times=51), ncol=5, byrow=TRUE)
                    # IMPORTANT - future classification relies on low-high sorting in each row
                    noneSmall[curIdx:(curIdx+50), ] <- 
                        t(apply(mtxNone + mtxAdd, 1, FUN=sort))
                    curIdx <- curIdx + 51
                }
            }
        }
    }
}

```
  
Next, the hands and weights are integrated to a single hand matrix and a single weighting vector:  
```{r}
jbSmall <- rbind(quadSmall, fhSmall, tripSmall, twoSmall, pairSmall, noneSmall)
jbWeight <- c(quadWeight, fhWeight, tripWeight, twoWeight, pairWeight, noneWeight)

str(jbSmall)
str(jbWeight)

# Confirm that there are sill 52c5 hands after weighting
all.equal(sum(jbWeight), choose(52, 5))

# Confirm that dimensions of hands and weight match up
all.equal(nrow(jbSmall), length(jbWeight))
all.equal(ncol(jbSmall), 5)

# Report the degree of space savings due to the weighting
summary(jbWeight)
```
  
The weighting allows for ~19x reduction in duplication which should speed up the processing time by roughly ~19x when using "no replacement" for drawing hands.  This is a strong improvement in efficiency.  
  
### Step 4:  Lookup the Hold 5 for these 134,459  
Each of the hands is scored for its hold 5 value:  
```{r}
idxSmall0 <- idxCard5(c1=jbSmall[, 1], c2=jbSmall[, 2], c3=jbSmall[, 3], 
                      c4=jbSmall[, 4], c5=jbSmall[, 5]
                      )

evSmall0 <- array0[idxSmall0, ] %*% as.matrix(scoreVector) / choose(47, 0)
summary(rep(evSmall0, jbWeight))

```
  
As expected, the average weighted EV of holding all 5 card is -66.3% as per above.  
  
### Step 5:  Lookup the Hold 4 for these 134,459  
Each of the hands is scored for each of its 5 "hold 4" value:  
```{r}
keyData <- numeric(0)
for (intCtr in 1:5) {
    idxLook <- (1:5)[-intCtr]
    idxSmall1 <- array1[idxCard4(c1=jbSmall[, idxLook[1]], c2=jbSmall[, idxLook[2]], 
                                 c3=jbSmall[, idxLook[3]], c4=jbSmall[, idxLook[4]]
                                 ), ] - array0[idxSmall0, ]
    keyData <- c(keyData, idxSmall1 %*% as.matrix(scoreVector) / choose(47, 1))
}

# Take the "draw 1" and subtract out the "draw 0" (cannot get those back)
evSmall1 <- matrix(data=keyData, ncol=5, byrow=FALSE)

summary(rep(evSmall1, rep(jbWeight, 5)))
```

As expected, the average weighted EV of holding 4 cards is -66.3% as per above.  
  
### Step 6:  Lookup the Hold 3 for these 134,459  
Each of the hands is scored for each of its 10 "hold 3" value:  
```{r}
keyData <- numeric(0)
for (intCtr in 1:4) {
    for (intCtr2 in (intCtr+1):5) {
        idxLook <- (1:5)[-c(intCtr, intCtr2)]
        
        sortA <- sort(c(idxLook, intCtr))
        sortB <- sort(c(idxLook, intCtr2))
        
        idxSmall2 <- array2[idxCard3(c1=jbSmall[, idxLook[1]], c2=jbSmall[, idxLook[2]], 
                                     c3=jbSmall[, idxLook[3]]), ] - 
            array1[idxCard4(c1=jbSmall[, sortA[1]], c2=jbSmall[, sortA[2]], 
                              c3=jbSmall[, sortA[3]], c4=jbSmall[, sortA[4]]), ] - 
            array1[idxCard4(c1=jbSmall[, sortB[1]], c2=jbSmall[, sortB[2]], 
                              c3=jbSmall[, sortB[3]], c4=jbSmall[, sortB[4]]), ] + 
            array0[idxSmall0, ]
        
        keyData <- c(keyData, idxSmall2 %*% as.matrix(scoreVector) / choose(47, 2))
    }
}

evSmall2 <- matrix(data=keyData, ncol=10, byrow=FALSE)

summary(rep(evSmall2, rep(jbWeight, 10)))
```
  
As expected, the average weighted EV of holding 3 cards is -66.3% as per above.  
  
### Step 7:  Lookup the Hold 2 for these 134,459  
Each of the hands is scored for each of its 10 "hold 2" values:  
```{r}
keyData <- numeric(0)
for (intCtr in 1:4) {
    for (intCtr2 in (intCtr+1):5) {
        idxLook <- (1:5)[-c(intCtr, intCtr2)]
        
        sortA <- sort(c(idxLook[1], intCtr, intCtr2))
        sortB <- sort(c(idxLook[2], intCtr, intCtr2))
        sortC <- sort(c(idxLook[3], intCtr, intCtr2))
        
        sortAB <- sort(c(idxLook[1], idxLook[2], intCtr, intCtr2))
        sortAC <- sort(c(idxLook[1], idxLook[3], intCtr, intCtr2))
        sortBC <- sort(c(idxLook[2], idxLook[3], intCtr, intCtr2))
        
        idxSmall3 <- array3[idxCard2(c1=jbSmall[, intCtr], c2=jbSmall[, intCtr2]), ] - 
            array2[idxCard3(c1=jbSmall[, sortA[1]], c2=jbSmall[, sortA[2]], 
                              c3=jbSmall[, sortA[3]]), ] - 
            array2[idxCard3(c1=jbSmall[, sortB[1]], c2=jbSmall[, sortB[2]], 
                              c3=jbSmall[, sortB[3]]), ] - 
            array2[idxCard3(c1=jbSmall[, sortC[1]], c2=jbSmall[, sortC[2]], 
                              c3=jbSmall[, sortC[3]]), ] + 
            array1[idxCard4(c1=jbSmall[, sortAB[1]], c2=jbSmall[, sortAB[2]], 
                              c3=jbSmall[, sortAB[3]], c4=jbSmall[, sortAB[4]]), ] + 
            array1[idxCard4(c1=jbSmall[, sortAC[1]], c2=jbSmall[, sortAC[2]], 
                              c3=jbSmall[, sortAC[3]], c4=jbSmall[, sortAC[4]]), ] + 
            array1[idxCard4(c1=jbSmall[, sortBC[1]], c2=jbSmall[, sortBC[2]], 
                              c3=jbSmall[, sortBC[3]], c4=jbSmall[, sortBC[4]]), ] - 
            array0[idxSmall0, ]
        
        keyData <- c(keyData, idxSmall3 %*% as.matrix(scoreVector) / choose(47, 3))
    }
}

evSmall3 <- matrix(data=keyData, ncol=10, byrow=FALSE)

summary(rep(evSmall3, rep(jbWeight, 10)))

```
  
As expected, the average weighted EV of holding 2 cards is -66.3% as per above.  
  
### Step 8:  Lookup the Hold 1 for these 134,459  
Each of the hands is scored for each of its 5 "hold 1" values:  
```{r}
keyData <- numeric(0)
for (intCtr in 1:5) {
    idxLook <- (1:5)[-c(intCtr)]
        
    sortA <- sort(c(idxLook[1], intCtr))
    sortB <- sort(c(idxLook[2], intCtr))
    sortC <- sort(c(idxLook[3], intCtr))
    sortD <- sort(c(idxLook[4], intCtr))
        
    sortAB <- sort(c(idxLook[1], idxLook[2], intCtr))
    sortAC <- sort(c(idxLook[1], idxLook[3], intCtr))
    sortAD <- sort(c(idxLook[1], idxLook[4], intCtr))
    sortBC <- sort(c(idxLook[2], idxLook[3], intCtr))
    sortBD <- sort(c(idxLook[2], idxLook[4], intCtr))
    sortCD <- sort(c(idxLook[3], idxLook[4], intCtr))
        
    sortABC <- sort(c(idxLook[1], idxLook[2], idxLook[3], intCtr))
    sortABD <- sort(c(idxLook[1], idxLook[2], idxLook[4], intCtr))
    sortACD <- sort(c(idxLook[1], idxLook[3], idxLook[4], intCtr))
    sortBCD <- sort(c(idxLook[2], idxLook[3], idxLook[4], intCtr))
        
    idxSmall4 <- array4[idxCard1(c1=jbSmall[, intCtr]), ] - 
        array3[idxCard2(c1=jbSmall[, sortA[1]], c2=jbSmall[, sortA[2]]), ] -
        array3[idxCard2(c1=jbSmall[, sortB[1]], c2=jbSmall[, sortB[2]]), ] - 
        array3[idxCard2(c1=jbSmall[, sortC[1]], c2=jbSmall[, sortC[2]]), ] - 
        array3[idxCard2(c1=jbSmall[, sortD[1]], c2=jbSmall[, sortD[2]]), ] + 
        array2[idxCard3(c1=jbSmall[, sortAB[1]], c2=jbSmall[, sortAB[2]], 
                          c3=jbSmall[, sortAB[3]]), ] +
        array2[idxCard3(c1=jbSmall[, sortAC[1]], c2=jbSmall[, sortAC[2]], 
                          c3=jbSmall[, sortAC[3]]), ] +
        array2[idxCard3(c1=jbSmall[, sortAD[1]], c2=jbSmall[, sortAD[2]], 
                          c3=jbSmall[, sortAD[3]]), ] +
        array2[idxCard3(c1=jbSmall[, sortBC[1]], c2=jbSmall[, sortBC[2]], 
                          c3=jbSmall[, sortBC[3]]), ] +
        array2[idxCard3(c1=jbSmall[, sortBD[1]], c2=jbSmall[, sortBD[2]], 
                          c3=jbSmall[, sortBD[3]]), ] +
        array2[idxCard3(c1=jbSmall[, sortCD[1]], c2=jbSmall[, sortCD[2]], 
                          c3=jbSmall[, sortCD[3]]), ] -
        array1[idxCard4(c1=jbSmall[, sortABC[1]], c2=jbSmall[, sortABC[2]], 
                          c3=jbSmall[, sortABC[3]], c4=jbSmall[, sortABC[4]]), ] - 
        array1[idxCard4(c1=jbSmall[, sortABD[1]], c2=jbSmall[, sortABD[2]], 
                          c3=jbSmall[, sortABD[3]], c4=jbSmall[, sortABD[4]]), ] - 
        array1[idxCard4(c1=jbSmall[, sortACD[1]], c2=jbSmall[, sortACD[2]], 
                          c3=jbSmall[, sortACD[3]], c4=jbSmall[, sortACD[4]]), ] - 
        array1[idxCard4(c1=jbSmall[, sortBCD[1]], c2=jbSmall[, sortBCD[2]], 
                          c3=jbSmall[, sortBCD[3]], c4=jbSmall[, sortBCD[4]]), ] + 
        array0[idxSmall0, ]
        
    keyData <- c(keyData, idxSmall4 %*% as.matrix(scoreVector) / choose(47, 4))
}

evSmall4 <- matrix(data=keyData, ncol=5, byrow=FALSE)

summary(rep(evSmall4, rep(jbWeight, 5)))

```
  
As expected, the average weighted EV of holding 1 cards is -66.3% as per above.  
  
### Step 9:  Lookup the Hold 0 for these 134,459  
Each of the hands is scored for its "hold 0" values:  
```{r}
keyData <- numeric(0)

idxLook <- (1:5)
        
sortA <- sort(c(idxLook[1]))
sortB <- sort(c(idxLook[2]))
sortC <- sort(c(idxLook[3]))
sortD <- sort(c(idxLook[4]))
sortE <- sort(c(idxLook[5]))
        
sortAB <- sort(c(idxLook[1], idxLook[2]))
sortAC <- sort(c(idxLook[1], idxLook[3]))
sortAD <- sort(c(idxLook[1], idxLook[4]))
sortAE <- sort(c(idxLook[1], idxLook[5]))
sortBC <- sort(c(idxLook[2], idxLook[3]))
sortBD <- sort(c(idxLook[2], idxLook[4]))
sortBE <- sort(c(idxLook[2], idxLook[5]))
sortCD <- sort(c(idxLook[3], idxLook[4]))
sortCE <- sort(c(idxLook[3], idxLook[5]))
sortDE <- sort(c(idxLook[4], idxLook[5]))
        
sortABC <- sort(c(idxLook[1], idxLook[2], idxLook[3]))
sortABD <- sort(c(idxLook[1], idxLook[2], idxLook[4]))
sortABE <- sort(c(idxLook[1], idxLook[2], idxLook[5]))
sortACD <- sort(c(idxLook[1], idxLook[3], idxLook[4]))
sortACE <- sort(c(idxLook[1], idxLook[3], idxLook[5]))
sortADE <- sort(c(idxLook[1], idxLook[4], idxLook[5]))
sortBCD <- sort(c(idxLook[2], idxLook[3], idxLook[4]))
sortBCE <- sort(c(idxLook[2], idxLook[3], idxLook[5]))
sortBDE <- sort(c(idxLook[2], idxLook[4], idxLook[5]))
sortCDE <- sort(c(idxLook[3], idxLook[4], idxLook[5]))

sortABCD <- sort(c(idxLook[1], idxLook[2], idxLook[3], idxLook[4]))
sortABCE <- sort(c(idxLook[1], idxLook[2], idxLook[3], idxLook[5]))
sortABDE <- sort(c(idxLook[1], idxLook[2], idxLook[4], idxLook[5]))
sortACDE <- sort(c(idxLook[1], idxLook[3], idxLook[4], idxLook[5]))
sortBCDE <- sort(c(idxLook[2], idxLook[3], idxLook[4], idxLook[5]))

idxSmall5 <- array5[rep(1, nrow(jbSmall)), , drop=FALSE] - 
    array4[idxCard1(c1=jbSmall[, sortA]), ] -
    array4[idxCard1(c1=jbSmall[, sortB]), ] -
    array4[idxCard1(c1=jbSmall[, sortC]), ] -
    array4[idxCard1(c1=jbSmall[, sortD]), ] -
    array4[idxCard1(c1=jbSmall[, sortE]), ] +
    array3[idxCard2(c1=jbSmall[, sortAB[1]], c2=jbSmall[, sortAB[2]]), ] +
    array3[idxCard2(c1=jbSmall[, sortAC[1]], c2=jbSmall[, sortAC[2]]), ] +
    array3[idxCard2(c1=jbSmall[, sortAD[1]], c2=jbSmall[, sortAD[2]]), ] +
    array3[idxCard2(c1=jbSmall[, sortAE[1]], c2=jbSmall[, sortAE[2]]), ] +
    array3[idxCard2(c1=jbSmall[, sortBC[1]], c2=jbSmall[, sortBC[2]]), ] +
    array3[idxCard2(c1=jbSmall[, sortBD[1]], c2=jbSmall[, sortBD[2]]), ] +
    array3[idxCard2(c1=jbSmall[, sortBE[1]], c2=jbSmall[, sortBE[2]]), ] +
    array3[idxCard2(c1=jbSmall[, sortCD[1]], c2=jbSmall[, sortCD[2]]), ] +
    array3[idxCard2(c1=jbSmall[, sortCE[1]], c2=jbSmall[, sortCE[2]]), ] +
    array3[idxCard2(c1=jbSmall[, sortDE[1]], c2=jbSmall[, sortDE[2]]), ] -
    array2[idxCard3(c1=jbSmall[, sortABC[1]], c2=jbSmall[, sortABC[2]], 
                    c3=jbSmall[, sortABC[3]]), ] -
    array2[idxCard3(c1=jbSmall[, sortABD[1]], c2=jbSmall[, sortABD[2]], 
                    c3=jbSmall[, sortABD[3]]), ] -
    array2[idxCard3(c1=jbSmall[, sortABE[1]], c2=jbSmall[, sortABE[2]], 
                    c3=jbSmall[, sortABE[3]]), ] -
    array2[idxCard3(c1=jbSmall[, sortACD[1]], c2=jbSmall[, sortACD[2]], 
                    c3=jbSmall[, sortACD[3]]), ] -
    array2[idxCard3(c1=jbSmall[, sortACE[1]], c2=jbSmall[, sortACE[2]], 
                    c3=jbSmall[, sortACE[3]]), ] -
    array2[idxCard3(c1=jbSmall[, sortADE[1]], c2=jbSmall[, sortADE[2]], 
                    c3=jbSmall[, sortADE[3]]), ] -
    array2[idxCard3(c1=jbSmall[, sortBCD[1]], c2=jbSmall[, sortBCD[2]], 
                    c3=jbSmall[, sortBCD[3]]), ] -
    array2[idxCard3(c1=jbSmall[, sortBCE[1]], c2=jbSmall[, sortBCE[2]], 
                    c3=jbSmall[, sortBCE[3]]), ] -
    array2[idxCard3(c1=jbSmall[, sortBDE[1]], c2=jbSmall[, sortBDE[2]], 
                    c3=jbSmall[, sortBDE[3]]), ] -
    array2[idxCard3(c1=jbSmall[, sortCDE[1]], c2=jbSmall[, sortCDE[2]], 
                    c3=jbSmall[, sortCDE[3]]), ] +
    array1[idxCard4(c1=jbSmall[, sortABCD[1]], c2=jbSmall[, sortABCD[2]], 
                    c3=jbSmall[, sortABCD[3]], c4=jbSmall[, sortABCD[4]]), ] +
    array1[idxCard4(c1=jbSmall[, sortABCE[1]], c2=jbSmall[, sortABCE[2]], 
                    c3=jbSmall[, sortABCE[3]], c4=jbSmall[, sortABCE[4]]), ] +
    array1[idxCard4(c1=jbSmall[, sortABDE[1]], c2=jbSmall[, sortABDE[2]], 
                    c3=jbSmall[, sortABDE[3]], c4=jbSmall[, sortABDE[4]]), ] +
    array1[idxCard4(c1=jbSmall[, sortACDE[1]], c2=jbSmall[, sortACDE[2]], 
                    c3=jbSmall[, sortACDE[3]], c4=jbSmall[, sortACDE[4]]), ] +
    array1[idxCard4(c1=jbSmall[, sortBCDE[1]], c2=jbSmall[, sortBCDE[2]], 
                    c3=jbSmall[, sortBCDE[3]], c4=jbSmall[, sortBCDE[4]]), ] -
    array0[idxSmall0, ]
        
keyData <- c(keyData, idxSmall5 %*% as.matrix(scoreVector) / choose(47, 5))
    
evSmall5 <- matrix(data=keyData, ncol=1, byrow=FALSE)

summary(rep(evSmall5, rep(jbWeight, 1)))

```
  
As expected, the average weighted EV of holding 0 cards is -66.3% as per above.  
  
### Step 10:  Calculate EV, Optimal Decision, and Weighting  
Each of the hands is scored for each of its possible holds, with the best EV hold and type saved:  
```{r}
evAll <- cbind(evSmall0, evSmall1, evSmall2, evSmall3, evSmall4, evSmall5)
evKey <- apply(evAll, 1, FUN=function(x){ c(which.max(x), max(x)) } )
```
  
### Step 11:  Describe Overall Game EV and Statistics  
With the game holds and EV calculated, we can now calculate the overall game EV
```{r}
# Overall Game EV
summary(rep(evKey[2, , drop=FALSE], jbWeight))
1 + mean(rep(evKey[2, , drop=FALSE], jbWeight))

# Best draws (keep all is on left)
hist(rep(evKey[1, , drop=FALSE], jbWeight), 
     breaks=0:33, 
     col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
            rep("lightgreen", 10), rep("red", 5), rep("black", 1) 
           ) 
     )

# By type of draw (keep all is on left, value 1)
newCutIdx <- cut(rep(evKey[1, ,drop=FALSE], jbWeight), 
                 breaks=c(0.5, 1.5, 6.5, 16.5, 26.5, 31.5, 32.5)
                 )
data.frame(newType=newCutIdx) %>% 
    group_by(newType) %>% summarize(ct=n())

```
  
Good news, the overall game EV matches the theoretical 99.54%, while the counts of holds by number of cards also matches to the theory.
  
Further, histograms and EV are examined by starting hand type being RF/SF/Quad/FH:  
```{r}
# Overall Game EV - dealt RF/SF/Quads/FH
summary(rep(evKey[2, , drop=FALSE][evSmall0 %in% c(8, 24, 49, 799)], 
            jbWeight[evSmall0 %in% c(8, 24, 49, 799)]
            )
        )
1 + mean(rep(evKey[2, , drop=FALSE][evSmall0 %in% c(8, 24, 49, 799)], 
            jbWeight[evSmall0 %in% c(8, 24, 49, 799)]
            )
        )

# Best draws (keep all is on left)
hist(rep(evKey[1, , drop=FALSE][evSmall0 %in% c(8, 24, 49, 799)], 
         jbWeight[evSmall0 %in% c(8, 24, 49, 799)]
         ), 
     breaks=0:33, 
     col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
            rep("lightgreen", 10), rep("red", 5), rep("black", 1) 
           ),
     main="Dealt Royal, Straight Flush, Quad, or Full House", 
     xlab="Index for Hold (1=all, 32=none)"
     )

data.frame(idx=rep(evKey[1, , drop=FALSE][evSmall0 %in% c(8, 24, 49, 799)], 
                   jbWeight[evSmall0 %in% c(8, 24, 49, 799)]
                   )
           ) %>% group_by(idx) %>% summarize(ct=n())
```
  
Further, histograms and EV are examined by starting hand type being Flush/Straight:  
```{r}
# Overall Game EV - dealt Flush/Straight
summary(rep(evKey[2, , drop=FALSE][evSmall0 %in% c(3, 5)], 
            jbWeight[evSmall0 %in% c(3, 5)]
            )
        )
1 + mean(rep(evKey[2, , drop=FALSE][evSmall0 %in% c(3, 5)], 
            jbWeight[evSmall0 %in% c(3, 5)]
            )
        )

# Best draws (keep all is on left)
hist(rep(evKey[1, , drop=FALSE][evSmall0 %in% c(3, 5)], 
         jbWeight[evSmall0 %in% c(3, 5)]
         ), 
     breaks=0:33, 
     col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
            rep("lightgreen", 10), rep("red", 5), rep("black", 1) 
           ),
     main="Dealt Flush or Straight", 
     xlab="Index for Hold (1=all, 32=none)"
     )

data.frame(idx=rep(evKey[1, , drop=FALSE][evSmall0 %in% c(3, 5)], 
                   jbWeight[evSmall0 %in% c(3, 5)]
                   )
           ) %>% group_by(idx) %>% summarize(ct=n())
```
  
So, while you always keep the dealt Royal, Straight Flush, Quads, and Full House, there are a handful of occasions where you pitch one card from the dealt straight or dealt flush to chase a better hand.

Further, histograms and EV are examined by starting hand type being Trips/Two Pair:  
```{r}
# Overall Game EV - dealt Trips/Two Pair
summary(rep(evKey[2, , drop=FALSE][evSmall0 %in% c(1, 2)], 
            jbWeight[evSmall0 %in% c(1, 2)]
            )
        )
1 + mean(rep(evKey[2, , drop=FALSE][evSmall0 %in% c(1, 2)], 
            jbWeight[evSmall0 %in% c(1, 2)]
            )
        )

# Best draws (keep all is on left)
hist(rep(evKey[1, , drop=FALSE][evSmall0 %in% c(1, 2)], 
         jbWeight[evSmall0 %in% c(1, 2)]
         ), 
     breaks=0:33, 
     col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
            rep("lightgreen", 10), rep("red", 5), rep("black", 1) 
           ),
     main="Dealt Trips or Two Pair", 
     xlab="Index for Hold (1=all, 32=none)"
     )

data.frame(idx=rep(evKey[1, , drop=FALSE][evSmall0 %in% c(1, 2)], 
                   jbWeight[evSmall0 %in% c(1, 2)]
                   ),
           typ=rep(evSmall0[evSmall0 %in% c(1, 2)], 
                   jbWeight[evSmall0 %in% c(1, 2)]
                   )
           ) %>% group_by(typ, idx) %>% summarize(ct=n())
```
  
So, you always keep dealt Trips (draw 2) and always keep a dealt Two Pair (draw 1).  
  
Further, histograms and EV are examined by starting hand type being a Paying Pair:  
```{r}
# Overall Game EV - dealt Paying Pair
summary(rep(evKey[2, , drop=FALSE][evSmall0 %in% c(0)], 
            jbWeight[evSmall0 %in% c(0)]
            )
        )
1 + mean(rep(evKey[2, , drop=FALSE][evSmall0 %in% c(0)], 
            jbWeight[evSmall0 %in% c(0)]
            )
        )

# Best draws (keep all is on left)
hist(rep(evKey[1, , drop=FALSE][evSmall0 %in% c(0)], 
         jbWeight[evSmall0 %in% c(0)]
         ), 
     breaks=0:33, 
     col=c( rep("blue", 1), rep("lightblue", 5), rep("orange", 10),
            rep("lightgreen", 10), rep("red", 5), rep("black", 1) 
           ),
     main="Dealt Paying Pair", 
     xlab="Index for Hold (1=all, 32=none)"
     )

data.frame(idx=rep(evKey[1, , drop=FALSE][evSmall0 %in% c(0)], 
                   jbWeight[evSmall0 %in% c(0)]
                   ),
           typ=rep(evSmall0[evSmall0 %in% c(0)], 
                   jbWeight[evSmall0 %in% c(0)]
                   )
           ) %>% group_by(typ, idx) %>% summarize(ct=n())
```
  
On very rare occasion, you kick the paying pair to go after a better hand (Straight Flush), but otherwise it is a simple "keep the pair" decision.  
  
