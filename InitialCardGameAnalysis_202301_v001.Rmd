---
title: "Wild Card Game Analysis"
author: "davegoblue"
date: "2023-01-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
This file explores card games that use a standard 52-card deck, optionally modified so that one or more cards are wild, as follows:  
  
* One or more jokers may be added (the card has no natural rank or suit but may take on the most favorable)  
* One or more natural cards may also be used as a wild (in deuces wild, the deuce has a natural suit and rank and can also take on the suit and rank of a more favorable card)  
  
The analysis treats cards 1-52 as being the standard deck, with suits being 1-13, 14-26, 27-39, and 40-52. Counting the first card of each suit as 1, ranks are 1=Ace, 2-10=same card as value, 11=Jack, 12=Queen, 13=King. The Ace almost always plays as the highest rank, but can be treated as low for making a 5432A straight
  
## Methodology
### Basic Parameters
Several basic parameters of the game are established:  
```{r}

library(tidyverse) # tidyverse functionality is included throughout

source("./Generic_Added_Utility_Functions_202105_v001.R") # Basic functions

nCards <- 53 # This is a standard 52-card deck with a joker
nRanks <- 13 # There are 13 ranks A, 2-10, J, Q, K
nSuits <- 4 # There are four suits, each of 13 cards
perHand <- 5 # Number of cards drawn per hand
idxWild <- c(2, 15, 28, 41, 53) # The indices of the cards that can be considered wild (deuces and the joker)

# Check alignment of basic parameters
if(nSuits*nRanks > nCards) stop("\nerror, misaligned parameters for number of ranks, suits, and cards\n")
if(!isTRUE(setdiff(1:nCards, 1:(nRanks*nSuits)) %in% idxWild %>% reduce(.f=`&`)))
    stop("\nError, any cards outside the standard nRanks*nSuits must be included in idxWild\n")

# Announce the number of wild cards
cat("\nThe game will be played with a", nCards, "card deck with", length(idxWild), "cards considered wild")
cat("\nWild cards are of indices", paste0(idxWild, collapse=", "))

# Announce any cards of no suit or rank
if(!isTRUE(idxWild %in% 1:(nRanks*nSuits) %>% reduce(.f=`&`))) { 
    cat("\nWilds with no natural rank or suit at indices:", 
        paste0(idxWild[!(idxWild %in% 1:(nRanks*nSuits))], collapse=",")
        )
} else cat("\nAll wilds have a natural suit and rank")

# Announce wilds with natural ranks and suits
if(isTRUE(idxWild %in% 1:(nRanks*nSuits) %>% reduce(.f=`|`))) { 
    tmpIdxWild <- idxWild[idxWild %in% 1:(nRanks*nSuits)]
    cat("\nWilds with natural rank and suit at indices:", paste0(tmpIdxWild, collapse=", "))
    cat("\nThese are of suit-independent rank", paste0((tmpIdxWild-1)%%nRanks+1, collapse=", "), "\n")
} else cat("\nNo wilds have a natural suit and rank\n")

```

All choose(nCards, perHand) combinations of hands are created based on index:  
```{r, cache=TRUE}

startTime <- proc.time()


# Create a matrix of all possible hand indices
mtxHands <- t(combn(1:nCards, perHand))
str(mtxHands)


proc.time() - startTime

```
  
Hands are scored for their hand type, optionally using wilds. Functions are written:  
```{r}

# Determine if a hand is a flush
isFlush <- function(suits, useWild=4) {
    apply(suits, 1, FUN=function(x) ifelse(min(x)==max(x), TRUE, (max(x[x!=useWild])==min(x[x!=useWild]))))
}

# Determine if a hand is a straight (hard-coded for 5-card hands in a 13-card deck, Ace high or low)
isStraight <- function(rankCounts, isEligible=TRUE) {
    # Exclusion matrix for straights, currently designed only for 13-card decks and A high or low
    strMatrix <- matrix(data=0L, nrow=13, ncol=10)
    strMatrix[c(1, 10, 11, 12, 13), 1] <- 1L
    for (intCtr in 1:9) { strMatrix[intCtr:(intCtr+4), intCtr+1] <- 1L }
    apply(rankCounts, 1, max)<=1 & rowSums(rankCounts%*%(strMatrix-1)==0)>=1 & isEligible
}

# Hard-coded for 52-card deck with 1 joker
findHandTypes <- function (aHands, retAll=FALSE) {
    
    # Track hands that contain the joker and total number of wilds
    aJoker <- rowSums(aHands==53)>0
    nWild <- aJoker + rowSums(aHands%%13==2)
    
    # 1. Calculate natural values
    # 1a. Calculate ranks and suits, counting the joker as having no "rank" and being of a fifth "suit"
    aRanks <- ifelse(aHands==53, 0, 1 + (aHands-1) %% 13)
    aSuits <- ifelse(aHands==53, 0, 1 + (aHands-1) %/% 13)

    # 1b. Find the counts by rank in each hand
    aRankCount <- matrix(data=-1L, nrow=nrow(aHands), ncol=13)
    for (intCtr in 1:13) { aRankCount[, intCtr] <- rowSums(aRanks == intCtr) }
        
    # 1c. Find the natural flushes and straights
    nFlush <- isFlush(aSuits, useWild=-1)
    nStraight <- isStraight(aRankCount, isEligible=!aJoker)

    # 1d. Find max and count of ranks
    nQuads <- rowSums(aRankCount == 4)
    nTrips <- rowSums(aRankCount == 3)
    nPairs <- rowSums(aRankCount == 2)

    # 1e. Score the natural hand values (default is that a hand has nothing of value)
    nType <- rep(0L, nrow(aHands))
    # Five wilds (cannot exist) <- 1
    nType[nFlush==1 & nStraight==1 & aRankCount[, 1]==1 & aRankCount[, 13]==1] <- 2 # Royal
    # Five of a kind (cannot exist as natural) <- 3
    nType[nFlush==1 & nStraight==1 & (aRankCount[, 1]!=1 | aRankCount[, 13]!=1)] <- 4 # Straight flush
    nType[nQuads==1] <- 5 # Four of a kind
    nType[nTrips==1 & nPairs==1] <- 6 # Full House
    nType[nFlush==1 & nStraight==0] <- 7 # Flush
    nType[nFlush==0 & nStraight==1] <- 8 # Straight
    nType[nTrips==1 & nPairs==0] <- 9 # Three of a Kind
    nType[nPairs==2] <- 10 # Two Pair
    nType[nTrips==0 & nPairs==1] <- 11 # Pair

    
    # 2. Calculate wild values
    # 2a. Calculate ranks and suits, counting the joker and 2's as having no "rank" and being of a fifth "suit"
    wRanks <- ifelse(aHands==53|(aHands%%13==2), 0, 1 + (aHands-1) %% 13)
    wSuits <- ifelse(aHands==53|(aHands%%13==2), 0, 1 + (aHands-1) %/% 13)

    # 2b. Find the counts by rank in each hand
    wRankCount <- matrix(data=-1L, nrow=nrow(aHands), ncol=13)
    for (intCtr in 1:13) { wRankCount[, intCtr] <- rowSums(wRanks == intCtr) }
        
    # 2c. Find the wild flushes and straights
    wFlush <- isFlush(wSuits, useWild=0)
    wStraight <- isStraight(wRankCount, isEligible=TRUE)
    
    # 2d. Find max and count of ranks
    wQuads <- rowSums(wRankCount == 4)
    wTrips <- rowSums(wRankCount == 3)
    wPairs <- rowSums(wRankCount == 2)

    # 2e. Score the wild hand values (default is that a hand has nothing of value)
    wType <- rep(0L, nrow(aHands))
    
    # 2e1. Calculate number of royal cards in hand
    nRoyal <- rowSums(wRankCount[, c(1, 10, 11, 12, 13)])
    
    # 2e2. Five wilds (always five wilds)
    wType[nWild==5] <- 1 # Five wild
    
    # 2e3. Four wilds (always either royal flush or five of a kind)
    wType[nWild==4 & nRoyal==1] <- 2 # Royal
    wType[nWild==4 & nRoyal==0] <- 3 # Five of a kind
    
    # 2e4. Three wilds (always either royal flush or five of a kind or straight flush or four of a kind)
    wType[nWild==3 & wFlush==1 & wStraight==1 & nRoyal==2] <- 2 # Royal
    wType[nWild==3 & wPairs==1] <- 3 # Five of a kind
    wType[nWild==3 & wFlush==1 & wStraight==1 & nRoyal<2] <- 4 # Straight Flush
    wType[nWild==3 & !(wFlush==1 & wStraight==1) & wPairs==0] <- 5 # Four of a kind
    
    # 2e5. Two wilds (always either royal, five of a kind, straight flush, four of a kind, flush, straight, trips)
    # Cannot be a full house as any 3-2 using two wilds could instead be 5-0 or 1-4 and thus a better hand
    wType[nWild==2 & wFlush==1 & wStraight==1 & nRoyal==3] <- 2 # Royal
    wType[nWild==2 & wTrips==1] <- 3 # Five of a kind
    wType[nWild==2 & wFlush==1 & wStraight==1 & nRoyal<3] <- 4 # Straight Flush
    wType[nWild==2 & wPairs==1] <- 5 # Four of a kind
    wType[nWild==2 & wFlush==1 & wStraight==0] <- 7 # Flush
    wType[nWild==2 & wFlush==0 & wStraight==1] <- 8 # Straight
    wType[nWild==2 & !(wFlush==1 | wStraight==1) & wPairs==0 & wTrips==0] <- 9 # Three of a kind
    
    # 2e6. One wild (can be anything from pair to royal, with the exception of never two pair)
    wType[nWild==1 & wFlush==1 & wStraight==1 & nRoyal==4] <- 2 # Royal
    wType[nWild==1 & wQuads==1] <- 3 # Five of a kind
    wType[nWild==1 & wFlush==1 & wStraight==1 & nRoyal<4] <- 4 # Straight Flush
    wType[nWild==1 & wTrips==1] <- 5 # Four of a kind
    wType[nWild==1 & wPairs==2] <- 6 # Full House
    wType[nWild==1 & wFlush==1 & wStraight==0] <- 7 # Flush
    wType[nWild==1 & wFlush==0 & wStraight==1] <- 8 # Straight
    wType[nWild==1 & wPairs==1] <- 9 # Three of a kind
    wType[nWild==1 & !(wFlush==1 | wStraight==1) & wPairs==0 & wTrips==0 & wQuads==0] <- 11 # Pair
    
    # 2e7. No wild (is identical to natural)
    wType[nWild==0] <- nType[nWild==0]
    
    # Return the requested data
    if (isTRUE(retAll)) {
        list(nType=nType, 
             wType=wType, 
             nWild=nWild,
             wRankCount=wRankCount,
             aRankCount=aRankCount
             )
    } else {
        list(nType=nType, wType=wType, nWild=nWild)
    }
    
}

```
  
```{r, cache=TRUE}

# Calculate hands
tmpTime <- proc.time(); tmpHandTypes<-findHandTypes(mtxHands, retAll=TRUE); proc.time()-tmpTime

```
  
Hand types are evaluated:  
```{r, fig.height=9, fig.width=9}

# Create tibble
tblAllTypes <- tibble::tibble(wType=tmpHandTypes$wType, 
                              nType=tmpHandTypes$nType, 
                              nWild=tmpHandTypes$nWild
                              ) %>%
    mutate(wType=ifelse(wType==0, 99, wType), 
           nType=ifelse(nType==0, 99, nType)
           )
tblAllTypes

# Plot the overlaps
tblAllTypes %>%
    count(wType, nType) %>%
    mutate(wType=ifelse(wType %in% c(1, 3), case_when(wType==3 ~ "3 (5K)", wType==1 ~ "1 (5W)"), wType), 
           nType=case_when(nType==2 ~ "2 (RF)", nType==4 ~ "4 (SF)", nType==5 ~ "5 (4K)", nType==6 ~ "6 (FH)", 
                           nType==7 ~ "7 (FL)", nType==8 ~ "8 (ST)", nType==9 ~ "9 (3K)", nType==10 ~ "10 (2P)", 
                           nType==11 ~ "11 (Pair)", nType==99 ~ "99 (HC)", TRUE ~ "Error"
                           )
           ) %>%
    mutate(wType=factor(wType, 
                        levels=c("99", "11", "10", "9", "8", "7", "6", "5", "4", "3 (5K)", "2", "1 (5W)")
                        ), 
           nType=factor(nType, 
                        levels=c("99 (HC)", "11 (Pair)", "10 (2P)", "9 (3K)", "8 (ST)", "7 (FL)", 
                                 "6 (FH)", "5 (4K)", "4 (SF)", "2 (RF)"
                                 )
                        )
           ) %>%
    ggplot(aes(x=wType, y=nType)) + 
    geom_tile(aes(fill=(n>0))) + 
    geom_text(aes(label=n), size=3) + 
    scale_fill_discrete("Overlap\nexists?") + 
    labs(title="Number of hands by type in 53c5 game", 
         subtitle="Deuces can be natural or wild, joker (card 53) is wild only", 
         y="Natural hand type", 
         x="Wild hand type"
         )

```
  
Hands can be scored based on a paytable for both wild-type hands and natural-type hands (only the highest payout applies). An example from the game "DJ Wild" is assessed:  
```{r, fig.height=9, fig.width=9}

# Hand values
handValues <- tibble::tibble(handRank=c(1:11, 99), 
                             handDesc=c("5W", "RF", "5K", "SF", "4K", "FH", "FL", "ST", "3K", "2P", "1P", "HC"),
                             handLabel=paste0(handRank, " (", handDesc, ")"),
                             blindPay=c(2000, 100, 40, 25, 5, 4, 3, 2, 0, 0, 0, 0),
                             wildPay=c(2000, 90, 70, 25, 6, 5, 4, 3, 1, -1, -1, -1), 
                             naturalPay=c(NA, 1000, NA, 200, 60, 30, 25, 20, 6, -1, -1, -1)
                             )
handValues

# Create a mapping vector for type to description
vecMapHands <- handValues$handLabel %>% purrr::set_names(handValues$handRank)

# Payout grid plotted for all possible values
allValueGrid <- expand.grid(wildType=c(1:11, 99), naturalType=c(1:11, 99)) %>%
    tibble::tibble() %>%
    full_join(count(tblAllTypes, wType, nType), by=c("wildType"="wType", "naturalType"="nType")) %>%
    mutate(bestType=pmin(wildType, naturalType)) %>%
    left_join(select(handValues, handRank, wildPay), by=c("wildType"="handRank")) %>%
    left_join(select(handValues, handRank, naturalPay), by=c("naturalType"="handRank")) %>%
    left_join(select(handValues, handRank, blindPay), by=c("bestType"="handRank")) %>%
    mutate(bonusPay=pmax(wildPay, naturalPay, na.rm=TRUE))
allValueGrid

# Plot of payout values
allValueGrid %>%
    filter(!is.na(n)) %>%
    ggplot(aes(x=fct_rev(factor(vecMapHands[as.character(wildType)], levels=vecMapHands)), 
               y=fct_rev(factor(vecMapHands[as.character(naturalType)], levels=vecMapHands))
               )
           ) + 
    geom_tile(fill="lightgreen") +
    geom_text(aes(label=bonusPay)) + 
    labs(title="Example payouts by type in 53c5 game", 
         subtitle="Deuces can be natural or wild, joker (card 53) is wild only", 
         y="Natural hand type", 
         x="Wild hand type"
         )

# EV of payout values
allValueGrid %>%
    filter(!is.na(n)) %>%
    summarize(totPays=sum(n*bonusPay), n=sum(n)) %>%
    mutate(ev=totPays/n)

# Table by hand type
allValueTable <- allValueGrid %>%
    filter(!is.na(n)) %>%
    mutate(natWild=ifelse(naturalPay>wildPay, "Natural", "Wild"), 
           reportBonusType=ifelse(natWild=="Natural", naturalType, wildType),
           reportBonusLabel=factor(vecMapHands[as.character(reportBonusType)], levels=vecMapHands)
           ) %>%
    group_by(natWild, reportBonusLabel, bonusPay) %>%
    summarize(n=sum(n), .groups="drop") %>%
    mutate(prob=n/sum(n), per=1/prob, ev=n*bonusPay/sum(n))
allValueTable
allValueTable %>% select(n, ev) %>% colSums() %>% round(4)

```
  
Convert all hands to a value with ranks for tie-breaking (Ace high, with 5432A straights treated as having first tie-breaker 5 and last tie-breaker A). Hands are first converted to counts by rank with wild cards filling the next best ranks:  
```{r}

# Get the number of wilds in each hand
perHandNWild <- (rowSums(mtxHands==53)>0) + rowSums(mtxHands%%13==2)

# Get the ranks in each hand
perHandRanks <- ifelse(mtxHands==53, 0, 1 + (mtxHands-1) %% 13) # track joker as wild
perHandRanks[perHandRanks==2] <- 0 # track deuces as wild, ignore rank (place as best later)
perHandRanks[perHandRanks==1] <- 14 # count Aces as high

# Create the matrix of card types
perHandRankCount <- matrix(data=-1L, nrow=nrow(mtxHands), ncol=14)
for (intCtr in 1:14) { perHandRankCount[, intCtr] <- rowSums(perHandRanks == intCtr) }

# Create a tie-breaker matrix filled with 0's (column 13 is Ace)
mtxTieBreak <- matrix(data=0L, nrow=nrow(mtxHands), ncol=13)

# Function to get the cards in a straight
getStraightType <- function(x) {
    if(min(x[x>0]) >= 10) c(10, 11, 12, 13, 14)
    else if(min(x[x>0]) <= 5 & max(x)==14) c(2, 3, 4, 5, 14) # this treats Ace as the last card to resolve (Ace low)
    else seq(min(x[x>0]), min(x[x>0])+4)
}

# Function to get the cards in a flush
getFlushType <- function(x) {
    # Wild cards should be added as highest rank not already in hand (try A then K then Q then J then T)
    numAdd <- sum(x==0)
    if(numAdd > 0) {
        notThere <- (14:10)[!((14:10) %in% x)][1:numAdd]
        x <- c(x[x!=0], notThere)
    }
    sort(x, decreasing=TRUE)
}

# Function to get the cards in a four of a kind, full house, three of a kind, two pair, pair, or high card
getHighTypes <- function(rks, idx=1:14, outNum=c(1, 1, 1, 1, 1)) {
    vecOut <- rep(0L, length(outNum))
    for(x in seq_along(outNum)) {
        vecOut[x]<-max((rks==max(rks)) * idx)
        rks[match(vecOut[x], idx)] <- 0
    }
    rep(vecOut, times=outNum)
}

# 1. Five wild (nothing to do)
# 2. Royal flush (make the ranks 1 in the last 5 columns)
perHandRanks[tmpHandTypes$wType==2, ] <- t(apply(perHandRanks[tmpHandTypes$wType==2, ], 1, FUN=getStraightType))
# 3. Five of a kind (make the ranks all the same as the only rank)
perHandRanks[tmpHandTypes$wType==3, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==3, ], 
                                           1, 
                                           FUN=getHighTypes, 
                                           outNum=c(5)
                                           )
                                     )
# 4. Straight flush (make the ranks all the best straight possible)
perHandRanks[tmpHandTypes$wType==4, ] <- t(apply(perHandRanks[tmpHandTypes$wType==4, ], 1, FUN=getStraightType))
# 5. Four of a kind (make the ranks four of the most frequent card or the highest card, one of the other)
perHandRanks[tmpHandTypes$wType==5, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==5, ], 
                                           1, 
                                           FUN=getHighTypes, 
                                           outNum=c(4, 1)
                                           )
                                     )
# 6. Full house (make the ranks three of the most frequent card, two of the other)
perHandRanks[tmpHandTypes$wType==6, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==6, ], 
                                           1, 
                                           FUN=getHighTypes, 
                                           outNum=c(3, 2)
                                           )
                                     )
# 7. Flush (need to implement)
perHandRanks[tmpHandTypes$wType==7, ] <- t(apply(perHandRanks[tmpHandTypes$wType==7, ], 1, FUN=getFlushType))
# 8. Straight (make the ranks all the best straight possible)
perHandRanks[tmpHandTypes$wType==8, ] <- t(apply(perHandRanks[tmpHandTypes$wType==8, ], 1, FUN=getStraightType))
# 9. Three of a kind (make the ranks three of the most frequent or highest card, one each of the other)
perHandRanks[tmpHandTypes$wType==9, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==9, ], 
                                           1, 
                                           FUN=getHighTypes, 
                                           outNum=c(3, 1, 1)
                                           )
                                     )
# 10. Two pair (make the ranks two of the highest pair, two of the lowest pair, one of the remainder)
perHandRanks[tmpHandTypes$wType==10, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==10, ], 
                                            1, 
                                            FUN=getHighTypes, 
                                            outNum=c(2, 2, 1)
                                            )
                                      )
# 11. One pair (make the ranks two of the pair or highest card, one each of the remainder)
perHandRanks[tmpHandTypes$wType==11, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==11, ], 
                                            1, 
                                            FUN=getHighTypes, 
                                            outNum=c(2, 1, 1, 1)
                                            )
                                      )
# 0. High card (make the ranks in order of the highest cards)
perHandRanks[tmpHandTypes$wType==0, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==0, ], 
                                            1, 
                                            FUN=getHighTypes, 
                                            outNum=c(1, 1, 1, 1, 1)
                                            )
                                      )

# Create the hand ranking table
allHandRanks <- tibble::tibble(handNum=1:nrow(mtxHands), wType=tmpHandTypes$wType) %>% 
    bind_cols(perHandRanks) %>% 
    set_names(c("handNum", "wType", "tb1", "tb2", "tb3", "tb4", "tb5")) %>% 
    mutate(wType=ifelse(wType==0, 99, wType)) %>% 
    arrange(wType, desc(tb1), desc(tb2), desc(tb3), desc(tb4), desc(tb5)) %>% 
    mutate(chgRank=ifelse(row_number()==1 | wType!=lag(wType) | tb1 != lag(tb1) | tb2 != lag(tb2) | tb3 != lag(tb3) | tb4 != lag(tb4) | tb5 != lag(tb5), 1, 0), 
           rank=cumsum(chgRank)
           )
allHandRanks %>%
    count(wType, rank, tb1, tb2, tb3, tb4, tb5) %>%
    arrange(-n, rank) %>%
    mutate(nvr=row_number()) %>%
    group_by(wType) %>%
    mutate(nty=row_number()) %>%
    ungroup() %>%
    filter(nvr<=10 | nty==1)

```
  
As expected, straight is the hand type with the greatest number of possible ties (there are only 10 types of straight and each can have 1,024 permutations of suits)

A function is written to assess probabilities associated with any given hand:  
```{r}

# Sort allHandRanks and ensure handNum and row_number() match
sortedHandRanks <- allHandRanks %>%
    mutate(qual=ifelse(wType<=11, "Q", "N")) %>%
    arrange(handNum)
if (sum((sortedHandRanks$handNum) != (1:nrow(sortedHandRanks)))>0) 
    stop("\nError in handNum order in sortedHandRanks\n")

# Function to get probabilities
findHandProbs <- function(exRank, idxExclude=NULL, df=sortedHandRanks) {
    rkData <- if(is.null(idxExclude)) df$rank else df$rank[-idxExclude]
    qualData <- if(is.null(idxExclude)) df$qual else df$qual[-idxExclude]
    pLN <- mean(rkData < exRank & qualData=="N")
    pLQ <- mean(rkData < exRank & qualData=="Q")
    pTN <- mean(rkData == exRank & qualData=="N")
    pTQ <- mean(rkData == exRank & qualData=="Q")
    pWN <- mean(rkData > exRank & qualData=="N")
    pWQ <- mean(rkData > exRank & qualData=="Q")
    pWNoTie <- (pWN+pWQ)/(1-pTN-pTQ)
    c(pLN=pLN, pLQ=pLQ, pTN=pTN, pTQ=pTQ, pWN=pWN, pWQ=pWQ, pWNoTie=pWNoTie)
}

# Example hand index
exHandNum <- 123456
exHandRank <- sortedHandRanks$rank[exHandNum]
cat("\nExample hand", 
    exHandNum, 
    "is of type", 
    sortedHandRanks$wType[exHandNum], 
    "and rank",
    exHandRank,
    "with cards", 
    mtxHands[exHandNum,], 
    "\n"
    )

res <- findHandProbs(exHandRank)
cat("Associated probabilities (if cards in example hand available to replay):", 
    "\nLoss: ", res["pLN"]+res["pLQ"], 
    "\nTie: ", res["pTN"]+res["pTQ"],
    "\nWin (no qualify): ", res["pWN"], 
    "\nWin (qualify): ", res["pWQ"], 
    "\nWin (excluding ties):", res["pWNoTie"],
    "\np(dealer qualifies):", res["pLQ"]+res["pTQ"]+res["pWQ"],
    "\nOptimal action: ", ifelse(res["pWNoTie"]<0.25, "Fold", ifelse(res["pWNoTie"]<=0.5, "Single", "Double")),
    "\n"
    )

```

The function is run excluding unavailable cards (e.g., none of a player's cards can appear in the dealer's hand). First, a list of exclusions is generated:  
```{r, cache=TRUE}

# Get all exclusion indices once
cardInHand <- lapply(1:53, FUN=function(x) which(rowSums(mtxHands==x)>0))

```
  
Then, the function is written and applied to the example hand:  
```{r}

# Function to get key values
getKeyValues <- function(keyRank, exclCards=c(), lstExclude=cardInHand, dfSort=sortedHandRanks) {

    # Get the union of exclusions
    if(length(exclCards)==0) exclHands<-c()
    else exclHands <- purrr::reduce(.x=lstExclude[c(exclCards)], .f=union)

    dfSort %>%
        filter(!(handNum %in% exclHands)) %>%
        summarize(pLQ=mean(qual=="Q" & rank<keyRank),
                  pLN=mean(qual=="N" & rank<keyRank), 
                  pTQ=mean(qual=="Q" & rank==keyRank),
                  pTN=mean(qual=="N" & rank==keyRank), 
                  pWQ=mean(qual=="Q" & rank>keyRank),
                  pWN=mean(qual=="N" & rank>keyRank), 
                  n=n()
                  ) %>%
        mutate(pWNoTie=(pWQ+pWN)/(1-pTQ-pTN), rank=keyRank)
        
}

smallSorted <- sortedHandRanks %>% select(handNum, rank, qual)

# Heads up probabilities
t <- proc.time(); getKeyValues(exHandRank, exclCards=mtxHands[exHandNum,], dfSort=smallSorted); proc.time() - t

# Heads up probabilities, dealer does not have a wild card
t <- proc.time() 
getKeyValues(exHandRank, exclCards=unique(c(mtxHands[exHandNum,], 2, 15, 28, 41, 53)), dfSort=smallSorted)
proc.time() - t

```

As expected, probabilities change slightly due to cards made unavailable (in player's hands or otherwise). Wild cards are very important in expected value of hand quality

A function is added to run multiple hands:  
```{r, fig.height=9, fig.width=9}

# Blind payouts
blindPay <- c(2000, 100, 40, 25, 5, 4, 3, 2, 0, 0, 0, 0) %>% purrr::set_names(paste0("b_", c(1:11, 99)))

# Add number of wilds
sortedHandRanks <- sortedHandRanks %>%
    mutate(nWild=perHandNWild)

calculateResults <- function(useHandNums, dfRanks=sortedHandRanks, hands=mtxHands, bPay=blindPay) {

    map_dfr(useHandNums, 
            .f=function(x) {
                getKeyValues(keyRank=dfRanks$rank[x], exclCards=as.vector(hands[x,])) %>%
                    mutate(type=dfRanks$wType[x], 
                           handNum=x, 
                           betPlay=ifelse((4*pWQ+3*pWN+2*pTQ+2*pTN)<(pLQ+pLN), 0, ifelse(pWNoTie<0.5, 1, 2)), 
                           evAnte=ifelse(betPlay==0, -1, pWQ-pLQ-pLN), 
                           evPlay=betPlay*(pWQ+pWN-pLQ-pLN),
                           evBlind=ifelse(betPlay==0, -1, bPay[paste0("b_", type)]*(pWQ+pWN)-pLQ-pLN), 
                           evAll=evAnte+evPlay+evBlind
                           )
                }
            )
}

```
  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Run for example hand of all hand types 4 (straight flush) or better
seq1a <- sortedHandRanks %>% 
    filter(wType <= 4) %>%
    group_by(nWild, wType, tb1, tb2, tb3, tb4, tb5) %>% 
    filter(row_number()==1) %>% 
    ungroup()

# Run for select hands
t <- proc.time(); resSFPlus <- calculateResults(useHandNums=seq1a$handNum); proc.time()-t

# Statistics for EV by hand type
resSFPlus %>%
    group_by(type) %>%
    summarize(n=n(), across(c(pWNoTie, evAll), .fns=list(min=min, mean=mean, med=median, max=max)))

# Plot for result type
resSFPlus %>%
    mutate(qualifies=pWQ+pTQ+pLQ, ties=pTQ+pTN) %>%
    select(handNum, type, pWQ, pWN, pLQ, pLN, ties, qualifies) %>%
    pivot_longer(-c(handNum, type)) %>%
    ggplot(aes(x=factor(type), y=value)) + 
    geom_boxplot(fill="lightblue") + 
    facet_wrap(~name) + 
    labs(title="Probabilities of results by hand type", x="Hand type", y="Probability")

```
  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Run for example hand of all hand types 5-8 (4K thru straight) or better
seq1b <- sortedHandRanks %>% 
    filter(wType <= 8 & wType >= 5) %>%
    group_by(nWild, wType, tb1, tb2, tb3, tb4, tb5) %>% 
    filter(row_number()==1) %>% 
    ungroup()

# Run for select hands
t <- proc.time(); resSTto4K <- calculateResults(useHandNums=seq1b$handNum); proc.time()-t

# Statistics for EV by hand type
resSTto4K %>%
    group_by(type) %>%
    summarize(n=n(), across(c(pWNoTie, evAll), .fns=list(min=min, mean=mean, med=median, max=max)))

# Plot for result type
resSTto4K %>%
    mutate(qualifies=pWQ+pTQ+pLQ, ties=pTQ+pTN) %>%
    select(handNum, type, pWQ, pWN, pLQ, pLN, ties, qualifies) %>%
    pivot_longer(-c(handNum, type)) %>%
    ggplot(aes(x=factor(type), y=value)) + 
    geom_boxplot(fill="lightblue") + 
    facet_wrap(~name) + 
    labs(title="Probabilities of results by hand type", x="Hand type", y="Probability")

```
  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Run for example hand of all hand types 9-10 (3K thru 2P)
seq1c <- sortedHandRanks %>% 
    filter(wType <= 10 & wType >= 9) %>%
    group_by(nWild, wType, tb1, tb2, tb3, tb4, tb5) %>% 
    filter(row_number()==1) %>% 
    ungroup()

# Run for select hands
t <- proc.time(); res3Kto2P <- calculateResults(useHandNums=seq1c$handNum); proc.time()-t

# Statistics for EV by hand type
res3Kto2P %>%
    group_by(type) %>%
    summarize(n=n(), across(c(pWNoTie, evAll), .fns=list(min=min, mean=mean, med=median, max=max)))

# Plot for result type
res3Kto2P %>%
    mutate(qualifies=pWQ+pTQ+pLQ, ties=pTQ+pTN) %>%
    select(handNum, type, pWQ, pWN, pLQ, pLN, ties, qualifies) %>%
    pivot_longer(-c(handNum, type)) %>%
    ggplot(aes(x=factor(type), y=value)) + 
    geom_boxplot(fill="lightblue") + 
    facet_wrap(~name) + 
    labs(title="Probabilities of results by hand type", x="Hand type", y="Probability")

```
  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Run for example hand of all hand types 11 with no wild (pair)
seq1d <- sortedHandRanks %>% 
    filter(wType == 11 & nWild==0) %>%
    group_by(nWild, wType, tb1, tb2, tb3, tb4, tb5) %>% 
    filter(row_number()==1) %>% 
    ungroup()

# Run for select hands
t <- proc.time(); resPairNoWild <- calculateResults(useHandNums=seq1d$handNum); proc.time()-t
resPairNoWild

```
  
```{r, fig.height=9, fig.width=9}

# Statistics for EV by hand type
resPairNoWild %>%
    full_join(select(seq1d, handNum, tb1), by="handNum") %>%
    group_by(tb1) %>%
    summarize(n=n(), across(c(pWNoTie, evAll), .fns=list(min=min, mean=mean, med=median, max=max)))

# Plot for result type
resPairNoWild %>%
    full_join(select(seq1d, handNum, tb1), by="handNum") %>%
    mutate(qualifies=pWQ+pTQ+pLQ, ties=pTQ+pTN) %>%
    select(handNum, tb1, pWQ, pWN, pLQ, pLN, ties, qualifies) %>%
    pivot_longer(-c(handNum, tb1)) %>%
    ggplot(aes(x=factor(tb1), y=value)) + 
    geom_boxplot(fill="lightblue") + 
    facet_wrap(~name) + 
    labs(title="Probabilities of results by pair type (no wild)", x="Pair type", y="Probability")

```
  
```{r, fig.height=9, fig.width=9, cache=TRUE}

# Run for example hand of all hand types 11 with wild (pair) and type 99 (no pair)
seq1e <- sortedHandRanks %>% 
    filter(wType==99 | (wType == 11 & nWild==1)) %>%
    group_by(nWild, wType, tb1, tb2, tb3, tb4, tb5) %>% 
    filter(row_number()==1) %>% 
    ungroup()

# Run for select hands
t <- proc.time(); resWildPairNoPair <- calculateResults(useHandNums=seq1e$handNum); proc.time()-t
resWildPairNoPair

```
  
```{r, fig.height=9, fig.width=9}

# Statistics for EV by hand type
resWildPairNoPair %>%
    full_join(select(seq1e, handNum, tb1, nWild), by="handNum") %>%
    group_by(type, nWild, tb1) %>%
    summarize(n=n(), across(c(pWNoTie, evAll), .fns=list(min=min, mean=mean, med=median, max=max)))

# Plot for result type
resWildPairNoPair %>%
    full_join(select(seq1e, handNum, tb1, nWild), by="handNum") %>%
    mutate(qualifies=pWQ+pTQ+pLQ, ties=pTQ+pTN) %>%
    select(handNum, tb1, nWild, type, pWQ, pWN, pLQ, pLN, ties, qualifies) %>%
    pivot_longer(-c(handNum, tb1, nWild, type)) %>%
    mutate(lab=paste0(type, "-", nWild, "-", stringr::str_pad(as.character(tb1), 2, side="left", pad="0"))) %>%
    ggplot(aes(x=factor(lab), y=value)) + 
    geom_boxplot(fill="lightblue") + 
    facet_wrap(~name) + 
    labs(title="Probabilities of results by type\nPair with wild (11-1), or no pair (99-0)", 
         x="Type", 
         y="Probability"
         )

```
  
The result files are combined and saved:  
```{r, fig.height=9, fig.width=9}

resAll_202301_v001 <- bind_rows(resWildPairNoPair, 
                                resPairNoWild, 
                                res3Kto2P, 
                                resSTto4K, 
                                resSFPlus,
                                .id="src"
                                ) %>%
    mutate(src=c("1"="Wild Pair or No Paor", 
                 "2"="Pair, No Wild", 
                 "3"="Two Pair or Trips", 
                 "4"="Straight to Quads", 
                 "5"="Straight Flush or Better"
                 )[src]
           )
resAll_202301_v001

saveToRDS(resAll_202301_v001, ovrWriteError=FALSE)

```
  
Results are explored:  
```{r, fig.height=9, fig.width=9}

# Create the analysis frame
dfResAll_202301_v001 <- resAll_202301_v001 %>% 
    left_join(select(sortedHandRanks, handNum, nWild, wType, starts_with("tb")), by="handNum") %>% 
    full_join(sortedHandRanks %>% count(nWild, wType, tb1, tb2, tb3, tb4, tb5, name="nOfType"))

# Chart of overall probabilities by bet amount
dfResAll_202301_v001 %>% 
    summarize(n=sum(nOfType), 
              across(c(pWNoTie, evAnte, evPlay, evBlind, evAll), .fns=function(x) sum(x*nOfType)/sum(nOfType))
              )

# Chart of probabilities by bet amount
dfResAll_202301_v001 %>% 
    group_by(betPlay) %>% 
    summarize(n=sum(nOfType), 
              minPw=min(pWNoTie), 
              across(c(pWNoTie, evAnte, evPlay, evBlind, evAll), .fns=function(x) sum(x*nOfType)/sum(nOfType))
              )

# Plot of win probabilities
dfResAll_202301_v001 %>%
    arrange(pWNoTie) %>% 
    mutate(cs=cumsum(nOfType)) %>% 
    ggplot(aes(x=cs/choose(53, 5), y=pWNoTie)) + 
    geom_line() + 
    geom_point(data=tibble::tibble(x=c(0, 0.25, 0.5, 1), col=c("black", "red", "green", "black")) %>% mutate(y=x), 
               aes(x=x, y=y, color=col), 
               size=3
               ) +
    scale_color_identity() +
    geom_abline(slope=1, intercept=0, lty=2) + 
    labs(title="Probability of winning based on 5-card hand", 
         x="5-card hand percentile", 
         y="Probability of winning (ties excluded)"
         )

```
  
Volatility of the bonus bet is explored, assuming 100 hands:  
```{r, fig.height=9, fig.width=9}

nBonusPay <- allValueGrid %>%
    select(n, bonusPay) %>%
    filter(!is.na(n)) %>%
    group_by(bonusPay) %>%
    summarize(n=sum(n))
nBonusPay

# Overall metrics - mean and standard deviation
nBonusPay %>%
    summarize(evBonus=sum(bonusPay*n)/sum(n), 
              evBonus2=sum(n*(bonusPay**2))/sum(n)
              ) %>%
    mutate(sdBonus=sqrt(evBonus2-evBonus**2))

# Simulations of 100 hands
set.seed(23013015)
nSims <- 10000
nPerSim <- 100
simTotal <- vector("numeric", length=nSims)

for(intCtr in 1:nSims) simTotal[intCtr] <- sum(sample(nBonusPay$bonusPay, 
                                                      size=nPerSim, 
                                                      prob=nBonusPay$n, 
                                                      replace=TRUE
                                                      )
                                               )

cat("\n", 
    nSims, 
    "simulations each of", 
    nPerSim, 
    "hands has mean:", 
    round(mean(simTotal), 2), 
    "with sd:", 
    round(sd(simTotal), 1), 
    "\n"
    )

# Plot of outcomes
tibble::tibble(result=simTotal) %>%
    arrange(result) %>%
    mutate(rn=row_number(), cummean=cumsum(result)/rn) %>%
    ggplot(aes(x=(rn-1)/(max(rn)-1), y=cummean)) + 
    geom_point() + 
    labs(title=paste0("Mean return for ", nPerSim, " hands"), 
         x="Result percentile", 
         y="Cumulative mean return for hands through percentile"
         )

# Quantiles and proportion greater than zero
quantile(simTotal, c(0, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.975, 0.99, 1))

cat("\n", 
    paste0(round(mean(simTotal>0)*100, 1), "%"), 
    "of simulations are wins, with mean win per winning simulation:", 
    round(mean(simTotal[simTotal>0]), 1), 
    "and median win per winning simulation:", 
    round(median(simTotal[simTotal>0]), 1)
    )
cat("\n", 
    paste0(round(mean(simTotal==0)*100, 1), "%"), 
    "of simulations are draws"
    )
cat("\n", 
    paste0(round(mean(simTotal<0)*100, 1), "%"), 
    "of simulations are losers, with mean loss per losing simulation:", 
    round(mean(simTotal[simTotal<0]), 1), 
    "and median loss per losing simulation:", 
    round(median(simTotal[simTotal<0]), 1),
    "\n"
    )

```
  
Volatility of the main bet is explored, assuming 100 hands:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

dfHandData <- dfResAll_202301_v001 %>%
    select(wType, nOfType, betPlay, starts_with("p")) %>%
    mutate(win=pWQ+pWN, tie=pTQ+pTN, lose=pLQ+pLN, blindPay=blindPay[paste0("b_", wType)])
dfHandData

getHandOutcome <- function(pWQ, pWN, tie, lose, betPlay, blindPay) {
    if(betPlay==0) return(tibble::tibble(result="fold", ante=-1, blind=-1, play=0))
    result <- sample(c("win/qualify", "win/no qualify", "tie", "lose"), 
                     size=1, 
                     replace=TRUE, 
                     prob=c(pWQ, pWN, tie, lose)
                     )
    return(tibble::tibble(result=result, 
                          ante=case_when(result=="win/qualify" ~ 1, 
                                         result %in% c("win/no qualify", "tie") ~ 0, 
                                         result=="lose" ~ -1, 
                                         TRUE ~ -99
                                         ),
                          blind=case_when(result %in% c("win/qualify", "win/no qualify") ~ blindPay, 
                                          result=="tie" ~ 0, 
                                          result=="lose" ~ -1, 
                                          TRUE ~ -99
                                          ), 
                          play=case_when(result %in% c("win/qualify", "win/no qualify") ~ betPlay, 
                                         result=="tie" ~ 0, 
                                         result=="lose" ~ -betPlay, 
                                         TRUE ~ -99
                                         )
                          )
           )
    
}

lst200 <- lapply(1:200, FUN=function(y) {
    map_dfr(1:100, 
            .f=function(x) {
                rn <- sample(1:nrow(dfHandData), size=1, replace=TRUE, prob=dfHandData$nOfType)
                rd <- dfHandData[rn,]
                getHandOutcome(pWQ=rd$pWQ, 
                               pWN=rd$pWN, 
                               tie=rd$tie, 
                               lose=rd$lose, 
                               betPlay=rd$betPlay, 
                               blindPay=rd$blindPay
                               ) %>%
                    mutate(rn=rn, n=1)
                }
            )
            }
    )

res200 <- map_dfr(lst200, .f=function(x) summarize(x, across(c("ante", "blind", "play"), .fns=sum), n=n()))
res200

res200 %>%
    mutate(overall=ante+blind+play) %>%
    summarize(across(.fns=mean))

```
  
The process is converted for parallel processing:  
```{r, fig.height=9, fig.width=9}

# Simulations of 100 hands
set.seed(23020115)
nSims <- 10000
nPerSim <- 100
simTotal <- vector("numeric", length=nSims)

# Get the hand numbers for the simulation
rn <- sample(1:nrow(dfHandData), size=nPerSim*nSims, replace=TRUE, prob=dfHandData$nOfType)

# Get the outcomes for the simulation
rd <- dfHandData[rn,] %>% 
    mutate(prob=runif(nPerSim*nSims), 
           wintie=win+tie, 
           res=case_when(prob<=pWQ ~ "winQ", 
                         prob<=win ~ "winNo", 
                         prob <= wintie ~ "tie", 
                         prob <= wintie+lose ~ "lose", 
                         TRUE ~ "ERROR"
                         )
           )

# Convert to payouts by bet
rp <- rd %>%
    mutate(resActual=ifelse(betPlay==0, "fold", res), 
           resPlay=case_when(resActual %in% c("winQ", "winNo") ~ betPlay, 
                             resActual %in% c("fold", "tie") ~ 0, 
                             resActual %in% c("lose") ~ -betPlay, 
                             TRUE ~ -Inf
                             ), 
           resBlind=case_when(resActual %in% c("winQ", "winNo") ~ blindPay, 
                              resActual %in% c("tie") ~ 0, 
                              resActual %in% c("lose", "fold") ~ -1, 
                              TRUE ~ -Inf
                              ), 
           resAnte=case_when(resActual %in% c("winQ") ~ 1, 
                             resActual %in% c("tie", "winNo") ~ 0, 
                             resActual %in% c("lose", "fold") ~ -1, 
                             TRUE ~ -Inf
                             ), 
           resAll=resPlay+resBlind+resAnte
           ) %>%
    select(wType, betPlay, res, resActual, resPlay, resBlind, resAnte, resAll)
rp

# Get statistics by key attributes
rp %>%
    summarize(n=n(), across(c(resPlay, resBlind, resAnte, resAll), .fns=mean))

rp %>%
    group_by(wType, betPlay) %>%
    summarize(n=n(), across(c(resPlay, resBlind, resAnte, resAll), .fns=mean), .groups="drop") %>%
    arrange(desc(wType), betPlay)

rp %>%
    group_by(wType, resActual) %>%
    summarize(n=n(), across(c(resPlay, resBlind, resAnte, resAll), .fns=mean), .groups="drop") %>%
    arrange(desc(wType), resActual) %>%
    print(n=40)

rp %>%
    group_by(betPlay, resActual, res) %>%
    summarize(n=n(), 
              across(c(resPlay, resBlind, resAnte, resAll), .fns=list(mean=mean)), 
              .groups="drop"
              ) %>%
    arrange(betPlay)

```
  
The value of holding a specific card (no other values known) is explored:  
```{r, fig.height=9, fig.width=9}

# Full database of hands and outcomes
fullHandDB <- sortedHandRanks %>%
    select(handNum, rank, qual, nWild) %>%
    full_join(select(dfResAll_202301_v001, -handNum), by=c("rank", "nWild")) %>%
    mutate(nType=tblAllTypes$nType) %>%
    left_join(select(allValueGrid, wType=wildType, nType=naturalType, bonusPay), by=c("wType", "nType"))
fullHandDB

# Average bonus value given presence of card in hand
cardBonusValue <- map_dfr(.x=1:53,
                          .f=function(x) fullHandDB %>%
                              mutate(keyHand=ifelse(handNum %in% cardInHand[[x]], "Y", "N")) %>%
                              group_by(keyHand) %>%
                              summarize(n=n(), ev=mean(bonusPay), pctWin=mean(bonusPay>0)), 
                          .id="cardNum"
                          )

# Check that values are suit independent
map_dfr(.x=1:13, 
        .f=function(x) cardBonusValue %>% 
            filter(as.integer(cardNum) %in% (x+c(0, 13, 26, 39))) %>%
            group_by(keyHand) %>%
            summarize(across(where(is.numeric), .fns=function(x) max(x)-min(x))), 
        .id="cardRank"
        ) %>%
    summary()

# Show hand values
cardBonusValue %>%
    filter(as.integer(cardNum) %in% c(1:13, 53)) %>%
    select(haveCard=keyHand, cardNum, ev, winProb=pctWin) %>%
    pivot_longer(-c(haveCard, cardNum)) %>%
    mutate(haveCard=ifelse(haveCard=="Y", "1. First card is this", "2. First card is NOT this")) %>%
    ggplot(aes(x=fct_reorder(cardNum, 
                             value, 
                             .fun=function(x) x[order(x, decreasing=TRUE)[2]] + min(x)/100
                             )
               )
           ) + 
    geom_point(aes(y=value)) + 
    geom_text(aes(y=value+0.01, label=round(value, 3)), size=2.5, hjust=0) +
    coord_flip() + 
    facet_grid(haveCard~name, scales="free_x") +
    labs(title="Expected value of bonus given single card in hand", y="Average", x="Card Index")

```
  
As expected, wild cards are very valuable and make bonus hands much more likely. The deuce is more valuable than the joker since it can make higher-paying natural straights and flushes. Of the non-wild cards, 10 is most valuable (can make any straight, including royal), followed by 7-8-9 (can make any straight, naturally or wild)
  
The value of holding a specific card (no other values known) is explored:  
```{r, fig.height=9, fig.width=9}

# Average bonus value given presence of card in hand
cardMainValue <- map_dfr(.x=1:53,
                         .f=function(x) fullHandDB %>%
                             mutate(keyHand=ifelse(handNum %in% cardInHand[[x]], "Y", "N")) %>%
                             group_by(keyHand, betPlay) %>%
                             summarize(n=n(), 
                                       across(c(pLQ, pLN, pTQ, pTN, pWQ, pWN, evPlay, evAll), .fns=mean), 
                                       .groups="drop"
                                       ), 
                         .id="cardNum"
                         )

# Check that values are suit independent
map_dfr(.x=1:13, 
        .f=function(x) cardMainValue %>% 
            filter(as.integer(cardNum) %in% (x+c(0, 13, 26, 39))) %>%
            group_by(keyHand, betPlay) %>%
            summarize(across(where(is.numeric), .fns=function(x) max(x)-min(x)), .groups="drop"), 
        .id="cardRank"
        ) %>%
    summary()

# Show play bet size probabilities by initial card
cardMainValue %>%
    filter(as.integer(cardNum) %in% c(1:13, 53), keyHand=="Y") %>%
    group_by(cardNum) %>%
    mutate(pct=n/sum(n), cumpct=cumsum(pct)-pct/2) %>%
    ungroup() %>%
    ggplot(aes(x=factor(cardNum, levels=c(53, 2, 1, 13:3)))) + 
    geom_col(aes(y=pct, fill=fct_rev(factor(betPlay))), position="fill") + 
    geom_text(aes(y=cumpct, label=round(pct,3)), size=2.5) +
    labs(title="Play bet size by initial card", x="Initial card", y="Frequency") + 
    scale_fill_discrete("Play Bet")

# Show main bet EV by initial card and bet amount
cardMainValue %>%
    filter(as.integer(cardNum) %in% c(1:13, 53), keyHand=="Y") %>%
    group_by(cardNum) %>%
    summarize(across(c(evPlay, evAll), .fns=function(x) sum(x*n)/sum(n)), .groups="drop") %>%
    pivot_longer(-c(cardNum)) %>%
    ggplot(aes(x=factor(cardNum, levels=c(3:13, 1, 2, 53)))) + 
    geom_col(aes(y=value), fill="lightblue") + 
    geom_text(aes(y=value/2, label=round(value,3)), size=2.5) +
    labs(title="EV by initial card", x="Initial card", y="EV") + 
    coord_flip() +
    facet_wrap(~name)

# Show main bet EV by initial card and bet amount
cardMainValue %>%
    filter(as.integer(cardNum) %in% c(1:13, 53), keyHand=="Y") %>%
    select(cardNum, betPlay, evPlay, evAll) %>%
    pivot_longer(-c(cardNum, betPlay)) %>%
    ggplot(aes(x=factor(cardNum, levels=c(3:13, 1, 2, 53)))) + 
    geom_col(aes(y=value), fill="lightblue") + 
    geom_text(aes(y=value/2, label=round(value,3)), size=2.5) +
    labs(title="EV by initial card and bet size", x="Initial card", y="EV") + 
    coord_flip() +
    facet_grid(betPlay~name)

```
  
