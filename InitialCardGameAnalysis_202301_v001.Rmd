---
title: "Wild Card Game Analysis"
author: "davegoblue"
date: "2023-01-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
This file explores card games that use a standard 52-card deck, optionally modified so that one or more cards are wild, as follows:  
  
* One or more jokers may be added (the card has no natural rank or suit but may take on the most favorable)  
* One or more natural cards may also be used as a wild (in deuces wild, the deuce has a natural suit and rank and can also take on the suit and rank of a more favorable card)  
  
The analysis treats cards 1-52 as being the standard deck, with suits being 1-13, 14-26, 27-39, and 40-52. Counting the first card of each suit as 1, ranks are 1=Ace, 2-10=same card as value, 11=Jack, 12=Queen, 13=King. The Ace almost always plays as the highest rank, but can be treated as low for making a 5432A straight
  
## Methodology
### Basic Parameters
Several basic parameters of the game are established:  
```{r}

library(tidyverse) # tidyverse functionality is included throughout

nCards <- 53 # This is a standard 52-card deck with a joker
nRanks <- 13 # There are 13 ranks A, 2-10, J, Q, K
nSuits <- 4 # There are four suits, each of 13 cards
perHand <- 5 # Number of cards drawn per hand
idxWild <- c(2, 15, 28, 41, 53) # The indices of the cards that can be considered wild (deuces and the joker)

# Check alignment of basic parameters
if(nSuits*nRanks > nCards) stop("\nerror, misaligned parameters for number of ranks, suits, and cards\n")
if(!isTRUE(setdiff(1:nCards, 1:(nRanks*nSuits)) %in% idxWild %>% reduce(.f=`&`)))
    stop("\nError, any cards outside the standard nRanks*nSuits must be included in idxWild\n")

# Announce the number of wild cards
cat("\nThe game will be played with a", nCards, "card deck with", length(idxWild), "cards considered wild")
cat("\nWild cards are of indices", paste0(idxWild, collapse=", "))

# Announce any cards of no suit or rank
if(!isTRUE(idxWild %in% 1:(nRanks*nSuits) %>% reduce(.f=`&`))) { 
    cat("\nWilds with no natural rank or suit at indices:", 
        paste0(idxWild[!(idxWild %in% 1:(nRanks*nSuits))], collapse=",")
        )
} else cat("\nAll wilds have a natural suit and rank")

# Announce wilds with natural ranks and suits
if(isTRUE(idxWild %in% 1:(nRanks*nSuits) %>% reduce(.f=`|`))) { 
    tmpIdxWild <- idxWild[idxWild %in% 1:(nRanks*nSuits)]
    cat("\nWilds with natural rank and suit at indices:", paste0(tmpIdxWild, collapse=", "))
    cat("\nThese are of suit-independent rank", paste0((tmpIdxWild-1)%%nRanks+1, collapse=", "), "\n")
} else cat("\nNo wilds have a natural suit and rank\n")

```

All choose(nCards, perHand) combinations of hands are created based on index:  
```{r, cache=TRUE}

startTime <- proc.time()


# Create a matrix of all possible hand indices
mtxHands <- t(combn(1:nCards, perHand))
str(mtxHands)


proc.time() - startTime

```
  
Hands are scored for their hand type, optionally using wilds. Functions are written:  
```{r}

# Determine if a hand is a flush
isFlush <- function(suits, useWild=4) {
    apply(suits, 1, FUN=function(x) ifelse(min(x)==max(x), TRUE, (max(x[x!=useWild])==min(x[x!=useWild]))))
}

# Determine if a hand is a straight (hard-coded for 5-card hands in a 13-card deck, Ace high or low)
isStraight <- function(rankCounts, isEligible=TRUE) {
    # Exclusion matrix for straights, currently designed only for 13-card decks and A high or low
    strMatrix <- matrix(data=0L, nrow=13, ncol=10)
    strMatrix[c(1, 10, 11, 12, 13), 1] <- 1L
    for (intCtr in 1:9) { strMatrix[intCtr:(intCtr+4), intCtr+1] <- 1L }
    apply(rankCounts, 1, max)<=1 & rowSums(rankCounts%*%(strMatrix-1)==0)>=1 & isEligible
}

# Hard-coded for 52-card deck with 1 joker
findHandTypes <- function (aHands, retAll=FALSE) {
    
    # Track hands that contain the joker and total number of wilds
    aJoker <- rowSums(aHands==53)>0
    nWild <- aJoker + rowSums(aHands%%13==2)
    
    # 1. Calculate natural values
    # 1a. Calculate ranks and suits, counting the joker as having no "rank" and being of a fifth "suit"
    aRanks <- ifelse(aHands==53, 0, 1 + (aHands-1) %% 13)
    aSuits <- ifelse(aHands==53, 0, 1 + (aHands-1) %/% 13)

    # 1b. Find the counts by rank in each hand
    aRankCount <- matrix(data=-1L, nrow=nrow(aHands), ncol=13)
    for (intCtr in 1:13) { aRankCount[, intCtr] <- rowSums(aRanks == intCtr) }
        
    # 1c. Find the natural flushes and straights
    nFlush <- isFlush(aSuits, useWild=-1)
    nStraight <- isStraight(aRankCount, isEligible=!aJoker)

    # 1d. Find max and count of ranks
    nQuads <- rowSums(aRankCount == 4)
    nTrips <- rowSums(aRankCount == 3)
    nPairs <- rowSums(aRankCount == 2)

    # 1e. Score the natural hand values (default is that a hand has nothing of value)
    nType <- rep(0L, nrow(aHands))
    # Five wilds (cannot exist) <- 1
    nType[nFlush==1 & nStraight==1 & aRankCount[, 1]==1 & aRankCount[, 13]==1] <- 2 # Royal
    # Five of a kind (cannot exist as natural) <- 3
    nType[nFlush==1 & nStraight==1 & (aRankCount[, 1]!=1 | aRankCount[, 13]!=1)] <- 4 # Straight flush
    nType[nQuads==1] <- 5 # Four of a kind
    nType[nTrips==1 & nPairs==1] <- 6 # Full House
    nType[nFlush==1 & nStraight==0] <- 7 # Flush
    nType[nFlush==0 & nStraight==1] <- 8 # Straight
    nType[nTrips==1 & nPairs==0] <- 9 # Three of a Kind
    nType[nPairs==2] <- 10 # Two Pair
    nType[nTrips==0 & nPairs==1] <- 11 # Pair

    
    # 2. Calculate wild values
    # 2a. Calculate ranks and suits, counting the joker and 2's as having no "rank" and being of a fifth "suit"
    wRanks <- ifelse(aHands==53|(aHands%%13==2), 0, 1 + (aHands-1) %% 13)
    wSuits <- ifelse(aHands==53|(aHands%%13==2), 0, 1 + (aHands-1) %/% 13)

    # 2b. Find the counts by rank in each hand
    wRankCount <- matrix(data=-1L, nrow=nrow(aHands), ncol=13)
    for (intCtr in 1:13) { wRankCount[, intCtr] <- rowSums(wRanks == intCtr) }
        
    # 2c. Find the wild flushes and straights
    wFlush <- isFlush(wSuits, useWild=0)
    wStraight <- isStraight(wRankCount, isEligible=TRUE)
    
    # 2d. Find max and count of ranks
    wQuads <- rowSums(wRankCount == 4)
    wTrips <- rowSums(wRankCount == 3)
    wPairs <- rowSums(wRankCount == 2)

    # 2e. Score the wild hand values (default is that a hand has nothing of value)
    wType <- rep(0L, nrow(aHands))
    
    # 2e1. Calculate number of royal cards in hand
    nRoyal <- rowSums(wRankCount[, c(1, 10, 11, 12, 13)])
    
    # 2e2. Five wilds (always five wilds)
    wType[nWild==5] <- 1 # Five wild
    
    # 2e3. Four wilds (always either royal flush or five of a kind)
    wType[nWild==4 & nRoyal==1] <- 2 # Royal
    wType[nWild==4 & nRoyal==0] <- 3 # Five of a kind
    
    # 2e4. Three wilds (always either royal flush or five of a kind or straight flush or four of a kind)
    wType[nWild==3 & wFlush==1 & wStraight==1 & nRoyal==2] <- 2 # Royal
    wType[nWild==3 & wPairs==1] <- 3 # Five of a kind
    wType[nWild==3 & wFlush==1 & wStraight==1 & nRoyal<2] <- 4 # Straight Flush
    wType[nWild==3 & !(wFlush==1 & wStraight==1) & wPairs==0] <- 5 # Four of a kind
    
    # 2e5. Two wilds (always either royal, five of a kind, straight flush, four of a kind, flush, straight, trips)
    # Cannot be a full house as any 3-2 using two wilds could instead be 5-0 or 1-4 and thus a better hand
    wType[nWild==2 & wFlush==1 & wStraight==1 & nRoyal==3] <- 2 # Royal
    wType[nWild==2 & wTrips==1] <- 3 # Five of a kind
    wType[nWild==2 & wFlush==1 & wStraight==1 & nRoyal<3] <- 4 # Straight Flush
    wType[nWild==2 & wPairs==1] <- 5 # Four of a kind
    wType[nWild==2 & wFlush==1 & wStraight==0] <- 7 # Flush
    wType[nWild==2 & wFlush==0 & wStraight==1] <- 8 # Straight
    wType[nWild==2 & !(wFlush==1 | wStraight==1) & wPairs==0 & wTrips==0] <- 9 # Three of a kind
    
    # 2e6. One wild (can be anything from pair to royal, with the exception of never two pair)
    wType[nWild==1 & wFlush==1 & wStraight==1 & nRoyal==4] <- 2 # Royal
    wType[nWild==1 & wQuads==1] <- 3 # Five of a kind
    wType[nWild==1 & wFlush==1 & wStraight==1 & nRoyal<4] <- 4 # Straight Flush
    wType[nWild==1 & wTrips==1] <- 5 # Four of a kind
    wType[nWild==1 & wPairs==2] <- 6 # Full House
    wType[nWild==1 & wFlush==1 & wStraight==0] <- 7 # Flush
    wType[nWild==1 & wFlush==0 & wStraight==1] <- 8 # Straight
    wType[nWild==1 & wPairs==1] <- 9 # Three of a kind
    wType[nWild==1 & !(wFlush==1 | wStraight==1) & wPairs==0 & wTrips==0 & wQuads==0] <- 11 # Pair
    
    # 2e7. No wild (is identical to natural)
    wType[nWild==0] <- nType[nWild==0]
    
    # Return the requested data
    if (isTRUE(retAll)) {
        list(nType=nType, 
             wType=wType, 
             nWild=nWild,
             wRankCount=wRankCount,
             aRankCount=aRankCount
             )
    } else {
        list(nType=nType, wType=wType, nWild=nWild)
    }
    
}

```
  
```{r, cache=TRUE}

# Calculate hands
tmpTime <- proc.time(); tmpHandTypes<-findHandTypes(mtxHands, retAll=TRUE); proc.time()-tmpTime

```
  
Hand types are evaluated:  
```{r, fig.height=9, fig.width=9}

# Create tibble
tblAllTypes <- tibble::tibble(wType=tmpHandTypes$wType, 
                              nType=tmpHandTypes$nType, 
                              nWild=tmpHandTypes$nWild
                              ) %>%
    mutate(wType=ifelse(wType==0, 99, wType), 
           nType=ifelse(nType==0, 99, nType)
           )
tblAllTypes

# Plot the overlaps
tblAllTypes %>%
    count(wType, nType) %>%
    mutate(wType=ifelse(wType %in% c(1, 3), case_when(wType==3 ~ "3 (5K)", wType==1 ~ "1 (5W)"), wType), 
           nType=case_when(nType==2 ~ "2 (RF)", nType==4 ~ "4 (SF)", nType==5 ~ "5 (4K)", nType==6 ~ "6 (FH)", 
                           nType==7 ~ "7 (FL)", nType==8 ~ "8 (ST)", nType==9 ~ "9 (3K)", nType==10 ~ "10 (2P)", 
                           nType==11 ~ "11 (Pair)", nType==99 ~ "99 (HC)", TRUE ~ "Error"
                           )
           ) %>%
    mutate(wType=factor(wType, 
                        levels=c("99", "11", "10", "9", "8", "7", "6", "5", "4", "3 (5K)", "2", "1 (5W)")
                        ), 
           nType=factor(nType, 
                        levels=c("99 (HC)", "11 (Pair)", "10 (2P)", "9 (3K)", "8 (ST)", "7 (FL)", 
                                 "6 (FH)", "5 (4K)", "4 (SF)", "2 (RF)"
                                 )
                        )
           ) %>%
    ggplot(aes(x=wType, y=nType)) + 
    geom_tile(aes(fill=(n>0))) + 
    geom_text(aes(label=n), size=3) + 
    scale_fill_discrete("Overlap\nexists?") + 
    labs(title="Number of hands by type in 53c5 game", 
         subtitle="Deuces can be natural or wild, joker (card 53) is wild only", 
         y="Natural hand type", 
         x="Wild hand type"
         )

```
  
Hands can be scored based on a paytable for both wild-type hands and natural-type hands (only the highest payout applies). An example from the game "DJ Wild" is assessed:  
```{r, fig.height=9, fig.width=9}

# Hand values
handValues <- tibble::tibble(handRank=c(1:11, 99), 
                             handDesc=c("5W", "RF", "5K", "SF", "4K", "FH", "FL", "ST", "3K", "2P", "1P", "HC"),
                             handLabel=paste0(handRank, " (", handDesc, ")"),
                             blindPay=c(2000, 100, 40, 25, 5, 4, 3, 2, 0, 0, 0, 0),
                             wildPay=c(2000, 90, 70, 25, 6, 5, 4, 3, 1, -1, -1, -1), 
                             naturalPay=c(NA, 1000, NA, 200, 60, 30, 25, 20, 6, -1, -1, -1)
                             )
handValues

# Create a mapping vector for type to description
vecMapHands <- handValues$handLabel %>% purrr::set_names(handValues$handRank)

# Payout grid plotted for all possible values
allValueGrid <- expand.grid(wildType=c(1:11, 99), naturalType=c(1:11, 99)) %>%
    tibble::tibble() %>%
    full_join(count(tblAllTypes, wType, nType), by=c("wildType"="wType", "naturalType"="nType")) %>%
    mutate(bestType=pmin(wildType, naturalType)) %>%
    left_join(select(handValues, handRank, wildPay), by=c("wildType"="handRank")) %>%
    left_join(select(handValues, handRank, naturalPay), by=c("naturalType"="handRank")) %>%
    left_join(select(handValues, handRank, blindPay), by=c("bestType"="handRank")) %>%
    mutate(bonusPay=pmax(wildPay, naturalPay, na.rm=TRUE))
allValueGrid

# Plot of payout values
allValueGrid %>%
    filter(!is.na(n)) %>%
    ggplot(aes(x=fct_rev(factor(vecMapHands[as.character(wildType)], levels=vecMapHands)), 
               y=fct_rev(factor(vecMapHands[as.character(naturalType)], levels=vecMapHands))
               )
           ) + 
    geom_tile(fill="lightgreen") +
    geom_text(aes(label=bonusPay)) + 
    labs(title="Example payouts by type in 53c5 game", 
         subtitle="Deuces can be natural or wild, joker (card 53) is wild only", 
         y="Natural hand type", 
         x="Wild hand type"
         )

# EV of payout values
allValueGrid %>%
    filter(!is.na(n)) %>%
    summarize(totPays=sum(n*bonusPay), n=sum(n)) %>%
    mutate(ev=totPays/n)

# Table by hand type
allValueTable <- allValueGrid %>%
    filter(!is.na(n)) %>%
    mutate(natWild=ifelse(naturalPay>wildPay, "Natural", "Wild"), 
           reportBonusType=ifelse(natWild=="Natural", naturalType, wildType),
           reportBonusLabel=factor(vecMapHands[as.character(reportBonusType)], levels=vecMapHands)
           ) %>%
    group_by(natWild, reportBonusLabel, bonusPay) %>%
    summarize(n=sum(n), .groups="drop") %>%
    mutate(prob=n/sum(n), per=1/prob, ev=n*bonusPay/sum(n))
allValueTable
allValueTable %>% select(n, ev) %>% colSums() %>% round(4)

```
  
Convert all hands to a value with ranks for tie-breaking (Ace high, with 5432A straights treated as having first tie-breaker 5 and last tie-breaker A). Hands are first converted to counts by rank with wild cards filling the next best ranks:  
```{r}

# Get the number of wilds in each hand
perHandNWild <- (rowSums(mtxHands==53)>0) + rowSums(mtxHands%%13==2)

# Get the ranks in each hand
perHandRanks <- ifelse(mtxHands==53, 0, 1 + (mtxHands-1) %% 13) # track joker as wild
perHandRanks[perHandRanks==2] <- 0 # track deuces as wild, ignore rank (place as best later)
perHandRanks[perHandRanks==1] <- 14 # count Aces as high

# Create the matrix of card types
perHandRankCount <- matrix(data=-1L, nrow=nrow(mtxHands), ncol=14)
for (intCtr in 1:14) { perHandRankCount[, intCtr] <- rowSums(perHandRanks == intCtr) }

# Create a tie-breaker matrix filled with 0's (column 13 is Ace)
mtxTieBreak <- matrix(data=0L, nrow=nrow(mtxHands), ncol=13)

# Function to get the cards in a straight
getStraightType <- function(x) {
    if(min(x[x>0]) >= 10) c(10, 11, 12, 13, 14)
    else if(min(x[x>0]) <= 5 & max(x)==14) c(2, 3, 4, 5, 14) # this treats Ace as the last card to resolve (Ace low)
    else seq(min(x[x>0]), min(x[x>0])+4)
}

# Function to get the cards in a flush
getFlushType <- function(x) {
    # Wild cards should be added as highest rank not already in hand (try A then K then Q then J then T)
    numAdd <- sum(x==0)
    if(numAdd > 0) {
        notThere <- (14:10)[!((14:10) %in% x)][1:numAdd]
        x <- c(x[x!=0], notThere)
    }
    sort(x, decreasing=TRUE)
}

# Function to get the cards in a four of a kind, full house, three of a kind, two pair, pair, or high card
getHighTypes <- function(rks, idx=1:14, outNum=c(1, 1, 1, 1, 1)) {
    vecOut <- rep(0L, length(outNum))
    for(x in seq_along(outNum)) {
        vecOut[x]<-max((rks==max(rks)) * idx)
        rks[match(vecOut[x], idx)] <- 0
    }
    rep(vecOut, times=outNum)
}

# 1. Five wild (nothing to do)
# 2. Royal flush (make the ranks 1 in the last 5 columns)
perHandRanks[tmpHandTypes$wType==2, ] <- t(apply(perHandRanks[tmpHandTypes$wType==2, ], 1, FUN=getStraightType))
# 3. Five of a kind (make the ranks all the same as the only rank)
perHandRanks[tmpHandTypes$wType==3, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==3, ], 
                                           1, 
                                           FUN=getHighTypes, 
                                           outNum=c(5)
                                           )
                                     )
# 4. Straight flush (make the ranks all the best straight possible)
perHandRanks[tmpHandTypes$wType==4, ] <- t(apply(perHandRanks[tmpHandTypes$wType==4, ], 1, FUN=getStraightType))
# 5. Four of a kind (make the ranks four of the most frequent card or the highest card, one of the other)
perHandRanks[tmpHandTypes$wType==5, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==5, ], 
                                           1, 
                                           FUN=getHighTypes, 
                                           outNum=c(4, 1)
                                           )
                                     )
# 6. Full house (make the ranks three of the most frequent card, two of the other)
perHandRanks[tmpHandTypes$wType==6, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==6, ], 
                                           1, 
                                           FUN=getHighTypes, 
                                           outNum=c(3, 2)
                                           )
                                     )
# 7. Flush (need to implement)
perHandRanks[tmpHandTypes$wType==7, ] <- t(apply(perHandRanks[tmpHandTypes$wType==7, ], 1, FUN=getFlushType))
# 8. Straight (make the ranks all the best straight possible)
perHandRanks[tmpHandTypes$wType==8, ] <- t(apply(perHandRanks[tmpHandTypes$wType==8, ], 1, FUN=getStraightType))
# 9. Three of a kind (make the ranks three of the most frequent or highest card, one each of the other)
perHandRanks[tmpHandTypes$wType==9, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==9, ], 
                                           1, 
                                           FUN=getHighTypes, 
                                           outNum=c(3, 1, 1)
                                           )
                                     )
# 10. Two pair (make the ranks two of the highest pair, two of the lowest pair, one of the remainder)
perHandRanks[tmpHandTypes$wType==10, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==10, ], 
                                            1, 
                                            FUN=getHighTypes, 
                                            outNum=c(2, 2, 1)
                                            )
                                      )
# 11. One pair (make the ranks two of the pair or highest card, one each of the remainder)
perHandRanks[tmpHandTypes$wType==11, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==11, ], 
                                            1, 
                                            FUN=getHighTypes, 
                                            outNum=c(2, 1, 1, 1)
                                            )
                                      )
# 0. High card (make the ranks in order of the highest cards)
perHandRanks[tmpHandTypes$wType==0, ] <- t(apply(perHandRankCount[tmpHandTypes$wType==0, ], 
                                            1, 
                                            FUN=getHighTypes, 
                                            outNum=c(1, 1, 1, 1, 1)
                                            )
                                      )

# Create the hand ranking table
allHandRanks <- tibble::tibble(handNum=1:nrow(mtxHands), wType=tmpHandTypes$wType) %>% 
    bind_cols(perHandRanks) %>% 
    set_names(c("handNum", "wType", "tb1", "tb2", "tb3", "tb4", "tb5")) %>% 
    mutate(wType=ifelse(wType==0, 99, wType)) %>% 
    arrange(wType, desc(tb1), desc(tb2), desc(tb3), desc(tb4), desc(tb5)) %>% 
    mutate(chgRank=ifelse(row_number()==1 | wType!=lag(wType) | tb1 != lag(tb1) | tb2 != lag(tb2) | tb3 != lag(tb3) | tb4 != lag(tb4) | tb5 != lag(tb5), 1, 0), 
           rank=cumsum(chgRank)
           )
allHandRanks %>%
    count(wType, rank, tb1, tb2, tb3, tb4, tb5) %>%
    arrange(-n, rank) %>%
    mutate(nvr=row_number()) %>%
    group_by(wType) %>%
    mutate(nty=row_number()) %>%
    ungroup() %>%
    filter(nvr<=10 | nty==1)

```
  
As expected, straight is the hand type with the greatest number of possible ties (there are only 10 types of straight and each can have 1,024 permutations of suits)

A function is written to assess probabilities associated with any given hand:  
```{r}

# Sort allHandRanks and ensure handNum and row_number() match
sortedHandRanks <- allHandRanks %>%
    mutate(qual=ifelse(wType<=11, "Q", "N")) %>%
    arrange(handNum)
if (sum((sortedHandRanks$handNum) != (1:nrow(sortedHandRanks)))>0) 
    stop("\nError in handNum order in sortedHandRanks\n")

# Function to get probabilities
findHandProbs <- function(exRank, idxExclude=NULL, df=sortedHandRanks) {
    rkData <- if(is.null(idxExclude)) df$rank else df$rank[-idxExclude]
    qualData <- if(is.null(idxExclude)) df$qual else df$qual[-idxExclude]
    pLN <- mean(rkData < exRank & qualData=="N")
    pLQ <- mean(rkData < exRank & qualData=="Q")
    pTN <- mean(rkData == exRank & qualData=="N")
    pTQ <- mean(rkData == exRank & qualData=="Q")
    pWN <- mean(rkData > exRank & qualData=="N")
    pWQ <- mean(rkData > exRank & qualData=="Q")
    pWNoTie <- (pWN+pWQ)/(1-pTN-pTQ)
    c(pLN=pLN, pLQ=pLQ, pTN=pTN, pTQ=pTQ, pWN=pWN, pWQ=pWQ, pWNoTie=pWNoTie)
}

# Example hand index
exHandNum <- 123456
exHandRank <- sortedHandRanks$rank[exHandNum]
cat("\nExample hand", 
    exHandNum, 
    "is of type", 
    sortedHandRanks$wType[exHandNum], 
    "and rank",
    exHandRank,
    "with cards", 
    mtxHands[exHandNum,], 
    "\n"
    )

res <- findHandProbs(exHandRank)
cat("Associated probabilities (if cards in example hand available to replay):", 
    "\nLoss: ", res["pLN"]+res["pLQ"], 
    "\nTie: ", res["pTN"]+res["pTQ"],
    "\nWin (no qualify): ", res["pWN"], 
    "\nWin (qualify): ", res["pWQ"], 
    "\nWin (excluding ties):", res["pWNoTie"],
    "\np(dealer qualifies):", res["pLQ"]+res["pTQ"]+res["pWQ"],
    "\nOptimal action: ", ifelse(res["pWNoTie"]<0.25, "Fold", ifelse(res["pWNoTie"]<=0.5, "Single", "Double")),
    "\n"
    )

```

The function is run excluding unavailable cards (e.g., none of a player's cards can appear in the dealer's hand):  
