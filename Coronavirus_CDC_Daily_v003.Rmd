---
title: "CDC Daily by State"
author: "davegoblue"
date: "8/3/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
This file is designed to use CDC data to assess coronavirus disease burden by state, including creating and analyzing state-level clusters.

Through March 7, 2021, [The COVID Tracking Project](https://covidtracking.com/) collected and integrated data on tests, cases, hospitalizations, deaths, and the like by state and date.  The latest code for using this data is available in Coronavirus_Statistics_CTP_v004.Rmd.

The COVID Tracking Project suggest that [US federal data sources](https://covidtracking.com/analysis-updates/federal-covid-data-101-how-to-find-data) are now sufficiently robust to be used for analyses that previously relied on COVID Tracking Project.  This code is an attempt to update modules in Coronavirus_Statistics_CTP_v004.Rmd to leverage US federal data.

The code in this module builds on code available in _v002 to include vaccines data:  
  
* Generic_Added_Utility_Functions_202105_v001.R - generic functions that can be used in other areas  
* Coronavirus_CDC_Daily_Functions_v001.R - functions specific to coronavirus daily data  
  
Broadly, the CDC data analyzed by this module includes:  
  
* CDC case and death data by state and date are available for download on the [CDC website](https://data.cdc.gov/api/views/9mfq-cb36/rows.csv?accessType=DOWNLOAD)  
* CDC hospital data are available for download on the [healthdata.gov website](https://beta.healthdata.gov/api/views/g62h-syeh/rows.csv?accessType=DOWNLOAD)  
* CDC vaccines data are also available for download on the [CDC website](https://data.cdc.gov/api/views/unsk-b7fc/rows.csv?accessType=DOWNLOAD):  
  
## Functions and Mapping Files
The tidyverse package is loaded and functions are sourced:  
```{r}

# The tidyverse functions are routinely used without package::function format
library(tidyverse)

# Functions are available in source file
source("./Generic_Added_Utility_Functions_202105_v001.R")
source("./Coronavirus_CDC_Daily_Functions_v001.R")

```

A series of mapping files are also available to allow for parameterized processing.  Mappings include:  
  
* urlMapper - mapping file for urlType and url location to download data  
* renMapper - mapping file for renaming of variables in the raw data file  
* selfListMapper - mapping file for transformations by variable type  
* fullListMapper - mapping file for transformations across variable types  
* lstComboMapper - mapping file for elements to be combined by data type (most common is to combine NYC and NYS data to NY if the file provides them separately)  
* uqMapper - mapping file for fields that should combine to be unique keys for processed files  
* lstFilterMapper - mapping file for filtering to subset (most common is to keep 50 states and DC)  
* vecSelectMapper - mapping file for variables to keep  
* checkControlGroupMapper - mapping file for group_by() of control total checks  
* checkControlAggMapper - mapping file for numeric variables for control total checks  
* checkSimilarityMapper - mapping file for similarity checks to perform  
* plotSimilarityMaooer - mapping file for fields where differences in universe should be plotted
* keyAggMapper - mapping file for the aggregate-level control total checks to perform  
* perCapMapper - named vector that drives conversion from original field name to per capita field name  
  
These default parameters are maintained in a separate .R file and can be sourced:  
```{r}

source("./Coronavirus_CDC_Daily_Default_Mappings_v002.R")

```

## Example for Comparison to Previous
The function is tested on existing, previously downloaded data:  
```{r, fig.height=9, fig.width=9}

readList <- list("cdcDaily"="./RInputFiles/Coronavirus/CDC_dc_downloaded_210801.csv", 
                 "cdcHosp"="./RInputFiles/Coronavirus/CDC_h_downloaded_210801.csv", 
                 "vax"="./RInputFiles/Coronavirus/vaxData_downloaded_210801.csv"
                 )
compareList <- list("cdcDaily"=readFromRDS("cdc_daily_210708")$dfRaw$cdcDaily, 
                    "cdcHosp"=readFromRDS("cdc_daily_210708")$dfRaw$cdcHosp, 
                    "vax"=readFromRDS("cdc_daily_210728_vaxonly")$dfRaw$vax
                    )

cdc_daily_210801_test <- readRunCDCDaily(thruLabel="Jul 31, 2021", 
                                         downloadTo=lapply(readList, FUN=function(x) if(file.exists(x)) NA else x), 
                                         readFrom=readList,
                                         compareFile=compareList, 
                                         writeLog=NULL, 
                                         useClusters=readFromRDS("cdc_daily_210528")$useClusters, 
                                         weightedMeanAggs=c("tcpm7", "tdpm7", "cpm7", "dpm7", "hpm7", 
                                                            "vxcpm7", "vxcgte65pct"
                                                            ),
                                         skipAssessmentPlots=FALSE, 
                                         brewPalette="Paired"
                                         )

all.equal(names(cdc_daily_210801_test), names(readFromRDS("cdc_daily_210801")))
sapply(names(cdc_daily_210801_test), FUN=function(x)
    identical(cdc_daily_210801_test[[x]], readFromRDS("cdc_daily_210801")[[x]])
    )
sapply(names(cdc_daily_210801_test$plotDataList), FUN=function(x)
    identical(cdc_daily_210801_test$plotDataList[[x]], readFromRDS("cdc_daily_210801")$plotDataList[[x]])
    )

```
  
As expected, all data elements are identical.  Plot environments change with each creation, so the plot objects are not identical.

The latest data are downloaded and processed, with caching to avoid multiple file downloads:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

readList <- list("cdcDaily"="./RInputFiles/Coronavirus/CDC_dc_downloaded_210804.csv", 
                 "cdcHosp"="./RInputFiles/Coronavirus/CDC_h_downloaded_210804.csv", 
                 "vax"="./RInputFiles/Coronavirus/vaxData_downloaded_210804.csv"
                 )
compareList <- list("cdcDaily"=readFromRDS("cdc_daily_210708")$dfRaw$cdcDaily, 
                    "cdcHosp"=readFromRDS("cdc_daily_210708")$dfRaw$cdcHosp, 
                    "vax"=readFromRDS("cdc_daily_210728_vaxonly")$dfRaw$vax
                    )

cdc_daily_210804 <- readRunCDCDaily(thruLabel="Aug 3, 2021", 
                                    downloadTo=lapply(readList, FUN=function(x) if(file.exists(x)) NA else x), 
                                    readFrom=readList,
                                    compareFile=compareList, 
                                    writeLog=NULL, 
                                    useClusters=readFromRDS("cdc_daily_210528")$useClusters, 
                                    weightedMeanAggs=c("tcpm7", "tdpm7", "cpm7", "dpm7", "hpm7", 
                                                       "vxcpm7", "vxcgte65pct"
                                                       ),
                                    skipAssessmentPlots=FALSE, 
                                    brewPalette="Paired"
                                    )

saveToRDS(cdc_daily_210804)

```

The raw hospital data is explored for admissions with confirmed/suspected coronavirus:  
```{r, fig.height=9, fig.width=9}

cdcHospAdmit_210804 <- cdc_daily_210804$dfRaw$cdcHosp %>%
    select(state, date, ends_with("confirmed"), ends_with("suspected")) %>%
    filter(state %in% c(state.abb, "DC")) %>%
    arrange(date, state) %>%
    pivot_longer(-c(state, date)) %>%
    mutate(name=stringr::str_replace(name, pattern="previous_day_admission_", replacement=""), 
           name=stringr::str_replace(name, pattern="_covid", replacement="")
           ) %>%
    left_join(getStateData(keepVars=c("state", "pop")), by="state") %>%
    mutate(vpm=1000000*value/pop) %>%
    group_by(state, name) %>%
    mutate(vpm7=zoo::rollmean(vpm, k=7, fill=NA)) %>%
    ungroup()

cdcHospAdmit_210804 %>%
    filter(!is.na(vpm7), state %in% state.abb) %>%
    mutate(div=as.character(state.division)[match(state, state.abb)]) %>%
    group_by(div, date, name) %>%
    summarize(wt_vpm7=sum(pop*vpm7)/sum(pop), tot_pop=sum(pop), .groups="drop") %>%
    ggplot(aes(x=date, y=wt_vpm7)) + 
    geom_col(aes(fill=name), position="stack") + 
    facet_wrap(~div) + 
    scale_fill_discrete("Metric") + 
    labs(x=NULL, 
         y="Newly admitted for COVID per million (rolling 7-day)", 
         title="Hospital admissions for COVID", 
         subtitle="All metrics divided by total population (all ages) for states reporting"
         )

```

Hospital coverage data became robust about a year ago.  The overwhelming majority of admissions are adult, split between confirmed and suspected cases.  Next steps are to explore changes in admissions by age groups:  
```{r, fig.height=9, fig.width=9}

hospAge_210804 <- cdc_daily_210804$dfRaw$cdcHosp %>%
    select(state, 
           date, 
           grep(x=names(.), pattern="ed_\\d.*[9+]$", value=TRUE), 
           grep(x=names(.), pattern="pediatric.*ed$", value=TRUE)
           ) %>% 
    pivot_longer(-c(state, date)) %>% 
    mutate(confSusp=ifelse(grepl(x=name, pattern="confirmed"), "confirmed", "suspected"), 
           adultPed=ifelse(grepl(x=name, pattern="adult"), "adult", "ped"), 
           age=ifelse(adultPed=="ped", "0-17", stringr::str_replace_all(string=name, pattern=".*_", replacement="")), 
           age=ifelse(age %in% c("0-17", "18-19"), "0-19", age), 
           div=as.character(state.division)[match(state, state.abb)]
           ) 
hospAge_210804

# Plot for overall trends by age group
p1 <- hospAge_210804 %>% 
    filter(state %in% c(state.abb, "DC"), !is.na(value)) %>% 
    mutate(ageBucket=age) %>% 
    group_by(date, ageBucket) %>% 
    summarize(value=sum(value), .groups="drop") %>% 
    arrange(date) %>%
    group_by(ageBucket) %>% 
    mutate(value7=zoo::rollmean(value, k=7, fill=NA)) %>% 
    filter(date >= "2020-08-01") %>% 
    ggplot(aes(x=date, y=value7)) + 
    labs(x=NULL, 
         y="Confirmed or suspected COVID admissions (rolling-7 mean)", 
         title="Hospital admissions for COVID by age bucket (Aug 2020 - Jul 2021)", 
         subtitle="50 states and DC (includes confirmed and suspected from CDC data)"
         ) + 
    lims(y=c(0, NA))

# Line plots by age group
p1 + 
    geom_line(aes(group=ageBucket, color=ageBucket), size=1) + 
    scale_color_discrete("Age\nbucket")
# Stacked bar plots by age group
p1 + 
    geom_col(aes(fill=ageBucket), position="stack") + 
    scale_color_discrete("Age\nbucket")
# Proportions by age group
p1 + 
    geom_col(aes(fill=ageBucket), position="fill") + 
    scale_color_discrete("Age\nbucket")

# Plot for overall trends by age group
hospAge_210804 %>% 
    filter(state %in% state.abb, !is.na(value)) %>% 
    mutate(ageBucket=ifelse(age >= "60", "60+", ifelse(age=="0-19", "0-19", "20-59"))) %>% 
    group_by(date, state, ageBucket) %>% 
    summarize(value=sum(value), .groups="drop") %>% 
    group_by(ageBucket, state) %>% 
    mutate(value7=zoo::rollmean(value, k=7, fill=NA)) %>% 
    filter(date >= "2020-06-01") %>% 
    ggplot(aes(x=date, y=value7)) + 
    geom_line(aes(color=ageBucket, group=ageBucket)) + 
    scale_color_discrete("Age\nbucket") + 
    labs(x=NULL, 
         y="Confirmed or suspected COVID admissions (rolling-7 mean)", 
         title="Hospital admissions for COVID by age bucket (Aug 2020 - Jul 2021)"
         ) + 
    lims(y=c(0, NA)) + 
    facet_wrap(~state, scales="free_y")

```

Next steps are to explore alignment of the hospitalization and case/death curves.  Michigan having had a distinct spring peak is used as an example:  
```{r, fig.height=9, fig.width=9}

allHosp_210804 <- hospAge_210804 %>%
    mutate(ageBucket=ifelse(age >= "60", "60+", ifelse(age=="0-19", "0-19", "20-59"))) %>% 
    group_by(date, state, ageBucket) %>% 
    summarize(value=sum(value), .groups="drop") %>% 
    group_by(ageBucket, state) %>% 
    mutate(value7=zoo::rollmean(value, k=7, fill=NA)) %>%
    ungroup() %>%
    left_join(getStateData(keepVars=c("state", "pop"))) %>%
    mutate(vpm7=1000000*value7/pop)
allHosp_210804

allCaseDeath_210804 <- cdc_daily_210804$dfPerCapita %>%
    select(state, date, new_cases, new_deaths, vxa, vxc, cpm7, dpm7, vxapm7, vxcpm7) %>%
    pivot_longer(-c(state, date))
allCaseDeath_210804

allPivot_210804 <- allHosp_210804 %>%
    select(state, date, name=ageBucket, value=vpm7) %>%
    bind_rows(allCaseDeath_210804) %>%
    checkUniqueRows(uniqueBy=c("state", "date", "name"))
allPivot_210804

# Plot Michigan data
typeMapper <- c("cases"="1. Cases per million per day (rolling 7 mean)", 
                "deaths"="2. Deaths per million per day (rolling 7 mean)", 
                "hosp"="3. Admitted to hospital per million per day (rolling 7 mean)", 
                "vax"="4. Vaccinated per capita (administered, completed)"
                )
allPivot_210804 %>%
    filter(state=="MI", !is.na(value)) %>%
    mutate(plotType=case_when(name %in% c("0-19", "20-59", "60+") ~ "hosp", 
                              name %in% c("vxapm7", "vxcpm7") ~ "vax", 
                              name=="cpm7" ~ "cases", 
                              name=="dpm7" ~ "deaths", 
                              TRUE ~ "notuse"
                              )
           ) %>%
    filter(plotType != "notuse") %>%
    ggplot(aes(x=date, y=value)) + 
    geom_line(data=~filter(., plotType=="cases"), color="blue", size=1) +
    geom_line(data=~filter(., plotType=="deaths"), color="red", size=1) +
    geom_line(data=~filter(., plotType=="vax"), aes(color=name, group=name, y=value/1000000)) +
    geom_col(data=~filter(., plotType=="hosp"), aes(fill=name), position="stack") + 
    scale_color_discrete("Vaccine\nMetric") + 
    scale_fill_discrete("Hospitalized\nby Age") +
    facet_wrap(~typeMapper[plotType], scales="free_y") + 
    labs(x=NULL, y=NULL) +
    lims(y=c(0, NA))

hospCase <- 10
allPivot_210804 %>%
    filter(state=="MI", !is.na(value)) %>%
    mutate(plotType=case_when(name %in% c("0-19", "20-59", "60+") ~ "hosp", 
                              name %in% c("vxapm7", "vxcpm7") ~ "vax", 
                              name=="cpm7" ~ "cases", 
                              name=="dpm7" ~ "deaths", 
                              TRUE ~ "notuse"
                              )
           ) %>%
    filter(plotType %in% c("cases", "hosp")) %>%
    ggplot(aes(x=date, y=value)) + 
    geom_col(data=~filter(., plotType=="hosp"), aes(fill=name, y=hospCase*value), position="stack") + 
    geom_line(data=~filter(., plotType=="cases"), color="black", size=1) +
    scale_fill_discrete("Hospital Admssions by Age") + 
    scale_y_continuous("Cases per million (rolling 7 mean per day)", 
                       sec.axis = sec_axis(~ . / hospCase, 
                                           name = "Hospital admissions per million (rolling 7 mean per day"
                                           )
                       ) +
    labs(x=NULL, 
         title="Alignment of Michigan cases and hospitalizations data", 
         subtitle=paste0("Ratio of ", 
                         hospCase, 
                         ":1 applied (cases are black line, hospital admissions are stacked bar)"
                         )
         ) + 
    theme(legend.position="bottom")

hospDeath <- 0.2
allPivot_210804 %>%
    filter(state=="MI", !is.na(value)) %>%
    mutate(plotType=case_when(name %in% c("0-19", "20-59", "60+") ~ "hosp", 
                              name %in% c("vxapm7", "vxcpm7") ~ "vax", 
                              name=="cpm7" ~ "cases", 
                              name=="dpm7" ~ "deaths", 
                              TRUE ~ "notuse"
                              )
           ) %>%
    filter(plotType %in% c("deaths", "hosp")) %>%
    ggplot(aes(x=date, y=value)) + 
    geom_col(data=~filter(., plotType=="hosp"), aes(fill=name, y=hospDeath*value), position="stack") + 
    geom_line(data=~filter(., plotType=="deaths"), color="black", size=1) +
    scale_fill_discrete("Hospital Admssions by Age") + 
    scale_y_continuous("Deaths per million (rolling 7 mean per day)", 
                       sec.axis = sec_axis(~ . / hospDeath, 
                                           name = "Hospital admissions per million (rolling 7 mean per day"
                                           )
                       ) +
    labs(x=NULL, 
         title="Alignment of Michigan deaths and hospitalizations data", 
         subtitle=paste0("Ratio of ", 
                         hospDeath, 
                         ":1 applied (deaths are black line, hospital admissions are stacked bar)"
                         )
         ) + 
    theme(legend.position="bottom")

```

At a glance, the Michigan data appear reasonably well aligned.  Hospital admissions run at ~10% of confirmed cases with a small delay.  Deaths run at ~20% of hospital admissions in the mid-winter wave and ~10% of admissions in the spring wave.  These are consistent with estimates of ~1.5% CFR and ~5 cases per diagnosed cases (fatality rate ~0.3%).

Next steps are to convert this process to functional form, automate selection of scaling parameters, and explore other states of interest:  
```{r}

# Function to create case-hospital-death file
makeCaseHospDeath <- function(dfHosp, dfCaseDeath) {

    # FUNCTION ARGUMENTS:
    # dfHosp: the tibble or data.frame containing the hospital data by date-state
    # dfCaseDeath: the tibble or data.frame containing the case and death data by date-state
    
    allHosp <- dfHosp %>%
        mutate(ageBucket=ifelse(age >= "60", "60+", ifelse(age=="0-19", "0-19", "20-59"))) %>% 
        group_by(date, state, ageBucket) %>% 
        summarize(value=sum(value), .groups="drop") %>% 
        group_by(ageBucket, state) %>% 
        mutate(value7=zoo::rollmean(value, k=7, fill=NA)) %>%
        ungroup() %>%
        left_join(getStateData(keepVars=c("state", "pop"))) %>%
        mutate(vpm7=1000000*value7/pop)

    allCaseDeath <- dfCaseDeath %>%
        select(state, date, new_cases, new_deaths, vxa, vxc, cpm7, dpm7, vxapm7, vxcpm7) %>%
        pivot_longer(-c(state, date))

    allPivot <- allHosp %>%
        select(state, date, name=ageBucket, value=vpm7) %>%
        bind_rows(allCaseDeath) %>%
        checkUniqueRows(uniqueBy=c("state", "date", "name"))
    
    allPivot
    
}

alignCaseHospDeath <- function(dfPivot=NULL, 
                               dfHosp=NULL, 
                               dfCaseDeath=NULL, 
                               typeMapper=c("cases"="1. Cases per million per day (rolling 7 mean)", 
                                            "deaths"="2. Deaths per million per day (rolling 7 mean)", 
                                            "hosp"="3. Admitted to hospital per million per day (rolling 7 mean)", 
                                            "vax"="4. Vaccinated per capita (administered, completed)"
                                            ), 
                               keyState="MI", 
                               hospCaseScalar=10, 
                               hospDeathScalar=0.2, 
                               returnPlots=FALSE
                               ) 
    {
    
    # FUNCTION ARGUMENTS:
    # dfPivot: the tibble or data.frame containing integrated case-hospital-death data 
    #          (if NULL, build from dfHosp and dfCaseDeath)
    # dfHosp: the tibble or data.frame containing the hospital data by date-state
    # dfCaseDeath: the tibble or data.frame containing the case and death data by date-state
    # typeMapper: mapping file for labelling facets
    # keyState: the state to explore
    # hospCaseScalar: the scalar to be applied for placing cases and hospitalizations on the same plot
    # hospDeathScalar: the scalar to be applied for placing hospitalizations and deaths on the same plot
    
    # Create the pivoted data if it was not passed
    if (is.null(dfPivot)) {
        if (is.null(dfHosp) | is.null(dfCaseDeath)) stop("\nMust pass dfPivot OR both of dfHosp and dfCaseDeath\n")
        dfPivot <- makeCaseHospDeath(dfHosp=dfHosp, dfCaseDeath=dfCaseDeath)
    }

    # Create the plotting data
    plotData <- dfPivot %>%
        filter(state==keyState, !is.na(value)) %>%
        mutate(plotType=case_when(name %in% c("0-19", "20-59", "60+") ~ "hosp", 
                                  name %in% c("vxapm7", "vxcpm7") ~ "vax", 
                                  name=="cpm7" ~ "cases", 
                                  name=="dpm7" ~ "deaths", 
                                  TRUE ~ "notuse"
                                  )
               )
    
    # Create overall plot
    p1 <- plotData %>%
        filter(plotType != "notuse") %>%
        ggplot(aes(x=date, y=value)) + 
        geom_line(data=~filter(., plotType=="cases"), color="blue", size=1) +
        geom_line(data=~filter(., plotType=="deaths"), color="red", size=1) +
        geom_line(data=~filter(., plotType=="vax"), aes(color=name, group=name, y=value/1000000)) +
        geom_col(data=~filter(., plotType=="hosp"), aes(fill=name), position="stack") + 
        scale_color_discrete("Vaccine\nMetric") + 
        scale_fill_discrete("Hospitalized\nby Age") +
        facet_wrap(~typeMapper[plotType], scales="free_y") + 
        labs(x=NULL, y=NULL, title=paste0("Key coronavirus metrics for state: ", keyState)) +
        lims(y=c(0, NA))
    print(p1)

    p2 <- plotData %>%
        filter(plotType %in% c("cases", "hosp")) %>%
        ggplot(aes(x=date, y=value)) + 
        geom_col(data=~filter(., plotType=="hosp"), aes(fill=name, y=hospCaseScalar*value), position="stack") + 
        geom_line(data=~filter(., plotType=="cases"), color="black", size=1) +
        scale_fill_discrete("Hospital Admssions by Age") + 
        scale_y_continuous("Cases per million (rolling 7 mean per day)", 
                           sec.axis = sec_axis(~ . / hospCaseScalar, 
                                               name = "Hospital admissions per million (rolling 7 mean per day"
                                               )
                           ) +
        labs(x=NULL, 
             title=paste0("Alignment of ", keyState, " cases and hospitalizations data"), 
             subtitle=paste0("Ratio of ", 
                             hospCaseScalar, 
                             ":1 applied (cases are black line, hospital admissions are stacked bar)"
                             )
             ) + 
        theme(legend.position="bottom")
    print(p2)

    p3 <- plotData %>%
        filter(plotType %in% c("deaths", "hosp")) %>%
        ggplot(aes(x=date, y=value)) + 
        geom_col(data=~filter(., plotType=="hosp"), aes(fill=name, y=hospDeathScalar*value), position="stack") + 
        geom_line(data=~filter(., plotType=="deaths"), color="black", size=1) +
        scale_fill_discrete("Hospital Admssions by Age") + 
        scale_y_continuous("Deaths per million (rolling 7 mean per day)", 
                           sec.axis = sec_axis(~ . / hospDeathScalar, 
                                               name = "Hospital admissions per million (rolling 7 mean per day"
                                               )
                           ) +
        labs(x=NULL, 
             title=paste0("Alignment of ", keyState, " deaths and hospitalizations data"), 
             subtitle=paste0("Ratio of ", 
                             hospDeathScalar, 
                             ":1 applied (deaths are black line, hospital admissions are stacked bar)"
                             )
             ) + 
        theme(legend.position="bottom")
    print(p3)
    
    if(isTRUE(returnPlots)) list(p1=p1, p2=p2, p3=p3)
    
}

```

The function is tested for MI, FL, and TX:  
```{r, fig.height=9, fig.width=9}

dfPivot_210804 <- makeCaseHospDeath(dfHosp=hospAge_210804, dfCaseDeath=cdc_daily_210804$dfPerCapita)
dfPivot_210804

miAlign <- alignCaseHospDeath(dfPivot_210804, keyState="MI", returnPlots=TRUE)
flAlign <- alignCaseHospDeath(dfPivot_210804, keyState="FL", returnPlots=TRUE, hospDeathScalar=0.14)
txAlign <- alignCaseHospDeath(dfPivot_210804, keyState="TX", returnPlots=TRUE, hospDeathScalar=0.14)

# Key plots on a single page
gridExtra::grid.arrange(miAlign$p1, flAlign$p1, txAlign$p1, nrow=2)
gridExtra::grid.arrange(miAlign$p2, flAlign$p2, txAlign$p2, nrow=1)
gridExtra::grid.arrange(miAlign$p3, flAlign$p3, txAlign$p3, nrow=1)

```

Next, an implied CFR (deaths per case) rate is calculated for inclusion:  
```{r, fig.height=9, fig.width=9}

# Filter to single-state data
miData <- dfPivot_210804 %>%
    filter(state=="MI", name %in% c("cpm7", "dpm7"), !is.na(value))

# Plot core metrics
miData %>%
    ggplot(aes(x=date, y=value)) + 
    geom_line(aes(group=name, color=name)) + 
    facet_wrap(~c("cpm7"="Cases per million", "dpm7"="Deaths per million")[name], scales="free_y") + 
    labs(x=NULL, y="Value per million (rolling 7-day mean)", title="Coronavirus burden in state: MI") + 
    theme(legend.position="none")

# Create correlation for assigned lag/lead and variables in a data frame
lagCorrCheck <- function(df, lagLead=0, varFix="dpm7", varMove="cpm7") {
    df %>%
        mutate(lagVar=if(lagLead >= 0) lag(get(varMove), lagLead) else lead(get(varMove), abs(lagLead))) %>%
        filter(!is.na(lagVar)) %>%
        summarize(correl=cor(lagVar, get(varFix))) %>%
        pull(correl)
}

miCorrDF <- miData %>%
    select(date, name, value) %>%
    pivot_wider(date)
miCorrDF

# Assessing best lag/lead for full dataset
lagLeads=-10:40
miRhoFull <- tibble::tibble(lagLead=lagLeads, 
                            rho=sapply(lagLeads, FUN=function(x) lagCorrCheck(miCorrDF, lagLead=x))
                            )
bestFull <- miRhoFull %>% filter(rho==max(rho))
miRhoFull %>% 
    ggplot(aes(x=lagLead, y=rho)) + 
    geom_point() + 
    geom_hline(data=bestFull, aes(yintercept=rho), lty=2) +
    geom_vline(data=bestFull, aes(xintercept=lagLead), lty=2) +
    labs(x="Lag or lead of cases", 
         y="Correlation to deaths", 
         title="All Michigan case and death data", 
         subtitle=paste0("Best correlation ", 
                         round(bestFull$rho, 3), 
                         " obtained at lag/lead of: ", 
                         bestFull$lagLead
                         )
         )

# Assessing best lag/lead for August 2020 and beyond
lagLeads=-10:40
miRhoLate <- tibble::tibble(lagLead=lagLeads, 
                            rho=sapply(lagLeads, 
                                       FUN=function(x) lagCorrCheck(miCorrDF %>% filter(date >= "2020-08-01"), 
                                                                    lagLead=x
                                                                    )
                                       )
                            )
bestLate <- miRhoLate %>% filter(rho==max(rho))
miRhoLate %>% 
    ggplot(aes(x=lagLead, y=rho)) + 
    geom_point() + 
    geom_hline(data=bestLate, aes(yintercept=rho), lty=2) +
    geom_vline(data=bestLate, aes(xintercept=lagLead), lty=2) +
    labs(x="Lag or lead of cases", 
         y="Correlation to deaths", 
         title="Michigan case and death data (August 2020 to present)", 
         subtitle=paste0("Best correlation ", 
                         round(bestLate$rho, 3), 
                         " obtained at lag/lead of: ", 
                         bestLate$lagLead
                         )
         )

miCorrDF %>%
    mutate(lag20=lag(cpm7, 20)) %>%
    filter(!is.na(lag20), lag20 > 0) %>%
    ggplot(aes(x=date)) + 
    geom_line(aes(y=cpm7), color="navy") + 
    geom_line(aes(y=lag20), color="navy", lty=2) + 
    geom_line(aes(y=8000*pmin(0.1, dpm7/lag20)), color="red") + 
    scale_y_continuous("Cases per million (rolling 7 mean per day) - actual and 20-day lag", 
                       sec.axis = sec_axis(~ . / 8000, 
                                           name = "Implied CFR (capped at 10%)"
                                           )
                       ) +
    labs(x=NULL, title="Implied case fatality rate using 20-day lag in Michigan")

miCorrDF %>%
    mutate(lag20=lag(cpm7, 20)) %>%
    filter(!is.na(lag20)) %>%
    ggplot(aes(x=date)) + 
    geom_line(aes(y=cpm7), color="navy") + 
    geom_line(aes(y=lag20), color="navy", lty=2) + 
    geom_line(aes(y=50*dpm7), color="red") + 
    labs(x=NULL, 
         y="Per million (7-day rolling mean)\nCases, Lag-20 cases, and 50*Deaths", 
         title="Burden metrics for Michigan"
         )

```
  
Michigan appears to fairly consistently have a lag of 2-3 weeks between cases and deaths.  The CFR during spikes has consistently declined from over 10% to around 2% to around 1%.  The estimated CFR outside of spikes appears noisy.  Next steps are to convert to functional form and run for other states:  
```{r, fig.height=9, fig.width=9}

# Create correlation for assigned lag/lead and variables in a data frame
lagCorrCheck <- function(df, lagLead=0, varFix="dpm7", varMove="cpm7") {
    df %>%
        mutate(lagVar=if(lagLead >= 0) lag(get(varMove), lagLead) else lead(get(varMove), abs(lagLead))) %>%
        filter(!is.na(lagVar)) %>%
        summarize(correl=cor(lagVar, get(varFix))) %>%
        pull(correl)
}


findCorrAlign <- function(df, 
                          keyState, 
                          varFix="dpm7", 
                          varMove="cpm7", 
                          lagLeads=-10:40,
                          minDate=NULL, 
                          maxDate=NULL,
                          varMapper=c("cpm7"="Cases per million", "dpm7"="Deaths per million"), 
                          yLab="Value per million (rolling 7-day mean)", 
                          printPlots=TRUE, 
                          returnPlots=FALSE,
                          returnData=FALSE
                          ) {
    
    # FUNCTION ARGUMENTS
    # df: pivoted data frame with state-date-name-value
    # keyState: state to include
    # varFix: metric to be held constant
    # varMove: metric to be lagged/led
    # lagLeads: lags and leads for the variable that moves
    # minDate: minimum date for lag/lead (NULL means data-driven)
    # maxDate: maximum date for lag/lead (NULL means data-driven)
    # varMapper: mapping file for varFix and varMove to descriptive labels
    # yLab: label for the y-axis in the first plot
    # printPlots: boolean, should the plots be printed?
    # returnPlots: boolean, should the plots be returned?
    # returnData: boolean, should the data frames be returned as a list?
    
    # Set minDate and maxDate to the actual minmax if passed as NULL 
    if (is.null(minDate)) minDate <- df %>% summarize(date=min(date)) %>% pull(date)
    if (is.null(maxDate)) maxDate <- df %>% summarize(date=max(date)) %>% pull(date)
    
    # Filter to relevant data
    df <- df %>%
        filter(state %in% all_of(keyState), name %in% all_of(c(varFix, varMove)), !is.na(value))

    # Plot core metrics for requested states
    p1 <- df %>%
        ggplot(aes(x=date, y=value)) + 
        geom_line(aes(group=name, color=name)) + 
        facet_wrap(~varMapper[name], scales="free_y") + 
        labs(x=NULL, y=yLab, title=paste0("Metrics by state for: ", paste0(keyState, collapse=", "))) + 
        theme(legend.position="none")
    if(isTRUE(printPlots)) print(p1)

    # Create dataset for correlations
    dfCorr <- df %>%
        select(date, name, value) %>%
        pivot_wider(date)

    # Find correlation by lag/lead for dataset
    dfRho <- tibble::tibble(lagLead=lagLeads, 
                            rho=sapply(lagLeads, 
                                       FUN=function(x) {
                                           lagCorrCheck(dfCorr %>% filter(date >= minDate, date <= maxDate), 
                                                        lagLead=x
                                                        )
                                           }
                                       )
                            )
    
    # Find best correlation and lag/lead
    bestRho <- dfRho %>% 
        filter(rho==max(rho))

    # Plot correlations by lag/lead
    p2 <- dfRho %>% 
        ggplot(aes(x=lagLead, y=rho)) + 
        geom_point() + 
        geom_hline(data=bestRho, aes(yintercept=rho), lty=2) +
        geom_vline(data=bestRho, aes(xintercept=lagLead), lty=2) +
        labs(x=paste0("Lag or lead of ", varMapper[varMove]), 
             y=paste0("Correlation to ", varMapper[varFix]), 
             title=paste0("Correlations by lag/lead for state: ", keyState), 
             subtitle=paste0("Best correlation ", 
                             round(bestRho$rho, 3), 
                             " obtained at lag/lead of: ", 
                             bestRho$lagLead
                             )
             )
    if(isTRUE(printPlots)) print(p2)

    if (isTRUE(returnData) | isTRUE(returnPlots)) {
        list(dfRho=if(isTRUE(returnData)) dfRho else NULL, 
             bestRho=if(isTRUE(returnData)) bestRho else NULL, 
             dfCorr=if(isTRUE(returnData)) dfCorr else NULL, 
             p1=if(isTRUE(returnPlots)) p1 else NULL, 
             p2=if(isTRUE(returnPlots)) p2 else NULL
             )
    }
    
}

findCorrAlign(dfPivot_210804, keyState="MI")
findCorrAlign(dfPivot_210804, keyState="MI", minDate="2020-08-01", returnData=TRUE)
findCorrAlign(dfPivot_210804, keyState="FL")
findCorrAlign(dfPivot_210804, keyState="TX", minDate="2020-10-01")

```

Next steps are to create functional form for calculating IFR and aligning plots:  
```{r, fig.height=9, fig.width=9}

plotCFRLag <- function(lst, 
                       lagUse=NULL, 
                       scaleUse=NULL, 
                       cfrCap=0.06, 
                       multDeath=50,
                       mainTitle="Coronavirus data for selected geography: ", 
                       printPlots=TRUE, 
                       returnPlots=FALSE
                       ) {
    
    # FUNCTION ARGUMENTS:
    # lst: data frame with date-cpm7-dpm7 OR list with both dfCorr and bestRho
    # lagUse: the lag to use (if NULL, use the value in bestRho$lagLead)
    # scaleUse: scalar for secondary y-axis (NULL means calculate from data)
    # cfrCap: the cap for all values of CFR
    # multDeath: multiplier for death data in plot 2
    # mainTitle: main title for plots
    # printPlots: boolean, should the plots be printed?
    # returnPlots: boolean, should the plots be returned?
    
    # Create dfCorr and lagUse
    if ("list" %in% class(lst)) {
        dfCorr <- lst[["dfCorr"]]
        if (is.null(lagUse)) lagUse <- lst[["bestRho"]]$lagLead
    } else {
        dfCorr <- lst
    }
    
    # Check that dfCorr is a data frame with date-cpm7-dpm7 and lagUse is not NULL
    if (!("data.frame" %in% class(dfCorr))) stop("\nMust have a data frame for lst/dfCorr\n")
    if (!(all(c("date", "cpm7", "dpm7") %in% names(dfCorr)))) stop("\ndfCorr must have date-cpm7-dpm7\n")
    if (is.null(lagUse)) stop("\nMust have a value for lagUse\n")
    
    # Create scaleUse if not passed
    if (is.null(scaleUse)) scaleUse <- 500*ceiling(max(dfCorr$cpm7)/cfrCap/500)
    
    # Create plot of CFR by date, showing lagged cases
    basePlot <- dfCorr %>%
        mutate(lagData=if(lagUse >= 0) lag(cpm7, lagUse) else lead(cpm7, -lagUse)) %>%
        filter(!is.na(lagData), lagData > 0) %>%
        ggplot(aes(x=date)) + 
        geom_line(aes(y=cpm7), color="navy") + 
        geom_line(aes(y=lagData), color="navy", lty=2)
    p1 <- basePlot + 
        geom_line(aes(y=scaleUse*pmin(cfrCap, dpm7/lagData)), color="red") + 
        scale_y_continuous(paste0("Cases per million\n(rolling 7-day mean)"), 
                           sec.axis = sec_axis(~ . / scaleUse, 
                                               name = paste0("Implied CFR (capped at ", 
                                                             round(100*cfrCap, 1), 
                                                             "%)"
                                                             )
                                               )
                           ) +
        labs(x=NULL, 
             title=mainTitle, 
             subtitle=paste0("Red line (right axis) is implied fatality rate\n", 
                             "Blue line is cases with and without ", 
                             abs(lagUse), 
                             "-day ", 
                             if(lagUse > 0) "lag" else "lead"
                             )
             )
    if (isTRUE(printPlots)) print(p1)
    
    # Apply a CFR to the data and show alignment
    p2 <- basePlot +
        geom_line(aes(y=multDeath*dpm7), color="red") + 
        labs(x=NULL, 
             y="Per million (7-day rolling mean)", 
             title=mainTitle, 
             subtitle=paste0("Red line is ", 
                             multDeath, 
                             "*deaths\n", 
                             "Blue line is cases with and without ", 
                             abs(lagUse), 
                             "-day ", 
                             if(lagUse > 0) "lag" else "lead"
                             )
         )
    if (isTRUE(printPlots))print(p2)
    
    if (isTRUE(returnPlots)) list(p1=p1, p2=p2)
    
}

# Run for Michigan, Florida, California
findCorrAlign(dfPivot_210804, keyState="MI", minDate="2020-08-01", returnData=TRUE) %>%
    plotCFRLag(mainTitle=paste0(formals(plotCFRLag)$mainTitle, "MI"))
findCorrAlign(dfPivot_210804, keyState="FL", returnData=TRUE) %>%
    plotCFRLag(mainTitle=paste0(formals(plotCFRLag)$mainTitle, "FL"), multDeath=100)
findCorrAlign(dfPivot_210804, keyState="CA", returnData=TRUE) %>%
    plotCFRLag(mainTitle=paste0(formals(plotCFRLag)$mainTitle, "CA"), multDeath=70)

```

Functions have been updated so that plots can be returned and/or printed.  A new function allows for creating all plots for state on a single page:  
```{r, fig.height=9, fig.width=9}

# Function to plot all states on the same page
onePageCFRPlot <- function(df, keyState, multDeath=100, cfrCap=0.06, ...) {
    
    # FUNCTION ARGUMENTS:
    # df: the data frame containing state-date-name-value
    # keyState: the key state to be analyzed
    # multDeath: multiplier for death in the death/lagged cases chart of plotCFRLag()
    # ...: other arguments to be passed to findCorrAlign()
    
    # Find the correlations data
    corrData <- findCorrAlign(df, 
                              keyState=keyState, 
                              yLab="Value per million\n(rolling 7-day mean)", 
                              printPlots=FALSE, 
                              returnPlots=TRUE, 
                              returnData=TRUE, 
                              ...
                              )
    
    # Find CFR
    cfrData <- plotCFRLag(corrData, 
                          cfrCap=cfrCap, 
                          multDeath=multDeath, 
                          mainTitle=paste0(formals(plotCFRLag)$mainTitle, keyState), 
                          printPlots=FALSE, 
                          returnPlots=TRUE
                          )
    
    # Create single-page summary
    gridExtra::grid.arrange(corrData$p1, corrData$p2, cfrData$p1, cfrData$p2, nrow=2)
    
}

# Run for Michigan, Florida, California, Texas, New York, South Dakota
onePageCFRPlot(dfPivot_210804, keyState="MI", minDate="2020-08-01")
onePageCFRPlot(dfPivot_210804, keyState="FL", multDeath=100)
onePageCFRPlot(dfPivot_210804, keyState="CA", multDeath=70)
onePageCFRPlot(dfPivot_210804, keyState="TX", multDeath=70)
onePageCFRPlot(dfPivot_210804, keyState="NY", multDeath=10, cfrCap=0.1)
onePageCFRPlot(dfPivot_210804, keyState="SD", multDeath=70)

```

Summaries are created for vaccination status by age cohort and state:  
```{r, fig.height=9, fig.width=9}

cdc_daily_210815 <- readFromRDS("cdc_daily_210815")

# Example using hard coding and wide data
cdc_daily_210815$dfRaw$vax %>% 
    filter(date==max(date), state %in% c(state.abb, "DC")) %>% 
    select(state, contains("Administered_Dose1")) %>% 
    ggplot(aes(x=fct_reorder(state, Administered_Dose1_Recip_65PlusPop_Pct))) + 
    geom_col(aes(fill="65+", y=Administered_Dose1_Recip_65PlusPop_Pct)) + 
    geom_col(aes(y=Administered_Dose1_Recip_18PlusPop_Pct, fill="18+")) + 
    geom_col(aes(y=Administered_Dose1_Pop_Pct, fill="All")) + 
    geom_text(aes(y=Administered_Dose1_Recip_65PlusPop_Pct, 
                  label=paste0(Administered_Dose1_Recip_65PlusPop_Pct, "% (", state, ")")
                  ), 
              hjust=0, 
              size=3
              ) + 
    geom_text(aes(y=Administered_Dose1_Recip_18PlusPop_Pct+0.5, 
                  label=paste0(Administered_Dose1_Recip_18PlusPop_Pct, "%")
                  ), 
              hjust=0, 
              size=3
              ) + 
    coord_flip() + 
    labs(x=NULL, 
         y="% Fully Vaccinated", 
         title="First-dose vaccinated by age cohort and state (mid-Aug 2020)", 
         subtitle="Black: all population, Yellow: 18+, Blue: 65+"
         ) + 
    scale_fill_manual("Cohort", 
                      breaks=c("All", "18+", "65+"), 
                      values=c("65+"="lightblue", "18+"="yellow", "All"="black" )
                      ) + 
    geom_text(aes(y=Administered_Dose1_Pop_Pct+0.5, 
                  label=paste0(Administered_Dose1_Pop_Pct, "%")
                  ), 
              hjust=0, 
              size=3
              ) + 
    theme(legend.position="bottom")



# Function for reproducibility
tempStackPlot <- function(df, 
                          yVars, 
                          xVar="state", 
                          yLab="", 
                          plotTitle="", 
                          colorVector=c("lightblue", "grey", "orange", "black")
                          ) {

    # FUNCTION ARGUMENTS:
    # df: data frame or tibble
    # yVars: named vector with c("variable"="name")
    # xVar: the x variable
    # yLab: the y-axis label for the plot
    # plotTitle: the title for the plot
    # colorVector: colors to use for filled bars (sequentially, can have more, but not less, than length(yVars))
    
    colorVector <- colorVector[1:length(yVars)]
    names(colorVector) <- names(yVars)
    
    p1 <- df %>% 
        select(all_of(xVar), all_of(names(yVars))) %>%
        pivot_longer(-c(all_of(xVar))) %>%
        ggplot(aes(x=fct_reorder(get(xVar[1]), value, max))) + 
        coord_flip() + 
        labs(x=NULL, y=yLab, title=plotTitle) + 
        geom_col(aes(y=value, fill=name), position="identity") + 
        geom_text(aes(y=value+0.5, 
                      label=paste0(value, "%", ifelse(name==names(yVars)[1], paste0(" (", state, ")"), ""))
                      ), 
                  hjust=0, 
                  size=3
                  ) + 
        scale_fill_manual("Cohort", 
                          breaks=rev(names(yVars)), 
                          labels=rev(unname(yVars)),
                          values=colorVector
                          ) +
        theme(legend.position="bottom")

    p1
    
}

# Run for fully vaccinated
tempStackPlot(cdc_daily_210815$dfRaw$vax %>% filter(date==max(date), state %in% c(state.abb, "DC")), 
              yVars=c("vxcgte65pct"="65+", 
                      "vxcgte18pct"="18+", 
                      "vxcpoppct"="All"
                      ), 
              yLab="% Fully vaccinated", 
              plotTitle="Fully vaccinated by age cohort and state (mid-Aug 2020)"
              )

# Run for first dose
tempStackPlot(cdc_daily_210815$dfRaw$vax %>% filter(date==max(date), state %in% c(state.abb, "DC")), 
              yVars=c("Administered_Dose1_Recip_65PlusPop_Pct"="65+", 
                      "Administered_Dose1_Recip_18PlusPop_Pct"="18+", 
                      "Administered_Dose1_Pop_Pct"="All"
                      ), 
              yLab="% Receiving First Dose", 
              plotTitle="First-dose vaccinated by age cohort and state (mid-Aug 2020)"
              )

```

The plotting is extended to show the evolution of vaccination over time:  
```{r, fig.height=9, fig.width=9}

# Create data
cdcVaxGrowth <- cdc_daily_210815$dfRaw$vax %>% 
    filter(date %in% c(as.Date(max(date)-lubridate::dmonths(c(0, 2, 4)), origin="1970-01-01")), 
           state %in% c(state.abb, "DC")
           )

# Run for fuly vaccinated
p1 <- cdcVaxGrowth %>%
    select(state, date, vxcpoppct) %>%
    pivot_wider(state, names_from="date", values_from="vxcpoppct") %>%
    tempStackPlot(yVars=c("2021-08-15"="2021-08-15", 
                          "2021-06-15"="2021-06-15", 
                          "2021-04-15"="2021-04-15"
                          ), 
                  yLab="% Fully Vaccinated (all population)", 
                  plotTitle="Evolution of fully vaccinated rate by state"
                  )

p2 <- cdcVaxGrowth %>%
    select(state, date, vxcgte65pct) %>%
    pivot_wider(state, names_from="date", values_from="vxcgte65pct") %>%
    tempStackPlot(yVars=c("2021-08-15"="2021-08-15", 
                          "2021-06-15"="2021-06-15", 
                          "2021-04-15"="2021-04-15"
                          ), 
                  yLab="% Fully Vaccinated (65+)", 
                  plotTitle="Evolution of fully vaccinated rate by state"
                  )

gridExtra::grid.arrange(p1, p2, nrow=1)



# Run for first dose
p1 <- cdcVaxGrowth %>%
    select(state, date, Administered_Dose1_Pop_Pct) %>%
    pivot_wider(state, names_from="date", values_from="Administered_Dose1_Pop_Pct") %>%
    tempStackPlot(yVars=c("2021-08-15"="2021-08-15", 
                          "2021-06-15"="2021-06-15", 
                          "2021-04-15"="2021-04-15"
                          ), 
                  yLab="% First-dose (all population)", 
                  plotTitle="Evolution of first dose rate by state"
                  )

p2 <- cdcVaxGrowth %>%
    select(state, date, Administered_Dose1_Recip_65PlusPop_Pct) %>%
    pivot_wider(state, names_from="date", values_from="Administered_Dose1_Recip_65PlusPop_Pct") %>%
    tempStackPlot(yVars=c("2021-08-15"="2021-08-15", 
                          "2021-06-15"="2021-06-15", 
                          "2021-04-15"="2021-04-15"
                          ), 
                  yLab="% First-dose (65+)", 
                  plotTitle="Evolution of first dose rate by state"
                  )

gridExtra::grid.arrange(p1, p2, nrow=1)

```

Similar plots are created for the evolution of cases per thousand and deaths per milion:  
```{r, fig.height=9, fig.width=9}

# Updated function for reproducibility
tempStackPlot <- function(df, 
                          yVars, 
                          xVar="state", 
                          yLab=NULL, 
                          plotTitle=NULL, 
                          colorVector=c("lightblue", "grey", "orange", "black"), 
                          addSuffix="%", 
                          scaleName="Cohort", 
                          textBuffer=0.5, 
                          makeDotPlot=FALSE, 
                          yLims=NULL
                          ) {

    # FUNCTION ARGUMENTS:
    # df: data frame or tibble
    # yVars: named vector with c("variable"="name"), in the desired order from right-most to left-most
    # xVar: the x variable
    # yLab: the y-axis label for the plot
    # plotTitle: the title for the plot
    # colorVector: colors to use for filled bars (sequentially, can have more, but not less, than length(yVars))
    # addSuffix: value to be appended to all values in plots (e.g., 96 would show as 96% in the text label)
    # scaleName: the name to use for the legend
    # textBuffer: distance from bar to text
    # makeDotPlot: boolean, should a dot-plot be made rather than stacked bars?
    # yLims: the limits for the y-axis passed as a length-2 vector such as c(0, 100) or c(0, NA)
    
    colorVector <- colorVector[1:length(yVars)]
    names(colorVector) <- names(yVars)
    
    # Function for the legend
    fnLegendKey <- if(isTRUE(makeDotPlot)) scale_color_manual else scale_fill_manual
    
    p1 <- df %>% 
        select(all_of(xVar), all_of(names(yVars))) %>%
        pivot_longer(-c(all_of(xVar))) %>%
        ggplot(aes(x=fct_reorder(get(xVar[1]), value, max))) + 
        coord_flip() + 
        labs(x=NULL, y=yLab, title=plotTitle) +
        (if(isTRUE(makeDotPlot)) geom_point(aes(y=value, color=name)) 
         else geom_col(aes(y=value, fill=name), position="identity")
         ) +
        geom_text(aes(y=value+textBuffer, 
                      label=paste0(value, 
                                   addSuffix, 
                                   ifelse(name==names(yVars)[1], paste0(" (", get(xVar[1]), ")"), "")
                                   )
                      ), 
                  hjust=0, 
                  size=3
                  ) + 
        fnLegendKey(scaleName, 
                    breaks=rev(names(yVars)), 
                    labels=rev(unname(yVars)),
                    values=colorVector
                    ) +
        theme(legend.position="bottom")
    
    # Add the y-limits if appropriate
    if (!is.null(yLims)) p1 <- p1 + lims(y=yLims)
    
    p1
    
}


# Create data
cdcBurdenGrowth <- cdc_daily_210815$dfPerCapita %>% 
    filter(date %in% c(as.Date(max(date)-2-lubridate::dmonths(c(0, 6, 12)), origin="1970-01-01")), 
           state %in% c(state.abb, "DC")
           )

# Run for cases
p1 <- cdcBurdenGrowth %>%
    select(state, date, tcpm) %>% 
    mutate(tcpm=round(tcpm/1000)) %>%
    pivot_wider(state, names_from="date", values_from="tcpm") %>%
    tempStackPlot(yVars=c("2021-08-13"="2021-08-13", 
                          "2021-02-11"="2021-02-11", 
                          "2020-08-12"="2020-08-12"
                          ), 
                  yLab="Cumulative cases per thousand", 
                  plotTitle="Evolution of cumulative cases per thousand by state", 
                  addSuffix="",
                  scaleName="Date"
                  )

# Run for deaths
p2 <- cdcBurdenGrowth %>%
    select(state, date, tdpm) %>% 
    mutate(tdpm=round(tdpm)) %>%
    pivot_wider(state, names_from="date", values_from="tdpm") %>%
    tempStackPlot(yVars=c("2021-08-13"="2021-08-13", 
                          "2021-02-11"="2021-02-11", 
                          "2020-08-12"="2020-08-12"
                          ), 
                  yLab="Cumulative deaths per million", 
                  plotTitle="Evolution of cumulative deaths per million by state", 
                  addSuffix="",
                  scaleName="Date"
                  )

gridExtra::grid.arrange(p1, p2, nrow=1)

```

The latest data as of August 31 are downloaded and processed, with caching to avoid multiple file downloads:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

readList <- list("cdcDaily"="./RInputFiles/Coronavirus/CDC_dc_downloaded_210902.csv", 
                 "cdcHosp"="./RInputFiles/Coronavirus/CDC_h_downloaded_210902.csv", 
                 "vax"="./RInputFiles/Coronavirus/vaxData_downloaded_210902.csv"
                 )
compareList <- list("cdcDaily"=readFromRDS("cdc_daily_210804")$dfRaw$cdcDaily, 
                    "cdcHosp"=readFromRDS("cdc_daily_210804")$dfRaw$cdcHosp, 
                    "vax"=readFromRDS("cdc_daily_210804")$dfRaw$vax
                    )

cdc_daily_210902 <- readRunCDCDaily(thruLabel="Sep 1, 2021", 
                                    downloadTo=lapply(readList, FUN=function(x) if(file.exists(x)) NA else x), 
                                    readFrom=readList,
                                    compareFile=compareList, 
                                    writeLog=NULL, 
                                    useClusters=readFromRDS("cdc_daily_210528")$useClusters, 
                                    weightedMeanAggs=c("tcpm7", "tdpm7", "cpm7", "dpm7", "hpm7", 
                                                       "vxcpm7", "vxcgte65pct"
                                                       ),
                                    skipAssessmentPlots=FALSE, 
                                    brewPalette="Paired"
                                    )

saveToRDS(cdc_daily_210902)

```

The pivoted file and summaries are also created:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

hospAge_210902 <- cdc_daily_210902$dfRaw$cdcHosp %>%
    select(state, 
           date, 
           grep(x=names(.), pattern="ed_\\d.*[9+]$", value=TRUE), 
           grep(x=names(.), pattern="pediatric.*ed$", value=TRUE)
           ) %>% 
    pivot_longer(-c(state, date)) %>% 
    mutate(confSusp=ifelse(grepl(x=name, pattern="confirmed"), "confirmed", "suspected"), 
           adultPed=ifelse(grepl(x=name, pattern="adult"), "adult", "ped"), 
           age=ifelse(adultPed=="ped", "0-17", stringr::str_replace_all(string=name, pattern=".*_", replacement="")), 
           age=ifelse(age %in% c("0-17", "18-19"), "0-19", age), 
           div=as.character(state.division)[match(state, state.abb)]
           ) 
hospAge_210902

dfPivot_210902 <- makeCaseHospDeath(dfHosp=hospAge_210902, dfCaseDeath=cdc_daily_210902$dfPerCapita)
dfPivot_210902

# Plot for overall trends by age group
p1 <- hospAge_210902 %>% 
    filter(state %in% c(state.abb, "DC"), !is.na(value)) %>% 
    mutate(ageBucket=age) %>% 
    group_by(date, ageBucket) %>% 
    summarize(value=sum(value), .groups="drop") %>% 
    arrange(date) %>%
    group_by(ageBucket) %>% 
    mutate(value7=zoo::rollmean(value, k=7, fill=NA)) %>% 
    filter(date >= "2020-08-01") %>% 
    ggplot(aes(x=date, y=value7)) + 
    labs(x=NULL, 
         y="Confirmed or suspected COVID admissions (rolling-7 mean)", 
         title="Hospital admissions for COVID by age bucket (Aug 2020 - Aug 2021)", 
         subtitle="50 states and DC (includes confirmed and suspected from CDC data)"
         ) + 
    lims(y=c(0, NA))

p1 + geom_line(aes(group=ageBucket, color=ageBucket), size=1) + 
    scale_color_discrete("Age\nbucket")
p1 + geom_col(aes(fill=ageBucket), position="stack") + 
    scale_color_discrete("Age\nbucket")
p1 + geom_col(aes(fill=ageBucket), position="fill") + 
    scale_color_discrete("Age\nbucket")

# Plot for overall trends by age group
hospAge_210902 %>% 
    filter(state %in% state.abb, !is.na(value)) %>% 
    mutate(ageBucket=ifelse(age >= "60", "60+", ifelse(age=="0-19", "0-19", "20-59"))) %>% 
    group_by(date, state, ageBucket) %>% 
    summarize(value=sum(value), .groups="drop") %>% 
    group_by(ageBucket, state) %>% 
    mutate(value7=zoo::rollmean(value, k=7, fill=NA)) %>% 
    filter(date >= "2020-06-01") %>% 
    ggplot(aes(x=date, y=value7)) + 
    geom_line(aes(color=ageBucket, group=ageBucket)) + 
    scale_color_discrete("Age\nbucket") + 
    labs(x=NULL, 
         y="Confirmed or suspected COVID admissions (rolling-7 mean)", 
         title="Hospital admissions for COVID by age bucket (Aug 2020 - Aug 2021)"
         ) + 
    lims(y=c(0, NA)) + 
    facet_wrap(~state, scales="free_y")

onePageCFRPlot(dfPivot_210902, keyState="FL", minDate="2020-08-01")
onePageCFRPlot(dfPivot_210902, keyState="LA", minDate="2020-08-01")
onePageCFRPlot(dfPivot_210902, keyState="OR", minDate="2020-08-01")
onePageCFRPlot(dfPivot_210902, keyState="HI", minDate="2020-08-01")

```

The latest data are downloaded and processed, with caching to avoid multiple file downloads:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

readList <- list("cdcDaily"="./RInputFiles/Coronavirus/CDC_dc_downloaded_211006.csv", 
                 "cdcHosp"="./RInputFiles/Coronavirus/CDC_h_downloaded_211006.csv", 
                 "vax"="./RInputFiles/Coronavirus/vaxData_downloaded_211006.csv"
                 )
compareList <- list("cdcDaily"=readFromRDS("cdc_daily_210804")$dfRaw$cdcDaily, 
                    "cdcHosp"=readFromRDS("cdc_daily_210804")$dfRaw$cdcHosp, 
                    "vax"=readFromRDS("cdc_daily_210804")$dfRaw$vax
                    )

cdc_daily_211006 <- readRunCDCDaily(thruLabel="Oct 5, 2021", 
                                    downloadTo=lapply(readList, FUN=function(x) if(file.exists(x)) NA else x), 
                                    readFrom=readList,
                                    compareFile=compareList, 
                                    writeLog=NULL, 
                                    useClusters=readFromRDS("cdc_daily_210528")$useClusters, 
                                    weightedMeanAggs=c("tcpm7", "tdpm7", "cpm7", "dpm7", "hpm7", 
                                                       "vxcpm7", "vxcgte65pct"
                                                       ),
                                    skipAssessmentPlots=FALSE, 
                                    brewPalette="Paired"
                                    )

saveToRDS(cdc_daily_211006)

```
  
Additional analysis of the resulting data is conducted:  
```{r, fig.height=9, fig.width=9}

hospAge_211006 <- cdc_daily_211006$dfRaw$cdcHosp %>%
    select(state, 
           date, 
           grep(x=names(.), pattern="ed_\\d.*[9+]$", value=TRUE), 
           grep(x=names(.), pattern="pediatric.*ed$", value=TRUE)
           ) %>% 
    pivot_longer(-c(state, date)) %>% 
    mutate(confSusp=ifelse(grepl(x=name, pattern="confirmed"), "confirmed", "suspected"), 
           adultPed=ifelse(grepl(x=name, pattern="adult"), "adult", "ped"), 
           age=ifelse(adultPed=="ped", "0-17", stringr::str_replace_all(string=name, pattern=".*_", replacement="")), 
           age=ifelse(age %in% c("0-17", "18-19"), "0-19", age), 
           div=as.character(state.division)[match(state, state.abb)]
           ) 
hospAge_211006

dfPivot_211006 <- makeCaseHospDeath(dfHosp=hospAge_211006, dfCaseDeath=cdc_daily_211006$dfPerCapita)
dfPivot_211006

# Plot for overall trends by age group
p1 <- hospAge_211006 %>% 
    filter(state %in% c(state.abb, "DC"), !is.na(value)) %>% 
    mutate(ageBucket=age) %>% 
    group_by(date, ageBucket) %>% 
    summarize(value=sum(value), .groups="drop") %>% 
    arrange(date) %>%
    group_by(ageBucket) %>% 
    mutate(value7=zoo::rollmean(value, k=7, fill=NA)) %>% 
    filter(date >= "2020-08-01") %>% 
    ggplot(aes(x=date, y=value7)) + 
    labs(x=NULL, 
         y="Confirmed or suspected COVID admissions (rolling-7 mean)", 
         title="Hospital admissions for COVID by age bucket (Aug 2020 - Sep 2021)", 
         subtitle="50 states and DC (includes confirmed and suspected from CDC data)"
         ) + 
    lims(y=c(0, NA))

p1 + geom_line(aes(group=ageBucket, color=ageBucket), size=1) + 
    scale_color_discrete("Age\nbucket")
p1 + geom_col(aes(fill=ageBucket), position="stack") + 
    scale_color_discrete("Age\nbucket")
p1 + geom_col(aes(fill=ageBucket), position="fill") + 
    scale_color_discrete("Age\nbucket")

# Plot for overall trends by age group
hospAge_211006 %>% 
    filter(state %in% state.abb, !is.na(value)) %>% 
    mutate(ageBucket=ifelse(age >= "60", "60+", ifelse(age=="0-19", "0-19", "20-59"))) %>% 
    group_by(date, state, ageBucket) %>% 
    summarize(value=sum(value), .groups="drop") %>% 
    group_by(ageBucket, state) %>% 
    mutate(value7=zoo::rollmean(value, k=7, fill=NA)) %>% 
    filter(date >= "2020-06-01") %>% 
    ggplot(aes(x=date, y=value7)) + 
    geom_line(aes(color=ageBucket, group=ageBucket)) + 
    scale_color_discrete("Age\nbucket") + 
    labs(x=NULL, 
         y="Confirmed or suspected COVID admissions (rolling-7 mean)", 
         title="Hospital admissions for COVID by age bucket (Aug 2020 - Sep 2021)"
         ) + 
    lims(y=c(0, NA)) + 
    facet_wrap(~state, scales="free_y")

onePageCFRPlot(dfPivot_211006, keyState="FL", minDate="2020-08-01")
onePageCFRPlot(dfPivot_211006, keyState="LA", minDate="2020-08-01")
onePageCFRPlot(dfPivot_211006, keyState="OR", minDate="2020-08-01")
onePageCFRPlot(dfPivot_211006, keyState="HI", minDate="2020-08-01")

```

The process is converted to functional form:  
```{r, fig.height=9, fig.width=9}

createBurdenPivot <- function(lst, 
                              dataThru,
                              minDatePlot="2020-08-01", 
                              plotByState=c(state.abb, "DC")
                              ) {
    
    # FUNCTION ARGUMENTS:
    # lst: a processed list that includes sub-component $dfRaw$cdcHosp
    # dataThru: character string to be used for 'data through'; most commonly MMM-YY
    # minDatePlot: starting date for plots
    # plotByState: states to be facetted for plot of hospitaliztions by age (FALSE means do not create plot)

    # Convert minDatePlot to Date if passed as character
    if ("character" %in% class(minDatePlot)) minDatePlot <- as.Date(minDatePlot)
    
    # Create the hospitalized by age data
    hospAge <- lst[["dfRaw"]][["cdcHosp"]] %>%
        select(state, 
               date, 
               grep(x=names(.), pattern="ed_\\d.*[9+]$", value=TRUE), 
               grep(x=names(.), pattern="pediatric.*ed$", value=TRUE)
               ) %>% 
        pivot_longer(-c(state, date)) %>% 
        mutate(confSusp=ifelse(grepl(x=name, pattern="confirmed"), "confirmed", "suspected"), 
               adultPed=ifelse(grepl(x=name, pattern="adult"), "adult", "ped"), 
               age=ifelse(adultPed=="ped", 
                          "0-17", 
                          stringr::str_replace_all(string=name, pattern=".*_", replacement="")
                          ), 
               age=ifelse(age %in% c("0-17", "18-19"), "0-19", age), 
               div=as.character(state.division)[match(state, state.abb)]
               )

    # Create the pivoted burden data
    dfPivot <- makeCaseHospDeath(dfHosp=hospAge, dfCaseDeath=lst[["dfPerCapita"]])

    # Plot for overall trends by age group
    p1 <- hospAge %>% 
        filter(state %in% c(state.abb, "DC"), !is.na(value)) %>% 
        mutate(ageBucket=age) %>% 
        group_by(date, ageBucket) %>% 
        summarize(value=sum(value), .groups="drop") %>% 
        arrange(date) %>%
        group_by(ageBucket) %>% 
        mutate(value7=zoo::rollmean(value, k=7, fill=NA)) %>% 
        filter(date >= minDatePlot) %>% 
        ggplot(aes(x=date, y=value7)) + 
        labs(x=NULL, 
             y="Confirmed or suspected COVID admissions (rolling-7 mean)", 
             title=paste0("Hospital admissions for COVID by age bucket (Aug 2020 - ", dataThru, ")"), 
             subtitle="50 states and DC (includes confirmed and suspected from CDC data)"
             ) + 
        lims(y=c(0, NA))

    # Create three main plots of hospitalized by age data
    print(p1 + geom_line(aes(group=ageBucket, color=ageBucket), size=1) + scale_color_discrete("Age\nbucket"))
    print(p1 + geom_col(aes(fill=ageBucket), position="stack") + scale_color_discrete("Age\nbucket"))
    print(p1 + geom_col(aes(fill=ageBucket), position="fill") + scale_color_discrete("Age\nbucket"))

    # Plot for trends by state and age group
    if (!isFALSE(plotByState)) {
        p2 <- hospAge %>% 
            filter(state %in% plotByState, !is.na(value)) %>% 
            mutate(ageBucket=ifelse(age >= "60", "60+", ifelse(age=="0-19", "0-19", "20-59"))) %>% 
            group_by(date, state, ageBucket) %>% 
            summarize(value=sum(value), .groups="drop") %>% 
            group_by(ageBucket, state) %>% 
            mutate(value7=zoo::rollmean(value, k=7, fill=NA)) %>% 
            filter(date >= minDatePlot) %>% 
            ggplot(aes(x=date, y=value7)) + 
            geom_line(aes(color=ageBucket, group=ageBucket)) + 
            scale_color_discrete("Age\nbucket") + 
            labs(x=NULL, 
                 y="Confirmed or suspected COVID admissions (rolling-7 mean)", 
                 title=paste0("Hospital admissions for COVID by age bucket (Aug 2020 - ", dataThru, ")")
                 ) + 
            lims(y=c(0, NA)) + 
            facet_wrap(~state, scales="free_y")
        print(p2)
    }
    
    # Return key data (do not return plot objects)
    list(hospAge=hospAge, dfPivot=dfPivot)
    
}

burdenPivotList_211006 <- createBurdenPivot(cdc_daily_211006, dataThru="Sep 2021")
identical(burdenPivotList_211006$dfPivot, dfPivot_211006)
identical(burdenPivotList_211006$hospAge, hospAge_211006)

```
  
Plots for burden growth are also updated:  
```{r, fig.height=9, fig.width=9}

# Create data
cdcBurdenGrowth_211006 <- cdc_daily_211006$dfPerCapita %>% 
    filter(date %in% c(as.Date(max(date)-2-lubridate::dmonths(c(0, 6, 12)), origin="1970-01-01")), 
           state %in% c(state.abb, "DC")
           )

# Run for cases
p1 <- cdcBurdenGrowth_211006 %>%
    select(state, date, tcpm) %>% 
    mutate(tcpm=round(tcpm/1000)) %>%
    pivot_wider(state, names_from="date", values_from="tcpm") %>%
    tempStackPlot(yVars=c("2021-10-03"="2021-10-03", 
                          "2021-04-03"="2021-04-03", 
                          "2020-10-02"="2020-10-02"
                          ), 
                  yLab="Cumulative cases per thousand", 
                  plotTitle="Evolution of cumulative cases per thousand by state", 
                  addSuffix="",
                  scaleName="Date"
                  )

# Run for deaths
p2 <- cdcBurdenGrowth_211006 %>%
    select(state, date, tdpm) %>% 
    mutate(tdpm=round(tdpm)) %>%
    pivot_wider(state, names_from="date", values_from="tdpm") %>%
    tempStackPlot(yVars=c("2021-10-03"="2021-10-03", 
                          "2021-04-03"="2021-04-03", 
                          "2020-10-02"="2020-10-02"
                          ), 
                  yLab="Cumulative deaths per million", 
                  plotTitle="Evolution of cumulative deaths per million by state", 
                  addSuffix="",
                  scaleName="Date"
                  )

gridExtra::grid.arrange(p1, p2, nrow=1)

```

The burden plot is converted to functional form:  
```{r, fig.height=9, fig.width=9}

cumulativeBurdenPlot <- function(lst, 
                                 keyStates=c(state.abb, "DC"), 
                                 keyDates=NULL, 
                                 ...
                                 ) {
    
    # FUNCTION ARGUMENTS:
    # lst: a processed list file containing dfPerCapita
    # keyStates: states to include in the plot
    # keyDates: dates to include in the burden plot
    #           NULL means default to max(date)-2 from current, 6 months ago, 12 months ago)
    # ...: other arguments to pass to tempStackPlot(), most commonly colorVector
    
    # Get the list of key dates
    if (is.null(keyDates)) {
        keyDates <- as.Date(max(lst[["dfPerCapita"]]$date)-2-lubridate::dmonths(c(0, 6, 12)), origin="1970-01-01")
    }
    
    # Convert to date if needed
    if (!("Date" %in% class(keyDates))) keyDates <- as.Date(keyDates)
    
    # Create data filtered for keyDates and keyStates
    burdenGrowth <- lst[["dfPerCapita"]] %>% 
        filter(date %in% all_of(keyDates), 
               state %in% all_of(keyStates)
               )

    # Create the naming vector for tempStackPlot
    vecName <- as.character(keyDates) %>% purrr::set_names(as.character(keyDates))
    
    # Create plot for cases
    p1 <- burdenGrowth %>%
        select(state, date, tcpm) %>% 
        mutate(tcpm=round(tcpm/1000)) %>%
        pivot_wider(state, names_from="date", values_from="tcpm") %>%
        tempStackPlot(yVars=vecName, 
                      yLab="Cumulative cases per thousand", 
                      plotTitle="Evolution of cumulative cases per thousand by state", 
                      addSuffix="",
                      scaleName="Date", 
                      ...
                      )

    # Create plot for deaths
    p2 <- burdenGrowth %>%
        select(state, date, tdpm) %>% 
        mutate(tdpm=round(tdpm)) %>%
        pivot_wider(state, names_from="date", values_from="tdpm") %>%
        tempStackPlot(yVars=vecName, 
                      yLab="Cumulative deaths per million", 
                      plotTitle="Evolution of cumulative deaths per million by state", 
                      addSuffix="",
                      scaleName="Date", 
                      ...
                      )

    # Print the plots
    gridExtra::grid.arrange(p1, p2, nrow=1)
    
    # Return the burden data
    burdenGrowth
    
}

# Run with general defaults
cumulativeBurdenPlot(cdc_daily_211006)

# Run for specified states and dates
cumulativeBurdenPlot(cdc_daily_211006, 
                     keyStates=state.abb[state.region=="South"], 
                     keyDates=c("2021-09-30", "2021-03-31", "2020-09-30", "2020-03-31")
                     )

# Pass a color vector
cumulativeBurdenPlot(cdc_daily_211006, 
                     keyStates=state.abb[state.region=="South"], 
                     keyDates=c("2021-09-30", "2021-06-30", "2021-03-31", 
                                "2020-12-31", "2020-09-30", "2020-06-30"
                                ), 
                     colorVector=c("lightblue", "grey", "green", "orange", "pink", "black")
                     )

```

Plots for vaccination are also updated:  
```{r, fig.height=9, fig.width=9}

# Run for fully vaccinated
tempStackPlot(cdc_daily_211006$dfRaw$vax %>% filter(date==max(date), state %in% c(state.abb, "DC")), 
              yVars=c("vxcgte65pct"="65+", 
                      "vxcgte18pct"="18+", 
                      "vxcpoppct"="All"
                      ), 
              yLab="% Fully vaccinated", 
              plotTitle="Fully vaccinated by age cohort and state (as of early-October 2021)"
              )

# Run for first dose
tempStackPlot(cdc_daily_211006$dfRaw$vax %>% filter(date==max(date), state %in% c(state.abb, "DC")), 
              yVars=c("Administered_Dose1_Recip_65PlusPop_Pct"="65+", 
                      "Administered_Dose1_Recip_18PlusPop_Pct"="18+", 
                      "Administered_Dose1_Pop_Pct"="All"
                      ), 
              yLab="% Receiving First Dose", 
              plotTitle="First-dose vaccinated by age cohort and state (as of early-October 2021)"
              )

# Create data
cdcVaxGrowth_211006 <- cdc_daily_211006$dfRaw$vax %>% 
    filter(date %in% c(as.Date(max(date)-lubridate::dmonths(c(0, 3, 6)), origin="1970-01-01")), 
           state %in% c(state.abb, "DC")
           )

# Run for fully vaccinated
p1 <- cdcVaxGrowth_211006 %>%
    select(state, date, vxcpoppct) %>%
    pivot_wider(state, names_from="date", values_from="vxcpoppct") %>%
    tempStackPlot(yVars=c("2021-10-05"="2021-10-05", 
                          "2021-07-05"="2021-07-05", 
                          "2021-04-05"="2021-04-05"
                          ), 
                  yLab="% Fully Vaccinated (all population)", 
                  plotTitle="Evolution of fully vaccinated rate by state"
                  )

p2 <- cdcVaxGrowth_211006 %>%
    select(state, date, vxcgte65pct) %>%
    pivot_wider(state, names_from="date", values_from="vxcgte65pct") %>%
    tempStackPlot(yVars=c("2021-10-05"="2021-10-05", 
                          "2021-07-05"="2021-07-05", 
                          "2021-04-05"="2021-04-05"
                          ), 
                  yLab="% Fully Vaccinated (65+)", 
                  plotTitle="Evolution of fully vaccinated rate by state"
                  )

gridExtra::grid.arrange(p1, p2, nrow=1)



# Run for first dose
p1 <- cdcVaxGrowth %>%
    select(state, date, Administered_Dose1_Pop_Pct) %>%
    pivot_wider(state, names_from="date", values_from="Administered_Dose1_Pop_Pct") %>%
    tempStackPlot(yVars=c("2021-08-15"="2021-08-15", 
                          "2021-06-15"="2021-06-15", 
                          "2021-04-15"="2021-04-15"
                          ), 
                  yLab="% First-dose (all population)", 
                  plotTitle="Evolution of first dose rate by state"
                  )

p2 <- cdcVaxGrowth %>%
    select(state, date, Administered_Dose1_Recip_65PlusPop_Pct) %>%
    pivot_wider(state, names_from="date", values_from="Administered_Dose1_Recip_65PlusPop_Pct") %>%
    tempStackPlot(yVars=c("2021-08-15"="2021-08-15", 
                          "2021-06-15"="2021-06-15", 
                          "2021-04-15"="2021-04-15"
                          ), 
                  yLab="% First-dose (65+)", 
                  plotTitle="Evolution of first dose rate by state"
                  )

gridExtra::grid.arrange(p1, p2, nrow=1)

```

The process is converted to functional form:  
```{r, fig.height=9, fig.width=9}

cumulativeVaccinePlot <- function(lst, 
                                 keyStates=c(state.abb, "DC"), 
                                 keyDates=NULL, 
                                 returnData=FALSE,
                                 ...
                                 ) {
    
    # FUNCTION ARGUMENTS:
    # lst: a processed list file containing dfPerCapita
    # keyStates: states to include in the plot
    # keyDates: dates to include in the burden plot
    #           NULL means default to max(date)-2 from current, 6 months ago, 12 months ago)
    # returnData: boolean, should the data be returned?
    # ...: other arguments to pass to tempStackPlot(), most commonly colorVector

    # Get the list of key dates
    if (is.null(keyDates)) {
        keyDates <- as.Date(max(lst[["dfRaw"]][["vax"]]$date)-2-lubridate::dmonths(c(0, 3, 6)), 
                            origin="1970-01-01"
                            )
    }
    
    # Convert to date if needed
    if (!("Date" %in% class(keyDates))) keyDates <- as.Date(keyDates)

    # Chart for fully vaccinated by state
    p5 <- tempStackPlot(lst[["dfRaw"]][["vax"]] %>% filter(date==max(keyDates), state %in% keyStates), 
                        yVars=c("vxcgte65pct"="65+", 
                                "vxcgte18pct"="18+", 
                                "vxcpoppct"="All"
                                ), 
                        yLab="% Fully vaccinated", 
                        plotTitle=paste0("Fully vaccinated by age cohort and state\n(as of ", max(keyDates), ")"), 
                        makeDotPlot=TRUE, 
                        yLims = c(0, 105)
                        )

    # Run for first dose
    p6 <- tempStackPlot(lst[["dfRaw"]][["vax"]] %>% filter(date==max(keyDates), state %in% keyStates), 
                        yVars=c("Administered_Dose1_Recip_65PlusPop_Pct"="65+", 
                                "Administered_Dose1_Recip_18PlusPop_Pct"="18+", 
                                "Administered_Dose1_Pop_Pct"="All"
                                ), 
                        yLab="% Receiving First Dose", 
                        plotTitle=paste0("First-dose vaccinated by age cohort and state\n(as of ", 
                                         max(keyDates), 
                                         ")"
                                         ),
                        makeDotPlot=TRUE,
                        yLims=c(0, 105)
                        )

    gridExtra::grid.arrange(p5, p6, nrow=1)
    
    # Create data filtered for keyDates and keyStates
    burdenGrowth <- lst[["dfRaw"]][["vax"]] %>% 
        filter(date %in% all_of(keyDates), 
               state %in% all_of(keyStates)
               )

    # Create the naming vector for tempStackPlot
    vecName <- as.character(keyDates) %>% purrr::set_names(as.character(keyDates))
    
    # Run for fully vaccinated
    p1 <- burdenGrowth %>%
        select(state, date, vxcpoppct) %>%
        pivot_wider(state, names_from="date", values_from="vxcpoppct") %>%
        tempStackPlot(yVars=vecName, 
                      yLab="% Fully Vaccinated (all population)", 
                      plotTitle="Evolution of fully vaccinated rate by state", 
                      ...
                      )

    p2 <- burdenGrowth %>%
        select(state, date, vxcgte65pct) %>%
        pivot_wider(state, names_from="date", values_from="vxcgte65pct") %>%
        tempStackPlot(yVars=vecName, 
                      yLab="% Fully Vaccinated (65+)", 
                      plotTitle="Evolution of fully vaccinated rate by state", 
                      ...
                      )

    gridExtra::grid.arrange(p1, p2, nrow=1)

    # Run for first dose
    p3 <- burdenGrowth %>%
        select(state, date, Administered_Dose1_Pop_Pct) %>%
        pivot_wider(state, names_from="date", values_from="Administered_Dose1_Pop_Pct") %>%
        tempStackPlot(yVars=vecName, 
                      yLab="% First-dose (all population)", 
                      plotTitle="Evolution of first dose rate by state", 
                      ...
                      )

    p4 <- burdenGrowth %>%
        select(state, date, Administered_Dose1_Recip_65PlusPop_Pct) %>%
        pivot_wider(state, names_from="date", values_from="Administered_Dose1_Recip_65PlusPop_Pct") %>%
        tempStackPlot(yVars=vecName, 
                      yLab="% First-dose (65+)", 
                      plotTitle="Evolution of first dose rate by state", 
                      ...
                      )

    gridExtra::grid.arrange(p3, p4, nrow=1)
    
    # Return the burden data
    if(isTRUE(returnData)) burdenGrowth
    
}


# Run with general defaults
cumulativeVaccinePlot(cdc_daily_211006)

# Run for specified states and dates
cumulativeVaccinePlot(cdc_daily_211006, 
                      keyStates=state.abb[state.region=="South"], 
                      keyDates=c("2021-09-30", "2021-06-30", "2021-03-31", "2020-12-31")
                      )

# Pass a color vector
cumulativeVaccinePlot(cdc_daily_211006, 
                      keyStates=state.abb[state.region=="South"], 
                      keyDates=c("2021-09-30", "2021-08-31", "2021-07-31", 
                                 "2021-06-30", "2021-05-31", "2021-04-30"
                                 ), 
                      colorVector=c("lightblue", "grey", "green", "orange", "pink", "black")
                      )

```

The functions are integrated for a post-processing capability:  
```{r, fig.height=9, fig.width=9}

postProcessCDCDaily <- function(lst, 
                                dataThruLabel,
                                keyStates=c(state.abb, "DC"), 
                                keyDatesBurden=NULL, 
                                keyDatesVaccine=NULL,
                                returnData=FALSE,
                                ...
                                ) {
    
    # FUNCTION ARGUMENTS:
    # lst: a processed list file from readRunCDCDaily
    # dataThruLabel: label for when the hospital data are through
    # keyStates: the list of states to be plotted (burden data will be created for all states)
    # keyDatesBurden: key dates to use for the burden plots (NULL means generate automatically)
    # keyDatesVaccine: key dates to use for the vaccine plots (NULL means generate automatically)
    # returnData: should the pivoted data be returned?
    # ...: other arguments passed through to cumulativeBurdenPlot()
    
    # Create the burden data
    burdenPivotList <- createBurdenPivot(lst, dataThru=dataThruLabel)

    # Create the cumulative burden plots
    cumulativeBurdenPlot(lst, 
                         keyStates=keyStates, 
                         keyDates=keyDatesBurden, 
                         ...
                         )
    
    # Create the cumulative vaccines data
    cumulativeVaccinePlot(lst, 
                          keyStates=keyStates, 
                          keyDates=keyDatesVaccine, 
                          ...
                          )
    
    if (isTRUE(returnData)) return(burdenPivotList)
    
}

# Example code
postProcessCDCDaily(cdc_daily_211006, 
                    dataThruLabel="Sep 2021", 
                    keyStates=state.abb[state.region=="South"], 
                    keyDatesBurden=c("2021-09-30", "2021-03-30", "2020-09-30", "2020-03-31"), 
                    keyDatesVaccine=c("2021-09-30", "2021-07-31", "2021-05-31", "2021-03-31")
                    )

```

Data from [the US Census](https://www.census.gov/data/tables/time-series/demo/popest/2010s-state-detail.html#par_textimage_673542126) is downloaded for age estimates by state. Per the documentation, AGE=85 means 85 and over, and AGE=999 means state total, while SEX=0 means total, SEX=1 means male, and SEX=2 means female:  
```{r}

popStateAge <- fileRead("./RInputFiles/sc-est2019-agesex-civ.csv")
popStateAge

# Exploration of the states and ages and sexes included
popStateAge %>% pull(NAME) %>% unique() %>% sort()
popStateAge %>% pull(AGE) %>% unique() %>% sort()
popStateAge %>% pull(SEX) %>% unique() %>% sort()

```
  
The data can then be explored for the total US population estimates over time, as well as the latest population estimates as of 2019:  
```{r, fig.height=9, fig.width=9}

# Total US population estimates
popStateAge %>%
    filter(AGE==999, NAME=="United States") %>%
    select(state=NAME, SEX, starts_with("POPEST")) %>%
    pivot_longer(-c(state, SEX)) %>%
    mutate(year=as.integer(stringr::str_extract(name, "\\d{4}")), 
           SEX=factor(SEX, levels=c("0", "1", "2"), labels=c("Total", "Male", "Female"))
           ) %>%
    ggplot(aes(x=factor(year))) + 
    geom_line(aes(y=value/1000000, group=SEX, color=SEX)) + 
    geom_text(aes(label=round(value/1000000, 1), 
                  y=value/1000000 + ifelse(SEX=="Male", -5, 5), 
                  color=SEX
                  )
              ) +
    lims(y=c(0, NA)) + 
    labs(x=NULL, y="Population (millions)", title="US Population Estimates by Year")

# Confirmation that US is the sum of the states
popStateAge %>%
    select(-c(SUMLEV, REGION, DIVISION, STATE)) %>%
    pivot_longer(-c(NAME, SEX, AGE)) %>%
    mutate(type=ifelse(NAME=="United States", "United States", "Component")) %>%
    group_by(type, SEX, AGE, name) %>%
    summarize(value=sum(value), .groups="drop") %>%
    pivot_wider(c(SEX, AGE, name), names_from="type", values_from="value") %>%
    mutate(diff=`United States`-Component) %>%
    arrange(-abs(diff))
    
# Using POPEST2019_CIV as the key metric
popStateAge_2019 <- popStateAge %>%
    filter(NAME != "United States") %>%
    select(stateFull=NAME, sex=SEX, age=AGE, pop2019=POPEST2019_CIV) %>%
    mutate(state=c(state.abb, "DC")[match(stateFull, c(state.name, "District of Columbia"))], 
           sex=factor(sex, levels=c("0", "1", "2"), labels=c("Total", "Male", "Female"))
           )
popStateAge_2019

# Total Population as of 2019
popStateAge_2019 %>%
    filter(age==999) %>%
    ggplot(aes(x=fct_reorder(state, pop2019, max))) + 
    geom_text(data=~filter(., sex == "Total"), 
              aes(label=paste0(round(pop2019/1000000, 1), " (", state, ")"), y=pop2019/1000000 + 0.1), 
              size=3, 
              hjust=0
              ) +
    geom_col(data=~filter(., sex != "Total"), aes(y=pop2019/1000000, fill=sex), position="stack") + 
    coord_flip() + 
    labs(x=NULL, y="Population (millions)", title="2019 Population by State and Sex")

# Population by Age as of 2019
popStateAge_2019 %>%
    filter(sex=="Total", age != 999) %>%
    group_by(age) %>%
    summarize(pop2019=sum(pop2019)) %>%
    ggplot(aes(x=factor(age))) + 
    geom_text(aes(label=round(pop2019/1000000, 1), y=pop2019/1000000 + 0.1), 
              size=3, 
              hjust=0
              ) +
    geom_col(aes(y=pop2019/1000000)) + 
    labs(x=NULL, y="Population (millions)", title="2019 Population by Age") + 
    coord_flip()

```

Population totals as well as splits by state, age, and sex seem reasonable. Age buckets are created and plotted by state:  
```{r, fig.height=9, fig.width=9}

# Add age buckets to data
popStateAgeBucket_2019 <- popStateAge_2019 %>%
    mutate(bucket10=case_when(age==999 ~ "Total", 
                              age <= 19 ~ "0-19", 
                              age >= 80 ~ "80+", 
                              TRUE ~ paste0(floor(age/10)*10, "-", floor(age/10)*10+9)
                              ), 
           bucket03=case_when(age==999 ~ "Total",age <= 19 ~ "0-19", age >= 60 ~ "60+", TRUE ~ "20-59"),
           bucketYMO=case_when(age==999 ~ "Total",age < 18 ~ "0-17", age >= 65 ~ "65+", TRUE ~ "18-64")
           )
popStateAgeBucket_2019

# Proportion by bucketYMO by state
popStateAgeBucket_2019 %>%
    filter(sex=="Total", age != 999) %>%
    group_by(state, bucketYMO) %>%
    summarize(pop2019=sum(pop2019), .groups="drop") %>%
    ggplot(aes(x=fct_reorder2(state, .x=bucketYMO, .y=pop2019, .fun=function(x, y) -sum(y[x=="0-17"])/sum(y)))) + 
    geom_col(aes(y=pop2019, fill=fct_rev(bucketYMO)), position="fill") + 
    coord_flip() + 
    labs(x=NULL, y="Proportion of 2019 population", title="Age distribution by state") + 
    scale_fill_discrete("Age Bucket")

# Proportion by bucket10 by state
popStateAgeBucket_2019 %>%
    filter(sex=="Total", age != 999) %>%
    group_by(state, bucket10) %>%
    summarize(pop2019=sum(pop2019), .groups="drop") %>%
    ggplot(aes(x=fct_reorder2(state, .x=bucket10, .y=pop2019, .fun=function(x, y) -sum(y[x=="0-19"])/sum(y)))) + 
    geom_col(aes(y=pop2019, fill=fct_rev(bucket10)), position="fill") + 
    coord_flip() + 
    labs(x=NULL, y="Proportion of 2019 population", title="Age distribution by state") + 
    scale_fill_discrete("Age Bucket")

# Mean age by state
popStateAgeBucket_2019 %>%
    filter(sex=="Total", age != 999) %>%
    group_by(state) %>%
    summarize(ageMean=sum(age*pop2019)/sum(pop2019), .groups="drop") %>%
    ggplot(aes(x=fct_reorder(state, -ageMean))) + 
    geom_text(aes(y=ageMean+0.2, label=round(ageMean, 1)), hjust=0, size=3) +
    geom_point(aes(y=ageMean)) + 
    coord_flip() + 
    labs(x=NULL, y="Average age", title="Mean age by state", subtitle="(caution that all 85+ counted as 85)") + 
    lims(y=c(0, NA))

```

There are meaningful differences in age distribution by state. Next steps are to incorporate per-capita metrics in to the hospitalization summaries:  
```{r, fig.height=9, fig.width=9}

# Integrate vpm in to the pivoted hospital data
burdenPivotList_211006$dfPivot %>%
    filter(name %in% c("0-19", "20-59", "60+"), state %in% c(state.abb, "DC"), !is.na(value)) %>%
    left_join(popStateAgeBucket_2019 %>%
                  filter(sex=="Total") %>%
                  group_by(state, bucket03) %>% 
                  summarize(pop2019=sum(pop2019), .groups="drop"), 
              by=c("state"="state", "name"="bucket03")
              ) %>%
    mutate(vpm=1000000*value/pop2019) %>%
    ggplot(aes(x=date, y=vpm)) + 
    geom_line(aes(group=name, color=name)) + 
    labs(x=NULL, y="Newly hospitalized per million", title="Per capita newly hospitalized by age bucket") +
    facet_wrap(~state, scales="free_y")

```

There is very significant variability by state that is not fully consistent with other metrics per capita such as cases and deaths. Further exploration is merited.

The hospitalized data in dfPivot was previously divided by total state population. The process is updated to use raw hospital data from hospAge:  
```{r, fig.height=9, fig.width=9}

ageMap <- popStateAgeBucket_2019 %>% 
    count(bucket10, bucket03) %>%
    filter(bucket10 != "Total") %>%
    select(-n)
ageMap

# Create hospitalized by age bucket by state data
hospBucketState <- burdenPivotList_211006$hospAge %>%
    left_join(ageMap, by=c("age"="bucket10")) %>%
    filter(!is.na(value)) %>%
    group_by(state, date, bucket03) %>%
    summarize(value=sum(value), .groups="drop") %>%
    filter(state %in% c(state.abb, "DC")) %>%
    left_join(popStateAgeBucket_2019 %>%
                  filter(sex=="Total") %>%
                  group_by(state, bucket03) %>% 
                  summarize(pop2019=sum(pop2019), .groups="drop"), 
              by=c("state", "bucket03")
              ) %>%
    mutate(vpm=1000000*value/pop2019) %>%
    group_by(state, bucket03) %>%
    arrange(date) %>%
    mutate(vpm7=zoo::rollmean(vpm, k=7, fill=NA), vpmcum=cumsum(vpm)) %>%
    ungroup()

hospBucketState %>%
    ggplot(aes(x=date, y=vpm7)) + 
    geom_line(aes(group=bucket03, color=bucket03)) + 
    labs(x=NULL, 
         y="Newly hospitalized per million (rolling 7-day mean)", 
         title="Per million newly hospitalized by age bucket"
         ) +
    facet_wrap(~state, scales="free_y") + 
    scale_color_discrete("Age")


hospBucketState %>%
    filter(state != "ND", date >= "2020-07-15") %>%
    ggplot(aes(x=date, y=vpmcum/1000)) + 
    geom_line(aes(group=bucket03, color=bucket03)) + 
    labs(x=NULL, 
         y="Cumulative hospitalized per thousand since 2020-07-15", 
         title="Cumulative newly hospitalized per thousand by age bucket", 
         subtitle="Since 2020-07-15, excludes ND"
         ) +
    facet_wrap(~state, scales="free_y") + 
    scale_color_discrete("Age")

```
  
The process to create population data by state and age is converted to functional form:  
```{r, fig.height=9, fig.width=9}

readPopStateAge <- function(loc) {
    
    # FUNCTION ARGUMENTS:
    # loc: file location on the local computer
    
    # Read the data
    df <- fileRead(loc) %>%
        checkUniqueRows(uniqueBy=c("NAME", "SEX", "AGE"))

    # Confirm that states, ages, and sexes are as expected
    a1 <- all.equal(sort(c(state.name, "District of Columbia", "United States")), 
                    df %>% pull(NAME) %>% unique() %>% sort()
                    )
    print(a1)
    a2 <- all.equal(c(0:85, 999), df %>% pull(AGE) %>% unique() %>% sort())
    print(a2)
    a3 <- all.equal(0:2, df %>% pull(SEX) %>% unique() %>% sort())
    print(a3)
    if(!isTRUE(a1) | !isTRUE(a2) | !isTRUE(a3)) stop("\nUnexpected values for state, age, or sex\n")

    # Plot for total US population estimates
    p1 <- df %>%
        filter(AGE==999, NAME=="United States") %>%
        select(state=NAME, SEX, starts_with("POPEST")) %>%
        pivot_longer(-c(state, SEX)) %>%
        mutate(year=as.integer(stringr::str_extract(name, "\\d{4}")), 
               SEX=factor(SEX, levels=c("0", "1", "2"), labels=c("Total", "Male", "Female"))
               ) %>%
        ggplot(aes(x=factor(year))) + 
        geom_line(aes(y=value/1000000, group=SEX, color=SEX)) + 
        geom_text(aes(label=round(value/1000000, 1), 
                      y=value/1000000 + ifelse(SEX=="Male", -5, 5), 
                      color=SEX
                      )
                  ) +
        lims(y=c(0, NA)) + 
        labs(x=NULL, y="Population (millions)", title="US Population Estimates by Year")
    print(p1)

    componentCheck <- function(vrbl, sumName, descMessage) {
        otherVars <- setdiff(c("NAME", "SEX", "AGE"), vrbl)
        dfCheck <- df %>%
            select(-c(SUMLEV, REGION, DIVISION, STATE)) %>%
            pivot_longer(-c(NAME, SEX, AGE)) %>%
            mutate(across(.cols=all_of(vrbl), .fns=~ifelse(.x==sumName, "Total", "Component"), .names="type")) %>%
            group_by_at(c("type", all_of(otherVars), "name")) %>%
            summarize(value=sum(value), .groups="drop") %>%
            pivot_wider(c(all_of(otherVars), "name"), names_from="type", values_from="value") %>%
            mutate(diff=Total-Component) %>%
            arrange(-abs(diff))
        if(max(abs(dfCheck$diff)) > 0) {
            print(dfCheck)
            stop(paste0("\nFAILED CHECK: ", descMessage, "\n"))
        } else {
            cat("\nPASSED CHECK:", descMessage, "\n\n")
        }
    }
    
    componentCheck("NAME", sumName="United States", descMessage="United States total is the sum of states and DC")
    componentCheck("AGE", sumName=999, descMessage="Age 999 total is the sum of the ages")
    componentCheck("SEX", sumName=0, descMessage="Sex 0 total is the sum of the sexes")

    # Return the data
    df
    
}


filterPopStateAge <- function(df, keyCol, keyColName=keyCol, yearLabel=NULL) {
    
    # FUNCTION ARGUENTS:
    # df: loaded data frame with columns
    # keyCol: the population column to select
    # keyColName: renaming to be applied for the population column (default will leave as-is)
    # yearLabel: label for year to use in plots (NULL means infer from keyCol)

    if (is.null(yearLabel)) yearLabel <- stringr::str_extract(keyCol, pattern="\\d{4}")
    
    # Create the selection and renaming vector
    useCols <- c("stateFull", "sex", "age", all_of(keyColName))
    names(useCols) <- c("NAME", "SEX", "AGE", all_of(keyCol))
    
    # Select the key variable and rename, add state abbreviation, convert sex to more interpretable factor
    dfFilter <- df %>%
        colSelector(names(useCols)) %>%
        colRenamer(useCols) %>%
        mutate(state=c(state.abb, "DC", "US")[match(stateFull, 
                                                    c(state.name, "District of Columbia", "United States")
                                                    )
                                              ], 
               sex=factor(sex, levels=c(0, 1, 2), labels=c("Total", "Male", "Female"))
               )

    # Plot for total population in the key year
    p1 <- dfFilter %>%
        filter(age==999, state != "US") %>%
        ggplot(aes(x=fct_reorder(state, get(keyColName), max))) + 
        geom_text(data=~filter(., sex == "Total"), 
                  aes(label=paste0(round(get(keyColName)/1000000, 1), " (", state, ")"), 
                      y=get(keyColName)/1000000 + 0.1
                      ), 
                  size=3, 
                  hjust=0
                  ) +
        geom_col(data=~filter(., sex != "Total"), aes(y=get(keyColName)/1000000, fill=sex), position="stack") + 
        coord_flip() + 
        labs(x=NULL, y="Population (millions)", title=paste0(yearLabel, " Population by State and Sex"))
    print(p1)
    
    # Population by Age in the key year
    p2 <- dfFilter %>%
        filter(sex=="Total", age != 999, state != "US") %>%
        group_by(age) %>%
        summarize(across(.cols=all_of(keyColName), sum)) %>%
        ggplot(aes(x=factor(age))) + 
        geom_text(aes(label=round(get(keyColName)/1000000, 1), y=get(keyColName)/1000000 + 0.1), 
                  size=3, 
                  hjust=0
                  ) +
        geom_col(aes(y=get(keyColName)/1000000), fill="lightblue") + 
        labs(x=NULL, y="Population (millions)", title=paste0(yearLabel, " Population by Age")) + 
        coord_flip()
    print(p2)

    # Return the data
    dfFilter
    
}


bucketPopStateAge <- function(df, popVar, popYearLabel=NULL) {
    
    # FUNCTION ARGUMENTS:
    # df: a filtered data frame containing the year of interest
    # popVar: name of the population variable
    # popYearLabel: year to use in the plot titles (NULL means infer from popVar)

    # Infer popYearLabel if not provided
    if(is.null(popYearLabel)) popYearLabel <- stringr::str_extract(popVar, pattern="\\d{4}")
    
    # Add age buckets to data
    dfBucket <- df %>%
        mutate(bucket10=case_when(age==999 ~ "Total", 
                                  age <= 19 ~ "0-19", 
                                  age >= 80 ~ "80+", 
                                  TRUE ~ paste0(floor(age/10)*10, "-", floor(age/10)*10+9)
                                  ), 
               bucket03=case_when(age==999 ~ "Total",age <= 19 ~ "0-19", age >= 60 ~ "60+", TRUE ~ "20-59"),
               bucketYMO=case_when(age==999 ~ "Total",age < 18 ~ "0-17", age >= 65 ~ "65+", TRUE ~ "18-64")
               )
    
    # Check that buckets worked as intended
    checkBucket <- function(keyVar) {
        dfBucket %>% 
            count(age, y=get(keyVar)) %>% 
            ggplot(aes(x=factor(age), y=y)) + 
            geom_tile(aes(fill=n)) + 
            coord_flip() + 
            labs(x=NULL, y=NULL, title=paste0("Age map for: ", keyVar))
    }
    p1 <- checkBucket(keyVar="bucket10")
    p2 <- checkBucket(keyVar="bucket03")
    p3 <- checkBucket(keyVar="bucketYMO")
    gridExtra::grid.arrange(p1, p2, p3, nrow=1)
    
    # Proportion by bucketYMO by state
    p4 <- dfBucket %>%
        filter(sex=="Total", age != 999, state != "US") %>%
        group_by(state, bucketYMO) %>%
        summarize(pop=sum(get(popVar)), .groups="drop") %>%
        ggplot(aes(x=fct_reorder2(state, .x=bucketYMO, .y=pop, .fun=function(x, y) -sum(y[x=="0-17"])/sum(y)))) + 
        geom_col(aes(y=pop, fill=fct_rev(bucketYMO)), position="fill") + 
        coord_flip() + 
        labs(x=NULL, 
             y=paste0("Proportion of ", popYearLabel, " population"), 
             title="Age distribution by state"
             ) + 
        scale_fill_discrete("Age Bucket")
    print(p4)
    
    # Proportion by bucket10 by state
    p5 <- dfBucket %>%
        filter(sex=="Total", age != 999, state != "US") %>%
        group_by(state, bucket10) %>%
        summarize(pop=sum(get(popVar)), .groups="drop") %>%
        ggplot(aes(x=fct_reorder2(state, .x=bucket10, .y=pop, .fun=function(x, y) -sum(y[x=="0-19"])/sum(y)))) + 
        geom_col(aes(y=pop, fill=fct_rev(bucket10)), position="fill") + 
        coord_flip() + 
        labs(x=NULL, 
             y=paste0("Proportion of ", popYearLabel, " population"), 
             title="Age distribution by state"
             ) + 
        scale_fill_discrete("Age Bucket")
    print(p5)

    # Mean age by state
    p6 <- dfBucket %>%
        filter(sex=="Total", age != 999, state != "US") %>%
        group_by(state) %>%
        mutate(age=ifelse(age==85, 90, age)) %>%
        summarize(ageMean=sum(age*get(popVar))/sum(get(popVar)), .groups="drop") %>%
        ggplot(aes(x=fct_reorder(state, -ageMean))) + 
        geom_text(aes(y=ageMean+0.2, label=round(ageMean, 1)), hjust=0, size=3) +
        geom_point(aes(y=ageMean)) + 
        coord_flip() + 
        labs(x=NULL, 
             y="Average age", 
             title="Mean age by state", 
             subtitle="(caution that all 85+ counted as 90 for mean calculation)"
             ) + 
        lims(y=c(0, NA))
    print(p6)
    
    # Return the bucketed data
    dfBucket
    
}

dfStateAgeBucket <- readPopStateAge("./RInputFiles/sc-est2019-agesex-civ.csv") %>%
    filterPopStateAge(keyCol="POPEST2019_CIV", keyColName="pop2019") %>%
    bucketPopStateAge(popVar="pop2019")
dfStateAgeBucket

```

Age-adjusted plots of hospitaliztion are also created:  
```{r, fig.height=9, fig.width=9}

hospAgePerCapita <- function(dfBucket, 
                             lst, 
                             popVar, 
                             excludeState=c(), 
                             cumStartDate=NULL
                             ) {
    
    # FUNCTION ARGUMENTS:
    # dfBucket: data frame containing bucketed age data by state
    # lst: a processed list file containing $hospAge
    # popVar: name of the population variable in dfBucket
    # excludeState: list of states to exclude from cumulative plot
    # cumStateDate: data to start the cumulative plots (NULL means use earliest date in data)
    
    # Find cumStartDate if not passed
    if(is.null(cumStartDate)) cumStartDate <- lst[["hospAge"]]$date %>% min()
    
    # Create mapping from bucket10 to bucket03
    ageMap10to03 <- dfBucket %>% 
        count(bucket10, bucket03) %>%
        select(-n)
    
    # Create population by state and bucket03
    popStateBucket03 <- dfBucket %>%
        filter(sex=="Total", state != "US") %>%
        group_by(state, bucket03) %>% 
        summarize(pop=sum(get(popVar)), .groups="drop")
    
    # Create hospitalized by age bucket by state data
    dfUse <- lst[["hospAge"]] %>%
        left_join(ageMap10to03, by=c("age"="bucket10")) %>%
        filter(!is.na(value)) %>%
        group_by(state, date, bucket03) %>%
        summarize(value=sum(value), .groups="drop") %>%
        filter(state %in% c(state.abb, "DC")) %>%
        left_join(popStateBucket03, by=c("state", "bucket03")) %>%
        mutate(vpm=1000000*value/pop) %>%
        group_by(state, bucket03) %>%
        arrange(date) %>%
        mutate(vpm7=zoo::rollmean(vpm, k=7, fill=NA), vpmcum=cumsum(vpm)) %>%
        ungroup()

    p1 <- dfUse %>%
        ggplot(aes(x=date, y=vpm7)) + 
        geom_line(aes(group=bucket03, color=bucket03)) + 
        labs(x=NULL, 
             y="Newly hospitalized per million (rolling 7-day mean)", 
             title="Per million newly hospitalized by age bucket"
             ) +
        facet_wrap(~state, scales="free_y") + 
        scale_color_discrete("Age")
    print(p1)
    
    p2 <- dfUse %>%
        filter(!(state %in% all_of(excludeState)), date >= cumStartDate) %>%
        ggplot(aes(x=date, y=vpmcum/1000)) + 
        geom_line(aes(group=bucket03, color=bucket03)) + 
        labs(x=NULL, 
             y=paste0("Cumulative hospitalized per thousand since ", cumStartDate), 
             title="Cumulative newly hospitalized per thousand by age bucket", 
             subtitle=paste0("Since ", 
                             cumStartDate, 
                             if(length(excludeState) > 0) paste0(", excludes ", paste0(excludeState, collapse=", ")) 
                             else ""
                             )
         ) +
        facet_wrap(~state, scales="free_y") + 
        scale_color_discrete("Age")
    print(p2)
    
    # Return the dataset
    dfUse
    
}

hospAgePerCapita(dfStateAgeBucket, 
                 lst=burdenPivotList_211006, 
                 popVar="pop2019", 
                 excludeState=c("ND"), 
                 cumStartDate="2020-07-15"
                 )

```

The full post-process is converted to functional form, with the option to return key elements in the list:  
```{r, fig.height=9, fig.width=9}

# Can be run only as-needed
dfStateAgeBucket <- readPopStateAge("./RInputFiles/sc-est2019-agesex-civ.csv") %>%
    filterPopStateAge(keyCol="POPEST2019_CIV", keyColName="pop2019") %>%
    bucketPopStateAge(popVar="pop2019")

# Create pivoted burden data
burdenPivotList_211006 <- postProcessCDCDaily(cdc_daily_211006, 
                                              dataThruLabel="Sep 2021", 
                                              keyStates=state.abb[state.region=="South"], 
                                              keyDatesBurden=c("2021-09-30", "2021-03-30", 
                                                               "2020-09-30", "2020-03-31"
                                                               ),
                                              keyDatesVaccine=c("2021-09-30", "2021-07-31", 
                                                                "2021-05-31", "2021-03-31"
                                                                ), 
                                              returnData=TRUE
                                              )

# Create hospitalized per capita data
hospAgePerCapita(dfStateAgeBucket, 
                 lst=burdenPivotList_211006, 
                 popVar="pop2019", 
                 excludeState=c("ND"), 
                 cumStartDate="2020-07-15"
                 )

```
  
The full process is run with the latest data and cached:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

readList <- list("cdcDaily"="./RInputFiles/Coronavirus/CDC_dc_downloaded_211024.csv", 
                 "cdcHosp"="./RInputFiles/Coronavirus/CDC_h_downloaded_211024.csv", 
                 "vax"="./RInputFiles/Coronavirus/vaxData_downloaded_211024.csv"
                 )
compareList <- list("cdcDaily"=readFromRDS("cdc_daily_211006")$dfRaw$cdcDaily, 
                    "cdcHosp"=readFromRDS("cdc_daily_211006")$dfRaw$cdcHosp, 
                    "vax"=readFromRDS("cdc_daily_211006")$dfRaw$vax
                    )

cdc_daily_211024 <- readRunCDCDaily(thruLabel="Oct 23, 2021", 
                                    downloadTo=lapply(readList, FUN=function(x) if(file.exists(x)) NA else x), 
                                    readFrom=readList,
                                    compareFile=compareList, 
                                    writeLog=NULL, 
                                    useClusters=readFromRDS("cdc_daily_210528")$useClusters, 
                                    weightedMeanAggs=c("tcpm7", "tdpm7", "cpm7", "dpm7", "hpm7", 
                                                       "vxcpm7", "vxcgte65pct"
                                                       ),
                                    skipAssessmentPlots=FALSE, 
                                    brewPalette="Paired"
                                    )

saveToRDS(cdc_daily_211024)

```

The post-processing steps are then run;  
```{r, fig.height=9, fig.width=9}

# Create pivoted burden data
burdenPivotList_211024 <- postProcessCDCDaily(cdc_daily_211024, 
                                              dataThruLabel="Oct 23, 2021", 
                                              keyDatesBurden=c("2021-10-23", "2021-04-23", 
                                                               "2020-10-23", "2020-04-23"
                                                               ),
                                              keyDatesVaccine=c("2021-10-23", "2021-08-23", 
                                                                "2021-06-23", "2021-04-23"
                                                                ), 
                                              returnData=TRUE
                                              )

# Create hospitalized per capita data
hospAgePerCapita(dfStateAgeBucket, 
                 lst=burdenPivotList_211024, 
                 popVar="pop2019", 
                 excludeState=c("ND"), 
                 cumStartDate="2020-07-15"
                 )

# Create CFR plots for select states
cfrStates <- list("FL"=list(keyState="FL", minDate="2020-08-01", multDeath=70), 
                  "LA"=list(keyState="LA", minDate="2020-08-01", multDeath=80), 
                  "CA"=list(keyState="CA", minDate="2020-08-01", multDeath=100), 
                  "IL"=list(keyState="IL", minDate="2020-08-01", multDeath=100)
                  )
purrr::walk(cfrStates, .f=function(x) onePageCFRPlot(burdenPivotList_211024$dfPivot, 
                                                     keyState=x$keyState, 
                                                     minDate=x$minDate, 
                                                     multDeath=x$multDeath
                                                     )
            )

```
  
A function is written to find local peaks in a vector. Peaks are defined as local maxima for a given window:  
```{r, fig.height=9, fig.width=9}

# Function to find local extrema in a vector
findPeaks <- function(x, 
                      width=1, 
                      align="center", 
                      FUN=max, 
                      gt=if(identical(FUN, max)) 0 else NULL, 
                      lt=if(identical(FUN, min)) 0 else NULL, 
                      fillVal=if(identical(FUN, max)) gt else if(identical(FUN, min)) lt else NA, 
                      epsTol=1e-12,
                      returnBool=TRUE, 
                      ...
                      ) {
    
    # FUNCTION ARGUMENTS:
    # x: a numeric vector
    # width: the width of the window to use
    # align: whether the window should be "center", "left", or "right"
    # FUN: the function to be used (max to find peaks, min to find valleys)
    # gt: to be defined, the value must be greater than gt (NULL means use any value)
    # lt: to be defined, the value must be less than lt (NULL means use any value)
    # fillVal: value to use as output if a window does not exist (too close to boundary)
    # epsTol: the epsilon value for considering two values to be the same
    # returnBool: should the boolean be returned? TRUE means return TRUE/FALSE for peaks, FALSE means return vector
    # ...: any other arguments to be passed to zoo::rollapply()
    
    # Create the rolling data
    rolls <- zoo::rollapply(x, width=width, align=align, FUN=FUN, fill=fillVal, ...)
    
    # No post-processing applied unless returnBool is TRUE
    if(!isTRUE(returnBool)) return(rolls)
    
    # Post-processing managed for gt and lt
    if(!is.null(gt)) rolls <- ifelse(rolls<=gt, NA, rolls)
    if(!is.null(lt)) rolls <- ifelse(rolls>=lt, NA, rolls)
    
    # Return the boolean vector
    !is.na(rolls) & (abs(rolls-x) <= epsTol)
    
}

# Testing on a sinusoidal sequence
sinX <- seq(0, 10*pi, by=0.01*pi)
ggplot(tibble::tibble(x=sinX, y=sin(sinX)), aes(x=x, y=y)) + 
    geom_line() + 
    geom_point(data=~filter(tibble::tibble(x=sinX, y=sin(sinX), z=findPeaks(y, width=21)), z), 
               color="green", 
               size=5
               ) +
    geom_point(data=~filter(tibble::tibble(x=sinX, y=sin(sinX), z=findPeaks(y, width=21, FUN=min)), z), 
               color="red", 
               size=5
               ) +
    labs(x=NULL, 
         y=NULL, 
         title="Example of maxima and minima for a sin curve", 
         subtitle="Green (max) and Red (min)"
         )

# Testing on national deaths data
cdc_daily_211024$dfPerCapita %>%
    group_by(date) %>%
    summarize(deaths=sum(new_deaths, na.rm=TRUE), .groups="drop") %>%
    mutate(deaths7=zoo::rollmean(deaths, k=7, fill=NA), 
           isPeak=findPeaks(deaths7, width=29, gt=1), 
           isValley=findPeaks(deaths7, width=29, FUN=min, gt=1, lt=NULL, fillVal=NA)
           ) %>%
    ggplot(aes(x=date, y=deaths7)) + 
    geom_line() + 
    geom_point(data=~filter(., isPeak), color="red", size=3) +
    geom_text(data=~filter(., isPeak), aes(y=deaths7+100, label=date), color="red", size=3) + 
    geom_point(data=~filter(., isValley), color="green", size=3) + 
    geom_text(data=~filter(., isValley), aes(y=deaths7-100, label=date), color="black", size=3) + 
    labs(x=NULL, 
         y="Rolling 7-day mean deaths", 
         title="US COVID deaths peaks and valleys", 
         subtitle="Red (peaks) and green (valleys)"
         )

```

The peaks can be calculated by census region with values for the peak and valley included:  
```{r, fig.height=9, fig.width=9}

cdc_daily_211024$dfPerCapita %>% 
    mutate(region=c(as.character(state.region), "South")[match(state, c(state.abb, "DC"))]) %>%
    group_by(region, date) %>%
    summarize(deaths=sum(new_deaths, na.rm=TRUE), .groups="drop") %>% 
    group_by(region) %>%
    mutate(deaths7=zoo::rollmean(deaths, k=7, fill=NA), 
           isPeak=findPeaks(deaths7, width=71, gt=1), 
           isValley=findPeaks(deaths7, width=71, FUN=min, gt=1, lt=NULL, fillVal=NA)
    ) %>% 
    ungroup() %>%
    ggplot(aes(x=date, y=deaths7)) + 
    geom_line() + 
    geom_point(data=~filter(., isPeak), color="red", size=3) +
    geom_text(data=~filter(., isPeak), 
              aes(y=deaths7+100, label=paste0(date, "\n", round(deaths))), 
              color="red", 
              size=3
              ) + 
    geom_point(data=~filter(., isValley), color="green", size=3) + 
    geom_text(data=~filter(., isValley), 
              aes(y=deaths7-100, label=paste0(date, "\n", round(deaths))), 
              color="black", 
              size=3
              ) + 
    labs(x=NULL, 
         y="Rolling 7-day mean deaths", 
         title="US COVID deaths peaks and valleys", 
         subtitle="Red (peaks) and green (valleys)"
         ) + 
    facet_wrap(~region, scales="free_y")

```

A similar approach can be run for states of at least 5 million people:  
```{r, fig.height=9, fig.width=9}

cdc_daily_211024$dfPerCapita %>% 
    filter(state %in% (getStateData() %>% filter(pop >= 5000000) %>% pull(state))) %>%
    group_by(state, date) %>%
    summarize(deaths=sum(new_deaths, na.rm=TRUE), .groups="drop") %>% 
    group_by(state) %>%
    mutate(deaths7=zoo::rollmean(deaths, k=7, fill=NA), 
           isPeak=findPeaks(deaths7, width=71, gt=1), 
           isValley=findPeaks(deaths7, width=71, FUN=min, gt=1, lt=NULL, fillVal=NA)
    ) %>% 
    ungroup() %>%
    ggplot(aes(x=date, y=deaths7)) + 
    geom_line() + 
    geom_point(data=~filter(., isPeak), color="red", size=3) +
    geom_text(data=~filter(., isPeak), 
              aes(y=deaths7+100, label=paste0(date, "\n", round(deaths))), 
              color="red", 
              size=3
              ) + 
    geom_point(data=~filter(., isValley), color="green", size=3) + 
    geom_text(data=~filter(., isValley), 
              aes(y=deaths7-100, label=paste0(date, "\n", round(deaths))), 
              color="black", 
              size=3
              ) + 
    labs(x=NULL, 
         y="Rolling 7-day mean deaths", 
         title="US COVID deaths peaks and valleys", 
         subtitle="Red (peaks) and green (valleys)"
         ) + 
    facet_wrap(~state, scales="free_y")

```
  
There is some noise to the state-level data, but the approach is generally identifying the right peaks and valleys. Next steps are to add post-processing so that certain peaks and valleys (such as a repeating value) are filtered. The approach is applied to US hospitalizations data:  
```{r, fig.height=9, fig.width=9}

cdc_daily_211024$dfPerCapita %>% 
    group_by(date) %>%
    summarize(hosp=sum(inp, na.rm=TRUE), .groups="drop") %>% 
    mutate(hosp7=zoo::rollmean(hosp, k=7, fill=NA), 
           isPeak=findPeaks(hosp7, width=71, gt=1), 
           isValley=findPeaks(hosp7, width=71, FUN=min, gt=1, lt=NULL, fillVal=NA)
    ) %>% 
    ungroup() %>%
    ggplot(aes(x=date, y=hosp7/1000)) + 
    geom_line() + 
    geom_point(data=~filter(., isPeak), color="red", size=3) +
    geom_text(data=~filter(., isPeak), 
              aes(y=hosp7/1000+10, label=paste0(date, "\n", round(hosp7/1000, 1))), 
              color="red", 
              size=3
              ) + 
    geom_point(data=~filter(., isValley), color="green", size=3) + 
    geom_text(data=~filter(., isValley), 
              aes(y=hosp7/1000-10, label=paste0(date, "\n", round(hosp7/1000, 1))), 
              color="black", 
              size=3
              ) + 
    labs(x=NULL, 
         y="Rolling 7-day mean hospitalized (000)", 
         title="US COVID hospitalized (000) peaks and valleys", 
         subtitle="Red (peaks) and green (valleys)"
         )

```
  
A function is written to allow for different variables and facets to be used:  
```{r, fig.height=9, fig.width=9}

makePeakValley <- function(df, 
                           numVar, 
                           windowWidth,
                           rollMean=NULL, 
                           uqBy=c("date"), 
                           facetVar=c(), 
                           fnNumVar=function(x) x, 
                           fnPeak=function(x) x+100, 
                           fnValley=function(x) x-100, 
                           useTitle="", 
                           yLab=""
                           ) {
    
    # FUNCTION ARGUMENTS
    # df: a data frame or tibble
    # numVar: the numeric variable of interest
    # windowWidth: width of the window for calculating peaks and valleys
    # rollMean: the number of days for rolling mean (NULL means no rolling mean)
    # uqBy: variable that the resutling data should be unique by
    # facetVar: variable for faceting (c() means no facets)
    # fnNumVar: what function should be applied to numVar (e.g., function(x) x/1000)
    # fnPeak: function for plotting the peak labels
    # fnValley: function for plotting the valley labels
    # useTitle: title for plots
    # yLab: y-axis label for plots
    
    # Create named vectors for useTitle and yLab if not passed
    if(is.null(names(useTitle))) 
        useTitle <- rep(useTitle, times=length(numVar)) %>% purrr::set_names(all_of(numVar))
    if(is.null(names(yLab))) 
        yLab <- rep(yLab, times=length(numVar)) %>% purrr::set_names(all_of(numVar))
    
    # Create named lists for fnNumVar, fnPeak, and fnValley
    tempMakeList <- function(f, n, nms) {
        tempList <- vector("list", length=n)
        for(a in 1:n) tempList[[a]] <- f
        names(tempList) <- nms
        tempList
    }
    if(is.null(names(fnNumVar))) fnNumVar <- tempMakeList(fnNumVar, n=length(numVar), nms=numVar)
    if(is.null(names(fnPeak))) fnPeak <- tempMakeList(fnPeak, n=length(numVar), nms=numVar)
    if(is.null(names(fnValley))) fnValley <- tempMakeList(fnValley, n=length(numVar), nms=numVar)
    
    # Create the relevant data frame
    newDF <- df %>% 
        group_by_at(all_of(c(uqBy, facetVar))) %>%
        summarize(across(all_of(numVar), .fns=sum, na.rm=TRUE), .groups="drop") %>%
        group_by_at(all_of(facetVar)) %>%
        mutate(if(!is.null(rollMean)) across(all_of(numVar), .fns=zoo::rollmean, k=rollMean, fill=NA),
               across(all_of(numVar), .fns=findPeaks, width=windowWidth, gt=1, .names="{.col}_isPeak"),
               across(all_of(numVar), 
                      .fns=findPeaks, 
                      width=windowWidth, 
                      FUN=min, 
                      gt=1, 
                      lt=NULL, 
                      fillVal=NA 
                      ,.names="{.col}_isValley"
                      )
               ) %>% 
        ungroup()
    
    # Create the relevant plots
    for(keyVar in numVar) {
    
        p1 <- newDF %>%
            ggplot(aes(x=get(uqBy), y=fnNumVar[[keyVar]](get(keyVar)))) + 
            geom_line() + 
            geom_point(data=~filter(., get(paste0(keyVar, "_isPeak"))), color="red", size=3) +
            geom_point(data=~filter(., get(paste0(keyVar, "_isValley"))), color="green", size=3) + 
            geom_text(data=~filter(., get(paste0(keyVar, "_isPeak"))), 
                      aes(y=fnPeak[[keyVar]](fnNumVar[[keyVar]](get(keyVar))), 
                          label=paste0(get(uqBy), "\n", round(fnNumVar[[keyVar]](get(keyVar))))
                          ), 
                      color="red", 
                      size=3
                      ) + 
            geom_text(data=~filter(., get(paste0(keyVar, "_isValley"))), 
                      aes(y=fnValley[[keyVar]](fnNumVar[[keyVar]](get(keyVar))), 
                          label=paste0(get(uqBy), "\n", round(fnNumVar[[keyVar]](get(keyVar))))
                          ), 
                      color="black", 
                      size=3
                      ) + 
            labs(x=NULL, 
                 y=yLab[[keyVar]], 
                 title=useTitle[[keyVar]], 
                 subtitle="Red (peaks) and green (valleys)"
                 )
        if(length(facetVar) > 0) p1 <- p1 + facet_wrap(~get(facetVar), scales="free_y")

        print(p1)
    
    }
    
    return(newDF)
    
}

cdc_daily_211024$dfPerCapita %>%
    mutate(regn=c(as.character(state.region), "South")[match(state, c(state.abb, "DC"))]) %>%
    makePeakValley(numVar=c("new_deaths", "new_cases", "inp"), 
                   windowWidth = 71, 
                   rollMean=7, 
                   facetVar=c("regn"), 
                   fnNumVar=function(x) x/1000, 
                   useTitle=c("new_deaths"="US coronavirus deaths", 
                              "new_cases"="US coronavirus cases", 
                              "inp"="US coronavirus total hospitalized"
                              ), 
                   yLab=c("new_deaths"="Rolling 7-day mean deaths (000)", 
                          "new_cases"="Rolling 7-day mean cases (000)", 
                          "inp"="Rolling 7-day mean in hospital (000)"
                          )
                   )

cdc_daily_211024$dfPerCapita %>%
    mutate(regn=c(as.character(state.region), "South")[match(state, c(state.abb, "DC"))]) %>%
    makePeakValley(numVar=c("new_deaths", "new_cases", "inp"), 
                   windowWidth = 71, 
                   rollMean=7, 
                   facetVar=c("regn"), 
                   fnNumVar=list("new_deaths"=function(x) x, 
                                 "new_cases"=function(x) x/1000,
                                 "inp"=function(x) x/1000
                                 ), 
                   fnPeak=list("new_deaths"=function(x) x+100, 
                               "new_cases"=function(x) x+10, 
                               "inp"=function(x) x+10
                               ),
                   fnValley=list("new_deaths"=function(x) x-100, 
                                 "new_cases"=function(x) x-5, 
                                 "inp"=function(x) x-5
                                 ),
                   useTitle=c("new_deaths"="US coronavirus deaths", 
                              "new_cases"="US coronavirus cases", 
                              "inp"="US coronavirus total hospitalized"
                              ), 
                   yLab=c("new_deaths"="Rolling 7-day mean deaths", 
                          "new_cases"="Rolling 7-day mean cases (000)", 
                          "inp"="Rolling 7-day mean in hospital (000)"
                          )
                   )

```

The same process is run with the vaccinations data:  
```{r, fig.height=9, fig.width=9}

cdc_daily_211024$dfPerCapita %>%
    select(date, state, vxa, vxc) %>%
    arrange(date, state) %>%
    group_by(state) %>%
    mutate(across(c(vxa, vxc), .fns=function(x) x-lag(x))) %>%
    ungroup() %>%
    mutate(regn=c(as.character(state.region), "South")[match(state, c(state.abb, "DC"))]) %>%
    filter(date >= "2020-12-01") %>%
    makePeakValley(numVar=c("vxc", "vxa"), 
                   windowWidth = 29, 
                   rollMean=15, 
                   facetVar=c("regn"), 
                   fnNumVar=list("vxa"=function(x) x/1000, 
                                 "vxc"=function(x) x/1000
                                 ), 
                   fnPeak=list("vxa"=function(x) x+50, 
                               "vxc"=function(x) x+50
                               ),
                   fnValley=list("vxa"=function(x) x-50, 
                                 "vxc"=function(x) x-50
                                 ),
                   useTitle=c("vxa"="Vaccines adminsitered (US)", 
                              "vxc"="Became fully vaccinated (US)"
                              ), 
                   yLab=c("vxa"="Rolling 15-day mean administered (000)",
                          "vxc"="Rolling 15-day mean completed (000)"
                          )
                   )

```

The process is repeated, focused only on states of at least 8 million people:  
```{r, fig.height=9, fig.width=9}

cdc_daily_211024$dfPerCapita %>%
    inner_join(getStateData(), by=c("state")) %>%
    filter(pop >= 8000000) %>%
    select(date, state, vxa, vxc) %>%
    arrange(date, state) %>%
    group_by(state) %>%
    mutate(across(c(vxa, vxc), .fns=function(x) x-lag(x))) %>%
    ungroup() %>%
    mutate(regn=c(as.character(state.region), "South")[match(state, c(state.abb, "DC"))]) %>%
    filter(date >= "2020-12-01") %>%
    makePeakValley(numVar=c("vxc", "vxa"), 
                   windowWidth = 29, 
                   rollMean=21, 
                   facetVar=c("state"), 
                   fnNumVar=list("vxa"=function(x) x/1000, 
                                 "vxc"=function(x) x/1000
                                 ), 
                   fnPeak=list("vxa"=function(x) x+25, 
                               "vxc"=function(x) x+25
                               ),
                   fnValley=list("vxa"=function(x) x-25, 
                                 "vxc"=function(x) x-25
                                 ),
                   useTitle=c("vxa"="Vaccines adminsitered (US)", 
                              "vxc"="Became fully vaccinated (US)"
                              ), 
                   yLab=c("vxa"="Rolling 21-day mean administered (000)",
                          "vxc"="Rolling 21-day mean completed (000)"
                          )
                   )

```

Next steps are to allow for a custom function by facet, to allow for labels in different positions when facets have different ranges:  
```{r, fig.height=9, fig.width=9}

makePeakValley <- function(df, 
                           numVar, 
                           windowWidth,
                           rollMean=NULL, 
                           uqBy=c("date"), 
                           facetVar=c(), 
                           fnNumVar=function(x) x, 
                           fnPeak=function(x) x+100, 
                           fnValley=function(x) x-100, 
                           fnGroupFacet=FALSE,
                           useTitle="", 
                           yLab=""
                           ) {
    
    # FUNCTION ARGUMENTS
    # df: a data frame or tibble
    # numVar: the numeric variable of interest
    # windowWidth: width of the window for calculating peaks and valleys
    # rollMean: the number of days for rolling mean (NULL means no rolling mean)
    # uqBy: variable that the resutling data should be unique by
    # facetVar: variable for faceting (c() means no facets)
    # fnNumVar: what function should be applied to numVar (e.g., function(x) x/1000)
    # fnPeak: function for plotting the peak labels
    # fnValley: function for plotting the valley labels
    # fnGroupFacet: boolean, should the functions be run separatelt for each facet as a grouping variable?
    #               useful for labeling if the goal is to use 0.1*max(yVar) rather than a global peak and valley
    # useTitle: title for plots
    # yLab: y-axis label for plots
    
    # Create named vectors for useTitle and yLab if not passed
    if(is.null(names(useTitle))) 
        useTitle <- rep(useTitle, times=length(numVar)) %>% purrr::set_names(all_of(numVar))
    if(is.null(names(yLab))) 
        yLab <- rep(yLab, times=length(numVar)) %>% purrr::set_names(all_of(numVar))
    
    # Create named lists for fnNumVar, fnPeak, and fnValley
    tempMakeList <- function(f, n, nms) {
        tempList <- vector("list", length=n)
        for(a in 1:n) tempList[[a]] <- f
        names(tempList) <- nms
        tempList
    }
    if(is.null(names(fnNumVar))) fnNumVar <- tempMakeList(fnNumVar, n=length(numVar), nms=numVar)
    if(is.null(names(fnPeak))) fnPeak <- tempMakeList(fnPeak, n=length(numVar), nms=numVar)
    if(is.null(names(fnValley))) fnValley <- tempMakeList(fnValley, n=length(numVar), nms=numVar)
    
    # Create the relevant data frame
    newDF <- df %>% 
        group_by_at(all_of(c(uqBy, facetVar))) %>%
        summarize(across(all_of(numVar), .fns=sum, na.rm=TRUE), .groups="drop") %>%
        group_by_at(all_of(facetVar)) %>%
        mutate(if(!is.null(rollMean)) across(all_of(numVar), .fns=zoo::rollmean, k=rollMean, fill=NA),
               across(all_of(numVar), .fns=findPeaks, width=windowWidth, gt=1, .names="{.col}_isPeak"),
               across(all_of(numVar), 
                      .fns=findPeaks, 
                      width=windowWidth, 
                      FUN=min, 
                      gt=1, 
                      lt=NULL, 
                      fillVal=NA 
                      ,.names="{.col}_isValley"
                      )
               ) %>% 
        ungroup()

    # Group by the facet variable(s) if not NULL and separate function by facet requested
    if(!is.null(facetVar) & isTRUE(fnGroupFacet)) newDF <- newDF %>% group_by_at(all_of(facetVar))
    
    # Create the relevant plots
    for(keyVar in numVar) {
    
        p1 <- newDF %>%
            mutate(posPeak=fnPeak[[keyVar]](fnNumVar[[keyVar]](get(keyVar))), 
                   posValley=fnValley[[keyVar]](fnNumVar[[keyVar]](get(keyVar)))
                   ) %>%
            ggplot(aes(x=get(uqBy), y=fnNumVar[[keyVar]](get(keyVar)))) + 
            geom_line() + 
            geom_point(data=~filter(., get(paste0(keyVar, "_isPeak"))), color="red", size=3) +
            geom_point(data=~filter(., get(paste0(keyVar, "_isValley"))), color="green", size=3) + 
            geom_text(data=~filter(., get(paste0(keyVar, "_isPeak"))), 
                      aes(y=posPeak, 
                          label=paste0(get(uqBy), "\n", round(fnNumVar[[keyVar]](get(keyVar))))
                          ), 
                      color="red", 
                      size=3
                      ) + 
            geom_text(data=~filter(., get(paste0(keyVar, "_isValley"))), 
                      aes(y=posValley, 
                          label=paste0(get(uqBy), "\n", round(fnNumVar[[keyVar]](get(keyVar))))
                          ), 
                      color="black", 
                      size=3
                      ) + 
            labs(x=NULL, 
                 y=yLab[[keyVar]], 
                 title=useTitle[[keyVar]], 
                 subtitle="Red (peaks) and green (valleys)"
                 )
        if(length(facetVar) > 0) p1 <- p1 + facet_wrap(~get(facetVar), scales="free_y")

        print(p1)
    
    }
    
    # Return the data, removing any grouping
    newDF %>% ungroup()
    
}


# Original format for burden
cdc_daily_211024$dfPerCapita %>%
    mutate(regn=c(as.character(state.region), "South")[match(state, c(state.abb, "DC"))]) %>%
    makePeakValley(numVar=c("new_deaths", "new_cases", "inp"), 
                   windowWidth = 71, 
                   rollMean=7, 
                   facetVar=c("regn"), 
                   fnNumVar=list("new_deaths"=function(x) x, 
                                 "new_cases"=function(x) x/1000,
                                 "inp"=function(x) x/1000
                                 ), 
                   fnPeak=list("new_deaths"=function(x) x+100, 
                               "new_cases"=function(x) x+10, 
                               "inp"=function(x) x+10
                               ),
                   fnValley=list("new_deaths"=function(x) x-100, 
                                 "new_cases"=function(x) x-5, 
                                 "inp"=function(x) x-5
                                 ),
                   useTitle=c("new_deaths"="US coronavirus deaths", 
                              "new_cases"="US coronavirus cases", 
                              "inp"="US coronavirus total hospitalized"
                              ), 
                   yLab=c("new_deaths"="Rolling 7-day mean deaths", 
                          "new_cases"="Rolling 7-day mean cases (000)", 
                          "inp"="Rolling 7-day mean in hospital (000)"
                          )
                   )


# Modified format - vaccinations by state
cdc_daily_211024$dfPerCapita %>%
    inner_join(getStateData(), by=c("state")) %>%
    filter(pop >= 8000000) %>%
    select(date, state, vxa, vxc) %>%
    arrange(date, state) %>%
    group_by(state) %>%
    mutate(across(c(vxa, vxc), .fns=function(x) x-lag(x))) %>%
    ungroup() %>%
    mutate(regn=c(as.character(state.region), "South")[match(state, c(state.abb, "DC"))]) %>%
    filter(date >= "2020-12-01") %>%
    makePeakValley(numVar=c("vxc", "vxa"), 
                   windowWidth = 29, 
                   rollMean=21, 
                   facetVar=c("state"), 
                   fnNumVar=list("vxa"=function(x) x/1000, 
                                 "vxc"=function(x) x/1000
                                 ), 
                   fnPeak=list("vxa"=function(x) x+25*max(x, na.rm=TRUE)/400, 
                               "vxc"=function(x) x+25*max(x, na.rm=TRUE)/400
                               ),
                   fnValley=list("vxa"=function(x) x-25*max(x, na.rm=TRUE)/400, 
                                 "vxc"=function(x) x-25*max(x, na.rm=TRUE)/400
                                 ),
                   fnGroupFacet=TRUE,
                   useTitle=c("vxa"="Vaccines adminsitered (US)", 
                              "vxc"="Became fully vaccinated (US)"
                              ), 
                   yLab=c("vxa"="Rolling 21-day mean administered (000)",
                          "vxc"="Rolling 21-day mean completed (000)"
                          )
                   )


```

The latest data are downloaded and processed:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

readList <- list("cdcDaily"="./RInputFiles/Coronavirus/CDC_dc_downloaded_211104.csv", 
                 "cdcHosp"="./RInputFiles/Coronavirus/CDC_h_downloaded_211104.csv", 
                 "vax"="./RInputFiles/Coronavirus/vaxData_downloaded_211104.csv"
                 )
compareList <- list("cdcDaily"=readFromRDS("cdc_daily_211006")$dfRaw$cdcDaily, 
                    "cdcHosp"=readFromRDS("cdc_daily_211006")$dfRaw$cdcHosp, 
                    "vax"=readFromRDS("cdc_daily_211006")$dfRaw$vax
                    )

cdc_daily_211104 <- readRunCDCDaily(thruLabel="Nov 03, 2021", 
                                    downloadTo=lapply(readList, FUN=function(x) if(file.exists(x)) NA else x), 
                                    readFrom=readList,
                                    compareFile=compareList, 
                                    writeLog=NULL, 
                                    useClusters=readFromRDS("cdc_daily_210528")$useClusters, 
                                    weightedMeanAggs=c("tcpm7", "tdpm7", "cpm7", "dpm7", "hpm7", 
                                                       "vxcpm7", "vxcgte65pct"
                                                       ),
                                    skipAssessmentPlots=FALSE, 
                                    brewPalette="Paired"
                                    )

saveToRDS(cdc_daily_211104)

```

The latest data are downloaded and processed:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

readList <- list("cdcDaily"="./RInputFiles/Coronavirus/CDC_dc_downloaded_211202.csv", 
                 "cdcHosp"="./RInputFiles/Coronavirus/CDC_h_downloaded_211202.csv", 
                 "vax"="./RInputFiles/Coronavirus/vaxData_downloaded_211202.csv"
                 )
compareList <- list("cdcDaily"=readFromRDS("cdc_daily_211104")$dfRaw$cdcDaily, 
                    "cdcHosp"=readFromRDS("cdc_daily_211104")$dfRaw$cdcHosp, 
                    "vax"=readFromRDS("cdc_daily_211104")$dfRaw$vax
                    )

cdc_daily_211202 <- readRunCDCDaily(thruLabel="Dec 01, 2021", 
                                    downloadTo=lapply(readList, FUN=function(x) if(file.exists(x)) NA else x), 
                                    readFrom=readList,
                                    compareFile=compareList, 
                                    writeLog=NULL, 
                                    useClusters=readFromRDS("cdc_daily_210528")$useClusters, 
                                    weightedMeanAggs=c("tcpm7", "tdpm7", "cpm7", "dpm7", "hpm7", 
                                                       "vxcpm7", "vxcgte65pct"
                                                       ),
                                    skipAssessmentPlots=FALSE, 
                                    brewPalette="Paired"
                                    )

saveToRDS(cdc_daily_211202)

```

The latest data are downloaded and processed:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

readList <- list("cdcDaily"="./RInputFiles/Coronavirus/CDC_dc_downloaded_211224.csv", 
                 "cdcHosp"="./RInputFiles/Coronavirus/CDC_h_downloaded_211224.csv", 
                 "vax"="./RInputFiles/Coronavirus/vaxData_downloaded_211224.csv"
                 )
compareList <- list("cdcDaily"=readFromRDS("cdc_daily_211202")$dfRaw$cdcDaily, 
                    "cdcHosp"=readFromRDS("cdc_daily_211202")$dfRaw$cdcHosp, 
                    "vax"=readFromRDS("cdc_daily_211202")$dfRaw$vax
                    )

cdc_daily_211224 <- readRunCDCDaily(thruLabel="Dec 23, 2021", 
                                    downloadTo=lapply(readList, FUN=function(x) if(file.exists(x)) NA else x), 
                                    readFrom=readList,
                                    compareFile=compareList, 
                                    writeLog=NULL, 
                                    useClusters=readFromRDS("cdc_daily_210528")$useClusters, 
                                    weightedMeanAggs=c("tcpm7", "tdpm7", "cpm7", "dpm7", "hpm7", 
                                                       "vxcpm7", "vxcgte65pct"
                                                       ),
                                    skipAssessmentPlots=FALSE, 
                                    brewPalette="Paired"
                                    )

saveToRDS(cdc_daily_211224)

```

Code is also written to download the latest data by individual hospital:  
```{r, fig.height=9, fig.width=9, cache=TRUE}

indivHospFile <- "./RInputFiles/Coronavirus/HHS_Hospital_20211225.csv"

# Download the file
fileDownload(indivHospFile, url="https://healthdata.gov/api/views/anag-cw7u/rows.csv?accessType=DOWNLOAD")

# Read the file and glimpse
indivHosp_20211225 <- fileRead(indivHospFile)
glimpse(indivHosp_20211225)

# Save in RDS format for future processing
saveToRDS(indivHosp_20211225)

```

Checks are run on some of the key fields in the data, including: 
  
* hospital_subtype - type of hospital  
* total_beds_7_day_avg - average number of staffed inpatient and outpatient beds, including overflow  
* all_adult_hospital_beds_7_day_avg - average number of staffed inpatient and outpatient beds, including overflow  
* all_adult_hospital_inpatient_bed_occupied_7_day_avg - average number occupied  
* total_adult_patients_hospitalized_confirmed_and_suspected_covid_7_day_avg - average number occupied COVID positive  
* inpatient_beds_7_day_avg - average number of staffed inpatient beds  
* total_icu_beds_7_day_avg - average number of staffed ICU beds  
* icu_beds_used_7_day_avg - average number of ICU beds occupied  
* staffed_icu_adult_patients_confirmed_and_suspected_covid_7_day_avg - adult COVID ICU beds occupied  
  
```{r, fig.height=9, fig.width=9}

# Hospital demographic data
indivHosp_20211225 %>% count(hospital_subtype)
indivHosp_20211225 %>% count(state) %>% filter(!(state %in% c(state.abb, "DC")))

# Hospital beds average
hhsMapper <- c("total_beds_7_day_avg"="total_beds", 
               "all_adult_hospital_beds_7_day_avg"="adult_beds", 
               "all_adult_hospital_inpatient_bed_occupied_7_day_avg"="adult_beds_occupied", 
               "total_adult_patients_hospitalized_confirmed_and_suspected_covid_7_day_avg"="adult_beds_covid", 
               "inpatient_beds_7_day_avg"="inpatient_beds", 
               "total_icu_beds_7_day_avg"="icu_beds", 
               "icu_beds_used_7_day_avg"="icu_beds_occupied", 
               "staffed_icu_adult_patients_confirmed_and_suspected_covid_7_day_avg"="adult_icu_covid"
               )

# Histograms by metric
indivHosp_20211225 %>%
    select(names(hhsMapper)) %>%
    pivot_longer(-c()) %>%
    ggplot(aes(x=value)) + 
    geom_histogram(fill="lightblue") + 
    facet_wrap(~name, scales="free")

# Histograms by metric, excluding NA and -999999
indivHosp_20211225 %>%
    select(names(hhsMapper)) %>%
    pivot_longer(-c()) %>%
    filter(!is.na(value), value != -999999) %>%
    ggplot(aes(x=value)) + 
    geom_histogram(fill="lightblue") + 
    facet_wrap(~hhsMapper[name], scales="free")

# Key metrics for a select hospital
set.seed(2112261542)
keyHosp <- indivHosp_20211225 %>% pull(hospital_pk) %>% sample(1)
keyHospName <- indivHosp_20211225 %>% 
    filter(hospital_pk %in% all_of(keyHosp), collection_week==max(collection_week)) %>%
    mutate(useName=paste0(hospital_name, " (code: ", keyHosp, ") ",city, ", ", state, " ", zip)) %>%
    pull(useName)

indivHosp_20211225 %>%
    filter(hospital_pk %in% all_of(keyHosp)) %>%
    select(date=collection_week, names(hhsMapper)) %>%
    pivot_longer(-c(date)) %>%
    filter(!is.na(value), value != -999999) %>%
    ggplot(aes(x=date, y=value)) + 
    geom_line() + 
    facet_wrap(~hhsMapper[name], scales="free_y") + 
    lims(y=c(0, NA)) + 
    labs(x=NULL, y="Average weekly value", title=keyHospName)

```

The key hospital is plotted for similar metrics:  
```{r, fig.height=9, fig.width=9}

# Adult Beds
indivHosp_20211225 %>%
    filter(hospital_pk %in% all_of(keyHosp)) %>%
    select(date=collection_week, names(hhsMapper)[1:4]) %>%
    colRenamer(vecRename=hhsMapper[1:4]) %>%
    pivot_longer(-c(date)) %>%
    filter(!is.na(value), value != -999999) %>%
    ggplot(aes(x=date, y=value)) + 
    geom_col(data=~filter(., !(name %in% c("total_beds", "adult_beds"))), aes(fill=name), position="identity") + 
    geom_line(data=~filter(., name %in% c("total_beds", "adult_beds")), 
              aes(group=name, color=name), 
              size=1.5
              ) + 
    lims(y=c(0, NA)) + 
    labs(x=NULL, y="Average weekly value", title=keyHospName, subtitle="Adult beds") + 
    scale_color_manual("Capacity", values=c("adult_beds"="black", "total_beds"="green")) + 
    scale_fill_manual("Occupied", values=c("adult_beds_covid"="red", "adult_beds_occupied"="lightblue"))

# Adult ICU Beds
indivHosp_20211225 %>%
    filter(hospital_pk %in% all_of(keyHosp)) %>%
    select(date=collection_week, names(hhsMapper)[6:8]) %>%
    colRenamer(vecRename=hhsMapper[6:8]) %>%
    pivot_longer(-c(date)) %>%
    filter(!is.na(value), value != -999999) %>%
    ggplot(aes(x=date, y=value)) + 
    geom_col(data=~filter(., !(name %in% c("icu_beds"))), aes(fill=name), position="identity") + 
    geom_line(data=~filter(., name %in% c("icu_beds")), aes(group=name, color=name), size=1.5) + 
    lims(y=c(0, NA)) + 
    labs(x=NULL, y="Average weekly value", title=keyHospName, subtitle="ICU beds") + 
    scale_color_manual("Capacity", values=c("icu_beds"="black")) + 
    scale_fill_manual("Occupied", values=c("adult_icu_covid"="red", "icu_beds_occupied"="lightblue"))

```

The process is converted to functional form:  
```{r, fig.height=9, fig.width=9}

plotHospitalUtilization <- function(df, 
                                    keyHosp=NULL, 
                                    plotTitle=NULL,
                                    seed=2112261542, 
                                    varMap=hhsMapper
                                    ) {
    
    # FUNCTION ARGUMENTS:
    # df: file containing hospital utilization data
    # keyHosp: character vector of hospital_pk to use (NULL means select one at random using seed)
    # plotTitle: title to use for plots (NULL means use a default based on keyHosp)
    # seed: random seed to use for selecting a hospital
    # varMap: character mapping file of format c("variable name"="plotting facet name")
    
    # Sample a keyHosp if not provided
    if(is.null(keyHosp)) {
        set.seed(seed)
        keyHosp <- df %>% 
            pull(hospital_pk) %>% 
            sample(1)        
    }
    
    # Get plotTitle if not provided
    if(is.null(plotTitle)) {
        if(length(keyHosp) > 1) plotTitle <- "Multiple hospitals combined"
        else {
            plotTitle <- df %>% 
                filter(hospital_pk %in% all_of(keyHosp), collection_week==max(collection_week)) %>%
                mutate(useName=paste0(hospital_name, " (code: ", keyHosp, ") ",city, ", ", state, " ", zip)) %>%
                pull(useName)
        }
    }

    # Create key plot data
    p1Data <- df %>%
        filter(hospital_pk %in% all_of(keyHosp)) %>%
        select(date=collection_week, names(varMap)) %>%
        pivot_longer(-c(date)) %>%
        filter(!is.na(value), value != -999999) %>%
        group_by(date, name) %>%
        summarize(value=sum(value, na.rm=TRUE), n=n(), .groups="drop")
    
    # Create the key plot
    p1 <- p1Data %>%
        ggplot(aes(x=date, y=value)) + 
        geom_line() + 
        facet_wrap(~hhsMapper[name], scales="free_y") + 
        lims(y=c(0, NA)) + 
        labs(x=NULL, y="Average weekly value", title=plotTitle)
    print(p1)
    
}

# Random hospital selection
plotHospitalUtilization(indivHosp_20211225)
plotHospitalUtilization(indivHosp_20211225, seed=2112281733)

# Combination of hospitals
indivHosp_20211225 %>% 
    filter(state=="FL", collection_week==max(collection_week)) %>% 
    pull(hospital_pk) %>%
    plotHospitalUtilization(df=indivHosp_20211225, keyHosp=., plotTitle="Florida Hospitals Summed")

```

