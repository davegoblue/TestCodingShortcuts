---
title: "CDC Daily by State"
author: "davegoblue"
date: "4/14/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
This file is designed to use CDC data to assess coronavirus disease burden by state, including creating and analyzing state-level cluters.

Through March 7, 2021, [The COVID Tracking Project](https://covidtracking.com/) collected and integrated data on tests, cases, hospitalizations, deaths, and the like by state and date.  The latest code for using this data is available in Coronavirus_Statistics_CTP_v004.Rmd.

The COVID Tracking Project suggest that [US federal data sources](https://covidtracking.com/analysis-updates/federal-covid-data-101-how-to-find-data) are now sufficiently robust to be used for analyses that previously relied on COVID Tracking Project.  This code is an attempt to update modules in Coronavirus_Statistics_CTP_v004.Rmd to leverage US federal data.

The code leverages tidyverse and a variable mapping file throughout:  
```{r}

# All functions assume that tidyverse and its components are loaded and available
# Other functions are declared in the sourcing files or use library::function()
library(tidyverse)

# For future use, source key modules from a separate .R file

# Create a variable mapping file - this is not yest updated for federal data
varMapper <- c("cases"="Cases", 
               "newCases"="Increase in cases, most recent 30 days",
               "casesroll7"="Rolling 7-day mean cases", 
               "deaths"="Deaths", 
               "newDeaths"="Increase in deaths, most recent 30 days",
               "deathsroll7"="Rolling 7-day mean deaths", 
               "cpm"="Cases per million",
               "cpm7"="Cases per day (7-day rolling mean) per million", 
               "newcpm"="Increase in cases, most recent 30 days, per million",
               "dpm"="Deaths per million", 
               "dpm7"="Deaths per day (7-day rolling mean) per million", 
               "newdpm"="Increase in deaths, most recent 30 days, per million", 
               "hpm7"="Currently Hospitalized per million (7-day rolling mean)", 
               "tpm"="Tests per million", 
               "tpm7"="Tests per million per day (7-day rolling mean)"
               )

# Helper functions used early in the process
# Function for saving an R object to RDS, including a check for whether the object already exists
saveToRDS <- function(obj, 
                      file=paste0(deparse(substitute(obj)), ".RDS"), 
                      dir="./RInputFiles/Coronavirus/", 
                      ovrWrite=FALSE, 
                      ovrWriteError=TRUE,
                      makeReadOnly=TRUE
                      ) {
    
    # FUNCTION ARGUMENTS:
    # obj: the R object to save
    # file: the file name to save as
    # dir: the directory to save in (file path will be paste0(dir, file))
    # ovrWrite: boolean, should the file be overwritten if it already exists?
    # ovrWriteError: boolean, should an error be thrown if an attempt is made to overwrite the file?
    # makeReadOnly: boolean, should the output file be made read-only?
    
    # Create the file name
    locFile <- paste0(dir, file)
    
    # Check if the file already exists and proceed as per options
    if (file.exists(locFile)) {
        cat("\nFile already exists:", locFile, "\n")
        if (!ovrWrite & ovrWriteError) stop("\nAborting due to ovrWrite=FALSE and ovrWriteError=TRUE")
        if (!ovrWrite) {
            cat("\nNot replacing the existing file since ovrWrite=FALSE\n")
            return(NULL)
        }
    }
    
    # Save the file and update the permissions to read-only (if flag is set)
    saveRDS(obj, file=locFile)
    if (makeReadOnly) Sys.chmod(locFile, mode="0555", use_umask = FALSE)
    
}



# Function for reading an R object from RDS
readFromRDS <- function(file, 
                        dir="./RInputFiles/Coronavirus/", 
                        addSuffix=".RDS", 
                        deparseSub=FALSE
                        ) {
    
    # FUNCTION ARGUMENTS:
    # file: the file name to read in
    # dir: the directory the file is in
    # addSuffix: the suffix that should be added to file (file path will be paste0(dir, file, addSuffix))
    # deparseSub: whether to deparse and substitute file (use it as the text name)
    
    # Convert file if needed
    if (deparseSub) file <- deparse(substitute(file))
    
    # Ensure that file is of type character
    if (!isTRUE(all.equal(class(file), "character"))) {
        stop("\nUnable to read since file is not a character\n")
    }
    
    # Create the file name
    locFile <- paste0(dir, file, addSuffix)
    
    # Read the file (will be the return)
    readRDS(locFile)
    
}


```
  
### Downloading and Integrating US Federal Data  
#### _Cases and Deaths by State-Date_
CDC case and death data by state and date are available for download on the [CDC website](https://data.cdc.gov/api/views/9mfq-cb36/rows.csv?accessType=DOWNLOAD).  The previously written function downloadCOVIDbyState() can be used to acquire the data by updating the API:  
```{r}

# NO CHANGES MADE TO FUNCTION - default API is from COVID Tracking Project
# Function to download data for COVID Tracking Project
downloadCOVIDbyState <- function(fileName, 
                                 api="https://api.covidtracking.com/v1/states/daily.csv", 
                                 ovrWrite=FALSE
                                 ) {
    
    # FUNCTION ARGUMENTS:
    # fileName: the filename that the data will be saved to
    # api: The API link for data downloads
    # ovrWrite: whether to allow overwriting of the existing fileName
    
    # Check whether fileName already exists
    if (file.exists(fileName)) {
        cat("\nFile already exists at:", fileName, "\n")
        if (ovrWrite) cat("Will over-write with current data from", api, "\n")
        else stop("Exiting due to ovrWrite=FALSE and a duplicate fileName\n")
    }
    
    # Download the file 
    download.file(api, destfile=fileName)
    
    # Show statistics on downloaded file
    file.info(fileName)
    
}


```

The data are downloaded and the process cached to avoid repeated hits against the CDC website:  
```{r cache=TRUE}

downloadCOVIDbyState("./RInputFiles/Coronavirus/CDC_dc_downloaded_210414.csv",
                     api="https://data.cdc.gov/api/views/9mfq-cb36/rows.csv?accessType=DOWNLOAD", 
                     ovrWrite=FALSE
                     )

```

Key fields from the documentation include:  
  
* submission_date - date of counts  
* state - state (includes 50 states, DC, NYC, and 8 territories/federations)  
* tot_cases - cumulative number of cases (confirmed and probable)  
* new_case - new cases (confirmed and probable)  
* tot_death - cumulative number of deaths (confirmed and probable)  
* new_death - new deaths (confirmed and probable)  
* consent_cases - boolean tracked as "Agree" (confirmed and probable tracked separately) or "Not Agree" (only total tracked)  
* consent_deaths - boolean tracked as "Agree" or "Not Agree" (same as for consent_cases)  
  
Basic formatting and QC is run on the downloaded data (this can later be converted to functional form):  
```{r}

# Read and glimpse downloaded CDC file
cdcRaw <- readr::read_csv("./RInputFiles/Coronavirus/CDC_dc_downloaded_210414.csv")
glimpse(cdcRaw)

# Check for variables in the consent_ fields
cdcRaw %>% 
    count(consent_cases, consent_deaths)

# Function to convert N/A, Agree, and Not agree to boolean
cdcToBool <- function(x) {
    y <- case_when(is.na(x) ~ "NA", 
                   x=="N/A" ~ "NA", 
                   x=="Agree" ~ "TRUE", 
                   x=="Not agree" ~ "FALSE", 
                   TRUE ~ "Problem"
                   )
    if (sum(y=="Problem") != 0) stop("Problem with the boolean conversion")
    y[y=="NA"] <- NA
    as.logical(y)
}

# Format fields as desired types
cdcProcessed <- cdcRaw %>%
    mutate(date=lubridate::mdy(submission_date), 
           creation_date=lubridate::mdy_hms(created_at), 
           bool_c_cases=cdcToBool(consent_cases), 
           bool_c_deaths=cdcToBool(consent_deaths)
           )
glimpse(cdcProcessed)

# Get control totals by state for numeric fields
cdcControl <- cdcProcessed %>%
    group_by(state) %>%
    summarize_if(is.numeric, .funs=function(x) sum(x, na.rm=TRUE))

# Plot control totals by state for numeric fields
for (keyVar in names(cdcControl)[2:ncol(cdcControl)]) {
    p1 <- cdcControl %>%
        select_at(vars(all_of(c("state", keyVar)))) %>%
        purrr::set_names(c("state", "y")) %>%
        ggplot(aes(x=fct_reorder(state, y), y=y)) + 
        geom_col(fill="lightblue") + 
        geom_text(aes(y=y/2, label=format(y, big.mark=",")), size=3, hjust=0) +
        labs(x="", y="", title=paste0("Control totals by state for ", keyVar)) + 
        coord_flip()
    print(p1)
}

```
  
Not every state reports on every metric.  In particular, some jurisdictions break cases and deaths in to probable and confirmed while others do not.  All states appear to report both total (cumulative) and new case.  Comparisons of these fields are run, since restatements of history can lead to total and cumsum(new) being different:  
```{r}

# Check for alignment of total and sum(new)
cdcMism <- cdcProcessed %>%
    arrange(state, date) %>%
    group_by(state) %>%
    mutate(ck_tot_case=cumsum(ifelse(is.na(new_case), 0, new_case)), 
           ck_tot_death=cumsum(ifelse(is.na(new_death), 0, new_death))
           ) %>%
    select(date, state, tot_cases, ck_tot_case, tot_death, ck_tot_death, everything()) %>%
    mutate(mism_case=tot_cases != ck_tot_case, mism_death=tot_death != ck_tot_death) %>%
    group_by(state) %>%
    summarize(mism_case=sum(mism_case), mism_death=sum(mism_death), .groups="drop") %>%
    filter(mism_death > 0 | mism_case > 0) %>%
    arrange(-mism_case, -mism_death)
cdcMism

```

Many states have data that are aligned throughout.  In some states, there are differences between the total and new fields that should be explored further.  A function is written to assess mismatches in the data:  
```{r}

# Function to report totals and plot trends by state
assessMismatch <- function(keyStates, 
                           keyMetric="cases",
                           df=cdcProcessed
                           ) {
    
    # FUNCTION ARGUMENTS
    # keyStates: states to be explored for differences
    # keyMetric: metric to be explored
    # df: the data frame containing data by state-date
    
    # Create a main database for comparisons
    dfUse <- cdcProcessed %>%
        arrange(state, date) %>%
        group_by(state) %>%
        mutate(ck_tot_case=cumsum(ifelse(is.na(new_case), 0, new_case)), 
               ck_tot_death=cumsum(ifelse(is.na(new_death), 0, new_death)), 
               d_cases=ck_tot_case-tot_cases,
               d_deaths=ck_tot_death-tot_death
               ) %>%
        select(date, 
               state, 
               cases=tot_cases, 
               ck_cases=ck_tot_case, 
               d_cases,
               deaths=tot_death, 
               ck_deaths=ck_tot_death, 
               d_deaths,
               everything()
               )
    
    # Show the discrepancies in the final data for each state
    dfUse %>%
        filter(state %in% all_of(keyStates)) %>%
        group_by(state) %>%
        filter(row_number()==n()) %>% 
        select(date, state, cases, ck_cases, d_cases, deaths, ck_deaths, d_deaths) %>%
        print()
    
    # Create plot of metric evolution
    dfPlot <- dfUse %>%
        filter(state %in% all_of(keyStates)) %>%
        select(date, state, cases, ck_cases, d_cases, deaths, ck_deaths, d_deaths) %>%
        pivot_longer(-c(date, state)) %>%
        filter(str_detect(name, keyMetric)) 
    p1 <- dfPlot %>%
        filter(!str_detect(name, "d_")) %>%
        mutate(useName=ifelse(str_detect(name, "ck_"), "cumsum(new)", "reported total")) %>%
        ggplot(aes(x=date, y=value)) + 
        geom_line(aes(group=useName, color=useName)) +
        labs(x="", 
             y="Cumulative reported", 
             title=paste0("Discrepancies in cumulative total ", keyMetric)
             ) +
        scale_color_discrete("Source") +
        facet_wrap(~state, scales="free_y")
    print(p1)
    p2 <- dfPlot %>%
        filter(str_detect(name, "d_")) %>%
        ggplot(aes(x=date, y=value)) + 
        geom_line(aes(group=state, color=state)) +
        labs(x="", 
             y="Cumulative discrepancy", 
             title=paste0("Discrepancies in cumulative total ", keyMetric)
             ) +
        scale_color_discrete("State")
    print(p2)
    
}

```
  
The function can then be applied to the case and death data with mismatches:  
```{r}

assessMismatch(keyStates=cdcMism %>% filter(mism_case > 0) %>% pull(state), keyMetric="cases")
assessMismatch(keyStates=cdcMism %>% filter(mism_death > 0) %>% pull(state), keyMetric="deaths")

```

The mismathes appear to arise at discrete points in time, likely reflecting a reclassification of many previous cases and deaths.  The total field is always greater than or equal to the sum of the new field.  This sugests using 'new' for shape of the curve and 'total' for overall disease burden.

A function is then written to rename and split columns appropriately:  
```{r}

# Create list of expected variables and renames (NA means keep as-is)
cdcVarNames <- c("date"=NA, 
                 "state"=NA, 
                 "tot_cases"=NA, 
                 "conf_cases"=NA, 
                 "prob_cases"=NA, 
                 "new_case"="new_cases", 
                 "pnew_case"="pnew_cases", 
                 "tot_death"="tot_deaths", 
                 "conf_death"="conf_deaths", 
                 "prob_death"="prob_deaths", 
                 "new_death"="new_deaths", 
                 "pnew_death"="pnew_deaths",
                 "bool_c_cases"="bool_cases", 
                 "bool_c_deaths"="bool_deaths"
                 )

# Function to rename variables, split, and pivot for easier analysis
renamePivotProcessed <- function(df, 
                                 selectRename=cdcVarNames
                                 ) {
    
    # FUNCTION ARGUMENTS
    # df: a processed CDC data file
    # selectRename: a list of variable -> new name (NA means keep as-is) as c('original'='new')
    
    # Check alignment of variables in df and selectRename
    dfNames <- names(df)
    selNames <- names(selectRename)
    
    # Create the vector of renamed variables after selection
    selRenames <- unname(selectRename[selNames])
    selRenames[is.na(selRenames)] <- selNames[is.na(selRenames)]
    
    # Names in one but not the other
    cat("\n*** Variables that will be dropped (not in selectRename vector) include:", 
        setdiff(dfNames, selNames), 
        sep="\n"
        )
    cat("\n\n*** Variables passed in selectRename that are not in the data include:", 
        setdiff(selNames, dfNames), 
        sep="\n"
        )
    
    # Select the key variables and rename
    df <- df %>%
        select_at(vars(all_of(selNames))) %>%
        purrr::set_names(selRenames)

    # Pivot and separate the data, keeping unique by date-state
    # Requires that selectRename have every variable as modifier_type
    df <- df %>%
        pivot_longer(-c(date, state)) %>%
        tidyr::separate(name, into=c("modifier", "metric"), sep="_")

    # Summary NA statistics of the new dataset
    cat("\nSummary statistics for processed and pivoted data\n")
    df %>%
        group_by(modifier, metric) %>%
        summarize(n=n(), nna=sum(is.na(value)), sum=sum(value, na.rm=TRUE), .groups="drop") %>%
        print()
    cat("\n")
    
    # Return the data frane
    df
    
}

```
  
The function is applied to create cdcPivotLong:  
```{r}

cdcPivotLong <- renamePivotProcessed(cdcProcessed)
glimpse(cdcPivotLong)

```

Next steps are to combine the NYS/NYC data as NY and to filter to the states and DC.