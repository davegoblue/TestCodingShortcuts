---
title: "Coronavirus US Data (as of 20-AUG-2020)"
author: "davegoblue"
date: "8/21/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background
This file is for analysis of some data downloaded from [The COVID Tracking Project](https://covidtracking.com/) on 20 August, 2020.  This file contains data on positive tests, hospitalizations, deaths, and the like for coronavirus cases in the US.  Data are unique by state and date.

#### _Data Availability_  
The downloaded data file is read in as CSV, and the date column is converted to date format:  
```{r}

library(tidyverse)

cvData <- readr::read_csv("./RInputFiles/Coronavirus/CV_downloaded_200820.csv")
glimpse(cvData)

cvData <- cvData %>% 
    mutate(date=lubridate::ymd(date))
glimpse(cvData)

cvData %>%
    select(date, state) %>%
    anyDuplicated()

```
  
As expected, the file is unique by date and state.  The date field has been converted from double to date.  The main columns of interest will be:  
  
* date  
* state  
* positiveIncrease - number of new positive cases for state during date  
* deathIncrease - number of new deaths for state during date  
  
A smaller frame containing only this data is created:  
```{r}

cvUse <- cvData %>%
    select(date, state, cases=positiveIncrease, deaths=deathIncrease)

cvUse %>%
    summarize_if(is.numeric, sum)

```
  
The numeric totals match those reported by the COVID Tracking Project for the same date.  They are roughly 5% lower than the totals reported by worldometers.info.  There are significant issues associated with official reporting for corornavirus, and a 5% discrepancy between sources is not unexpected.
  
The data are next checked for totals by state and by week:  
```{r}

cvUse %>%
    group_by(state) %>%
    summarize_if(is.numeric, sum) %>%
    pivot_longer(-state) %>%
    ggplot(aes(x=fct_reorder(state, value), y=value)) + 
    geom_col(fill="lightblue") +
    coord_flip() + 
    facet_wrap(~name, scales="free_x") + 
    labs(x="", y="", title="Coronavirus cases and deaths by state through August 20, 2020")

cvUse %>%
    group_by(week=lubridate::epiweek(date)) %>%
    summarize_if(is.numeric, sum) %>%
    pivot_longer(-week) %>%
    ggplot(aes(x=week, y=value)) + 
    geom_line() +
    facet_wrap(~name, scales="free_y") + 
    labs(x="", y="", title="Coronavirus cases and deaths by epidemiological week through August 20, 2020")

```
  
Sort order by state generally matches published reports of coronavirus burden by state.  The weekly data appear broadly aligned with other published data.  The dip in the final week is due to only 5 of the 7 days of the week being included in the Thursday data file.

State population data (2015 estimates) are obtained from usmap for converting metrics to per capita, and the cvData file is filtered to only those observations contained in the state population file:  
```{r}

statePop <- usmap::statepop %>%
    select(state=abbr, name=full, pop_2015)
glimpse(statePop)

cvUse <- cvUse %>%
    semi_join(statePop)

cvUse %>%
    summarize_if(is.numeric, sum)

```
  
Over 99% of the cases and deaths are preserved when the territories and other non-state data are removed.

There appear to be at least two peaks in the case and death data, likely driven by different locales experiencing outbreaks at different times.  Per capita cases and deaths by state are plotted:  
```{r}

# Per capita metrics by state
cvStatePerCapita <- cvUse %>%
    group_by(state) %>%
    summarize_if(is.numeric, sum) %>%
    inner_join(statePop) %>%
    mutate(cases=1000000*cases/pop_2015, deaths=1000000*deaths/pop_2015)

# Disease burden by state, per capita
cvStatePerCapita %>%
    ggplot(aes(x=cases, y=deaths)) +
    geom_text(aes(label=state)) + 
    labs(x="Cases per million through August 20", y="Deaths per million through August 20")

```
  
States will be defined as having a low impact of disease if 1) deaths per million are 100 or less, and 2) cases per million are 10000 or less:  
```{r}

lowBurden <- cvStatePerCapita %>%
    filter(deaths <= 100, cases <= 10000) %>%
    pull(state)

```
  
Next, the states that are not defined as low burden are hierarchically clustered, using total deaths per capita by week.  Due to very significant expansions in testing volume both by state and within state over time, death data is likely more representative of disease burden by time than cases data.  Deaths per capita by state by month are capped at 300 since otherwise the distance between the extremely high states (which is not so meaningful here) dominates the differences in early vs. late disease bruden:  
```{r}

# Calculate the raw data
clustData <- cvUse %>%
    filter(!(state %in% lowBurden)) %>%
    inner_join(statePop) %>% 
    mutate(month=lubridate::month(date), cpm=1000000*cases/pop_2015, dpm=1000000*deaths/pop_2015) %>% 
    filter(date >= as.Date("2020-03-15")) %>% 
    group_by(state, month) %>% 
    summarize(dpm=sum(dpm), cpm=sum(cpm), n=n()) %>% 
    pivot_wider(state, names_from=month, values_from=c(dpm, cpm)) %>%
    ungroup()

# Run clusters without normalization, but with dpm limited to 300
distData <- clustData %>%
    select(state, starts_with("dpm")) %>%
    mutate_if(is.numeric, .funs=~pmin(., 300)) %>%
    column_to_rownames("state")

cvTree <- hclust(dist(distData))

# Plot the dendrogram
plot(cvTree)

```
  
There appears to be a cluster of states that had early outbreaks, a cluster of states that had later outbreaks, and a large segment that falls in between these extremes.  Suppose the dendrogram is split in to three clusters, with the low burden states added as a fourth cluster:  
```{r}

# Get the clusters from the tree, adding the low burden states as cluster 4
cvClusters <- c(cutree(cvTree, k=3), 
                rep(4, length(lowBurden)) %>% set_names(lowBurden)
                )

# Add the clusters to the population data file
statePop <- statePop %>%
    mutate(cluster=factor(cvClusters[state]))

# Show a map of the clusters
usmap::plot_usmap(regions="states", data=statePop, values="cluster")

# Show population totals by cluster
statePop %>%
    group_by(cluster) %>%
    summarize(pop_2015=sum(pop_2015)/1000000) %>%
    ggplot(aes(x=fct_reorder(cluster, pop_2015), y=pop_2015)) + 
    geom_col(fill="lightblue") + 
    geom_text(aes(y=pop_2015/2, label=round(pop_2015))) + 
    labs(y="2015 population (millions)", x="Cluster", title="Population by cluster (millions)") +
    coord_flip()

# Virus by week by cluster
cvUse %>%
    mutate(cluster=factor(cvClusters[state]), week=lubridate::epiweek(date)) %>%
    group_by(cluster, week) %>%
    summarize(cases=sum(cases), deaths=sum(deaths)) %>%
    pivot_longer(-c(week, cluster)) %>%
    ggplot(aes(x=week, y=value, group=cluster, color=cluster)) + 
    geom_line() + 
    facet_wrap(~name, scales="free_y")

```
  
Metrics can be normalized by population to look at coronavirus burden per capita by segment over time:  
```{r}

# Integrated data file
cvWeekPop <- cvUse %>%
    mutate(week=lubridate::epiweek(date)) %>%
    inner_join(statePop, by="state")

# Summarized by date-cluster
cvDateCluster <- cvWeekPop %>%
    group_by(date, cluster) %>%
    summarize(cases=sum(cases), deaths=sum(deaths)) %>%
    inner_join(statePop %>% group_by(cluster) %>% summarize(pop_mill=sum(pop_2015)/1000000), by="cluster") %>%
    group_by(cluster) %>%
    mutate(cpm7=zoo::rollmean(cases, 7, fill=NA)/pop_mill, 
           dpm7=zoo::rollmean(deaths, 7, fill=NA)/pop_mill
           ) %>%
    ungroup()

# Plotted by date
cvDateCluster %>%
    select(date, cluster, cases=cpm7, deaths=dpm7) %>%
    pivot_longer(-c(date, cluster)) %>%
    filter(!is.na(value)) %>%
    ggplot(aes(x=date, y=value, group=cluster, color=cluster)) +
    geom_line() + 
    facet_wrap(~name, scales="free_y") + 
    labs(x="", y="Rolling 7-day mean, per million", title="Rolling 7-day mean disease burden, per million")

```
  
Broadly speaking:  
  
* Segment 4, which is small states with low coronavirus burden, may be experiencing a small rise in both cases and deaths  
* Segment 3, which is much of the northeast plus MI, IL, and LA has a significant spike early followed by a rapid and largely sustained decline  
* Segment 1, which is largely the south ex-LA/NM, appears to have peaked in cases by the middle of July and to be starting to decline in deaths as of the middle of August  
* Segment 2, which is about half the country, appears similar to Segment 1 but with a much less pronounced spike in both cases and deaths in July/August  

There appear to be meaningful differences in disease burden over time, and with a meaningful geographical explanatory component.

Next, the total volume of disease through August 20 is explored by state:  
```{r}

varMapper <- c("cases"="Cases through Aug 20", 
               "newCases"="Increase in cases, 30 days through Aug 20",
               "casesroll7"="Rolling 7-day mean cases, through Aug 20", 
               "deaths"="Deaths through Aug 20", 
               "newDeaths"="Increase in deaths, 30 days through Aug 20",
               "deathsroll7"="Rolling 7-day mean deaths, through Aug 20", 
               "cpm"="Cases through Aug 20 (per million)",
               "cpm7"="Cases per day (7-day rolling mean) through Aug 20 (per million)", 
               "newcpm"="Increase in cases, 30 days through Aug 20 (per million)",
               "dpm"="Deaths through Aug 20 (per million)", 
               "dpm7"="Deaths per day (7-day rolling mean) through Aug 20 (per million)", 
               "newdpm"="Increase in deaths, 30 days through Aug 20 (per million)", 
               "hpm7"="Currently Hospitalized per million (7-day rolling mean)"
               )

cvWeekPop %>%
    group_by(state, cluster) %>%
    summarize(cases=sum(cases), deaths=sum(deaths), pop_2015=mean(pop_2015)) %>%
    ungroup() %>%
    mutate(cpm=1000000*cases/pop_2015, dpm=1000000*deaths/pop_2015) %>%
    select(state, cluster, cases, deaths) %>%
    pivot_longer(c(cases, deaths)) %>%
    ggplot(aes(x=fct_reorder(state, value, .fun=min), y=value)) + 
    geom_col(aes(fill=cluster)) + 
    coord_flip() + 
    labs(x="", y="", title="Coronavirus impact by state through August 20, 2020") + 
    facet_wrap(~varMapper[name], scales="free_x")

cvWeekPop %>%
    group_by(state, cluster) %>%
    summarize(cases=sum(cases), deaths=sum(deaths), pop_2015=mean(pop_2015)) %>%
    ungroup() %>%
    mutate(cpm=1000000*cases/pop_2015, dpm=1000000*deaths/pop_2015) %>%
    select(state, cluster, cpm, dpm) %>%
    pivot_longer(c(cpm, dpm)) %>%
    ggplot(aes(x=fct_reorder(state, value, .fun=min), y=value)) + 
    geom_col(aes(fill=cluster)) + 
    coord_flip() + 
    labs(x="", y="", title="Coronavirus impact by state through August 20, 2020") + 
    facet_wrap(~varMapper[name], scales="free_x")

```
  
As expected, the segmentation approach has largely divided the states by total coronavirus burden.  Mississippi and Arizona are in segment 1 due to the late nature of their outbreak.

Further, the data are explored for a combination of total disease burden and change over the past 30 days:  
```{r}

cvWeekPop %>%
    mutate(newCases=ifelse(as.Date("2020-08-21")-date <= 30, cases, 0), 
           newDeaths=ifelse(as.Date("2020-08-21")-date <= 30, deaths, 0)
           ) %>%
    group_by(state, cluster) %>%
    summarize(cases=sum(cases), 
              deaths=sum(deaths), 
              newCases=sum(newCases),
              newDeaths=sum(newDeaths),
              pop_2015=mean(pop_2015)
              ) %>%
    ungroup() %>%
    mutate(cpm=1000000*cases/pop_2015, 
           dpm=1000000*deaths/pop_2015,
           newcpm=1000000*newCases/pop_2015, 
           newdpm=1000000*newDeaths/pop_2015
           ) %>%
    ggplot(aes(x=cpm, y=newcpm)) + 
    geom_text(aes(color=cluster, label=state)) + 
    labs(x=varMapper["cpm"], 
         y=varMapper["newcpm"], 
         title="Coronavirus impact by state through August 20, 2020"
         ) + 
    geom_abline(lty=2, slope=c(0.5)) + 
    lims(x=c(0, NA), y=c(0, NA)) +
    annotate("text", x=18000, y=11000, label="50% of total cases\nin last 30 days", hjust=1) + 
    annotate("segment", x=18500, y=10500, xend=20000, yend=10000, arrow=arrow(), lty=2)

cvWeekPop %>%
    mutate(newCases=ifelse(as.Date("2020-08-21")-date <= 30, cases, 0), 
           newDeaths=ifelse(as.Date("2020-08-21")-date <= 30, deaths, 0)
           ) %>%
    group_by(state, cluster) %>%
    summarize(cases=sum(cases), 
              deaths=sum(deaths), 
              newCases=sum(newCases),
              newDeaths=sum(newDeaths),
              pop_2015=mean(pop_2015)
              ) %>%
    ungroup() %>%
    mutate(cpm=1000000*cases/pop_2015, 
           dpm=1000000*deaths/pop_2015,
           newcpm=1000000*newCases/pop_2015, 
           newdpm=1000000*newDeaths/pop_2015
           ) %>%
    ggplot(aes(x=dpm, y=newdpm)) + 
    geom_text(aes(color=cluster, label=state)) + 
    labs(x=varMapper["dpm"], 
         y=varMapper["newdpm"], 
         title="Coronavirus impact by state through August 20, 2020"
         ) + 
    geom_abline(lty=2, slope=c(0.5)) + 
    lims(x=c(0, NA), y=c(0, NA)) +
    annotate("text", x=250, y=200, label="50% of total deaths\nin last 30 days", hjust=1) + 
    annotate("segment", x=250, y=200, xend=400, yend=200, arrow=arrow(), lty=2)

```
  
The clusters appear relatively well separated, with the possible exception of Louisiana which is arguably quite close to cluster 1.  Cluster 3 stands out as having had a very high overall impact, but with not much of an increase in the past 30 days.

The individual trends by state are also plotted, smoothed by week:  
```{r}

cvWeekPop %>%
    rbind(mutate(., state="cluster")) %>%
    group_by(state, cluster, date) %>%
    summarize_if(is.numeric, sum) %>%
    ungroup() %>%
    mutate(cpm=1000000*cases/pop_2015, dpm=1000000*deaths/pop_2015) %>%
    group_by(state, cluster) %>%
    mutate(cpm7=zoo::rollmean(cpm, k=7, fill=NA), dpm7=zoo::rollmean(dpm, k=7, fill=NA)) %>%
    ungroup() %>%
    filter(!is.na(cpm7)) %>%
    ggplot(aes(x=date, y=cpm7)) + 
    geom_line(data=~filter(., state != "cluster"), aes(group=state), alpha=0.25) + 
    geom_line(data=~filter(., state == "cluster"), aes(group=state, color=cluster), lwd=1.5) + 
    facet_wrap(~cluster, scales="free_y") + 
    labs(x="", 
         y=varMapper["cpm"], 
         title="Cases per million per day (rolling 7-day mean) by state and cluster", 
         subtitle="Caution that each facet has its own y axis with different scales"
         ) + 
    ylim(c(0, NA))

cvWeekPop %>%
    rbind(mutate(., state="cluster")) %>%
    group_by(state, cluster, date) %>%
    summarize_if(is.numeric, sum) %>%
    ungroup() %>%
    mutate(cpm=1000000*cases/pop_2015, dpm=1000000*deaths/pop_2015) %>%
    group_by(state, cluster) %>%
    mutate(cpm7=zoo::rollmean(cpm, k=7, fill=NA), dpm7=zoo::rollmean(dpm, k=7, fill=NA)) %>%
    ungroup() %>%
    filter(!is.na(dpm7)) %>%
    ggplot(aes(x=date, y=dpm7)) + 
    geom_line(data=~filter(., state != "cluster"), aes(group=state), alpha=0.25) + 
    geom_line(data=~filter(., state == "cluster"), aes(group=state, color=cluster), lwd=1.5) + 
    facet_wrap(~cluster, scales="free_y") + 
    labs(x="", 
         y=varMapper["dpm"], 
         title="Deaths per million per day (rolling 7-day mean) by state and cluster", 
         subtitle="Caution that each facet has its own y axis with different scales"
         ) + 
    ylim(c(0, NA))

```
  
With a few exceptions in a rather noisy segment 2 (as well as Louisiana in segment 3), states seem to broadly follow the disease state pattern for their cluster, though with some differences in magnitude and timing.
  
The process is converted to functional form so that it can be run using different data.  First, a function is written to read in the data:  
```{r}

# Function to read in the raw coronavirus data file (assume it is already downloaded)
readCVData <- function(fileName,
                       showGlimpse=TRUE,
                       uqVars=c("date", "state"),
                       errDups=TRUE
                       ) {

    # FUNCTION ARGUMENTS
    # fileName: location of the downloded CSV file from COVID Tracking Project
    # showGlimpse: boolean, whether to run glimpse() on the file
    # uqVars: variables that the file is expected to be unique by
    # errDups: boolean, whether to error out if uniqueness is violated
    
    # Read in the file and convert the 'date' from double to date
    cvData <- readr::read_csv(fileName) %>%
        mutate(date=lubridate::ymd(date))
    
    # See a sample of the data
    if (showGlimpse) glimpse(cvData)

    # Check that the data are unique by date and state
    nDups <- cvData %>%
        select_at(vars(all_of(uqVars))) %>%
        anyDuplicated()
    
    # Inform of the uniqueness check results
    if (nDups==0) {
        cat("\nFile is unique by:", uqVars, "and has dimensions:", dim(cvData), "\n")
    } else {
        cat("\nUniqueness check failed, file has duplicates by:", uqVars, "\n")
        if (errDups) stop("Fix and re-run")
    }
    
    # Return the file
    cvData
    
}

cvFull <- readCVData("./RInputFiles/Coronavirus/CV_downloaded_200820.csv")

```
  
Next, a function selects only the key variables of interest, filters to include only states (plus DC), and reports on relevant control totals:  
```{r}

# Function to select relevant variables and observations, and report on control totals
processCVData <- function(dfFull, 
                          varsKeep=c("date", "state", "positiveIncrease", "deathIncrease"), 
                          varsRename=c("positiveIncrease"="cases", "deathIncrease"="deaths"), 
                          stateList=c(state.abb, "DC")
                          ) {
    
    # FUNCTION ARGUMENTS
    # dfFull: the full data file originally loaded
    # varsKeep: variables to keep from the full file
    # varsRename: variables to be renamed, using a named vector of form originalName=newName
    # stateList: variables for filtering state (NULL means do not run any filters)
    
    # Select only the key variables
    df <- dfFull %>%
        select_at(vars(all_of(varsKeep)))
    
    # Apply the renaming of variables
    names(df) <- ifelse(is.na(varsRename[names(df)]), names(df), varsRename[names(df)])

    # Designate each record as being either a valid state or not
    if (!is.null(stateList)) {
        df <- df %>%
            mutate(validState=state %in% stateList)
    } else {
        df <- df %>%
            mutate(validState=TRUE)
    }
    
    # Summarize the control totals for the data, based on whether the state is valid
    cat("\n\nControl totals - note that validState other than TRUE will be discarded\n\n")
    df %>%
        mutate(n=1) %>%
        group_by(validState) %>%
        summarize_if(is.numeric, sum) %>%
        print()
    
    # Return the file, filtered to where validState is TRUE, and deleting variable validState
    df %>%
        filter(validState) %>%
        select(-validState)

}

cvFiltered <- processCVData(cvFull)

```
  
Next, a state population data is processed for future use:  
```{r}

# Function to extract and format key state data
getStateData <- function(df=usmap::statepop, 
                         renameVars=c("abbr"="state", "full"="name", "pop_2015"="pop"), 
                         keepVars=c("state", "name", "pop")
                         ) {
    
    # FUNCTION ARGUMENTS:
    # df: the data frame containing state data
    # renameVars: variables to be renamed, using named list with format "originalName"="newName"
    # keepVars: variables to be kept in the final file
    
    # Rename variables where appropriate
    names(df) <- ifelse(is.na(renameVars[names(df)]), names(df), renameVars[names(df)])
    
    # Return file with only key variables kept
    df %>%
        select_at(vars(all_of(keepVars)))
    
}

stateData <- getStateData()

```
  
Next, helper functions are written to convert a variable to per capita, or to convert a variable to a "rolling" mean:  
```{r}

# Helper function to create per capita metrics
helperPerCapita <- function(df, 
                            origVar, 
                            newName,
                            byVar="state",
                            popVar="pop",
                            popData=stateData,
                            mult=1000000
                            ) {
    
    # FUNCTION ARGUMENTS:
    # df: the data frame currently being processed
    # origVar: the variables to be converted to per capita
    # newName: the new per capita variable name
    # byVar: the variable that will be merged by
    # popVar: the name of the population variable in the popData file
    # popData: the file containing the population data
    # mult: the multiplier, so that the metric is "per mult people"
    
    # Create the per capita variable
    df %>%
        inner_join(select_at(popData, vars(all_of(c(byVar, popVar)))), by=byVar) %>%
        mutate(!!newName:=mult*get(origVar)/get(popVar)) %>%
        select(-all_of(popVar))
    
}


# Helper function to create rolling aggregates
helperRollingAgg <- function(df, 
                             origVar, 
                             newName,
                             func=zoo::rollmean,
                             k=7, 
                             fill=NA, 
                             ...
                             ) {
    
    # FUNCTION ARGUMENTS:
    # df: the data frame containing the data
    # origVar: the original data column name
    # newName: the new variable column name
    # func: the function to be applied (zoo::rollmean will be by far the most common)
    # k: the periodicity (k=7 is rolling weekly data)
    # fill: how to fill leading.trailing data to maintain the same vector lengths
    # ...: any other arguments to be passed to func
    
    # Create the appropriate variable
    df %>%
        mutate(!!newName:=func(get(origVar), k=k, fill=fill, ...))
    
}



# Function to add per capita and rolling to the base data frame
helperMakePerCapita <- function(df, 
                                k=7
                                ) {
    
    # FUNCTION ARGUMENTS:
    # df: the initial data frame for conversion
    # k: the rolling time period to use
    
    # Create the variables for cpm, dpm, cpm7, and dpm7
    dfNew <- df %>%
        helperPerCapita(origVar="cases", newName="cpm") %>%
        helperPerCapita(origVar="deaths", newName="dpm") %>%
        group_by(state) %>%
        arrange(date) %>%
        helperRollingAgg(origVar="cpm", newName=paste0("cpm", k), k=k) %>%
        helperRollingAgg(origVar="dpm", newName=paste0("dpm", k), k=k) %>%
        ungroup()

    # Return the new data frame
    dfNew
    
}


# Create the variables for cpm, dpm, cpm7, and dpm7
cvFilteredPerCapita <- helperMakePerCapita(cvFiltered, k=7)
cvFilteredPerCapita

```
  
Next, a function is written for creating side-by-side cases and death bar plots:  
```{r}

# Function to create side-by-side plots for a deaths and cases metric
# Data in df will be aggregated to be unique by byVar using aggFunc
helperBarDeathsCases <- function(df, 
                                 numVars,
                                 title="",
                                 xVar="state",
                                 fillVar=NULL,
                                 aggFunc=sum, 
                                 mapper=varMapper
                                 ) {
    
    # FUNCTION ARGUMENTS:
    # df: the data frame containing the data
    # numVars: the relevant numeric variables for plotting
    # title: plot title, default is nothing
    # xVar: the x-axis variable for plotting
    # fillVar: the variable that will color the bars in the final plot (NULL means use "lightblue" for all)
    # aggFunc: the aggregate function (will be applied to create data unique by byVar)
    # mapper: mapping file to convert x/y variables to descriptive axes (named vector "variable"="label")
    
    # OVERALL FUNCTION PROCESS:
    # 1.  Variables in numVar are aggregated by aggFunc to be unique by c(xVar, fillVar)
    # 2.  Data are pivoted longer
    # 3.  Bar charts are created, with coloring by fillVar if provided
    
    # Create the byVar for summing
    byVar <- xVar
    if (!is.null(fillVar)) { byVar <- c(byVar, fillVar) }
    
    # Process the data and create the plot
    p1 <- df %>%
        select_at(vars(all_of(c(byVar, numVars)))) %>%
        group_by_at(vars(all_of(byVar))) %>%
        summarize_all(aggFunc) %>%
        pivot_longer(-all_of(byVar)) %>%
        ggplot(aes(x=fct_reorder(get(xVar), value, .fun=min), y=value)) + 
        coord_flip() + 
        facet_wrap(~mapper[name], scales="free_x") + 
        labs(x="", y="", title=title) + 
        if (is.null(fillVar)) geom_col(fill="lightblue") else geom_col(aes_string(fill=fillVar))
    
    # Print the plot
    print(p1)
    
}


```
  
A function is written to assess the raw state-level totals:  
```{r}

# Function to assess state data (no segments created yet)
assessStateData <- function(df, 
                            titleStem="Coronavirus burden by state", 
                            cfrEst=0.005,
                            mapper=varMapper
                            ) {
    
    # FUNCTION ARGUMENTS:
    # df: the data frame containing the state-level data
    # titleStem: the main title description, with (total) or (per capita) appended
    # cfrEst: the estimated case fatality rate (CFR); a dashed abline will be plotted at this slope
    # mapper: mapping file to convert x/y variables to descriptive axes (named vector "variable"="label")
    
    # Plot cases and deaths by state, once for overall and once per capita
    helperBarDeathsCases(df, numVars=c("deaths", "cases"), title=paste0(titleStem, " (total)"))
    helperBarDeathsCases(df, numVars=c("dpm", "cpm"), title=paste0(titleStem, " (per capita)"))

    # Disease burden by state, per capita
    p1 <- df %>%
        group_by(state) %>%
        summarize(cpm=sum(cpm), dpm=sum(dpm)) %>%
        ggplot(aes(x=cpm, y=dpm)) +
        geom_text(aes(label=state)) + 
        labs(x=mapper["cpm"], 
             y=mapper["dpm"], 
             title="Deaths vs. cases by state (per million people)", 
             subtitle=paste0("Dashed line is a CFR of ", 
                             round(100*cfrEst, 1), 
                             "% (states far from this may have case counting issues)"
                             )
             ) + 
        geom_abline(slope=cfrEst, lty=2)
    print(p1)
    
    # Total disease burden nationally by day, not using functional form
    p2 <- df %>%
        select(date, cases, deaths) %>%
        group_by(date) %>%
        summarize_if(is.numeric, sum) %>%
        ungroup() %>%
        helperRollingAgg(origVar="cases", newName="casesroll7") %>%
        helperRollingAgg(origVar="deaths", newName="deathsroll7") %>%
        select(-cases, -deaths) %>%
        pivot_longer(-date) %>%
        filter(!is.na(value)) %>%
        ggplot(aes(x=date, y=value)) + 
        geom_line() +
        facet_wrap(~varMapper[name], scales="free_y") + 
        labs(x="", 
             y="",
             title=titleStem
             )
    print(p2)
    
}


# State-level assessments
assessStateData(cvFilteredPerCapita)

```
  
Next, functions for creating and assessing clusters are created.  The approach can use either hierarchical clustering or k-means, and focus on the following variables:  
  
* Aggregate cases  
* Aggregate deaths  
* Shape of case curve (percentage by week/month)  
* Shape of death curve (percentage by week/month)  
  
Cases is a tricky clustering variable since detection rates were in the single-digit percentages early in the outbreak (estimates of ~50x as many infected as diagnosed).  As testing volumes increased, it is likely that a greater percentage of cases are diagnosed.  States that have later outbreaks appear to have many more cases per capita but with a lower death rate per capita:  
```{r}

# Function to create an elbow plot for various numbers of clusters in the data
helperElbow <- function(mtx, 
                        testCenters, 
                        iter.max, 
                        nstart, 
                        silhouette=FALSE
                        ) {
    
    # FUNCTION ARGUMENTS:
    # mtx: a numeric matrix, or an object that can be coerced to a numeric matrix (no character fields)
    # testCenters: integer vector for the centers to be tested
    # iter.max: parameter passed to kmeans
    # nstart: parameter passed to kmeans
    # silhouette: whether to calculate the silhouette score
    
    # Create an object for storing tot.withinss and silhouetteScore
    totWithin <- vector("numeric", length(testCenters))
    silhouetteScore <- vector("numeric", length(testCenters))
    
    # Create the distancing data (required for silhouette score)
    if (silhouette) distData <- dist(mtx)
    
    # Run k-means for every value in testCenters, and store $tot.withinss (and silhouetteScore, if requested)
    n <- 1
    for (k in testCenters) {
        km <- kmeans(mtx, centers=k, iter.max=iter.max, nstart=nstart)
        totWithin[n] <- km$tot.withinss
        if (silhouette & (k > 1)) silhouetteScore[n] <- mean(cluster::silhouette(km$cluster, distData)[, 3])
        n <- n + 1
    }
    
    # Create the elbow plot
    p1 <- tibble::tibble(n=testCenters, wss=totWithin) %>%
        ggplot(aes(x=n, y=wss)) + 
        geom_point() + 
        geom_line() + 
        geom_text(aes(y=wss + 0.05*max(totWithin), x=n+0.2, label=round(wss, 1))) + 
        labs(x="Number of segments", y="Total Within Sum-Squares", title="Elbow plot") + 
        ylim(c(0, NA))
    
    # Create the silhouette plot if requested
    if (silhouette) {
        p2 <- tibble::tibble(n=testCenters, ss=silhouetteScore) %>%
            ggplot(aes(x=n, y=ss)) + 
            geom_point() + 
            geom_line() + 
            geom_text(aes(y=ss + 0.05*max(silhouetteScore), x=n+0.2, label=round(ss, 1))) + 
            labs(x="Number of segments", y="Mean silhouette width", title="Silhouette plot") + 
            ylim(c(-1, NA))
        gridExtra::grid.arrange(p1, p2, nrow=1)
    } else {
        print(p1)
    }
    
}


# Function to create clusters for the state data (requires all data from same year, as currently true)
clusterStates <- function(df, 
                          caseVar="cpm", 
                          deathVar="dpm",
                          shapeFunc=lubridate::month, 
                          minShape=NULL, 
                          minDeath=0,
                          minCase=0,
                          ratioTotalvsShape=1, 
                          ratioDeathvsCase=1, 
                          hierarchical=TRUE, 
                          hierMethod="complete", 
                          nCenters=3, 
                          iter.max=10,
                          nstart=1,
                          testCenters=NULL,
                          returnList=FALSE, 
                          seed=NULL
                          ) {
    
    # FUNCTION ARGUMENTS:
    # df: the data frame containing cases and deaths data
    # caseVar: the variable containing the cases per capita data
    # deathVar: the variable containing the deaths per capita data
    # shapeFunc: the function to be used for creating the shape of the curve
    # minShape: the minimum value to be used for shape (to avoid very small amounts of data in Jan/Feb)
    #           NULL means keep everything
    # minDeath: use this value as a floor for the death metric when calculating shape
    # minCase: use this metric as a floor for the case metric when calculating shape
    # ratioTotalvsShape: amount of standard deviation to be kept in total variable vs shape variables
    # ratioDeathvsCase: amount of standard deviation to be kept in deaths vs cases 
    #                   (total death data will be scaled to have sd this many times higher than cases)
    #                   (death percentages by time period will be scaled directly by this amount)
    # hierarchical: boolean, if TRUE run hierarchical clustering, otherwise run k-means clustering
    #               only hierarchical clustering is currently implemented
    # hierMethod: the method for hierarchical clustering (e.g., 'complete' or 'single')
    # nCenters: the number of centers to use for kmeans clustering
    # testCenters: integer vector of centers to test (will create an elbow plot); NULL means do not test
    # iter.max: maximumum number of kmeans iterations (default in kmeans algorithm is 10)
    # nstart: number of random sets chosen for kmeans (default in kmeans algorithm is 1)
    # returnList: boolean, if FALSE just the cluster object is returned
    #                      if TRUE, a list is returned with dfCluster and the cluster object
    # seed: set the seed to this value (NULL means no seed)
    
    # Extract key information (aggregates and by shapeFunc for each state)
    df <- df %>%
        select_at(vars(all_of(c("date", "state", caseVar, deathVar)))) %>%
        purrr::set_names(c("date", "state", "cases", "deaths")) %>%
        mutate(timeBucket=shapeFunc(date)) %>%
        group_by(state, timeBucket) %>%
        summarize(cases=sum(cases), deaths=sum(deaths)) %>%
        ungroup()
    
    # Limit to only relevant time buckets if requested
    if (!is.null(minShape)) {
        df <- df %>%
            filter(timeBucket >= minShape)
    }
    
    # Extract an aggregate by state, scaled so that they have the proper ratio
    dfAgg <- df %>%
        group_by(state) %>%
        summarize(totalCases=sum(cases), totalDeaths=sum(deaths)) %>%
        ungroup() %>%
        mutate(totalDeaths=ratioDeathvsCase*totalDeaths*sd(totalCases)/sd(totalDeaths))
    
    # Extract the percentages (shapes) by month, scaled so that they have the proper ratio
    dfShape <- df %>%
        pivot_longer(-c(state, timeBucket)) %>%
        group_by(state, name) %>%
        mutate(tot=pmax(sum(value), ifelse(name=="deaths", minDeath, minCase)), 
               value=ifelse(name=="deaths", ratioDeathvsCase, 1) * value / tot) %>%
        select(-tot) %>%
        pivot_wider(state, names_from=c(name, timeBucket), values_from=value) %>%
        ungroup()
    
    # Function to calculate SD of a subset of columns
    calcSumSD <- function(df) {
        df %>% ungroup() %>% select(-state) %>% summarize_all(.funs=sd) %>% as.vector() %>% sum()
    }
    # Down-weight the aggregate data so that there is the proper sum of sd in aggregates and shapes
    aggSD <- calcSumSD(dfAgg)
    shapeSD <- calcSumSD(dfShape)
    dfAgg <- dfAgg %>%
        mutate_if(is.numeric, ~. * ratioTotalvsShape * shapeSD / aggSD)

    # Combine so there is one row per state
    dfCluster <- dfAgg %>%
        inner_join(dfShape, by="state")
    
    # Create hierarchical segments or kmeans segments
    keyData <- dfCluster %>% column_to_rownames("state")
    if (hierarchical) {
        objCluster <-  hclust(dist(keyData), method=hierMethod)
        plot(objCluster)
    } else {
        # Create an elbow plot if testCenters is not NULL
        if (!is.null(testCenters)) {
            helperElbow(keyData, testCenters=testCenters, iter.max=iter.max, nstart=nstart, silhouette=TRUE)
        }
        # Create the kmeans cluster object, setting a seed if requested
        if (!is.null(seed)) set.seed(seed)
        objCluster <- kmeans(keyData, centers=nCenters, iter.max=iter.max, nstart=nstart)
        cat("\nCluster means and counts\n")
        n=objCluster$size %>% cbind(objCluster$centers) %>% round(2) %>% t() %>% print()
    }

    # Return the data and object is a list if returnList is TRUE, otherwise return only the clustering object
    if (!isTRUE(returnList)) {
        objCluster
    } else {
        list(objCluster=objCluster, dfCluster=dfCluster)
    }
    
}

# Test clusters that weight deaths heavily vs. cases and that weight shape more highly than total
testCluster <- clusterStates(cvFilteredPerCapita, 
                             minShape=3, 
                             ratioDeathvsCase = 5, 
                             ratioTotalvsShape = 0.5, 
                             minDeath=100, 
                             minCase=10000
                             )

```
  
The clusters can then be assessed against several criteria:  
```{r}

# Helper function to assess 30-day change vs. total
helperRecentvsTotal <- function(df, 
                                xVar, 
                                yVar,
                                title,
                                recencyDays=30, 
                                ablineSlope=0.5, 
                                mapper=varMapper, 
                                printPlot=TRUE
                                ) {
    
    # FUNCTION ARGUMENTS:
    # df: the tibble containing data by state by day
    # xVar: the x-variable
    # yVar: the y-variable
    # title: the plot title
    # recencyDays: number of days to consider as recent
    # ablineSlope: dashed line will be drawn with this slope and intercept 0
    # mapper: mapping file to convert x/y variables to descriptive axes (named vector "variable"="label")
    # printPlot: boolean, whether to display the plot (if FALSE, plot object is returned)
    
    # Get the most date cutoff
    dateCutoff <- df %>% pull(date) %>% max() - recencyDays + 1
    cat("\nRecency is defined as", format(dateCutoff, "%Y-%m-%d"), "through current\n")
    
    # Create the plot
    p1 <- df %>%
        mutate(newCases=ifelse(date >= dateCutoff, cases, 0), 
               newDeaths=ifelse(date >= dateCutoff, deaths, 0), 
               newcpm=ifelse(date >= dateCutoff, cpm, 0), 
               newdpm=ifelse(date >= dateCutoff, dpm, 0)
               ) %>%
        group_by(state, cluster) %>%
        summarize_if(is.numeric, .funs=sum) %>%
        ungroup() %>%
        ggplot(aes_string(x=xVar, y=yVar)) + 
        geom_text(aes(color=cluster, label=state)) + 
        labs(x=mapper[xVar], 
             y=mapper[yVar], 
             title=title, 
             subtitle=paste0("Dashed line represents ", 
                             round(100*ablineSlope), 
                             "% of total is new in last ", 
                             recencyDays,
                             " days"
                             )
             ) + 
        geom_abline(lty=2, slope=ablineSlope) + 
        lims(x=c(0, NA), y=c(0, NA)) + 
        theme(legend.position = "bottom")
    
    if (isTRUE(printPlot)) {
        print(p1)
    } else {
        p1
    }

}


# Function to plot cluster vs. individual elements on a key metric
helperTotalvsElements <- function(df, 
                                  keyVar, 
                                  title,
                                  aggFunc=median, 
                                  mapper=varMapper, 
                                  facetScales="free_y", 
                                  printPlot=TRUE
                                  ) {

    # FUNCTION ARGUMENTS:
    # df: the data frame containing n-day rolling averages
    # keyVar: the variable to be plotted
    # title: the plot title
    # aggFunc: how to aggregate the elements to the segment
    #          CAUTION that this is an aggregate of averages, rather than a population-weighted aggregate
    # mapper: the variable mapping file to get the appropriate label for keyVar
    # facetScales: the scaling for the facets - "free_y" to let them all float, "fixed" to have them the same
    # printPlot: boolean, if TRUE print the plot (otherwise return the plot object)

    # Create an appropriate subtitle
    subtitle <- if(facetScales=="free_y") {
        "Caution that each facet has its own y axis with different scales"
    } else if (facetScales=="fixed") { 
        "All facets are on the same scale"
    } else {
        "Update subtitle code in function helperTotalvsElements"
    }
    
    # Create the plots for segment-level data
    p1 <- df %>%
        rbind(mutate(., state="cluster")) %>%
        group_by(state, cluster, date) %>%
        summarize_at(vars(all_of(keyVar)), .funs=aggFunc) %>%
        ungroup() %>%
        filter(!is.na(get(keyVar))) %>%
        ggplot(aes_string(x="date", y=keyVar)) + 
        geom_line(data=~filter(., state != "cluster"), aes(group=state), alpha=0.25) + 
        geom_line(data=~filter(., state == "cluster"), aes(group=state, color=cluster), lwd=1.5) + 
        facet_wrap(~cluster, scales=facetScales) + 
        labs(x="", 
             y=mapper[keyVar], 
             title=title, 
             subtitle=subtitle,
             caption="Cluster-level aggregates weight each state equally\n(NOT population-weighted)"
             ) + 
        ylim(c(0, NA)) + 
        theme(legend.position="bottom")
    
    # Print plot if requested, otherwise return it
    if (isTRUE(printPlot)) {
        print(p1)
    } else {
        p1
    }
    
}



# Function to assess clusters
assessClusters <- function(clusters, 
                           dfState=stateData, 
                           dfBurden=cvFilteredPerCapita,
                           thruLabel="Aug 20, 2020",
                           plotsTogether=FALSE, 
                           clusterPlotsTogether=plotsTogether,
                           recentTotalTogether=plotsTogether, 
                           clusterAggTogether=plotsTogether
                           ) {
    
    # FUNCTION ARGUMENTS:
    # clusters: the named vector containing the clusters by state
    # dfState: the file containing the states and populations
    # dfBurden: the data containing the relevant per capita burden statistics by state-date
    # thruLabel: label for plots for 'data through'
    # plotsTogether: boolean, should plots be consolidated on fewer pages?
    # clusterPlotsTogether: boolean, should plots p1-p4 be consolidated?
    # recentTotalTogether: boolean, should recent total plots p7-p8 be consolidated?
    # clusterAggTogether: boolean, should aggregate plots p9/p11 and p10/p12 be consolidated?
    
    # Attach the clusters to the state population data
    dfState <- as.data.frame(clusters) %>%
        set_names("cluster") %>%
        rownames_to_column("state") %>%
        inner_join(dfState, by="state") %>%
        mutate(cluster=factor(cluster))
    
    # Plot the segments on a state map
    p1 <- usmap::plot_usmap(regions="states", data=dfState, values="cluster") + 
        scale_fill_discrete("cluster") + 
        theme(legend.position="right")
    
    # Plot the population totals by segment
    # Show population totals by cluster
    p2 <- dfState %>%
        group_by(cluster) %>%
        summarize(pop=sum(pop)/1000000) %>%
        ggplot(aes(x=fct_rev(cluster), y=pop)) + 
        geom_col(aes(fill=cluster)) + 
        geom_text(aes(y=pop/2, label=round(pop))) + 
        labs(y="2015 population (millions)", x="Cluster", title="Population by cluster (millions)") +
        coord_flip()
    
    # Plot the rolling 7-day mean dialy disease burden by cluster
    dfPlot <- dfState %>%
        inner_join(dfBurden, by="state") %>%
        tibble::as_tibble()
    
    # Plot the rolling 7-day mean dialy disease burden by cluster
    p3 <- dfPlot %>%        
        select(date, cluster, cases=cpm7, deaths=dpm7) %>%
        pivot_longer(-c(date, cluster)) %>%
        filter(!is.na(value)) %>%
        group_by(date, cluster, name) %>%
        summarize(value=median(value)) %>%
        ggplot(aes(x=date, y=value)) +
        geom_line(aes(group=cluster, color=cluster)) +
        facet_wrap(~name, scales="free_y") +
        labs(x="",
             y="Rolling 7-day mean, per million",
             title="Rolling 7-day mean daily disease burden, per million",
             subtitle="Median per day for states assigned to cluster"
             )
    
    # Plot the total cases and total deaths by cluster
    p4 <- dfPlot %>%
        group_by(cluster) %>%
        summarize(cases=sum(cases), deaths=sum(deaths)) %>%
        pivot_longer(-cluster) %>%
        ggplot(aes(x=fct_rev(cluster), y=value/1000)) + 
        geom_col(aes(fill=cluster)) + 
        geom_text(aes(y=value/2000, label=round(value/1000))) +
        coord_flip() + 
        facet_wrap(~varMapper[name], scales="free_x") + 
        labs(x="Cluster", y="Burden (000s)", title="Total cases and deaths by segment")

    # Place the plots together if plotsTogether is TRUE, otherwise just print
    if (isTRUE(plotsTogether)) {
        gridExtra::grid.arrange(p1, p2, p3, p4, nrow=2, ncol=2)
    } else {
        print(p1); print(p2); print(p3); print(p4)
    }
    
    # Plot total cases and total deaths by state, colored by cluster
    helperBarDeathsCases(dfPlot, 
                         numVars=c("cases", "deaths"), 
                         title=paste0("Coronavirus impact by state through ", thruLabel), 
                         xVar=c("state"), 
                         fillVar=c("cluster")
                         )
    
    # Plot cases per million and deaths per million by state, colored by cluster
    helperBarDeathsCases(dfPlot, 
                         numVars=c("cpm", "dpm"), 
                         title=paste0("Coronavirus impact by state through ", thruLabel), 
                         xVar=c("state"), 
                         fillVar=c("cluster")
                         )
    
    # Plot last-30 vs total for cases per million by state, colored by cluster
    p7 <- helperRecentvsTotal(dfPlot, 
                              xVar="cpm", 
                              yVar="newcpm", 
                              title=paste0("Coronavirus burden through ", thruLabel), 
                              printPlot=FALSE
                              )
    
    # Plot last-30 vs total for deaths per million by state, colored by cluster
    p8 <- helperRecentvsTotal(dfPlot, 
                              xVar="dpm", 
                              yVar="newdpm", 
                              title=paste0("Coronavirus burden through ", thruLabel), 
                              printPlot=FALSE
                              )
    
    # Print the plots either as a single page or separately
    if (isTRUE(recentTotalTogether)) {
        gridExtra::grid.arrange(p7, p8, nrow=1)
    } else {
        print(p7); print(p8)
    }
    
    # Plot the cases per million on a free y-scale and a fixed y-scale
    p9 <- helperTotalvsElements(dfPlot, 
                                keyVar="cpm7", 
                                title="Cases per million, 7-day rolling mean", 
                                printPlot=FALSE
                                )
    p10 <- helperTotalvsElements(dfPlot, 
                                 keyVar="cpm7", 
                                 title="Cases per million, 7-day rolling mean", 
                                 facetScales="fixed", 
                                 printPlot=FALSE
                                 )
    
    # Plot the deaths per million on a free y-scale and a fixed y-scale
    p11 <- helperTotalvsElements(dfPlot, 
                                 keyVar="dpm7", 
                                 title="Deaths per million, 7-day rolling mean", 
                                 printPlot=FALSE
                                 )
    p12 <- helperTotalvsElements(dfPlot, 
                                 keyVar="dpm7", 
                                 title="Deaths per million, 7-day rolling mean", 
                                 facetScales="fixed", 
                                 printPlot=FALSE
                                 )
    
    if (isTRUE(clusterAggTogether)) {
        gridExtra::grid.arrange(p9, p11, nrow=1)
        gridExtra::grid.arrange(p10, p12, nrow=1)
    } else {
        print(p9); print(p10); print(p11); print(p12)
    }
    # Return the plotting data frame
    dfPlot

}

# Check how 5 clusters look, with Vermont arbitrarily reassigned as the same cluster as New Hampshire
clustVec <- cutree(testCluster, k=6)
clustVec["VT"] <- clustVec["NH"]
plotData <- assessClusters(clustVec)

```
  
At a glance, the segments appear reasonable:  
  
* Segments 4 and 5 had early disease, but with less pronounced spikes in segment 5 than in segment 4, and with a greater case rebound in segment 5 than in segment 4    
* Segments 2 had late disease, with little spike early  
* Segments 1 and 3 have generally had fewer deaths, though with spiky cases that are similarly shaped if much lower than segment 2 (late disease, which may be increased testing finding a higher percentage of disease)  
  
The full process can then all be run in one place:  
```{r}

# Extract state data
stateData <- getStateData()

# Load and process CV data
cvFull <- readCVData("./RInputFiles/Coronavirus/CV_downloaded_200820.csv")
cvFiltered <- processCVData(cvFull)
cvFilteredPerCapita <- helperMakePerCapita(cvFiltered, k=7)

# Run state-level assessments
assessStateData(cvFilteredPerCapita)

# Test clusters that weight deaths heavily vs. cases and that weight shape more highly than total
testCluster <- clusterStates(cvFilteredPerCapita, 
                             minShape=3, 
                             ratioDeathvsCase = 5, 
                             ratioTotalvsShape = 0.5, 
                             minDeath=100, 
                             minCase=10000
                             )

# Check how 6 clusters look, with Vermont arbitrarily reassigned as the same cluster as New Hampshire
clustVec2 <- cutree(testCluster, k=7)
clustVec2["VT"] <- clustVec2["NH"]

# Create the cluster assessments
plotData2 <- assessClusters(clustVec2)

```
  
The process is easy to run and update now that it is in functional form.  An exploration is made for 6 segments, which allows for a bucket of LA, DC, RI.  These are states that had meaningful early disease spikes (though less than the main high-spike-early cluster) and also meaningful late disease spikes (though less than the main high-spike-late cluster).  Findings include:  
  
* There are significant differences (more than 10:1) in coronavirus deaths per capita by US state through August 20  
* There is strong evidence that cases are significantly undercounted in aggregate, since almost all states have a calculated CFR that is well above the current best estimate of 0.5%  
* The observed double-peak ("second wave") in the US national data appears to be driven by different geographies (segments) having their first wave at different times; there has been a significant increase in testing, so deaths vs. cases in the late first waves are much less than they were in the early first waves  
* While the segments are data-derived, there are significant qualitative similarities among many of the states assigned to a given cluster (e.g., south, Acela corrdior, central/upper plains, etc.)  
* With the exception of segment 5, all segments have between 40 million and 80 million people  
* Segment 2 (south plus AZ/NV) has a meaningful spike in cases and deaths in July/August; the spike in cases appears to be descending rapidly, with deaths plateaued if not decreasing  
* Segment 4 (NY, NJ, CT, MA) has a meaningful spike in cases and deaths in March-May; the spikes appear to have descended to, and remained near, zero thereafter  
* Segment 6 (IL, IN, MI, PA, MD, DE) had a meaningful spike in cases and deaths in March-May, though at under half the per capita levels of Segment 4; there has been a second spike of cases in July/August, though with little increase in deaths, suggestive that there may be increased testing more so than increased disease  
* Segment 5 (LA, DC, RI) is something of a blend of Segment 4 and Segment 6; it has a higher spike early than Segment 6, but has a meaningful spike in cases late unlike Segment 4  
* Segments 1 and 3 both have relatively low coronavirus burden, with segment 3 having greater cases than Segment 1 early, while segment 1 has greater cases than segment 3 late (Segment 1 is roughly a low-impact version of Segment 2, while Segment 3 is roughly a low-impact version of Segment 6)  
  
The clusterStates() function is updated in two ways:  
  
1.  Designed to output, at user's request, a list containing the processed state-level data as well as the clustering object  
2.  Designed to implement kmeans segmentation in addition to hierarchical clustering  
  
An example is run using k-means, with 2 segments (the most obvious best silhouette width given these parameters):  
```{r}

# Test clusters that weight deaths heavily vs. cases and that weight shape more highly than total
# Using kmeans and testing for 1-10 clusters
testCluster_km2 <- clusterStates(cvFilteredPerCapita, 
                                 minShape=3, 
                                 ratioDeathvsCase = 5, 
                                 ratioTotalvsShape = 0.5, 
                                 minDeath=100, 
                                 minCase=10000, 
                                 hierarchical=FALSE, 
                                 nCenters=2,
                                 testCenters=1:10, 
                                 iter.max=20,
                                 nstart=10, 
                                 returnList=TRUE, 
                                 seed=2008261350
                                 )

# Check how 2 clusters look
clustVec_km2 <- testCluster_km2$objCluster$cluster

# Create the cluster assessments
plotData_km2 <- assessClusters(clustVec_km2)

```
  
Given the criteria that deaths matter much more than cases and that aggregate matters more than shape, the main clustering distinction is the 11 states plus DC that had early, heavy disease.  While this produces the best mean silhouette width, it appears to be missing the distinction of states with a later spike.  The elbow plot is consistent with this, as there is no obvious break where within-sum-squares meaningfully stops decreasing.  Suppose that 5 segments are created, with the intent of splitting high/low deaths and early/late spikes:  
```{r}

# Test clusters that weight deaths heavily vs. cases and that weight shape more highly than total
# Using kmeans and testing for 1-10 clusters
testCluster_km5 <- clusterStates(cvFilteredPerCapita, 
                                 minShape=3, 
                                 ratioDeathvsCase = 5, 
                                 ratioTotalvsShape = 0.5, 
                                 minDeath=100, 
                                 minCase=10000, 
                                 hierarchical=FALSE, 
                                 nCenters=5,
                                 testCenters=1:10, 
                                 iter.max=20,
                                 nstart=10, 
                                 returnList=TRUE, 
                                 seed=2008261400
                                 )

# Check how 5 clusters look
clustVec_km5 <- testCluster_km5$objCluster$cluster

# Create the cluster assessments
plotData_km5 <- assessClusters(clustVec_km5)

```
  
The clusters appear very similar to those created using hierarchical clustering.  A comparison of the segments assigned is made:  
```{r}

tibble::tibble(state=names(clustVec), 
               hier5=clustVec, 
               hier6=clustVec2,
               km2=clustVec_km2,
               km5=clustVec_km5
               ) %>%
    count(hier6, hier5, km2, km5)

```
  
States are sufficiently differentiated, and the method sufficiently focused on deaths and aggregates, such that the clustering techniques produce similar results.  There are many states that are near the edges of the clusters, and the choice of metrics and even random seeds will drive their assignments.  Provided there are enough segments, there appears to typically be 1) at least one segment of early and heavy disease, 2) at least one segment of late and heavy disease, and 3) at least one segment of much lower than average disease.  There is then some differentiation as to how the "early and heavy" and "lower than average" segments are identified and/or further subsetted.
  
The assessClusters() function is updated to put smaller versions of related plots all on a single page.  Example usage is shown below:  
```{r}

# Create the cluster assessments
plotData_km5 <- assessClusters(clustVec_km5, 
                               dfState=stateData, 
                               dfBurden=cvFilteredPerCapita,
                               plotsTogether=TRUE
                               )

```
  
Hospitalization data is also included in the raw coronavirus file from The COVID Project:  
```{r}

# All fields contained in the raw CV file
names(cvData)

# Fields matching to 'hosp' or 'icu' or 'ventilator'
hospVars <- names(cvData) %>% 
    grep(x=., pattern="[Hh]osp|[Ii]cu|[Vv]entilator", value=TRUE) %>% 
    sort()
hospVars

```
  
Data are investigated for amount of 'missingness' by time period:  
```{r}

set.seed(2008281323)

cvData %>%
    select_at(vars(all_of(c("state", "date", hospVars)))) %>%
    sample_n(20) %>%
    purrr::set_names(c("state", "date", 
                       "hosp", "hospCum", "hospCur", "hospInc", 
                       "icuCum", "icuCur", "ventCum", "ventCur"
                       )
                     ) %>%
    arrange(date)

```
  
Missing data appears to be common, and not always reflective of zero.  There is at least some directional evidence that the hospitalized currently variables has been coming on line and that the hospitalized increase variable uses 0 for both NA and 'no increase'.  This would be problematic for using any of the variables (potentially other than hospCur) for cross-state comparisons.  An analysis is run to see the frequency of NA by variable by date:  
```{r}

# Not NA data
notNADate <- cvData %>%
    filter(state %in% c(state.abb, "DC")) %>%
    select_at(vars(all_of(c("state", "date", hospVars)))) %>%
    mutate(nState=1) %>%
    group_by(date) %>%
    summarize_if(is.numeric, .funs=function(x) { sum(!is.na(x))}) %>%
    ungroup()

# Evolution of Not NA states by time
notNADate %>%
    pivot_longer(-date) %>%
    ggplot(aes(x=date, 
               y=value, 
               group=fct_rev(fct_reorder(name, value, .fun=max)), 
               color=fct_rev(fct_reorder(name, value, .fun=max))
               )
           ) + 
    geom_line(lwd=1) + 
    geom_hline(yintercept=51, lty=2) + 
    labs(x="", y="Number of states with non-NA data", title="Evolution of data availability by metric") + 
    scale_color_discrete("") + 
    scale_x_date(date_breaks="1 months", date_labels="%m")

# Confirmation that hospitalized increase and nState are identical
sum(notNADate$hospitalizedIncrease != notNADate$nState)

```
  
The plots confirm the meaningful gaps in the hospitalization, ICU, and ventilator data.  Further, hospitalized increase exists and is non-missing for every case where there is a record (nState), suggesting that this metric has already had a filter such as ifelse(is.na(x), 0, x) applied.  The only data that appears to grow from NA to potentially stable is 'hospitalized currently', which has become valid in all 51 states as of August.

General data availability by metric is:  
```{r}

# Not NA data
notNADateState <- cvData %>%
    filter(state %in% c(state.abb, "DC")) %>%
    select_at(vars(all_of(c("state", "date", hospVars)))) %>%
    mutate(nState=1, month=lubridate::month(date)) %>%
    group_by(month, state) %>%
    summarize_if(is.numeric, .funs=function(x) { min(!is.na(x))}) %>%
    ungroup()

# Evolution of Not NA states by month
notNADateState %>%
    pivot_longer(-c(state, month)) %>%
    filter(!(name %in% c("nState", "hospitalizedIncrease"))) %>%
    ggplot(aes(y=fct_reorder(state, value, .fun=sum), x=month)) + 
    geom_tile(aes(fill=value)) + 
    labs(x="", y="", title="Evolution of data availability by metric") + 
    scale_fill_continuous("", low="white", high="green") + 
    facet_wrap(~name, nrow=1)

# States missing hospitalizedCurrently as of May 1
notNADateState %>%
    filter(hospitalizedCurrently != 1, month >= 5)

```
  
The hospitalized currently metric is fully complete as of August, and mostly complete as of June.  Only data from Florida, Hawaii, Kansas, and Nebraska is missing, and all but Nebraska report data in 'hospitalized' for those time periods.  How does the hospitalized data compare with the hospitalizedCurrently data for FL, HI, and KS?  
```{r}

# Hospitalized comparisons
cvData %>%
    arrange(state, date) %>% 
    group_by(state) %>%
    filter(state %in% c("FL", "HI", "KS"), 
           is.na(lag(hospitalizedCurrently, 10)), 
                 !is.na(lead(hospitalizedCurrently, 5))
           ) %>% 
    select(date, state, contains("hosp")) %>% 
    as.data.frame()

```
  
Prior to reporting hospitalizedCurrently, it appears that the hopitalized field and hospitalizedCumulative fields were identical for these states.  And, hospitalizedIncrease appears to be the change in hospitalizedCumulative, which would be the number of people newly admitted to the hospital on that day (no reduction for any discharges/deaths on that day).
  
The lack of data will meaningfully complicate any cross-state comparisons, since some states did not report the same metrics (or at all) during times when their state had meaningful disease burden as shown by cases and deaths.
  
Since the 'hospitalizedCurrently' field is the most complete, a function is written to plot the per capita evolution of this metric by segment:  
```{r}

# Function to create plots of the number hospitalized by state and cluster
plotHospitalized <- function(df, 
                             clusterVector,
                             dfState=stateData, 
                             subT=""
                             ) {
    
    # FUNCTION ARGUMENTS:
    # df: a data frame or tibble containing 'state', 'date', 'hospitalizedCurrently'
    # clusterVector: a named vector of form 'state'='cluster'
    # dfState: a state-level population file containing 'state' and 'pop'
    # subT: a subtitle for the plot
    
    # Create the key plotting data
    plotData <- df %>% 
        inner_join(dfState, by="state") %>% 
        mutate(cluster=factor(clusterVector[state])) %>% 
        filter(!is.na(hospitalizedCurrently)) %>% 
        select(date, state, cluster, hospitalizedCurrently, pop) %>%
        rbind(mutate(., state="Total")) %>%
        group_by(state, cluster, date) %>% 
        summarize(n=n(), 
                  hospitalizedCurrently=sum(hospitalizedCurrently), 
                  pop=sum(pop)
                  ) %>% 
        mutate(hpm=1000000*hospitalizedCurrently/pop) %>%
        helperRollingAgg(origVar="hpm", newName="hpm7") %>%
        ungroup()
    
    # Create the plot
    p1 <- plotData %>%
        filter(!is.na(hpm7)) %>%
        ggplot(aes(x=date, y=hpm7)) + 
        geom_line(data=~filter(., state != "Total"), aes(group=state), alpha=0.25) +
        geom_line(data=~filter(., state == "Total"), aes(group=state, color=cluster), lwd=1.5) + 
        facet_wrap(~cluster, scales="fixed") + 
        ylim(c(0, NA)) + 
        labs(x="", 
             y="Currently Hospitalized 7-day rolling mean (per million)", 
             title="Hospitalized per million by cluster", 
             subtitle=subT
             )
    print(p1)
    
    # Return the plot data
    plotData

}

# Create the hospitalized plot
dfHospital <- plotHospitalized(cvData, clusterVector=clustVec_km5, subT="Data through August 20")

```
  
The data show very similar patterns and shapes as when the segments were plotted using cases and deaths.

The hospital data can then be integrated to the existing data file with cases and deaths.  Filling with NA for the hospitalized data is OK, so a left join is performed:  
```{r}

# This will drop the cluster aggregate that was created inside dfHospital
metrics_km5 <- plotData_km5 %>%
    left_join(select(dfHospital, -n, -pop), by=c("state", "cluster", "date"))

# Explore cluster-level totals for cases, deaths, hospitalizedCurrently
metrics_km5_plotData <- metrics_km5 %>%
    select(state, cluster, date, pop, cases, deaths, hosp=hospitalizedCurrently) %>%
    pivot_longer(-c(state, cluster, date, pop)) %>%
    filter(!is.na(value)) %>%
    rbind(mutate(., state="cluster")) %>%
    group_by(state, cluster, date, name) %>%
    summarize(value=sum(value), pop=sum(pop)) %>%
    mutate(vpm=1000000*value/pop) %>%
    arrange(state, cluster, name, date) %>%
    group_by(state, cluster, name) %>%
    helperRollingAgg(origVar="vpm", newName="vpm7")

# Create facetted plots for totals by metric by segment
metrics_km5_plotData %>%
    filter(!is.na(vpm7)) %>%
    ggplot(aes(x=date, y=vpm7)) + 
    geom_line(data=~filter(., state=="cluster"), aes(group=cluster, color=cluster), lwd=1.5) +
    geom_line(data=~filter(., state!="cluster"), aes(group=state), alpha=0.25) + 
    facet_grid(name ~ cluster, scales="free_y") + 
    labs(x="", 
         y="Rolling 7-day mean per million", 
         title="Key metrics by cluster (7-day rolling mean per million)", 
         subtitle="Cases: new cases, Deaths: new deaths, Hospitalized: total in hospital (not new)"
         ) + 
    scale_x_date(date_breaks="1 months", date_labels="%b") + 
    theme(axis.text.x=element_text(angle=90))
    
# Create all-segment plot by metric
metrics_km5_plotData %>%
    filter(!is.na(vpm7)) %>%
    ggplot(aes(x=date, y=vpm7)) + 
    geom_line(data=~filter(., state=="cluster"), aes(group=cluster, color=cluster), lwd=1.5) +
    facet_wrap(~ name, scales="free_y", nrow=1) + 
    labs(x="", 
         y="Rolling 7-day mean per million", 
         title="Key metrics by cluster (7-day rolling mean per million)", 
         subtitle="Cases: new cases, Deaths: new deaths, Hospitalized: total in hospital (not new)"
         ) + 
    scale_x_date(date_breaks="1 months", date_labels="%b") + 
    theme(axis.text.x=element_text(angle=90))

# Create all-metric plot by segment (define 100% as peak for segment-metric)
metrics_km5_plotData %>%
    filter(!is.na(vpm7)) %>%
    group_by(state, cluster, name) %>%
    mutate(spm7=vpm7/max(vpm7)) %>%
    ggplot(aes(x=date, y=spm7)) + 
    geom_line(data=~filter(., state=="cluster"), aes(group=name, color=cluster, linetype=name), lwd=1) +
    facet_wrap(~ cluster, scales="free_y") + 
    labs(x="", 
         y="% of Maximum", 
         title="Key metrics by cluster (% of maximum)", 
         subtitle="Cases: new cases, Deaths: new deaths, Hospitalized: total in hospital (not new)"
         ) + 
    scale_x_date(date_breaks="1 months", date_labels="%b") + 
    theme(axis.text.x=element_text(angle=90))

```
  
For the segments hit early (2 and 4), there was at most a small time difference between the peak for cases, hospitalizations, and deaths.  This is potentially driven by very limited testing, with many diagnoses being made when patients already had advanced disease.  Segment 4 has had a reborund in cases but without any rebound in hospitalizations or deaths, suggesting that the recent spike in cases may be due to increased testing.

For the primary segment being hit late (1), there appears to be a 2-4 week gap between the peak in cases and hospitalizations and the peak in deaths.  This is potentially driven by a larger number of cases being found early due to increased testing.

Segments 3 and 5 are near their peaks for cases and hospitalizations, while segment 3 (but not segment 5) is also near its peak for deaths.  These segments have currently had a low burden on a per million basis, and the evolution of disease bruden in the following weeks or months is uncertain.  Segment 3 across plots may be showing more indicia of a late spike like segment 1, while segment 5 across plots may be showing more indicia of a modest rebound in cases like segment 4.

[The COVID Tracking Project](https://covidtracking.com/) offers an API for downloading the most recent data as JSON or CSV.  A function is written to download the data to a specified file name, read in the data and check key control totals:  
```{r}

# Function to download data for COVID Tracking Project
downloadCOVIDbyState <- function(fileName, 
                                 api="https://api.covidtracking.com/v1/states/daily.csv", 
                                 ovrWrite=FALSE
                                 ) {
    
    # COVID Tracking Project API allows data downloads for personal, non-commercial use
    # https://covidtracking.com/data/api
    
    # FUNCTION ARGUMENTS:
    # fileName: the filename that the data will be saved to
    # api: The API link for data downloads
    # ovrWrite: whether to allow overwriting of the existing fileName
    
    # Check whether fileName already exists
    if (file.exists(fileName)) {
        cat("\nFile already exists at:", fileName, "\n")
        if (ovrWrite) cat("Will over-write with current data from", api, "\n")
        else stop("Exiting due to ovrWrite=FALSE and a duplicate fileName\n")
    }
    
    # Download the file 
    download.file(api, destfile=fileName)
    
    # Show statistics on downloaded file
    file.info(fileName)
    
}

```
  
The function is run on 2020-August-30, with results cached to avoid overwriting:  
```{r cache=TRUE}

# Download the file with the August 30, 2020 data
downloadCOVIDbyState(fileName="./RInputFiles/Coronavirus/CV_downloaded_200830.csv")

```
  
A function can then be written to read the file, change the date field to type date, check uniqueness, and compare available fields, elements, and control totals to an existing file:  
```{r}

# Function to read, convert, and sanity check a downloaded file
readCOViDbyState <- function(fileName, 
                             checkFile=cvData, 
                             controlFields=c("positiveIncrease", "deathIncrease", "hospitalizedCurrently"), 
                             controlBy=c("state")
                             ) {
    
    # FUNCTION ARGUMENTS:
    # fileName: the file name for reading the data
    # checkFile: a file that can be used for comparison purposes
    # controlFields: fields that will be explicitly checked against checkFile
    # controlBy: level of aggregation at which fields will be explicitly checked against checkFile
    
    # Read in the file and convert the numeric date field to date using ymd format
    df <- readr::read_csv(fileName) %>% 
        mutate(date=lubridate::ymd(date))

    # Check that the file is unique by date-state
    if ((df %>% select(date, state) %>% anyDuplicated()) != 0) {
        stop("\nDuplicates by date and state, investigate and fix\n")
    } else {
        cat("\nFile is unique by state and date\n")
    }
    
    # Check for similarity of key elements
    helperSimilarity <- function(newData, refData, label) {
        cat("\n\nCheckin for similarity of:", label)
        cat("\nIn reference but not in current:", setdiff(refData, newData))
        cat("\nIn current but not in reference:", setdiff(newData, refData))
    }
    
    # Check for similarity of fields, dates, and states
    cat("\n*** COMPARISONS TO REFERENCE FILE:", deparse(substitute(checkFile)))
    helperSimilarity(newData=names(df), refData=names(checkFile), label="column names")
    helperSimilarity(newData=df %>% pull(state) %>% unique(), 
                     refData=checkFile %>% pull(state) %>% unique() , 
                     label="states"
                     )
    helperSimilarity(newData=df %>% pull(date) %>% unique() %>% format("%Y-%m-%d"), 
                     refData=checkFile %>% pull(date) %>% unique() %>% format("%Y-%m-%d"), 
                     label="dates"
                     )
    
    # Check for overall control totals in new file
    cat("\n\nOverall control totals in file:\n")
    df %>% 
        summarize_at(vars(all_of(controlFields)), .funs=sum, na.rm=TRUE) %>% 
        print()
    
    # Check for similarity of control totals by date in files
    dfByDate <- df %>% 
        group_by(date) %>%
        summarize_at(vars(all_of(controlFields)), .funs=sum, na.rm=TRUE) %>%
        ungroup() %>%
        pivot_longer(-date, values_to="newValue")
    checkByDate <- checkFile %>% 
        group_by(date) %>%
        summarize_at(vars(all_of(controlFields)), .funs=sum, na.rm=TRUE) %>%
        ungroup() %>%
        pivot_longer(-date, values_to="oldValue")
    cat("\n\n*** Difference of at least 5 and difference is at least 1%:\n\n")
    dfByDate %>% 
        inner_join(checkByDate) %>%
        filter(abs(newValue-oldValue)>=5, 
               pmax(newValue, oldValue)>=1.01*pmin(newValue, oldValue)
               ) %>%
        as.data.frame() %>%
        print()
    p1 <- dfByDate %>% 
        inner_join(checkByDate) %>%
        pivot_longer(-c(date, name), names_to="newOld") %>%
        ggplot(aes(x=date, y=value, group=newOld, color=newOld)) + 
        geom_line() + 
        facet_wrap(~name, nrow=1, scales="free_y") + 
        labs(title="Control totals by date for new and reference file", x="", y="Summed Value")
    print(p1)

    # Check for similarity of control totals by controlBy in files
    dfByControl <- df %>% 
        semi_join(select(checkFile, date), by="date") %>%
        group_by_at(vars(all_of(controlBy))) %>%
        summarize_at(vars(all_of(controlFields)), .funs=sum, na.rm=TRUE) %>%
        ungroup() %>%
        pivot_longer(-all_of(controlBy), values_to="newValue")
    checkByControl <- checkFile %>% 
        group_by_at(vars(all_of(controlBy))) %>%
        summarize_at(vars(all_of(controlFields)), .funs=sum, na.rm=TRUE) %>%
        ungroup() %>%
        pivot_longer(-all_of(controlBy), values_to="oldValue")
    cat("\n\n*** Difference of at least 5 and difference is at least 1%:\n\n")
    dfByControl %>% 
        inner_join(checkByControl) %>%
        filter(abs(newValue-oldValue)>=5, 
               pmax(newValue, oldValue)>=1.01*pmin(newValue, oldValue)
               ) %>%
        as.data.frame() %>%
        print()

    # Return the data file
    df
    
}

```
  
The file can then be read and sanity checked:  
```{r}

dfRaw_20200830 <- readCOViDbyState("./RInputFiles/Coronavirus/CV_downloaded_200830.csv")
glimpse(dfRaw_20200830)

```
  
There appear to be multiple modest restatements of the data, but the overall trends by date and state are substantially the same as in the previous file.

Next steps are to use existing segments and to track their evolution against the newer data.

The data can be run against the filtering functions, with only key variables maintained:  
```{r}

# Variables to be kept
varsFilter <- c("date", "state", "positiveIncrease", "deathIncrease", "hospitalizedCurrently")

# Keep the cases, deaths, and hospitalized currently data for the 50 states and DC
dfFiltered_20200830 <- processCVData(dfRaw_20200830, 
                                     varsKeep=varsFilter, 
                                     varsRename=c(positiveIncrease="cases", 
                                                  deathIncrease="deaths", 
                                                  hospitalizedCurrently="hosp"
                                                  )
                                     )

# Show a sample of the filtered file
glimpse(dfFiltered_20200830)

```
  
The function for making per capita variables is updated to allow for other fields to be included:  
```{r}

# Function to add per capita and rolling to the base data frame
# Updated function to take an arbitrary number of variables and convert them
helperMakePerCapita <- function(df, 
                                mapVars=c("cases"="cpm", "deaths"="dpm"),
                                k=7
                                ) {
    
    # FUNCTION ARGUMENTS:
    # df: the initial data frame for conversion
    # mapVars: named vector of variables to be converted 'original name'='converted name'
    # k: the rolling time period to use
    
    # Create the variables for per capita
    for (origVar in names(mapVars)) {
        df <- df %>% 
            helperPerCapita(origVar=origVar, newName=mapVars[origVar])
    }
    # Arrange the data by date in preparation for rolling aggregations
    df <- df %>% 
        group_by(state) %>% 
        arrange(date)
    # Create the rolling variables
    for (newVar in mapVars) {
        df <- df %>% 
            helperRollingAgg(origVar=newVar, newName=paste0(newVar, k), k=k)
    }

    # Return the updated data frame, ungrouped
    df %>%
        ungroup()
    
}

# Confirm that the function, with defaults, is identical to previous
identical(cvFilteredPerCapita, helperMakePerCapita(cvFiltered))

```
  
The updated function can then be applied, with the hospital data also included:  
```{r}

# Create per capita and rolling 7 for cases, deaths, hosp
dfPerCapita_20200830 <- helperMakePerCapita(dfFiltered_20200830, 
                                            mapVars=c("cases"="cpm", "deaths"="dpm", "hosp"="hpm")
                                            )
glimpse(dfPerCapita_20200830)

```
  
The data can then be applied to the segment assessment routine, using the clustVec (hierarchical with 5 segments after VT is collapsed to the NH segment) segments as an example:  
```{r}

# More generic version of varMapper that is date agnostic
varMapper <- c("cases"="Cases", 
               "newCases"="Increase in cases, most recent 30 days",
               "casesroll7"="Rolling 7-day mean cases", 
               "deaths"="Deaths", 
               "newDeaths"="Increase in deaths, most recent 30 days",
               "deathsroll7"="Rolling 7-day mean deaths", 
               "cpm"="Cases per million",
               "cpm7"="Cases per day (7-day rolling mean) per million", 
               "newcpm"="Increase in cases, most recent 30 days, per million",
               "dpm"="Deaths per million", 
               "dpm7"="Deaths per day (7-day rolling mean) per million", 
               "newdpm"="Increase in deaths, most recent 30 days, per million", 
               "hpm7"="Currently Hospitalized per million (7-day rolling mean)"
               )

# Create the cluster assessments
plot_20200830_hier5 <- assessClusters(clustVec, 
                                      dfState=stateData, 
                                      dfBurden=dfPerCapita_20200830,
                                      thruLabel="Aug 30, 2020",
                                      plotsTogether=TRUE
                                      )

# Create the hospitalized plot
dfHospital_20200830 <- plotHospitalized(rename(dfFiltered_20200830, hospitalizedCurrently=hosp),
                                        clusterVector=clustVec, 
                                        subT="Data through August 30"
                                        )

```
  
A function is then written to consolidate the key metrics (cases, deaths, hospitalizations) by cluster:  
```{r}

# Function to create plots of consolidated metrics
plotConsolidatedMetrics <- function(dfMain, 
                                    dfHosp=NULL, 
                                    varMain=c("state", "cluster", "date", "pop", "cases", "deaths", "hosp"),
                                    varDropHosp=c("n", "pop"), 
                                    joinBy=c("state", "cluster", "date"), 
                                    subT=NULL
                                    ) {
    
    # FUNCTION ARGUMENTS:
    # dfMain: the main file produced by assessClusters(), containing data by state-cluster-date
    # dfHosp: the separate file with hospital data (NULL means data already available in dfMain)
    # varMain: variables to keep from dfMain
    # varDropHosp: variables to drop from dfHosp
    # joinBy: variables for joining dfMain and dfHosp
    # subT: plot subtitle (NULL will use the defaults)
    
    if (is.null(subT)) {
        subT <- "Cases: new cases, Deaths: new deaths, Hosp: total in hospital (not new)"
    }
    
    # Filter dfMain to include only variables in varMain
    dfMain <- dfMain %>%
        select_at(vars(all_of(varMain)))
    
    # Left join dfMain to dfHosp unless dfHosp is NULL
    if (!is.null(dfHosp)) {
        dfHosp <- dfHosp %>%
            select_at(vars(all_of(names(dfHosp)[!(names(dfHosp) %in% varDropHosp)])))
        dfMain <- dfMain %>%
            left_join(dfHosp, by=all_of(joinBy))
    }
    
    # Check that variables state, cluster, date, pop are all available
    if (!(c("state", "cluster", "date", "pop") %in% names(dfMain) %>% all())) {
        stop("\nFunction requires variables state, cluster, date, and pop after processing\n")
    }
    
    # Create the relevant plotting data
    dfPlot <- dfMain %>%
        pivot_longer(-c(state, cluster, date, pop)) %>%
        filter(!is.na(value)) %>%
        rbind(mutate(., state="cluster")) %>%
        group_by_at(vars(all_of(c(joinBy, "name")))) %>%
        summarize(value=sum(value), pop=sum(pop)) %>%
        mutate(vpm=1000000*value/pop) %>%
        arrange(state, cluster, name, date) %>%
        group_by(state, cluster, name) %>%
        helperRollingAgg(origVar="vpm", newName="vpm7")    

    # Create facetted plots for totals by metric by segment
    p1 <- dfPlot %>%
        filter(!is.na(vpm7)) %>%
        ggplot(aes(x=date, y=vpm7)) + 
        geom_line(data=~filter(., state=="cluster"), aes(group=cluster, color=cluster), lwd=1.5) +
        geom_line(data=~filter(., state!="cluster"), aes(group=state), alpha=0.25) + 
        facet_grid(name ~ cluster, scales="free_y") + 
        labs(x="", 
             y="Rolling 7-day mean per million", 
             title="Key metrics by cluster (7-day rolling mean per million)", 
             subtitle=subT
             ) + 
        scale_x_date(date_breaks="1 months", date_labels="%b") + 
        theme(axis.text.x=element_text(angle=90))
    print(p1)

    # Create all-segment plot by metric
    p2 <- dfPlot %>%
        filter(!is.na(vpm7)) %>%
        ggplot(aes(x=date, y=vpm7)) + 
        geom_line(data=~filter(., state=="cluster"), aes(group=cluster, color=cluster), lwd=1.5) +
        facet_wrap(~ name, scales="free_y", nrow=1) + 
        labs(x="", 
             y="Rolling 7-day mean per million", 
             title="Key metrics by cluster (7-day rolling mean per million)", 
             subtitle=subT
             ) + 
        scale_x_date(date_breaks="1 months", date_labels="%b") + 
        theme(axis.text.x=element_text(angle=90))
    print(p2)

    # Create all-metric plot by segment (define 100% as peak for segment-metric)
    p3 <- dfPlot %>%
        filter(!is.na(vpm7)) %>%
        group_by(state, cluster, name) %>%
        mutate(spm7=vpm7/max(vpm7)) %>%
        ggplot(aes(x=date, y=spm7)) + 
        geom_line(data=~filter(., state=="cluster"), aes(group=name, color=name), lwd=1) +
        facet_wrap(~ cluster, scales="free_y") + 
        labs(x="", 
             y="% of Maximum", 
             title="Key metrics by cluster (% of cluster maximum for variable)", 
             subtitle=subT
             ) + 
        scale_x_date(date_breaks="1 months", date_labels="%b") + 
        scale_color_discrete("variable") +
        theme(axis.text.x=element_text(angle=90))
    print(p3)
    
    # Return the plotting data
    dfPlot
    
}

```
  
The function can then be run for the updated data:  
```{r}

# Create the relevant consolidated plots
consolidatedPlotData_20200830 <- plotConsolidatedMetrics(plot_20200830_hier5)

```
  
There is increasing evidence that the primary late-outbreak segment is meaningfully past the peak and on the downswing, with the decline in deaths lagging the decline in cases and hospitalizations by a month or so.  The primary early-outbreak states are not seeing much rebound in hospitalization or death, even as there has been a spike in cases (potentially near or even past plateau) in one of the segments.  There is some evidence of spiking (cases and hospitalizations perhaps having peaked a month ago, deaths perhaps at or near peak now) of the mid-southern and western state segment that has generally seen low death rates from coronavirus.

[The Ethical Skeptic](https://theethicalskeptic.com/) creates interesting analyses of coronavirus, driven among other things by a search for consilience.  Among the points raised are that PCR testing (for coronavirus and in other areas) has a high false-positive rate.  As such, spikes in positive cases can be driven both by spikes in disease prevalence and spikes in testing.  There are also meaningful lags in data reporting that can influence the timing of reported spikes.

These factors could contribute to the observation that increases in hospitalizations and deaths sometimes, but not always, follow increases in positive test results.  It may also contribute to the observation that deaths no longer spike anywhere near as high for a given spike in positive cases as they did in March-May.

Next steps are to explore the evolution of reported tests (positive and negative) by cluster as well as the adjustment methodology used in the TES consilience plots (attempting to normalize reported positive cases so that a number of cases reported in April and the same number of cases reported in August represent the same level of disease prevalence).

There are many variables related to testing available in the COVID Tracking Project files:  
```{r}

# Columns that contain 'test' or 'Test'
testNames <- names(dfRaw_20200830) %>% grep(x=., pattern="[Tt]est", value=TRUE)
testNames

# Glimpse of the data
dfRaw_20200830 %>%
    select_at(vars(all_of(c("state", "date", testNames)))) %>% 
    glimpse()

# Summaries by the totalTestResultsSource, totals by column
dfRaw_20200830 %>%
    select_at(vars(all_of(testNames))) %>%
    group_by_at("totalTestResultsSource") %>%
    mutate(n=1) %>%
    summarize_all(sum, na.rm=TRUE) %>%
    pivot_longer(-totalTestResultsSource) %>%
    filter(value > 0) %>%
    ggplot(aes(x=fct_reorder(name, value), y=value)) + 
    geom_point() + 
    geom_text(aes(y=ifelse(name=="n", 15, 0.8)*value, label=scales::scientific(value)), hjust=1, size=3.5) +
    facet_wrap(~totalTestResultsSource) + 
    coord_flip() + 
    scale_y_log10() + 
    labs(title="Sum across records by test type", x="", y="Tests (log10)")

```
  
Most of the tests are based on the source 'posNeg', and most are of type 'totalTestsViral'.

The COIV Tracking Project API notes that fields 'negative' is a column that reports the total number of people with a negative test result. Since a person can test negative many times, this is not necessarily reflective of testing volume.

The 'totalTestResults' column (and therefore 'totalTestResultsIncrease') is heterogeneous data that cannot be easily compared across states.  It is either 'posNeg' (sum of positive and negative) or 'totalTestEncountersViral'.

The 'totalTestsViral' column is listed as being the total number of PCR tests.  It may in a handful of cases include antigen tests.

The 'totalTestEncountersViral' column is listed as being the total number of people who underwent PCR testing in a given day (multiple tests to the same person on the same day counted as only 1).

Data availability for some of the key variables is assessed by month:  
```{r}

# Not NA data
notNATests <- dfRaw_20200830 %>%
    filter(state %in% c(state.abb, "DC")) %>%
    select_at(vars(all_of(c("state", "date", testNames)))) %>%
    mutate(nState=1) %>%
    group_by(date) %>%
    summarize_if(is.numeric, .funs=function(x) { sum(!is.na(x))}) %>%
    ungroup()

# Evolution of Not NA states by time
notNATests %>%
    pivot_longer(-date) %>%
    ggplot(aes(x=date, 
               y=value, 
               group=fct_rev(fct_reorder(name, value, .fun=max)), 
               color=fct_rev(fct_reorder(name, value, .fun=max))
               )
           ) + 
    geom_line(lwd=1) + 
    geom_hline(yintercept=51, lty=2) + 
    labs(x="", y="Number of states with non-NA data", title="Evolution of data availability by metric") + 
    scale_color_discrete("") + 
    scale_x_date(date_breaks="1 months", date_labels="%m")

notNATests %>%
    pivot_longer(-date) %>% 
    filter(date==as.Date("2020-08-29")) %>% 
    arrange(-value)

```
  
Data availability varies significantly, with only the totalTestResults and totalTestResultsIncrease columns being generally available in all states on all dates.

Next, availability of data by state over time is assessed:  
```{r}

# Not NA data
notNADateStateTests <- dfRaw_20200830 %>%
    filter(state %in% c(state.abb, "DC")) %>%
    select_at(vars(all_of(c("state", "date", testNames)))) %>%
    mutate(nState=1, month=lubridate::month(date)) %>%
    group_by(month, state) %>%
    summarize_if(is.numeric, .funs=function(x) { min(!is.na(x))}) %>%
    ungroup()

# Evolution of Not NA states by month
notNADateStateTests %>%
    pivot_longer(-c(state, month)) %>%
    filter(!(name %in% c("nState"))) %>%
    ggplot(aes(y=fct_reorder(state, value, .fun=sum), x=month)) + 
    geom_tile(aes(fill=value)) + 
    labs(x="", y="", title="Evolution of data availability by metric") + 
    scale_fill_continuous("", low="white", high="green") + 
    facet_wrap(~name, nrow=1)

```
  
So, while the field is heterogeneous, data availability may suggest use of 'totalTestResultsIncrease' as a general proxy for the testing volume occurring over time.  The evolution is as follows:  
```{r}

dfRaw_20200830 %>%
    group_by(date) %>%
    summarize(tests=sum(totalTestResultsIncrease, na.rm=TRUE)) %>%
    ungroup() %>%
    arrange(date) %>%
    helperRollingAgg(origVar="tests", newName="tests7") %>%
    ggplot(aes(x=date, y=tests7)) + 
    geom_line() + 
    labs(x="Month", y="Daily tests (rolling 7-day mean", title="Rolling 7-day mean tests per day") + 
    scale_x_date(date_breaks="1 months", date_labels="%m")

```
  
The metric can also be assessed on a per capita basis by segment:  
```{r}

dfRaw_20200830 %>%
    select(state, date, totalTestResultsIncrease) %>%
    inner_join(stateData, by="state") %>%
    mutate(cluster=factor(clustVec[state])) %>%
    mutate(tpm=1000000*totalTestResultsIncrease/pop) %>%
    group_by(state) %>%
    arrange(date) %>%
    helperRollingAgg(origVar="tpm", newName="tpm7") %>%
    ungroup() %>%
    helperTotalvsElements(keyVar="tpm7", 
                          title="Evolution of tests by segment",
                          mapper=c("tpm7"="Tests per million per day (7-day rolling mean"), 
                          facetScales="free_y"
                          )
```
  
Testing appears to have grown rapidly in all segments, though with a significant decline in testing in the "late spike" states that is associated with the same timing as the fall in cases in "late spike" states.

Most segments appear to be reporting 2000 tests per 1 million population.  At a false positive rate of 1%, this would produce 20 false-positive tests per million.  The New England and Mid-Atlantic states are reporting case-per-million numbers of aound this magnitude, which is suggestive that they may be catching mostly false positives rather than disease prevalence.  This would be consisent with the hospitalization and deaths data being extremely low currently in these segments.

Further exploration will focus on integrating testing data with the other key metrics (cases, hospitalizations, deaths) for the overall process.
